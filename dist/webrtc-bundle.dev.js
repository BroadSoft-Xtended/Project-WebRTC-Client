// webrtc-bundle.dev.js 2.0.0
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {view: require('./lib/views/widget'), model: require('./lib/models/widget')};

require('./lib/loader');
},{"./lib/loader":4,"./lib/models/widget":5,"./lib/views/widget":6}],2:[function(require,module,exports){
module.exports = {"widget":".bdsft-reset{font-size:14px;font:normal normal 14px Open Sans,Arial,sans-serif}.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-size:100%;font:normal normal 100% Open Sans,Arial,sans-serif}.bdsft-reset,.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal;alignment-adjust:auto;alignment-baseline:baseline;-webkit-animation:none 0 ease 0 1 normal;-moz-animation:none 0 ease 0 1 normal;-ms-animation:none 0 ease 0 1 normal;animation:none 0 ease 0 1 normal;-webkit-animation-play-state:running;-moz-play-state:running;-ms-animation-play-state:running;animation-play-state:running;appearance:normal;azimuth:center;backface-visibility:visible;background:none 0 0 auto repeat scroll padding-box transparent;background-color:transparent;background-image:none;baseline-shift:baseline;binding:none;bleed:6pt;bookmark-label:content();bookmark-level:none;bookmark-state:open;bookmark-target:none;border:0 none transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;bottom:auto;box-align:stretch;box-decoration-break:slice;box-direction:normal;box-flex:0;box-flex-group:1;box-lines:single;box-ordinal-group:1;box-orient:inline-axis;box-pack:start;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;break-after:auto;break-before:auto;break-inside:auto;caption-side:top;clear:none;clip:auto;color:inherit;color-profile:auto;-webkit-column-count:auto;-webkit-column-fill:balance;-webkit-column-gap:normal;-webkit-column-rule:medium medium #1f1f1f;-webkit-column-span:1;-webkit-column-width:auto;-webkit-columns:auto auto;-moz-column-count:auto;-moz-column-fill:balance;-moz-column-gap:normal;-moz-column-rule:medium medium #1f1f1f;-moz-column-span:1;-moz-column-width:auto;-moz-columns:auto auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium medium #1f1f1f;column-span:1;column-width:auto;columns:auto auto;content:normal;counter-increment:none;counter-reset:none;crop:auto;cursor:auto;direction:ltr;display:inline;dominant-baseline:auto;drop-initial-after-adjust:text-after-edge;drop-initial-after-align:baseline;drop-initial-before-adjust:text-before-edge;drop-initial-before-align:caps-height;drop-initial-size:auto;drop-initial-value:initial;elevation:level;empty-cells:show;fit:fill;fit-position:0;float:none;float-offset:0;grid-columns:none;grid-rows:none;hanging-punctuation:none;height:auto;hyphenate-after:auto;hyphenate-before:auto;hyphenate-character:auto;hyphenate-lines:no-limit;hyphenate-resource:none;hyphens:manual;icon:auto;image-orientation:auto;image-rendering:auto;image-resolution:normal;inline-box-align:last;left:auto;line-height:inherit;line-stacking:inline-line-height exclude-ruby consider-shifts;list-style:disc outside none;margin:0;marks:none;marquee-direction:forward;marquee-loop:1;marquee-play-count:1;marquee-speed:normal;marquee-style:scroll;max-height:none;max-width:none;min-height:0;min-width:0;move-to:normal;nav-down:auto;nav-index:auto;nav-left:auto;nav-right:auto;nav-up:auto;opacity:1;orphans:2;outline:invert none medium;outline-offset:0;overflow:visible;overflow-style:auto;padding:0;page:auto;page-break-after:auto;page-break-before:auto;page-break-inside:auto;page-policy:start;perspective:none;perspective-origin:50% 50%;position:static;presentation-level:0;punctuation-trim:none;quotes:none;rendering-intent:auto;resize:none;right:auto;rotation:0;rotation-point:50% 50%;ruby-align:auto;ruby-overhang:none;ruby-position:before;ruby-span:none;size:auto;string-set:none;table-layout:auto;top:auto;-webkit-transform:none;-moz-transform:none;transform:none;-webkit-transform-origin:50% 50%;-moz-transform-origin:50% 50%;-o-transform-origin:50% 50%;transform-origin:50% 50% 0;transform-style:flat;-webkit-transition:all 0 ease 0;-moz-transition:all 0 ease 0;-o-transition:all 0 ease 0;transition:all 0 ease 0;unicode-bidi:normal;vertical-align:baseline;white-space:normal;white-space-collapse:collapse;widows:2;width:auto;word-break:normal;word-spacing:normal;word-wrap:normal;z-index:auto;text-align:start}.bdsft-reset address,.bdsft-reset blockquote,.bdsft-reset dd,.bdsft-reset div,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset frame,.bdsft-reset frameset,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset noframes,.bdsft-reset ol,.bdsft-reset p,.bdsft-reset ul,.bdsft-reset center,.bdsft-reset dir,.bdsft-reset hr,.bdsft-reset menu,.bdsft-reset pre,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary{display:block}.bdsft-reset li{display:list-item}.bdsft-reset table{display:table}.bdsft-reset tr{display:table-row}.bdsft-reset thead{display:table-header-group}.bdsft-reset tbody{display:table-row-group}.bdsft-reset tfoot{display:table-footer-group}.bdsft-reset col{display:table-column}.bdsft-reset colgroup{display:table-column-group}.bdsft-reset td,.bdsft-reset th{display:table-cell}.bdsft-reset caption{display:table-caption}.bdsft-reset input,.bdsft-reset select{display:inline-block}.bdsft-reset b,.bdsft-reset strong,.bdsft-reset strong>*{font-weight:bold}.bdsft-reset textarea,.bdsft-reset input{cursor:text}.bdsft-reset textarea .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset textarea .bdsft-reset input::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset input::-webkit-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-moz-placeholder,.bdsft-reset input .bdsft-reset textarea:-moz-placeholder,.bdsft-reset textarea .bdsft-reset input:-moz-placeholder,.bdsft-reset input .bdsft-reset input:-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea::-moz-placeholder,.bdsft-reset input .bdsft-reset textarea::-moz-placeholder,.bdsft-reset textarea .bdsft-reset input::-moz-placeholder,.bdsft-reset input .bdsft-reset input::-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset input .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset textarea .bdsft-reset input:-ms-input-placeholder,.bdsft-reset input .bdsft-reset input:-ms-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset input[type=checkbox],.bdsft-reset input[type=radio]{cursor:default}.bdsft-reset a,.bdsft-reset a *,.bdsft-reset a span,.bdsft-reset button,.bdsft-reset button *,.bdsft-reset button span,.bdsft-reset input[type=submit],.bdsft-reset input[type=reset]{cursor:pointer}.bdsft-reset a:link,.bdsft-reset a:visited,.bdsft-reset a:hover,.bdsft-reset a:active{color:inherit;background:transparent;text-shadow:none}.bdsft-reset button::-moz-focus-inner{border:0;padding:0}.bdsft-reset *[class^='bdsft-icon']{font-family:FontAwesome!important}.bdsft-webrtc button{border:0;border-radius:20px;padding:5px 10px;font-size:14px;color:#fff;background-color:#999;text-align:center}.bdsft-webrtc input,.bdsft-webrtc textarea{background:#333;border:1px solid #3c3c3c;color:#d3d3d3;font-family:arial;font-size:18px;padding:0;border-radius:0}.bdsft-webrtc input:focus,.bdsft-webrtc textarea:focus{outline:0}.bdsft-webrtc .button:hover{box-shadow:0 0 10px #999}.bdsft-webrtc .ui-widget-content.ui-dialog{display:none;color:#999;font-size:22px;background:#333;padding:10px;border:2px solid #ddd;box-shadow:0 0 10px #999;border-radius:3px;z-index:99}.bdsft-webrtc .no-close .ui-dialog-titlebar-close{display:none}.bdsft-webrtc .unsupported{position:absolute;top:240px;left:30px;width:600px;background-color:#191414;text-align:center;display:none;color:#fff;z-index:10}.bdsft-webrtc .historyRowSample{display:none}.bdsft-webrtc [id$=\"sample\"]{display:none!important}.bdsft-webrtc #javascript_disabled{display:block;background-color:#fff;color:#000}.bdsft-webrtc a.disabled{pointer-events:none;cursor:default;background-color:#999;opacity:.5}.bdsft-webrtc .main{position:relative;top:0;left:0;width:100%}.bdsft-webrtc .client{position:relative;top:0;left:0}.bdsft-webrtc .client::-webkit-scrollbar{width:8px}.bdsft-webrtc .client::-webkit-scrollbar-track,.bdsft-webrtc .client::-webkit-scrollbar-thumb{background:#272727}.bdsft-webrtc .client::-webkit-scrollbar-track:window-inactive,.bdsft-webrtc .client::-webkit-scrollbar-thumb:window-inactive{background:#272727}.bdsft-webrtc .client._960x720{width:960px}.bdsft-webrtc .client._640x360,.bdsft-webrtc .client._640x480{width:640px}.bdsft-webrtc .client._320x180,.bdsft-webrtc .client._320x240{width:320px}.bdsft-webrtc .client._1280x720,.bdsft-webrtc .client.hd{width:1280px}.bdsft-webrtc .client .row:before,.bdsft-webrtc .client .row:after{display:none}.bdsft-webrtc .client.audioOnly:not(.offerToReceiveVideo){display:inline-block;width:auto}.bdsft-webrtc .client.fullscreen-shown{width:100%!important;height:100%!important;top:0;left:0;position:absolute}.bdsft-webrtc .client.fullscreen-shown .main{height:100%}.bdsft-webrtc .main:-webkit-full-screen-ancestor:not(iframe){position:absolute!important;top:0;left:0;right:0;bottom:0;width:100%;height:100%}.bdsft-webrtc #screen_sharing_unsupported{position:relative;top:0;left:0;margin:10px;background:#f00;display:none}.bdsft-webrtc #screen_sharing_unsupported span{text-decoration:underline}"}
},{}],3:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else {
        if (typeof root === 'undefined' || root !== Object(root)) {
            throw new Error('templatizer: window does not exist or is not an object');
        }
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)r.push(e&&e[i]?a.escape(t([n[i]])):t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}(); 

    var templatizer = {};


    // widget.jade compiled template
    templatizer["widget"] = function tmpl_widget() {
        return '<div class="wrapper bdsft-reset bdsft-webrtc"><div id="unsupported" class="unsupported"></div><div id="whiteboard_unsupported" class="unsupported"></div><div id="screen_sharing_unsupported" class="unsupported">Could not retrieve screen capture. Do you have it enabled?<br/>Open link to check : <span>chrome://flags/#enable-usermedia-screen-capture</span></div><noscript><div id="javascript_disabled" class="unsupported">JavaScript must be enabled to load the WebRTC client</div></noscript><div id="conversejs"></div><div class="client classes"><div class="main"><div class="errorPopup"></div></div></div></div>';
    };

    return templatizer;
}));

},{"fs":7}],4:[function(require,module,exports){
var loader = require('webrtc-core').loader;
var Widget = require('../');

var widgetLoader = loader(Widget, {
      // Overwrite styles and templates
      // style: {
      //       authentication: require('../js/styles').authentication
      // },
      // template: {
      //       authentication: require('../js/templates').authentication
      // },
      dependencies: {
            audio: require("webrtc-audio"),
            authentication: require("webrtc-authentication"),
            chat: require("webrtc-chat"),
            dialpad: require("webrtc-dialpad"),
            dms: require("webrtc-dms"),
            callcontrol: require("webrtc-callcontrol"),
            connectionstatus: require("webrtc-connectionstatus"),
            fullscreen: require("webrtc-fullscreen"),
            history: require("webrtc-history"),
            incomingcall: require("webrtc-incomingcall"),
            messages: require("webrtc-messages"),
            settings: require("webrtc-settings"),
            sipstack: require("webrtc-sipstack"),
            stats: require("webrtc-stats"),
            sound: require("webrtc-sound"),
            timer: require("webrtc-timer"),
            transfer: require("webrtc-transfer"),
            video: require("webrtc-video"),
            videobar: require("webrtc-videobar"),
            xmpp: require("webrtc-xmpp"),
            widget: Widget
      }
});

window.BroadSoftWebRTC = window.BroadSoftWebRTC || {};
window.BroadSoftWebRTC.loader = widgetLoader;

module.exports = widgetLoader;
},{"../":1,"webrtc-audio":44,"webrtc-authentication":101,"webrtc-callcontrol":158,"webrtc-chat":215,"webrtc-connectionstatus":274,"webrtc-core":334,"webrtc-dialpad":382,"webrtc-dms":437,"webrtc-fullscreen":574,"webrtc-history":631,"webrtc-incomingcall":690,"webrtc-messages":746,"webrtc-settings":804,"webrtc-sipstack":862,"webrtc-sound":950,"webrtc-stats":1005,"webrtc-timer":1064,"webrtc-transfer":1122,"webrtc-video":1179,"webrtc-videobar":1237,"webrtc-xmpp":1294}],5:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Widget);

var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Widget(eventbus, video, urlconfig, sipstack, cookieconfig, fullscreen, settings, callcontrol, history) {
  var self = {};

  self.props = ['classes'];

  self.bindings = {
    classes: {
        video: 'displayResolution',
        fullscreen: 'visible',
        urlconfig: 'hd',
        sipstack: ['audioOnly', 'offerToReceiveVideo'],
        cookieconfig: 'hd'
    }
  }

  self.listeners = function(settingsDatabinder, callcontrolDatabinder){
    settingsDatabinder.onModelPropChange('visible', function(visible){
      visible && history.hide();
      visible && callcontrol.hide();
    });
    callcontrolDatabinder.onModelPropChange('visible', function(visible){
      !visible && history.hide();
      visible && settings.hide();
    });
  }

  return self;
}
},{"webrtc-core":334}],6:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(WidgetView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var WebRTC_C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;
var PopupView = require('webrtc-core').popup;
var defaults = require('webrtc-core').defaults;

function WidgetView(eventbus, debug, videoView, videobarView, callcontrolView, sipstack, transferView, authenticationView, 
  incomingcallView, messagesView, settingsView, connectionstatusView, statsView, historyView, chatView, xmppView, widget) {
  var self = {};

  self.model = widget;

  self.elements = ['client', 'main'];

  self.visibilities = {};

  self.appendTo = function(parent) {
    parent.append(self.view);
  };
  self.remove = function() {
    self.view.remove();
  };

  self.init = function() {
    var unsupported = Utils.compatibilityCheck();
    if (unsupported) {
      Utils.getElement('#unsupported').html(unsupported).show();
    }

    // var whiteboardUnsupported = Utils.whiteboardCompabilityCheck();
    // if (whiteboardUnsupported) {
    //   Utils.getElement('#whiteboard_unsupported').html(whiteboardUnsupported).show();
    // }

    videoView.view.appendTo(self.main);
    videobarView.view.appendTo(self.main);
    messagesView.view.appendTo(self.main);
    connectionstatusView.view.appendTo(self.main);

    PopupView(authenticationView, eventbus, {parent: self.main});
    PopupView(callcontrolView, eventbus, {parent: self.main});
    PopupView(incomingcallView, eventbus, {parent: self.main});
    PopupView(settingsView, eventbus, {parent: self.main});
    PopupView(transferView, eventbus, {parent: self.main});
    PopupView(chatView, eventbus, {parent: self.main, modifier: 67});
    PopupView(historyView, eventbus, {parent: self.main, modifier: 72});
    PopupView(statsView, eventbus, {parent: self.main, modifier: 83});
    PopupView(xmppView, eventbus, {parent: self.main, modifier: 88});
  };

  self.listeners = function() {
    // $(document).unbind('keypress').bind('keypress', function(e) {});
    // $(document).unbind('keydown').bind('keydown', function(event) {
    document.addEventListener('keydown', function(event) {
      var isModifier = event.altKey;
      if (isModifier) {
        if (transferView.target.is(event.target)) {
          return;
        }
        eventbus.modifier(event.which);
        event.stopPropagation();
      }
    });
  };

  return self;
}
},{"../../js/styles":2,"../../js/templates":3,"webrtc-core":334}],7:[function(require,module,exports){

},{}],8:[function(require,module,exports){
module.exports=require(7)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/lib/_empty.js":7}],9:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":10,"ieee754":11,"is-array":12}],10:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],11:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],12:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],13:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],14:[function(require,module,exports){
var http = module.exports;
var EventEmitter = require('events').EventEmitter;
var Request = require('./lib/request');
var url = require('url')

http.request = function (params, cb) {
    if (typeof params === 'string') {
        params = url.parse(params)
    }
    if (!params) params = {};
    if (!params.host && !params.port) {
        params.port = parseInt(window.location.port, 10);
    }
    if (!params.host && params.hostname) {
        params.host = params.hostname;
    }

    if (!params.protocol) {
        if (params.scheme) {
            params.protocol = params.scheme + ':';
        } else {
            params.protocol = window.location.protocol;
        }
    }

    if (!params.host) {
        params.host = window.location.hostname || window.location.host;
    }
    if (/:/.test(params.host)) {
        if (!params.port) {
            params.port = params.host.split(':')[1];
        }
        params.host = params.host.split(':')[0];
    }
    if (!params.port) params.port = params.protocol == 'https:' ? 443 : 80;
    
    var req = new Request(new xhrHttp, params);
    if (cb) req.on('response', cb);
    return req;
};

http.get = function (params, cb) {
    params.method = 'GET';
    var req = http.request(params, cb);
    req.end();
    return req;
};

http.Agent = function () {};
http.Agent.defaultMaxSockets = 4;

var xhrHttp = (function () {
    if (typeof window === 'undefined') {
        throw new Error('no window object present');
    }
    else if (window.XMLHttpRequest) {
        return window.XMLHttpRequest;
    }
    else if (window.ActiveXObject) {
        var axs = [
            'Msxml2.XMLHTTP.6.0',
            'Msxml2.XMLHTTP.3.0',
            'Microsoft.XMLHTTP'
        ];
        for (var i = 0; i < axs.length; i++) {
            try {
                var ax = new(window.ActiveXObject)(axs[i]);
                return function () {
                    if (ax) {
                        var ax_ = ax;
                        ax = null;
                        return ax_;
                    }
                    else {
                        return new(window.ActiveXObject)(axs[i]);
                    }
                };
            }
            catch (e) {}
        }
        throw new Error('ajax not supported in this browser')
    }
    else {
        throw new Error('ajax not supported in this browser');
    }
})();

http.STATUS_CODES = {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Moved Temporarily',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Time-out',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Request Entity Too Large',
    414 : 'Request-URI Too Large',
    415 : 'Unsupported Media Type',
    416 : 'Requested Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large',// RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Time-out',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
};
},{"./lib/request":15,"events":13,"url":41}],15:[function(require,module,exports){
var Stream = require('stream');
var Response = require('./response');
var Base64 = require('Base64');
var inherits = require('inherits');

var Request = module.exports = function (xhr, params) {
    var self = this;
    self.writable = true;
    self.xhr = xhr;
    self.body = [];
    
    self.uri = (params.protocol || 'http:') + '//'
        + params.host
        + (params.port ? ':' + params.port : '')
        + (params.path || '/')
    ;
    
    if (typeof params.withCredentials === 'undefined') {
        params.withCredentials = true;
    }

    try { xhr.withCredentials = params.withCredentials }
    catch (e) {}
    
    if (params.responseType) try { xhr.responseType = params.responseType }
    catch (e) {}
    
    xhr.open(
        params.method || 'GET',
        self.uri,
        true
    );

    xhr.onerror = function(event) {
        self.emit('error', new Error('Network error'));
    };

    self._headers = {};
    
    if (params.headers) {
        var keys = objectKeys(params.headers);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            if (!self.isSafeRequestHeader(key)) continue;
            var value = params.headers[key];
            self.setHeader(key, value);
        }
    }
    
    if (params.auth) {
        //basic auth
        this.setHeader('Authorization', 'Basic ' + Base64.btoa(params.auth));
    }

    var res = new Response;
    res.on('close', function () {
        self.emit('close');
    });
    
    res.on('ready', function () {
        self.emit('response', res);
    });

    res.on('error', function (err) {
        self.emit('error', err);
    });
    
    xhr.onreadystatechange = function () {
        // Fix for IE9 bug
        // SCRIPT575: Could not complete the operation due to error c00c023f
        // It happens when a request is aborted, calling the success callback anyway with readyState === 4
        if (xhr.__aborted) return;
        res.handle(xhr);
    };
};

inherits(Request, Stream);

Request.prototype.setHeader = function (key, value) {
    this._headers[key.toLowerCase()] = value
};

Request.prototype.getHeader = function (key) {
    return this._headers[key.toLowerCase()]
};

Request.prototype.removeHeader = function (key) {
    delete this._headers[key.toLowerCase()]
};

Request.prototype.write = function (s) {
    this.body.push(s);
};

Request.prototype.destroy = function (s) {
    this.xhr.__aborted = true;
    this.xhr.abort();
    this.emit('close');
};

Request.prototype.end = function (s) {
    if (s !== undefined) this.body.push(s);

    var keys = objectKeys(this._headers);
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = this._headers[key];
        if (isArray(value)) {
            for (var j = 0; j < value.length; j++) {
                this.xhr.setRequestHeader(key, value[j]);
            }
        }
        else this.xhr.setRequestHeader(key, value)
    }

    if (this.body.length === 0) {
        this.xhr.send('');
    }
    else if (typeof this.body[0] === 'string') {
        this.xhr.send(this.body.join(''));
    }
    else if (isArray(this.body[0])) {
        var body = [];
        for (var i = 0; i < this.body.length; i++) {
            body.push.apply(body, this.body[i]);
        }
        this.xhr.send(body);
    }
    else if (/Array/.test(Object.prototype.toString.call(this.body[0]))) {
        var len = 0;
        for (var i = 0; i < this.body.length; i++) {
            len += this.body[i].length;
        }
        var body = new(this.body[0].constructor)(len);
        var k = 0;
        
        for (var i = 0; i < this.body.length; i++) {
            var b = this.body[i];
            for (var j = 0; j < b.length; j++) {
                body[k++] = b[j];
            }
        }
        this.xhr.send(body);
    }
    else if (isXHR2Compatible(this.body[0])) {
        this.xhr.send(this.body[0]);
    }
    else {
        var body = '';
        for (var i = 0; i < this.body.length; i++) {
            body += this.body[i].toString();
        }
        this.xhr.send(body);
    }
};

// Taken from http://dxr.mozilla.org/mozilla/mozilla-central/content/base/src/nsXMLHttpRequest.cpp.html
Request.unsafeHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "cookie2",
    "content-transfer-encoding",
    "date",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
];

Request.prototype.isSafeRequestHeader = function (headerName) {
    if (!headerName) return false;
    return indexOf(Request.unsafeHeaders, headerName.toLowerCase()) === -1;
};

var objectKeys = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var indexOf = function (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) {
        if (xs[i] === x) return i;
    }
    return -1;
};

var isXHR2Compatible = function (obj) {
    if (typeof Blob !== 'undefined' && obj instanceof Blob) return true;
    if (typeof ArrayBuffer !== 'undefined' && obj instanceof ArrayBuffer) return true;
    if (typeof FormData !== 'undefined' && obj instanceof FormData) return true;
};

},{"./response":16,"Base64":17,"inherits":19,"stream":39}],16:[function(require,module,exports){
var Stream = require('stream');
var util = require('util');

var Response = module.exports = function (res) {
    this.offset = 0;
    this.readable = true;
};

util.inherits(Response, Stream);

var capable = {
    streaming : true,
    status2 : true
};

function parseHeaders (res) {
    var lines = res.getAllResponseHeaders().split(/\r?\n/);
    var headers = {};
    for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        if (line === '') continue;
        
        var m = line.match(/^([^:]+):\s*(.*)/);
        if (m) {
            var key = m[1].toLowerCase(), value = m[2];
            
            if (headers[key] !== undefined) {
            
                if (isArray(headers[key])) {
                    headers[key].push(value);
                }
                else {
                    headers[key] = [ headers[key], value ];
                }
            }
            else {
                headers[key] = value;
            }
        }
        else {
            headers[line] = true;
        }
    }
    return headers;
}

Response.prototype.getResponse = function (xhr) {
    var respType = String(xhr.responseType).toLowerCase();
    if (respType === 'blob') return xhr.responseBlob || xhr.response;
    if (respType === 'arraybuffer') return xhr.response;
    return xhr.responseText;
}

Response.prototype.getHeader = function (key) {
    return this.headers[key.toLowerCase()];
};

Response.prototype.handle = function (res) {
    if (res.readyState === 2 && capable.status2) {
        try {
            this.statusCode = res.status;
            this.headers = parseHeaders(res);
        }
        catch (err) {
            capable.status2 = false;
        }
        
        if (capable.status2) {
            this.emit('ready');
        }
    }
    else if (capable.streaming && res.readyState === 3) {
        try {
            if (!this.statusCode) {
                this.statusCode = res.status;
                this.headers = parseHeaders(res);
                this.emit('ready');
            }
        }
        catch (err) {}
        
        try {
            this._emitData(res);
        }
        catch (err) {
            capable.streaming = false;
        }
    }
    else if (res.readyState === 4) {
        if (!this.statusCode) {
            this.statusCode = res.status;
            this.emit('ready');
        }
        this._emitData(res);
        
        if (res.error) {
            this.emit('error', this.getResponse(res));
        }
        else this.emit('end');
        
        this.emit('close');
    }
};

Response.prototype._emitData = function (res) {
    var respBody = this.getResponse(res);
    if (respBody.toString().match(/ArrayBuffer/)) {
        this.emit('data', new Uint8Array(respBody, this.offset));
        this.offset = respBody.byteLength;
        return;
    }
    if (respBody.length > this.offset) {
        this.emit('data', respBody.slice(this.offset));
        this.offset = respBody.length;
    }
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{"stream":39,"util":43}],17:[function(require,module,exports){
;(function () {

  var object = typeof exports != 'undefined' ? exports : this; // #8: web workers
  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  function InvalidCharacterError(message) {
    this.message = message;
  }
  InvalidCharacterError.prototype = new Error;
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  // encoder
  // [https://gist.github.com/999166] by [https://github.com/nignag]
  object.btoa || (
  object.btoa = function (input) {
    for (
      // initialize result and counter
      var block, charCode, idx = 0, map = chars, output = '';
      // if the next input index does not exist:
      //   change the mapping table to "="
      //   check if d has no fractional digits
      input.charAt(idx | 0) || (map = '=', idx % 1);
      // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
      output += map.charAt(63 & block >> 8 - idx % 1 * 8)
    ) {
      charCode = input.charCodeAt(idx += 3/4);
      if (charCode > 0xFF) {
        throw new InvalidCharacterError("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
      }
      block = block << 8 | charCode;
    }
    return output;
  });

  // decoder
  // [https://gist.github.com/1020396] by [https://github.com/atk]
  object.atob || (
  object.atob = function (input) {
    input = input.replace(/=+$/, '');
    if (input.length % 4 == 1) {
      throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
    }
    for (
      // initialize result and counters
      var bc = 0, bs, buffer, idx = 0, output = '';
      // get next character
      buffer = input.charAt(idx++);
      // character found in table? initialize bit storage and add its ascii value;
      ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,
        // and if not first of each 4 characters,
        // convert the first 8 bits to one ascii character
        bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0
    ) {
      // try to find character in table (0-63, not found => -1)
      buffer = chars.indexOf(buffer);
    }
    return output;
  });

}());

},{}],18:[function(require,module,exports){
var http = require('http');

var https = module.exports;

for (var key in http) {
    if (http.hasOwnProperty(key)) https[key] = http[key];
};

https.request = function (params, cb) {
    if (!params) params = {};
    params.scheme = 'https';
    return http.request.call(this, params, cb);
}

},{"http":14}],19:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],20:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],21:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":22}],22:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],23:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],24:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],25:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],26:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":24,"./encode":25}],27:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":28}],28:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":30,"./_stream_writable":32,"_process":22,"core-util-is":33,"inherits":19}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":31,"core-util-is":33,"inherits":19}],30:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;


/*<replacement>*/
var debug = require('util');
if (debug && debug.debuglog) {
  debug = debug.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/


util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.readableObjectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  var Duplex = require('./_stream_duplex');

  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (util.isString(chunk) && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (util.isNullOrUndefined(chunk)) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      if (!addToFront)
        state.reading = false;

      // if we want the data now, just emit it.
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit('data', chunk);
        stream.read(0);
      } else {
        // update the buffer info.
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);

        if (state.needReadable)
          emitReadable(stream);
      }

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (isNaN(n) || util.isNull(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  debug('read', n);
  var state = this._readableState;
  var nOrig = n;

  if (!util.isNumber(n) || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended)
      endReadable(this);
    else
      emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0)
      endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  }

  if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read pushed data synchronously, then `reading` will be false,
  // and we need to re-evaluate how much data we can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  var ret;
  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (util.isNull(ret)) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we tried to read() past the EOF, then emit end on the next tick.
  if (nOrig !== n && state.ended && state.length === 0)
    endReadable(this);

  if (!util.isNull(ret))
    this.emit('data', ret);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync)
      process.nextTick(function() {
        emitReadable_(stream);
      });
    else
      emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    debug('onunpipe');
    if (readable === src) {
      cleanup();
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);
    src.removeListener('data', ondata);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain &&
        (!dest._writableState || dest._writableState.needDrain))
      ondrain();
  }

  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    if (false === ret) {
      debug('false write response, pause',
            src._readableState.awaitDrain);
      src._readableState.awaitDrain++;
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain)
      state.awaitDrain--;
    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  // If listening to data, and it has not explicitly been paused,
  // then call resume to start the flow of data on the next tick.
  if (ev === 'data' && false !== this._readableState.flowing) {
    this.resume();
  }

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        var self = this;
        process.nextTick(function() {
          debug('readable nexttick read 0');
          self.read(0);
        });
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    if (!state.reading) {
      debug('resume read 0');
      this.read(0);
    }
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(function() {
      resume_(stream, state);
    });
  }
}

function resume_(stream, state) {
  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading)
    stream.read(0);
}

Readable.prototype.pause = function() {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  if (state.flowing) {
    do {
      var chunk = stream.read();
    } while (null !== chunk && state.flowing);
  }
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    debug('wrapped data');
    if (state.decoder)
      chunk = state.decoder.write(chunk);
    if (!chunk || !state.objectMode && !chunk.length)
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"./_stream_duplex":28,"_process":22,"buffer":9,"core-util-is":33,"events":13,"inherits":19,"isarray":20,"stream":39,"string_decoder/":34,"util":8}],31:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (!util.isNullOrUndefined(data))
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('prefinish', function() {
    if (util.isFunction(this._flush))
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":28,"core-util-is":33,"inherits":19}],32:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  var Duplex = require('./_stream_duplex');

  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex)
    this.objectMode = this.objectMode || !!options.writableObjectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!util.isBuffer(chunk) &&
      !util.isString(chunk) &&
      !util.isNullOrUndefined(chunk) &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (util.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (!util.isFunction(cb))
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function() {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function() {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing &&
        !state.corked &&
        !state.finished &&
        !state.bufferProcessing &&
        state.buffer.length)
      clearBuffer(this, state);
  }
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      util.isString(chunk)) {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (util.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing || state.corked)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, false, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev)
    stream._writev(chunk, state.onwrite);
  else
    stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      state.pendingcb--;
      cb(er);
    });
  else {
    state.pendingcb--;
    cb(er);
  }

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished &&
        !state.corked &&
        !state.bufferProcessing &&
        state.buffer.length) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  if (stream._writev && state.buffer.length > 1) {
    // Fast case, write everything using _writev()
    var cbs = [];
    for (var c = 0; c < state.buffer.length; c++)
      cbs.push(state.buffer[c].callback);

    // count the one we are adding, as well.
    // TODO(isaacs) clean this up
    state.pendingcb++;
    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
      for (var i = 0; i < cbs.length; i++) {
        state.pendingcb--;
        cbs[i](err);
      }
    });

    // Clear buffer
    state.buffer = [];
  } else {
    // Slow case, write chunks one-by-one
    for (var c = 0; c < state.buffer.length; c++) {
      var entry = state.buffer[c];
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);

      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        c++;
        break;
      }
    }

    if (c < state.buffer.length)
      state.buffer = state.buffer.slice(c);
    else
      state.buffer.length = 0;
  }

  state.bufferProcessing = false;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));

};

Writable.prototype._writev = null;

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (util.isFunction(chunk)) {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (util.isFunction(encoding)) {
    cb = encoding;
    encoding = null;
  }

  if (!util.isNullOrUndefined(chunk))
    this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function prefinish(stream, state) {
  if (!state.prefinished) {
    state.prefinished = true;
    stream.emit('prefinish');
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    if (state.pendingcb === 0) {
      prefinish(stream, state);
      state.finished = true;
      stream.emit('finish');
    } else
      prefinish(stream, state);
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":28,"_process":22,"buffer":9,"core-util-is":33,"inherits":19,"stream":39}],33:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":9}],34:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":9}],35:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":29}],36:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = require('stream');
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":28,"./lib/_stream_passthrough.js":29,"./lib/_stream_readable.js":30,"./lib/_stream_transform.js":31,"./lib/_stream_writable.js":32,"stream":39}],37:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":31}],38:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":32}],39:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":13,"inherits":19,"readable-stream/duplex.js":27,"readable-stream/passthrough.js":35,"readable-stream/readable.js":36,"readable-stream/transform.js":37,"readable-stream/writable.js":38}],40:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

function assertEncoding(encoding) {
  if (encoding && !Buffer.isEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  this.charBuffer = new Buffer(6);
  this.charReceived = 0;
  this.charLength = 0;
};


StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  var offset = 0;

  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var i = (buffer.length >= this.charLength - this.charReceived) ?
                this.charLength - this.charReceived :
                buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, offset, i);
    this.charReceived += (i - offset);
    offset = i;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (i == buffer.length) return charStr;

    // otherwise cut off the characters end from the beginning of this buffer
    buffer = buffer.slice(i, buffer.length);
    break;
  }

  var lenIncomplete = this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - lenIncomplete, end);
    this.charReceived = lenIncomplete;
    end -= lenIncomplete;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    this.charBuffer.write(charStr.charAt(charStr.length - 1), this.encoding);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }

  return i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 2;
  this.charLength = incomplete ? 2 : 0;
  return incomplete;
}

function base64DetectIncompleteChar(buffer) {
  var incomplete = this.charReceived = buffer.length % 3;
  this.charLength = incomplete ? 3 : 0;
  return incomplete;
}

},{"buffer":9}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":23,"querystring":26}],42:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],43:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":42,"_process":22,"inherits":19}],44:[function(require,module,exports){
module.exports = {view: require('./lib/views/audio'), model: require('./lib/models/audio')};
},{"./lib/models/audio":48,"./lib/views/audio":49}],45:[function(require,module,exports){
module.exports = {
    enableMute: true
};
},{}],46:[function(require,module,exports){
module.exports = {"audio":".bdsft-webrtc .cell-muteAudio.enableMute:not(.muted).started .mute,.bdsft-webrtc .cell-muteAudio.enableMute.muted.started .unmute{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .cell-muteAudio.enableMute:not(.started) .mute,.bdsft-webrtc .cell-muteAudio.enableMute:not(.started) .unmute,.bdsft-webrtc .cell-muteAudio.enableMute.muted.started .mute,.bdsft-webrtc .cell-muteAudio.enableMute:not(.muted).started .unmute{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .cell-muteAudio:not(.enableMute){display:none!important}"}
},{}],47:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // audio.jade compiled template
    templatizer["audio"] = function tmpl_audio() {
        return '<div class="bdsft-webrtc"><div class="cell cell-muteAudio classes"><div class="icon fadeable mute"><a href="" title="Mute Audio" class="icon-muteAudio"></a></div><div class="icon fadeable unmute"><a href="" title="Unmute Audio" class="icon-unmuteAudio"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],48:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Audio, {
  config: require('../../js/config')
});

var utils = require('webrtc-core').utils;

function Audio(eventbus, sipstack, urlconfig) {
  var self = {};

  self.updateLocalAudio = function() {
    enableLocalAudio(!self.muted);
  };

  var enableLocalAudio = function(enabled) {
    var localStreams = sipstack.getLocalStreams();
    if (!localStreams || localStreams.length === 0) {
      return;
    }
    var localMedia = localStreams[0];
    var localAudio = localMedia.getAudioTracks()[0];
    localAudio.enabled = enabled;
  };

  self.props = ['muted', 'classes'];

  self.bindings = {
    classes: {
        audio: ['muted', 'enableMute'],
        sipstack: 'callState'
      },
    localAudio: {
      audio: 'muted'
    },
    enableMute: {
      urlconfig: 'enableMute'
    }
  };

  self.mute = function() {
    self.muted = true;
  };

  self.unmute = function() {
    self.muted = false;
  };
  
  self.listeners = function() {
    eventbus.on(["resumed", "started", "userMediaUpdated"], function() {
      self.updateLocalAudio();
    });
  };

  return self;
}

},{"../../js/config":45,"webrtc-core":53}],49:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(AudioView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

function AudioView(audio, sound) {
  var self = {};

  self.elements = ['mute', 'unmute'];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.listeners = function() {
    self.mute.bind('click', clickHander(function() {
      audio.mute();
    }));
    self.unmute.bind('click', clickHander(function() {
      audio.unmute();
    }));
  };

  return self;
}
},{"../../js/styles":46,"../../js/templates":47,"webrtc-core":53}],50:[function(require,module,exports){
module.exports = {
	debug: {
		names: '*',
		level: 'debug'
	},
	urlconfig: {
		view: 'audioVideo'
	}
}

},{}],51:[function(require,module,exports){
module.exports = {"core":"@font-face{font-family:'Exario-Icon-Fonts';src:url(\"../fonts/Exario-Icon-Fonts.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'Exario-Icon-Fonts';src:url(\"data:application/font-woff;base64,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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/Exario-Icon-Fonts.svg#Exario-Icon-Fonts\") format(\"svg\");font-weight:normal;font-style:normal}@font-face{font-family:'bsl_icons';src:url(\"../fonts/bsl_icons.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'bsl_icons';src:url(\"data:application/font-woff;base64,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N3JgWV1XfTGc+xSMgoiFgoeIiomKiYuFi4aOh5CHkIeRh5KHkYOYgZ+AnoGeg54Ig52EoYSkhaSHoougi56MnIybjZuNnY+dj52RnJGakpqUm5ablpuYmZqXmpedl6CWCKCWo5Slk6aSqZGuj62PsI60iwjmi4v3AQWLm5OXmpGQjY+MkIuVi5OHk4QI92/7bwWSg4+Di4GLgYeChIQIDvtv+bn3hhWLgYl+h3qHeod+h4KDeHR3ZHVneGiBaIuBi4GMgYyBjICOf45/j4KNhY6FjYCPfJAIfJGCjoeNZphpm26dWqlZtFe/V79ivm27eal7rH2wio+IlIWahZuIlYiRiZGJlIeXCIiXiJaKlYqVipWLlYuula6er6CyoKKek5SPmI+cj5uPmY2Vi5CLj4qOipKJlXyYcQiQg5CBk36SfZF/koCRgZGAkIKMiY+HkIORg4+EjoWNho2Fi4aLg4WCgH+AgICBfoEIfoF/gYCBgYCFgouEi4iMh42GjYWNiIyIjIiOh4+Ej4WNh4uKqFetXrBmsGa4ar9uCIyKj4mRh5GHkIiOio2Kj4mQiZGJj4qOi5KLlJGWlpWVlZeVmJSYlpeWlZeWlJGTiwiQi5GJkImRiJGHk4WThpCIjYmUhpWFloWWhZeEmYSYg5WGkoemfZqBjYSMiYyHi4UIDv0m9+j4JhWLhomHh4cI+577ngWHh4eJhouGi4eNh48IbqcFh4+JkIuQi5CNj4+PCPd193T7dfd1BYePiY+LkIuQjY+PjwioqAWPj4+MkIuQi4+Kj4cI9577nwWPiI2Gi4YIDviU+fQV+3qL+077Tov7eov7evdO+073eov3eov3TvdOi/d6i/d6+073Tvt6iwj3fPu+FfvD+8MFg4N/i4OTCIWRi4v7O/c8BYOTi5eTkwi0tAWTk5eLk4MI9wr7C/eM94wFk5OXi5ODCLRiBZODi3+DgwgO+JSrFft6i/tO906L93qL93r3TvdO93qL93qL9077Tov7eov7evtO+077eosI91P4rRWTk4uYg5MIYLUFg5N/i4ODCPsM+wz7DfcMBYOTf4uDgwhgYQWEg4t+koMI9w37DPsN+wwFhIOLfpKDCLZhBZODl4uTkwj3DfcM9wz7DAWTg5eLk5MItrUFk5OLmIOTCPsN9wz3DfcMBQ74hPnkFft6i/tO+06L+3qL+3r3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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/bsl_icons.svg#bsl_icons\") format(\"svg\");font-weight:normal;font-style:normal}.bdsft-webrtc [class^=\"icon-\"],.bdsft-webrtc [class*=\" icon-\"]{font-family:'bsl_icons';speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.bdsft-webrtc [class^=\"icon-\"].exario{font-family:'Exario-Icon-Fonts';speak:none;text-decoration:none;margin:0 .35em 0 0;font-size:25px}.bdsft-webrtc .icon-link:before{content:\"\\e00b\"}.bdsft-webrtc .icon{cursor:pointer}.bdsft-webrtc .icon a{speak:none;text-decoration:none;margin:0 .35em 0 0}.bdsft-webrtc .icon a:before{color:#fff}.bdsft-webrtc .icon-quality:before{color:#0f0;opacity:.4}.bdsft-webrtc .icon-quality1:before{content:\"\\e007\"}.bdsft-webrtc .icon-quality2:before{content:\"\\e006\"}.bdsft-webrtc .icon-quality3:before{content:\"\\e005\"}.bdsft-webrtc .icon-quality4:before{content:\"\\e004\"}.bdsft-webrtc .icon-trash:before{content:\"\\e013\";color:#f00}.bdsft-webrtc .icon-screen-sharing:before{content:\"\\e604\"}.bdsft-webrtc .icon-screen-sharing-off:before{content:\"\\e605\"}.bdsft-webrtc .icon-dialpadShow:before,.bdsft-webrtc .icon-dialpadShow:hover:before,.bdsft-webrtc .icon-dialpadHide:before,.bdsft-webrtc .icon-dialpadHide:hover:before{content:\"\\ed3b\"}.bdsft-webrtc a.icon-hangup:before,.bdsft-webrtc a.icon-hangup:hover:before{content:\"\\e600\";color:#f00}.bdsft-webrtc .icon-clock:before{content:\"\\e634\"}.bdsft-webrtc .icon-cog:before,.bdsft-webrtc .icon-settings:before,.bdsft-webrtc .icon-settings:hover:before{content:\"\\e601\"}.bdsft-webrtc .icon-resume:before,.bdsft-webrtc .icon-resume:hover:before,.bdsft-webrtc .icon-hold:before,.bdsft-webrtc .icon-hold:hover:before{content:\"\\e6bb\"}.bdsft-webrtc .icon-unmuteAudio:before,.bdsft-webrtc .icon-unmuteAudio:hover:before{content:\"\\e6c1\"}.bdsft-webrtc .icon-muteAudio:before,.bdsft-webrtc .icon-muteAudio:hover:before{content:\"\\e6c3\"}.bdsft-webrtc .icon-arrow-up-thick:before{content:\"\\f5a4\"}.bdsft-webrtc .icon-arrow-down-thick:before{content:\"\\f5a5\"}.bdsft-webrtc .icon-cancel3:before{content:\"\\f2c9\"}.bdsft-webrtc .icon-fullscreenContract:before,.bdsft-webrtc .icon-fullscreenContract:hover:before,.bdsft-webrtc .icon-fullscreenExpand:before,.bdsft-webrtc .icon-fullscreenExpand:hover:before{content:\"\\f371\"}.bdsft-webrtc .icon-th:before{content:\"\\e602\"}.bdsft-webrtc .icon-selfViewShow:before,.bdsft-webrtc .icon-selfViewShow:hover:before,.bdsft-webrtc .icon-selfViewHide:before,.bdsft-webrtc .icon-selfViewHide:hover:before{content:\"\\f17f\"}.bdsft-webrtc .icon-transfer:before,.bdsft-webrtc .icon-transfer:hover:before{content:\"\\f186\"}.bdsft-webrtc .icon-angle-right:before{content:\"\\f1fe\"}.bdsft-webrtc a.icon-call:before{content:\"\\e00e\";color:#3b9e3b}.bdsft-webrtc .icon-highlightable:hover{color:<%= iconHighlightColor %>}.bdsft-webrtc .icon a:hover:before,.bdsft-webrtc .icon a:hover,.bdsft-webrtc .icon span:hover,.bdsft-webrtc .videoBar a:hover:before,.bdsft-webrtc .videoBar a:hover{color:<%= iconHighlightColor %>}.bdsft-webrtc .table{display:table;width:100%}.bdsft-webrtc .fixed{table-layout:fixed}.bdsft-webrtc .collapse{border-collapse:collapse}.bdsft-webrtc .cell{display:table-cell}.bdsft-webrtc .heading{display:table-row;font-weight:bold}.bdsft-webrtc .row{display:table-row;margin:0}.bdsft-webrtc .group{display:table-row-group}.bdsft-webrtc .hidden{display:none!important}.bdsft-webrtc .opaque{opacity:0!important}.bdsft-webrtc .popup{background:#292929;padding:10px;border:2px solid #ddd;float:left;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;box-shadow:0 0 10px #999;border-radius:3px;font-size:14px;line-height:18px;z-index:100}.bdsft-webrtc .popup .actions{text-align:right}.bdsft-webrtc .popup .title{font-weight:bold;font-size:18px;color:#fff}.bdsft-webrtc .centered{top:50%;left:50%;bottom:auto;right:auto;transform:translate(-50%,-50%);backface-visibility:hidden}.bdsft-webrtc .centered.audioOnly:not(.offerToReceiveVideo){top:45px;bottom:auto;transform:translate(-50%,0)}.bdsft-webrtc .topright{right:auto;left:100%;top:0;bottom:auto}.bdsft-webrtc .bottomleft{right:auto;left:0;bottom:auto;top:100%}.bdsft-webrtc .audioOnly .centered,.bdsft-webrtc .audioOnly.centered{top:0;transform:translate(-50%,40px)}.bdsft-webrtc .fadeable{opacity:0;display:block;z-index:-1;backface-visibility:hidden}.bdsft-webrtc .fadeIn{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .fadeOut{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}@keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-o-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-moz-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@-webkit-keyframes flickerAnimation{0%{opacity:0;height:0}5%{opacity:.5;height:auto}20%{opacity:1;height:auto}80%{opacity:1;height:auto}85%{opacity:.5;height:auto}100%{opacity:0;height:0}}@keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-o-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-moz-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}@-webkit-keyframes fadeInAnimation{0%{opacity:0;height:0}5%{opacity:.1;height:auto}20%{opacity:.2;height:auto}80%{opacity:.8;height:auto}100%{opacity:1;height:auto}}"}
},{}],52:[function(require,module,exports){
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

/* More information about these options at jshint.com/docs/options */
/* global mozRTCIceCandidate, mozRTCPeerConnection,
mozRTCSessionDescription, webkitRTCPeerConnection */
/* exported trace,requestUserMedia */

'use strict';

var RTCPeerConnection = null;
var getUserMedia = null;
var attachMediaStream = null;
var reattachMediaStream = null;
var webrtcDetectedBrowser = null;
var webrtcDetectedVersion = null;

function trace(text) {
  // This function is used for logging.
  if (text[text.length - 1] === '\n') {
    text = text.substring(0, text.length - 1);
  }
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ': ' + text);
  } else {
    console.log(text);
  }
}

if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  console.log('This appears to be Firefox');

  webrtcDetectedBrowser = 'firefox';

  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    // .urls is not supported in FF yet.
    if (pcConfig && pcConfig.iceServers) {
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        if (pcConfig.iceServers[i].hasOwnProperty('urls')) {
          pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
          delete pcConfig.iceServers[i].urls;
        }
      }
    }
    return new mozRTCPeerConnection(pcConfig, pcConstraints);
  };

  // The RTCSessionDescription object.
  window.RTCSessionDescription = mozRTCSessionDescription;

  // The RTCIceCandidate object.
  window.RTCIceCandidate = mozRTCIceCandidate;

  // getUserMedia shim (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.mozGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Shim for MediaStreamTrack.getSources.
  MediaStreamTrack.getSources = function(successCb) {
    setTimeout(function() {
      var infos = [
        {kind: 'audio', id: 'default', label:'', facing:''},
        {kind: 'video', id: 'default', label:'', facing:''}
      ];
      successCb(infos);
    }, 0);
  };

  // Creates ICE server from the URL for FF.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create ICE server with STUN URL.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      if (webrtcDetectedVersion < 27) {
        // Create iceServer with turn url.
        // Ignore the transport parameter from TURN url for FF version <=27.
        var turnUrlParts = url.split('?');
        // Return null for createIceServer if transport=tcp.
        if (turnUrlParts.length === 1 ||
          turnUrlParts[1].indexOf('transport=udp') === 0) {
          iceServer = {
            'url': turnUrlParts[0],
            'credential': password,
            'username': username
          };
        }
      } else {
        // FF 27 and above supports transport parameters in TURN url,
        // So passing in the full url to create iceServer.
        iceServer = {
          'url': url,
          'credential': password,
          'username': username
        };
      }
    }
    return iceServer;
  };

  window.createIceServers = function(urls, username, password) {
    var iceServers = [];
    // Use .url for FireFox.
    for (var i = 0; i < urls.length; i++) {
      var iceServer =
        window.createIceServer(urls[i], username, password);
      if (iceServer !== null) {
        iceServers.push(iceServer);
      }
    }
    return iceServers;
  };

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    console.log('Attaching media stream');
    element.mozSrcObject = stream;
  };

  reattachMediaStream = function(to, from) {
    console.log('Reattaching media stream');
    to.mozSrcObject = from.mozSrcObject;
  };

} else if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  console.log('This appears to be Chrome');

  webrtcDetectedBrowser = 'chrome';
  // Temporary fix until crbug/374263 is fixed.
  // Setting Chrome version to 999, if version is unavailable.
  var result = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
  if (result !== null) {
    webrtcDetectedVersion = parseInt(result[2], 10);
  } else {
    webrtcDetectedVersion = 999;
  }

  // Creates iceServer from the url for Chrome M33 and earlier.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create iceServer with stun url.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      // Chrome M28 & above uses below TURN format.
      iceServer = {
        'url': url,
        'credential': password,
        'username': username
      };
    }
    return iceServer;
  };

  // Creates an ICEServer object from multiple URLs.
  window.createIceServers = function(urls, username, password) {
    return {
      'urls': urls,
      'credential': password,
      'username': username
    };
  };

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    return new webkitRTCPeerConnection(pcConfig, pcConstraints);
  };

  // Get UserMedia (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    if (typeof element.srcObject !== 'undefined') {
      element.srcObject = stream;
    } else if (typeof element.mozSrcObject !== 'undefined') {
      element.mozSrcObject = stream;
    } else if (typeof element.src !== 'undefined') {
      element.src = URL.createObjectURL(stream);
    } else {
      console.log('Error attaching stream to element.');
    }
  };

  reattachMediaStream = function(to, from) {
    to.src = from.src;
  };
} else {
  console.log('Browser does not appear to be WebRTC-capable');
}

// Returns the result of getUserMedia as a Promise.
function requestUserMedia(constraints) {
  return new Promise(function(resolve, reject) {
    var onSuccess = function(stream) {
      resolve(stream);
    };
    var onError = function(error) {
      reject(error);
    };

    try {
      getUserMedia(constraints, onSuccess, onError);
    } catch (e) {
      reject(e);
    }
  });
}

if (typeof module !== 'undefined') {
  module.exports = {
    RTCPeerConnection: RTCPeerConnection,
    getUserMedia: getUserMedia,
    attachMediaStream: attachMediaStream,
    reattachMediaStream: reattachMediaStream,
    webrtcDetectedBrowser: webrtcDetectedBrowser,
    webrtcDetectedVersion: webrtcDetectedVersion,
    requestUserMedia: requestUserMedia,
    trace: trace
  };
}

},{}],53:[function(require,module,exports){
var adapter = require('./adapter');
var constants = require('./constants');
var cookieprop = require('./cookieprop');
var visibleprop = require('./visibleprop');
var dateformat = require('./dateformat');
var icon = require('./icon');
var prop = require('./prop');
var utils = require('./utils');
var eventbus = require('./eventbus');
var debug = require('./debug');
var bdsft = require('./bdsft');
var element = require('./element');
var factory = require('./factory');
var popup = require('./popup');
var loader = require('./loader');
var urlconfig = require('./urlconfig');
var cookieconfig = require('./cookieconfig');


module.exports = {adapter: adapter, constants: constants, cookieprop: cookieprop, visibleprop: visibleprop, dateformat:  dateformat,
icon: icon, prop: prop, utils: utils, eventbus: eventbus, debug: debug, bdsft: bdsft, element: element, factory: factory, popup: popup, 
loader: loader, urlconfig: urlconfig, cookieconfig: cookieconfig};
},{"./adapter":52,"./bdsft":54,"./constants":57,"./cookieconfig":58,"./cookieprop":59,"./dateformat":62,"./debug":63,"./element":64,"./eventbus":65,"./factory":66,"./icon":67,"./loader":68,"./popup":69,"./prop":70,"./urlconfig":72,"./utils":73,"./visibleprop":74}],54:[function(require,module,exports){
var utils = require('./utils')
var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;
var DataBinder = require('./databinder');
var Utils = require('./utils');
var StylesManager = require('./stylesmanager');

var databinder = function(name, constructorArgs, source) {
	var databinder;
	if (name === source._name || name === 'self') {
		if (!source.databinder) {
			throw Error('databinder : undefined on ' + source._name);
		}
		return source.databinder;
	}

	for (var i = 0; i < constructorArgs.length; i++) {
		if (constructorArgs[i]._name && (constructorArgs[i]._name === name || constructorArgs[i]._name.replace(/view$/, '') === name)) {
			if (!constructorArgs[i].databinder) {
				throw Error('databinder : undefined on ' + name);
			}
			return constructorArgs[i].databinder;
		}
	}

	// View without model
	if (name === source._name.replace(/view$/, '')) {
		return new DataBinder(name);
	}

	throw Error('databinder : ' + name + ' constructor argument missing in ' + source._name);
};
var bdsft = {
	View: View,
	Model: Model,
	databinder: databinder
};

module.exports = bdsft;

function View(constructor, options) {
	var self = {};

	self.options = options;
	self.argNames = argNamesFun(constructor);
	self.name = functionName(constructor);
	self.viewName = self.name.replace('view', '');
	self.constructor = constructor;

	self.create = function(constructorArgs, createOptions) {
		constructorArgs = constructorArgs || [];
		createOptions = createOptions || {};
		options = options || {};
		var object = createFun(constructor, constructorArgs);

		object.appendTo = function(view) {
			object.view.appendTo(view);
		};
		object.updateContentView = function(contentView, items, createItemViewCallback) {
			object._contentViews = object._contentViews || {};
			for (var name in items) {
				var item = items[name];
	      		var view = object._contentViews[name];
	      		if(!view) {
					var view = createItemViewCallback(item);
					object._contentViews[name] = view;
					view.view.appendTo(contentView);
	      		}
			}
			for(var name in object._contentViews) {
				if(!items[name]) {
					object._contentViews[name].view.remove();
					delete object._contentViews[name];
				}
			}
		};

		object._name = self.name;
		object.databinder = databinder(self.viewName, constructorArgs, object);
		var view = createOptions.template && createOptions.template[self.viewName] && createOptions.template[self.viewName]() || options.template && options.template[self.viewName] && options.template[self.viewName]() || object.template || require(self.viewName + '-bdsft-webrtc-templates')[self.viewName] && require(self.viewName + '-bdsft-webrtc-templates')[self.viewName]();
		if (!view) {
			console.error('no view template found : ' + self.viewName);
			return;
		}
		object.view = require('jquery')(view);
		(object.elements || []).forEach(function(element) {
			require('./app').element(object, element, object.databinder);
		});
		bindings(object, constructorArgs);
		call(object, 'listeners', options, constructorArgs);
		call(object, 'init', options, constructorArgs);

		StylesManager.inject(self.viewName, createOptions, options);

		var classesHolder = object.view.find('.classes:first');
		if (classesHolder.length === 0) {
			classesHolder = object.view;
		}
		var classes = classesHolder.attr('class');
		object.databinder.onModelPropChange('classes', function(value) {
			classesHolder.attr('class', classes + ' ' + value.join(' '));
		});

		return object;
	};

	return self;
}

function Model(constructor, options) {
	var self = {};

	self.create = function(constructorArgs, createOptions) {
		constructorArgs = constructorArgs || [];
		createOptions = createOptions || {};
		options = options || {};
		var object = createFun(constructor, constructorArgs);
		object._name = self.name;
		object.databinder = new DataBinder(self.name);
		var medias = utils.extend({},
			options.media,
			options.media && options.media['media'],
			options.media && options.media[self.name],
			createOptions.media && createOptions.media[self.name]
		);
		if (Object.keys(medias).length) {
			object.medias = medias;
		}
		var createConfig = createOptions.config && createOptions.config[self.name] || createOptions[self.name];
		var config = options.config && options.config[self.name] || options.config;
		if (config || createConfig) {
			var config = utils.extend({}, config, createConfig);
			for (var name in config) {
				require('./app')['prop'](object, {
					name: name,
					value: config[name]
				}, object.databinder);
			}
			if (!object.updateConfig) {
				object.updateConfig = function(config) {
					config = config || {};
					for (var name in config) {
						if (typeof object[name] !== 'undefined') {
							object[name] = config[name];
						}
					}
				};
			}
			if (!object.configChanges) {
				object.configChanges = function() {
					var changes = {};
					for (var name in config) {
						if (JSON.stringify(object[name]) !== JSON.stringify(config[name])) {
							changes[name] = object[name];
						}
					}
					return changes;
				};
			}
		}
		(Array.isArray(object.props) && object.props || object.props && Object.keys(object.props) || []).forEach(function(name) {
			var value = object.props[name];
			var prop = utils.extend({
				name: name
			}, typeof value !== 'object' && {
				value: value
			} || value)
			var type = prop.type || object._propstype || object.props._type || '';
			if (type === 'default') {
				type = '';
			}
			if (name === 'visible') {
				type = 'visible';
			}
			require('./app')[type + 'prop'](object, prop, object.databinder);
		});
		bindings(object, constructorArgs);
		call(object, 'listeners', options, constructorArgs);
		call(object, 'init', options, constructorArgs);
		return object;
	};

	self.argNames = argNamesFun(constructor);
	self.name = functionName(constructor);
	self.options = options;
	self.constructor = constructor;

	return self;
};

function bindings(object, constructorArgs) {
	(object.bindings && Object.keys(object.bindings) || []).forEach(function(name) {
		var from = object.bindings[name];
		var binding;
		if (name === 'classes') {
			binding = require('./classesbinding')(object, name, from, constructorArgs);
		} else {
			binding = require('./binding')(object, name, from, constructorArgs);
		}
		binding.init();
	});
}

function functionName(fun) {
	var ret = fun.toString();
	ret = ret.substr('function '.length);
	ret = ret.substr(0, ret.indexOf('('));
	return ret.toLowerCase();
}

function argNamesFun(fun) {
	var fnStr = fun.toString().replace(STRIP_COMMENTS, '')
	var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)
	if (result === null) {
		result = [];
	}
	return result;
}

function call(object, method, options, constructorArgs) {
	if (!object[method]) {
		return;
	}
	var argNames = argNamesFun(object[method]);
	var args = [];
	for (var i = 0; i < argNames.length; i++) {
		if (argNames[i].match(/databinder/i)) {
			var databinderArg = databinder(argNames[i].replace(/databinder/i, '') || object._name, constructorArgs, object);
			args.push(databinderArg);
		} else if (argNames[i] === 'options') {
			args.push(options);
		} else {
			// console.warn('no arg on '+ name +' found for : '+argNames[i]);
		}
	}
	return createFun(object[method], args);
}

function createFun(constructor, argArray) {
	var args = [null].concat(argArray);
	var factoryFunction = constructor.bind.apply(constructor, args);
	return new factoryFunction();
}
},{"./app":53,"./binding":55,"./classesbinding":56,"./databinder":61,"./stylesmanager":71,"./utils":73,"jquery":98}],55:[function(require,module,exports){
module.exports = Binding;
var bdsft = require('./bdsft');
var utils = require('./utils');

function Binding(object, toProp, from, constructorArgs) {
	var self = {};

	self.fromObject = function(fromModel) {
		var fromModelObj;
		if (object._name === fromModel || fromModel === 'self') {
			fromModelObj = object;
		} else {
			fromModelObj = constructorArgs.filter(function(arg) {
				return arg._name === fromModel;
			}).pop();
		}

		return fromModelObj;
	};

	self.init = function init() {
		var fromKeys = Object.keys(from);

		fromKeys.forEach(function(fromModel) {
			var databinder = bdsft.databinder(fromModel, constructorArgs, object);
			var fromProp = from[fromModel];
			var fromObj = self.fromObject(fromModel);
			if(fromObj) {
				if (Array.isArray(fromProp)) {
					fromProp.forEach(function(p) {
						if (!fromObj.hasOwnProperty(p)) {
							throw Error('binding error : '+p + ' does not exist in ' + fromModel);
						}
					})
				} else if (!fromObj.hasOwnProperty(fromProp)) {
					throw Error('binding error : '+fromProp + ' does not exist in ' + fromModel);
				}
			}

			var onChange = function(value, name) {
				var updateHandle = utils.camelize('update ' + toProp);
				if (typeof object[updateHandle] === 'function') {
					object[updateHandle](value, name);
				} else if (object.hasOwnProperty(updateHandle)) {
					object[updateHandle] = value;
				} else {
					var targetObj = self.fromObject(toProp);
					if(targetObj) {
						targetObj[name] = value;
						return;
					}
					
					if(!object.hasOwnProperty(toProp)) {
						throw Error('binding error : prop '+toProp + ' does not exist in ' + (object._name || object));
					}
					object[toProp] = value;
				}
			};
			databinder.onViewElChange(fromProp, onChange);
			databinder.onModelPropChange(fromProp, onChange);
		});
	};

	return self;
}
},{"./bdsft":54,"./utils":73}],56:[function(require,module,exports){
module.exports = ClassesBinding;

function ClassesBinding(object, toProp, from, constructorArgs) {
	var self = require('./binding')(object, toProp, from, constructorArgs);

	var value = function(fromObj, fromProp) {
		var val = fromObj[fromProp];
		if(typeof val === 'function') {
			val = val();
		}

		if (Array.isArray(val)) {
			return val;
		} else if (typeof val === 'string') {
			return val;
		} else if (typeof val === 'boolean' && fromProp.match(/visible/i)) {
			var prefix = fromProp.replace(/visible/i, '') || fromObj._name;
			return val ? prefix + '-shown' : prefix + '-hidden';
		} else {
			if (val) {
				return fromProp;
			}
		}
		return;
	};

	object.updateClasses = function() {
		var classes = [];
		Object.keys(from).forEach(function(fromModel) {
			var fromProp = from[fromModel];
			var fromObj = self.fromObject(fromModel);
			if(!fromObj) {
				throw Error('classes binding error : '+fromModel + ' does not exist in constructor of ' + object._name);
			}

			(Array.isArray(fromProp) && fromProp || [fromProp]).forEach(function(prop) {
				var val = value(fromObj, prop);
				if(!val) {
					return;
				} else if (Array.isArray(val)) {
					classes = classes.concat(val);
				} else {
					classes.push(val)
				}
			});
		});
		// prepend classes that start with a number with _
		classes = classes.map(function(clazz){
			return clazz.match(/^\d/) && '_' + clazz || clazz
		});
		// replace empty space with - and lower case 
		classes = classes.map(function(clazz){
			return clazz.trim().replace(/\s/, '-');
		});
		object[toProp] = classes;
	};

	return self;
}
},{"./binding":55}],57:[function(require,module,exports){
var C = {
    // RTCSession states
  STATE_CONNECTED: "connected",
  STATE_DISCONNECTED: "disconnected",
  STATE_CALLING: "calling",
  STATE_STARTED: "started",
  STATE_HELD: "held",
  
  WIDESCREEN: 'widescreen',
  STANDARD: 'standard',
  R_1920x1080: '1920x1080',
  R_1280x720: '1280x720',
  R_640x360: '640x360',
  R_320x180: '320x180',
  R_960x720: '960x720',
  R_640x480: '640x480',
  R_320x240: '320x240',
  EXPIRES: 365,

  STYLES: {
    iconHighlightColor: '#00adef'
  }

};

module.exports = C;
},{}],58:[function(require,module,exports){
module.exports = require('./bdsft').Model(CookieConfig);

var jQuery = $ = require('jquery');
require('jquery.cookie');

function CookieConfig() {
	var self = {};
	var prefix = 'bdsft_';

	self.get = function(name) {
		return $.cookie(prefix + name);
	};
	self.set = function(name, value) {
		return $.cookie(prefix + name, value);
	};

	self._propstype = 'cookie';

	self.props = ['authenticationUserid', 'userid', 'password', 'encodingResolution', 'displayResolution', 'hd', 'displayName', 'enableSelfView', 
		'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer'];

	return self;
}
},{"./bdsft":54,"jquery":98,"jquery.cookie":97}],59:[function(require,module,exports){
module.exports = CookieProp;

var Prop = require('./prop');
var C = require('./constants');
var Utils = require('./utils');
var $ = require('jquery');
require('jquery.cookie')

function CookieProp(obj, prop, databinder) {

	var self = {};

	var cookie = 'bdsft_'+ obj._name + '_' + prop.name;
	var expires = C.EXPIRES;

	var _onInit = prop.onInit;
	prop.onInit = function(){
		if(!prop.value && $.cookie(cookie)) {
			var value = $.cookie(cookie);
			if(value === 'true') {
 				obj[prop.name] = true;
			} else if(value === 'false') {
 				obj[prop.name] = false;
			} else {
 				obj[prop.name] = value;
			}
		}
		_onInit && _onInit();
		// console.log('cookie oninit : '+prop.name, obj[prop.name]);
	};

	var _onSet = prop.onSet;
	prop.onSet = function(value){
		if (value) {
			$.cookie(cookie, value, {
				expires: expires
			});
		} else {
			$.removeCookie(cookie);
		}
		_onSet && _onSet(value);
	};

	var propObj = Prop(obj, prop, databinder);

	return propObj;
}
},{"./constants":57,"./prop":70,"./utils":73,"jquery":98,"jquery.cookie":97}],60:[function(require,module,exports){
module.exports = CSS;

var ejs = require('ejs');
var utils = require('./utils');
var constants = require('./constants');

function CSS(name) {
	var self = {};

	var id = 'bdsft_css_'+name;

	var cssData = function(styleData, options){
		return utils.extend({}, options.constants && options.constants.STYLES || constants.STYLES, styleData);
	};

	var cssStr = function(styleData, options){
		var styles = options.style;
		if(!styles) {
			return;
		}
		return ejs.render(styles, cssData(styleData, options));
	};

	self.inject = function(styleData, options) {
		var css = cssStr(styleData, options);
		if(!css) {
			return;
		}
		var cssEl = utils.getElement('#'+id);
		if (!cssEl || cssEl.length === 0) {
			self.data = cssData(styleData, options);
			utils.createElement('<style>', {
				id: id,
				type: 'text/css',
				text: css
			}, {
				parent: 'head'
			});
		}
	};

	self.update = function(styleData, options) {
		var css = cssStr(styleData, options);
		if(!css) {
			return;
		}
		var cssEl = utils.getElement('#'+id);
		if (cssEl && cssEl.length > 0) {
			self.data = cssData(styleData, options);
			cssEl.text(css)
		}
	};

	return self;
}
},{"./constants":57,"./utils":73,"ejs":79}],61:[function(require,module,exports){
module.exports = DataBinder;

var ee = require('event-emitter');

function DataBinder( objectid ) {
  var emitter = ee({});

  var lastValues = {};
  var self = {};

  self.onModelChange = function(cb){
    emitter.on(objectid, function(data){
      if(!data.fromView) {
        cb(data.name, data.value, data.sender);
      }
    });
  };
  self.onModelPropChangeListener = function(name, cb){
    self.onModelChange(function(_name, value, sender){
      if(Array.isArray(name) && name.indexOf(_name) !== -1 || _name === name) {
        cb(value, _name, sender);
      }
    });
  };
  self.onModelPropChange = function(name, cb){
    self.onModelPropChangeListener(name, cb);
    (Array.isArray(name) && name || [name]).forEach(function(n){
      lastValues[n] !== undefined && cb(lastValues[n], n);
    });
  };
  self.onViewChange = function(cb){
    emitter.on(objectid, function(data){
      if(data.fromView) {
        cb(data.name, data.value, data.sender);
      }
    });
  };
  self.onViewElChangeListener = function(name, cb){
    self.onViewChange(function(_name, value, sender){
        if(Array.isArray(name) && name.indexOf(_name) !== -1 || _name === name) {
          cb(value, _name, sender);
        }
    });
  };
  self.onViewElChange = function(name, cb){
    self.onViewElChangeListener(name, cb);
    (Array.isArray(name) && name || [name]).forEach(function(n){
      lastValues[n] !== undefined && cb(lastValues[n], n);
    });
  };

  var emit  = function(name, value, fromView, sender, force){
    // break if both are NaNs as it does not match on equality
    if(value+'' === 'NaN' && lastValues[name]+'' === 'NaN') {
      return;
    }

    if(force || lastValues[name] !== value) {
      lastValues[name] = value;
      emitter.emit(objectid, {name: name, value: value, fromView: fromView, sender: sender});
    }
  };

  self.viewChanged = function(name, value, sender, force){
    emit(name, value, true, sender, force);
  };
  self.modelChanged = function(name, value, sender, force){
    emit(name, value, false, sender, force);
  };

  return self;
}

},{"event-emitter":82}],62:[function(require,module,exports){
module.exports = DateFormat;
var C = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  mthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
C.zeroPad = function(number) {
  return ("0" + number).substr(-2, 2);
};
C.dateMarkers = {
  d: ['getDate', function(v) {
    return C.zeroPad(v);
  }],
  m: ['getMonth', function(v) {
    return C.zeroPad(v + 1);
  }],
  n: ['getMonth', function(v) {
    return C.mthNames[v];
  }],
  w: ['getDay', function(v) {
    return C.dayNames[v];
  }],
  y: ['getFullYear', function(v) {
    return v;
  }],
  H: ['getHours', function(v) {
    return C.zeroPad(v);
  }],
  M: ['getMinutes', function(v) {
    return C.zeroPad(v);
  }],
  S: ['getSeconds', function(v) {
    return C.zeroPad(v);
  }],
  i: ['toISOString']
};

DateFormat.C = C;

function DateFormat(fstr) {
  this.formatString = fstr;
}

DateFormat.prototype = {
  format: function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = C.dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if (dateMarker[1] !== null) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  }
};
},{}],63:[function(require,module,exports){
module.exports = require('./bdsft').Model(Debug, {
	config: require('../js/config')
})

var stacktrace = require('stacktrace-js');
var utils = require('./utils');
var debug = require('debug');
var enabled = {};
var levels = {
	debug: 0,
	log: 1,
	info: 2,
	warn: 3,
	error: 4
};
function Debug(options) {
	var self = {};
	options = options || {};
	var id = options && options.id || options || '';

	var prefix = (options.name || caller()) + ':' + id;
	var debugObj;

	self.init = function(){
		var logPrefix = self.names;
		if(logPrefix+'' === 'true') {
			logPrefix = '*'
		}

		if (logPrefix) {
			enabled[id] = utils.withArray(logPrefix).map(function(a){
				return a + ':' + id;
			});
		} else {
			delete enabled[id];
		}
		updateEnabled();

		debugObj = debug(prefix);
	};

	var printMsg = function(level, msg) {
		if(self.level && levels[level] >= levels[self.level]) {
			debugObj.log = console[level].bind(console);
			self.print(msg);
		}
	}
	self.print = function(msg) {
		debugObj(msg);
	};
	self.log = function(msg){
		printMsg('log', msg);
	};
	self.warn = function(msg){
		printMsg('warn', msg);
	};
	self.error = function(msg){
		printMsg('error', msg);
	};
	self.debug = function(msg){
		printMsg('debug', msg);
	};
	self.info = function(msg){
		printMsg('info', msg);
	};

	return self;
}

var caller = function(){
	var list = stacktrace();
	for(var i=list.length-1; i >= 0; i--) {
		var match = null;
		if((match = list[i].match(/([A-Z]\S*).*@/g))) {
			if(match !== 'Object') {
				return match;				
			}
		}
	}

	return stacktrace().pop().match('(.*)@').pop();
}
var updateEnabled = function() {
	var values = [];
	Object.keys(enabled).forEach(function(key) {
		if(Array.isArray(enabled[key])) {
			values = values.concat(enabled[key]);
		} else {
			values.push(enabled[key]);
		}
	});
	debug.enable(values.join(','));
};
// exports.enable = function(id){
// 	enabledList.push('*'+id);
// 	var enabledStr = enabledList.join(',');
// 	debug.enable(enabledStr);
// };
// exports.disable = function(){
// 	enabledList = [];
// 	debug.disable();
// };
// exports.log = debug.log;
},{"../js/config":50,"./bdsft":54,"./utils":73,"debug":75,"stacktrace-js":100}],64:[function(require,module,exports){
module.exports = Element;

function Element(object, name, databinder) {
	var self = {};

	var element = object.view.find('.' + name);
	if(!element || !element.length) {
		console.warn('no element found for ' + name + ' in template '+object._name);
		return;
	}

	object[name] = element;

	element.on('change', function(){
		databinder.viewChanged(name, get(), self);
	});

	var isCheckbox = function() {
		return element.attr('type') === 'checkbox';
	};

	var isTextbox = function() {
		return (element.attr('type') === 'text' || element.attr('type') === 'password' || element.is('textarea'));
	};

	var isSelect = function() {
		return element && element[0] && element[0].nodeName.match(/select/i);
	};

	var get = function(){
		if(isCheckbox()){
			return element.prop('checked')
		} else if(isTextbox() || isSelect()) {
			return element.val();
		} else {
			return element.text();
			// console.error('element is no input : ', element);
		}
	};

	var set = function(value){
		if(isCheckbox()){
			element.prop('checked', value);
		} else if(isTextbox() || isSelect()) {
			element.val(typeof value !== 'undefined' ? value : '');
		} else {
			element.text(typeof value !== 'undefined' ? value : '');
			// console.error('element is no input : ', element);
		}
	};

	databinder.onModelPropChange(name, function(value){
		set(value);
		// databinder.viewChanged(name, value);
	});

	// add view listener to handle mutliple views sync
	databinder.onViewElChange(name, function(value, name, sender){
		if(sender !== self) {
			set(value);
		}
	});

	return self;
}
},{}],65:[function(require,module,exports){
module.exports = require('./bdsft').Model(EventBus);

var ee = require('event-emitter');

function EventBus() {
	var self = {};

	var lastEvents = {};

	var emitter = ee({});

	self.on = function(type, listener) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				emitter.on(t, listener);
			});
		} else {
			emitter.on(type, listener);
		}
	};
	self.once = function(type, listener) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				emitter.once(t, listener);
			});
		} else {
			emitter.once(type, listener);
		}
	};
	var doEmit = function(type, obj) {
		lastEvents[type] = obj;
		emitter.emit(type, obj);
	};
	self.emit = function(type, obj) {
		if (Array.isArray(type)) {
			type.forEach(function(t) {
				doEmit(t, obj);
			});
		} else {
			doEmit(type, obj);
		}
	};
	self.endCall = function() {
		self.emit('endCall', {});
	};
	self.userMediaUpdated = function(localStream) {
		self.emit('userMediaUpdated', {localStream: localStream});
	};
	self.incomingCall = function(data) {
		self.emit('incomingCall', data);
	};
	self.progress = function(data) {
		self.emit('progress', data);
	};
	self.started = function(data) {
		self.emit('started', data);
	};
	self.failed = function(data) {
		self.emit('failed', data);
	};
	self.ended = function(data) {
		self.emit('ended', data);
	};
	self.held = function(data) {
		self.emit('held', data);
	};
	self.resumed = function(data) {
		self.emit('resumed', data);
	};
	self.dataSent = function(data) {
		self.emit('dataSent', data);
	};
	self.dataReceived = function(data) {
		self.emit('dataReceived', data);
	};
	self.newDTMF = function(data) {
		self.emit('newDTMF', data);
	};
	self.reInvite = function(data) {
		self.emit('reInvite', data);
	};
	self.digit = function(digit, isFromDestination) {
		self.emit('digit', {
			digit: digit,
			isFromDestination: isFromDestination
		});
	};
	self.iceconnected = function(sender, data) {
		self.emit("iceconnected", {
			sender: sender,
			data: data
		});
	};
	self.icecompleted = function(sender, data) {
		self.emit("icecompleted", {
			sender: sender,
			data: data
		});
	};
	self.iceclosed = function(sender, data) {
		self.emit("iceclosed", {
			sender: sender,
			data: data
		});
	};
	self.calling = function(destination, session) {
		self.emit('calling', {
			destination: destination,
			session: session
		});
	};
	self.modifier = function(which) {
		self.emit('modifier', {
			which: which
		});
	};

	return self;
}
},{"./bdsft":54,"event-emitter":82}],66:[function(require,module,exports){
(function (global){
var $ = require('jquery');
var Utils = require('./utils');
module.exports = Factory;

function Factory(options) {
	options.dependencies = options.dependencies || {};

	function getId() {
		var id;
		if (typeof options === "object") {
			id = options.id;
		}
		return id || 'default';
	};

	function moduleOf(className, constructor) {
		var module = Utils.decamelize(className).split(' ')[0];
		if(options.dependencies[module]) {
			var name = className.replace(module, '').toLowerCase();
			if(options.dependencies[module][name]) {
				return module;
			}
		}

		// lookup in parent module
		if(constructor) {
			var module = options.dependencies[constructor.module];
			if(module && module[className]) {
				return constructor.module;
			}
		}

		// lookup name in all dependencies
		var modules = Object.keys(options.dependencies);
		for(var i=0; i < modules.length; i++){
			var module = modules[i];

			var dependency = options.dependencies[module][className] || options.dependencies[module][className.toLowerCase()];
			if(dependency) {
				return module;
			}

			if(options.dependencies[module].model && module === className) {
				return module;
			}
			if(options.dependencies[module].view && module === className.replace(/view$/i, '')) {
				return module;
			}
		}

		throw Error('factory error : could not find module for '+className + ' required by '+constructor.name + ' - dependencies : ', Object.keys(options.dependencies));
	};

	function requireArg(argName, constructor) {
		var module = moduleOf(argName, constructor);
		// console.log('requireArg : '+argName + ', module : '+module+', constructor : '+constructor.name);
		if(options.dependencies[module].model && module === argName) {
			return options.dependencies[module].model;
		}
		if(options.dependencies[module].view && module === argName.replace(/view$/i, '')) {
			return options.dependencies[module].view;
		}
		if(options.dependencies[module][argName]){
			return options.dependencies[module][argName];
		}
		argName = argName.replace(module, '').toLowerCase();
		if(options.dependencies[module][argName]){
			return options.dependencies[module][argName];
		}
		throw Error('factory error : could not find dependency for '+argName + ' required by '+constructor.name + ' - dependencies : ', Object.keys(options.dependencies));
	}

	function args(constructor) {
		return (constructor.argNames || []).map(function(argName) {
			if (argName === 'options') {
				return options;
			}

			var argConstructor = requireArg(argName, constructor);
			if (argName === 'debug') {
				return argConstructor.create([Utils.extend({}, options, {
					name: constructor.name
				})]);
			}
			// console.log('arg : '+argName);
			var arg = create(argConstructor, constructor);
			return arg;
		});
	};

	function create(constructor, parent) {
		var prefix = options.namespace || 'bdsft_webrtc';
		global[prefix] = global[prefix] || {};
		var name = constructor.name;
		var id = getId(name);
		global[prefix][id] = global[prefix][id] || {};
		var module = moduleOf(name, parent);
		constructor.module = module;
		global[prefix][id][module] = global[prefix][id][module] || {};

		var createConstructor = function(){
			// console.log('factory : ' + id);
			var constructorArgs = args(constructor);
			// console.log('factory : create ' + id + ' with ', constructor.argNames);
			var constructorOptions = Utils.extend({module: module}, parent && parent.options || {}, options);
			var object = constructor.create(constructorArgs, constructorOptions);
			return object;
		};

		// do not cache views
		if(name.match(/view/i)) {
			var object = createConstructor();
			if(!global[prefix][id][module][name]) {
				global[prefix][id][module][name] = object;
			} else {
				if(!Array.isArray(global[prefix][id][module][name])) {
					global[prefix][id][module][name] = [global[prefix][id][module][name]];
				}
				global[prefix][id][module][name].push(object);
			}
			return object;
		}

		if (!global[prefix][id][module][name]) {
			global[prefix][id][module][name] = createConstructor();
		}
		return global[prefix][id][module][name];
	}

	return create;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils":73,"jquery":98}],67:[function(require,module,exports){
  module.exports = Icon;

  function Icon(element, sound) {
    this.element = element;
    this.sound = sound;
    this.disabled = false;
  }

  Icon.prototype = {
    css: function(name) {
      return this.element.css(name);
    },
    attr: function(name) {
      return this.element.attr(name);
    },
    disable: function() {
      this.disabled = true;
    },
    enable: function() {
      this.disabled = false;
    },
    onClick: function(handler) {
      var self = this;
      this.element.bind("click", function(e) {
        e.preventDefault();
        if (self.disabled) {
          return;
        }
        self.sound.playClick();
        handler(e);
      });
    }
  };
},{}],68:[function(require,module,exports){
(function (global){
// var jQuery = jquery = $ = require('jquery');
// require('jquery.cookie')
// var core = require('webrtc-core');
var Constants = require('./constants');
var Utils = require('./utils');
var Factory = require('./factory');
var StylesManager = require('./stylesmanager');

module.exports = Loader;

function Loader(Widget, options) {
  var self = {};

  self.asScript = function(src, config, styles) {
    var script = '<script src="' + src + '" ';
    var dataStrs = Object.keys(styles || {}).map(function(key) {
      var value = styles[key];
      return "data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + '="' + value + '"';
    });
    script += dataStrs.join(' ');
    script += '>\n' + (config && Object.keys(config).length ? JSON.stringify(config, undefined, 2) : '') + '\n</script>';
    return script;
  };

  var currentScript = Utils.getElement('script').last();
  Utils.getElement(document).ready(function() {
    window.BroadSoftWebRTC = window.BroadSoftWebRTC || {};
    window.BroadSoftWebRTC.widgets = [];

    // for mocha tests
    if(!currentScript[0]) {
      return;
    }
    var configData = currentScript.text().trim() ? JSON.parse(currentScript.text()) : {};
    console.log("script config : ", configData);
    var styleData = currentScript.data();
    var src = currentScript[0].src;
    var widget = self.create(configData, styleData, src);
    widget.appendTo(currentScript.parent());
    currentScript.remove();
    window.BroadSoftWebRTC.widgets.push(widget);
  });

  self.create = function create(configData, styleData, src) {
    var count = window.BroadSoftWebRTC && window.BroadSoftWebRTC.widgets && window.BroadSoftWebRTC.widgets.length;
    var id =  (!count || count === 0) && 'default' || 'webrtc'+count;
    var namespace = "bdsft_webrtc";
    var factoryOptions = require('deep-extend')({id: id, namespace: namespace}, options, configData);
    factoryOptions.dependencies = require('deep-extend')({core: require('../')}, factoryOptions.dependencies);
    factoryOptions.styleData = styleData;
    var widget = Factory(factoryOptions)(Widget.view);

    var modules = function(){
      return (window[factoryOptions.namespace] || global[factoryOptions.namespace])[factoryOptions.id];
    }
    if(!widget.asScript) {
      widget.asScript = function(){
        var configs = {};
        for(var name in modules()) {
          var module = modules()[name];
          for(var className in module) {
            var object = module[className];
            var configChanges = object.configChanges && object.configChanges();
            if(configChanges && Object.keys(configChanges).length) {
              var changesObj = {};
              changesObj[name] = configChanges; 
              configs = Utils.extend(configs, changesObj);
            }
          }
        }
        return self.asScript(src, configs, StylesManager.changes());
      };
    }
    if(!widget.updateConfigs) {
      widget.updateConfigs = function(config){
        for(var name in modules()) {
          var module = modules()[name];
          for(var className in module) {
            var object = module[className];
            object.updateConfig && object.updateConfig(config && config[name] || config);
          }
        }
      };
    }
    if(!widget.updateStyles) {
      widget.updateStyles = function(styles){
        StylesManager.update(styles);
      };
    }
    return widget;
  }


  // (function($) {
  //   $.isBlank = function(obj) {
  //     return (!obj || $.trim(obj) === "");
  //   };
  // })(jQuery);

  if (typeof String.prototype.endsWith !== 'function') {
    String.prototype.endsWith = function(suffix) {
      return this.indexOf(suffix, this.length - suffix.length) !== -1;
    };
  }

  return self;
}

// Object.defineProperties(WebRTC, {
//   version: {
//     get: function() {
//       return '<%= pkg.version %>';
//     }
//   },
//   name: {
//     get: function() {
//       return '<%= pkg.title %>';
//     }
//   }
// });

// if(!jQuery.fn) {
//   jQuery.fn = {};
// }
// jQuery.fn.putCursorAtEnd = function() {

//   return this.each(function() {

//     $(this).focus();

//     // If this function exists...
//     if (this.setSelectionRange) {
//       // ... then use it (Doesn't work in IE)

//       // Double the length because Opera is inconsistent about whether a carriage return is one character or two. Sigh.
//       var len = $(this).val().length * 2;

//       this.setSelectionRange(len, len);

//     } else {
//       // ... otherwise replace the contents with itself
//       // (Doesn't work in Google Chrome)

//       $(this).val($(this).val());

//     }

//     // Scroll to the bottom, in case we're in a tall textarea
//     // (Necessary for Firefox and Google Chrome)
//     this.scrollTop = 999999;

//   });

// };

// if(!jQuery.cssHooks) {
//   jQuery.cssHooks = {};
// }
// jQuery.cssHooks.backgroundColor = {
//   get: function(elem) {
//     var bg = null;
//     if (elem.currentStyle) {
//       bg = elem.currentStyle.backgroundColor;
//     } else if (window.getComputedStyle) {
//       bg = document.defaultView.getComputedStyle(elem,
//         null).getPropertyValue("background-color");
//     }
//     if (bg.search("rgb") === -1 || bg === 'transparent') {
//       return bg;
//     } else {
//       bg = bg.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+).*\)$/);
//       var hex = function(x) {
//         return ("0" + parseInt(x, 10).toString(16)).slice(-2);
//       };
//       return "#" + hex(bg[1]) + hex(bg[2]) + hex(bg[3]);
//     }
//   }
// };
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../":53,"./constants":57,"./factory":66,"./stylesmanager":71,"./utils":73,"deep-extend":78}],69:[function(require,module,exports){
module.exports = PopupView;
var $ = require('jquery');

function PopupView(view, eventbus, opts) {
  opts = opts || {};
  view.attached = false;

  view.visible = false;

  view.show = function() {
    view.setVisible(true);
  };

  view.hide = function() {
    view.setVisible(false);
  };

  view.toggle = function(visible) {
    view.setVisible(typeof visible !== undefined && visible || !view.model.visible || !view.visible);
  };

  view.appendTo = function(parent) {
    view.view.appendTo(parent);
  };

  view.setVisible = function(visible) {
    view.visible = visible;
    view.model.visible = visible;
  };

  if(opts.modifier) {
    eventbus.on('modifier', function(e) {
      if (e.which === opts.modifier) {
        view.toggle();
      }
    });    
  }

  if (!view.attached) {
    view.appendTo(opts.parent && $(opts.parent) || $('body'));
    // document.body.appendChild(view.view[0]);
    view.attached = true;
  }

  return view;
}
},{"jquery":98}],70:[function(require,module,exports){
module.exports = Prop;

var ArrayObserver = require('observe-js').ArrayObserver;
var ObjectObserver = require('observe-js').ObjectObserver;

function Prop(obj, prop, databinder) {
	var self = {};

	var _name = self._name = prop.name || prop;
	var internal;

	var __get = function() {
		return internal;
	};
	var __init = function() {
		if (typeof prop.value !== 'undefined') {
			if (typeof prop.value === 'function') {
				__set(prop.value());
			} else {
				__set(prop.value);
			}
		}
		prop.onInit && prop.onInit();
	};
	var __set = function(value) {
		internal = value;
		if(internal) {
			if(Array.isArray(internal)) {
				var observer = new ArrayObserver(internal);
				observer.open(function(splices) {
					databinder.modelChanged(_name, internal, self, true);
				});
			}
			else if(typeof internal === 'object') {
				var observer = new ObjectObserver(internal);
				observer.open(function(added, removed, changed, getOldValueFn) {
					databinder.modelChanged(_name, internal, self, true);
				});
			}
		}
		databinder.modelChanged(_name, value, self);
		prop.onSet && prop.onSet(value);
	};

	databinder.onViewElChange(_name, function(value) {
		internal = value;
		prop.onSet && prop.onSet(value);
	});

	Object.defineProperty(obj, _name, {
		writeable: false,
		configurable: true,
		get: prop.get || __get,
		set: prop.set || __set
	});

	__init();

	return self;
}
},{"observe-js":99}],71:[function(require,module,exports){
var utils = require('./utils');
var constants = require('./constants');
var cssCore = require('./css')('core');
var stylesCore = require('../js/styles').core;

function Styl(viewName, createOptions, viewOptions) {
	var self = {};

	var module = viewOptions.module || createOptions.module;
	var name = (module && module + '_' || '') + viewName;
	var css = require('./css')(name);

	var style = function(){
		return createOptions.style && createOptions.style[viewName] 
		|| viewOptions.style && viewOptions.style[viewName]
		|| viewOptions.style && viewOptions.style['styles']
		|| viewOptions.style;
	};

	var data = function(){
		var styleData = utils.extend({}, createOptions.styleData);
		var images = utils.extend({}, 
			viewOptions.image,
			viewOptions.image && viewOptions.image['images'],
			viewOptions.image && viewOptions.image[viewName],
			createOptions.image && createOptions.image[viewName]
		);
		if(Object.keys(images).length) {
			styleData = utils.extend(styleData, images);
		}
		return styleData;
	};

	self.update = function(styles){
		// only update if view contains constants.STYLES and styles keys
		if(viewOptions.constants && viewOptions.constants.STYLES && utils.contains(viewOptions.constants.STYLES, styles)) {
			css.update(utils.extend(data(), styles), {constants: viewOptions.constants, style: style()});
		}
	};

	self.changes = function(){
		var changes = {};
		if(viewOptions.constants && viewOptions.constants.STYLES) {
			for(var name in viewOptions.constants.STYLES) {
				var value = viewOptions.constants.STYLES[name];
				if(css.data && css.data[name] !== value) {
					changes[name] = css.data[name];
				}
			}
		}
		return changes;
	};

	self.inject = function(){
		if(style()) {
			css.inject(data(), {constants: viewOptions.constants, style: style()});
		}
	}

	return self;
};

function StylesManager(){
	var self = {};

	self.styles = {};

	self.changes = function() {
		var changes = {};
        for(var name in self.styles) {
          var style = self.styles[name];
          style = style[name] || style;
          changes = utils.extend(changes, style.changes());
        }
        return changes;
	};

	self.update = function(styles) {
        for(var name in styles) {
          var style = self.styles[name];
          style = style[name] || style;
          style.update(styles && styles[name] || styles);
        }
	};

	self.inject = function(viewName, createOptions, viewOptions){
		if(!self.styles['core']) {
			var style = Styl('core', createOptions, {style: stylesCore, constants: constants, module: 'core'});
			style.inject();
			self.styles['core'] = style;
		}

		var module = viewOptions.module || createOptions.module;
		var moduleStyles;
		if(module) {
			self.styles[module] = self.styles[module] || {};
			moduleStyles = self.styles[module];
		} else {
			moduleStyles = self.styles;
		}

		if(!moduleStyles[viewName]) {
			var style = Styl(viewName, createOptions, viewOptions);
			style.inject();
			moduleStyles[viewName] = style;
		}
	}

	return self;
};

module.exports = StylesManager();
},{"../js/styles":51,"./constants":57,"./css":60,"./utils":73}],72:[function(require,module,exports){
module.exports = require('./bdsft').Model(URLConfig, {
	config: require('../js/config')
});

var Flags = {
	enableCallControl: 1,
	enableCallTimer: 2,
	enableCallHistory: 4,
	enableFullscreen: 8,
	enableSelfView: 16,
	enableCallStats: 32,
	enableScreenshare: 64,
	enableMute: 128,
	enableMessages: 256,
	enableRegistrationStatus: 512,
	enableConnectionStatus: 1024,
	enableSettings: 2048,
	enableAutoAnswer: 4096,
	enableConnectLocalMedia: 8192,
	enableTransfer: 16384,
	enableHold: 32768,
	enableIms: 65536
};

var Utils = require('./utils');

function URLConfig() {
	var self = {};

	var isAudioOnlyView = function(view) {
		return view && view.indexOf('audioOnly') !== -1
	};

	self.updateAudioOnlyView = function(view){
		self.audioOnlyView = isAudioOnlyView(view);
	};

	var contains = function(name, value) {
		var val = self.props[name];
		return val && val.indexOf(value) !== -1
	};
	var isTrue = function(name) {
		return Utils.getSearchVariable(name);
	};
	var isFeature = function(name) {
		var features = Utils.getSearchVariable('features');
		if(!features){
			return;
		}
		return (features & Flags[name]) === Flags[name];
	};
	var isTrueOrFeature = function(name) {
		var search = Utils.getSearchVariable(name);
		if(search !== undefined) {
			return search;
		}
		return isFeature(name);
	}

	self.props = {
		audioOnly: isTrue("audioOnly"),
		hd: isTrue("hd"),
		view: Utils.getSearchVariable("view") || self.view,
		maxCallLength: Utils.getSearchVariable("maxCallLength"),
		destination: Utils.getSearchVariable("destination"),
		networkUserId: Utils.getSearchVariable("networkUserId"),
		displayName: Utils.getSearchVariable("displayName"),
		size: Utils.getSearchVariable("size"),
		features: Utils.getSearchVariable("features"),
		enableCallControl: isTrueOrFeature('enableCallControl'),
		enableCallTimer: isTrueOrFeature('enableCallTimer'),
		enableCallHistory: isTrueOrFeature('enableCallHistory'),
		enableFullscreen: isTrueOrFeature('enableFullscreen'),
		enableScreenshare: isTrueOrFeature('enableScreenshare'),
		enableSelfView: isTrueOrFeature('enableSelfView'),
		enableCallStats: isTrueOrFeature('enableCallStats'),
		enableMute: isTrueOrFeature('enableMute'),
		enableMessages: isTrueOrFeature('enableMessages'),
		enableRegistrationStatus: isTrueOrFeature('enableRegistrationStatus'),
		enableConnectionStatus: isTrueOrFeature('enableConnectionStatus'),
		enableSettings: isTrueOrFeature('enableSettings'),
		enableAutoAnswer: isTrueOrFeature('enableAutoAnswer'),
		enableConnectLocalMedia: isTrueOrFeature('enableConnectLocalMedia'),
		enableTransfer: isTrueOrFeature('enableTransfer'),
		enableHold: isTrueOrFeature('enableHold'),
		enableIms: isTrueOrFeature('enableIms')
	}

	self.props.audioOnlyView = isAudioOnlyView(self.props.view);

	self.bindings = {
		audioOnlyView: {
			self: 'view'
		}
	}

	self.setViewAudio = function() {
		self.view = 'audioOnly';
	};

	self.setViewVideo = function() {
		self.view = 'audioVideo';
	};

	self.getFeatures = function() {
		var flags = 0;
		for (var flag in Flags) {
			var value = Flags[flag];
			if (self[flag]) {
				flags |= value;
			}
		}
		return flags;
	};

	self.setFeatures = function(flags) {
		for (var flag in Flags) {
			var value = Flags[flag];
			if (flags & value) {
				self[flag] = true;
			} else {
				self[flag] = false;
			}
		}
	};

	return self;
}
},{"../js/config":50,"./bdsft":54,"./utils":73}],73:[function(require,module,exports){
var adapter = require('./adapter');
var $ = require('jquery');

var __slice = [].slice;

var Utils = {
  createFun: function(fun, argArray, target) {
    var args = [target || null].concat(argArray);
    var factoryFunction = fun.bind.apply(fun, args);
    return new factoryFunction();
  },
  toArray: function(args) {
      return Array.prototype.slice.call(args);
  },
  getElement: function(selector) {
    return $(selector);
  },
  createEvent: function(eventName) {
    return $.Event(eventName)
  },
  createElement: function(tagName, attributes, options) {
    options = options || {};
    var el = $(tagName, attributes);
    el.appendTo(options.parent || $('body'));
    return el;
  },
  resolutionWidth: function(resolution) {
    if (resolution) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[0], 10);
    }
  },
  resolutionHeight: function(resolution) {
    if (resolution) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[1], 10);
    }
  },
  withArray: function(arg) {
      return Array.isArray(arg) ? arg : [arg];
  },
  capitalizeFirstLetter: function(string) {
    return string.charAt(0).toUpperCase() + string.slice(1);
  },
  lowercaseFirstLetter: function(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  },
  extend: function () {
    var consumer = arguments[0],
        providers = __slice.call(arguments, 1),
        key,
        i,
        provider;

    for (i = 0; i < providers.length; ++i) {
      provider = providers[i];
      for (key in provider) {
        if (provider.hasOwnProperty(key)) {
          consumer[key] = provider[key];
        };
      };
    };
    return consumer;
  },
  clone: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  rstring: function() { 
    return Math.random().toString().slice(2,8); 
  },
  dataURItoBlob: function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var blob = new Blob([ab], {type: mimeString});
    return blob;
  },

  decamelize: function (str) {
    return str.replace(/([a-z](?=[A-Z]))/g, '$1 ');
  },

  camelize: function (str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index) {
      if (+match === 0) return ""; // or if (/\s+/.test(match)) for white spaces
      return index == 0 ? match.toLowerCase() : match.toUpperCase();
    });
  },

  format: function(seconds)
  {
    var hrs = Math.floor(seconds / 3600);
    seconds %= 3600;
    var mns = Math.floor(seconds / 60);
    seconds %= 60;
    var formatedDuration = (hrs < 10 ? "0" : "") + hrs + ":" + (mns < 10 ? "0" : "") + mns + ":" + (seconds < 10 ? "0" : "") + seconds;
    return(formatedDuration);
  },
  /* format date and time for call history */
  formatDateTime: function (dateStr){
    var date = new Date(dateStr);
    var strDate =  (date.getMonth() + 1) + "/" + date.getDate();
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; 
    minutes = minutes < 10 ? '0'+minutes : minutes;
    var strTime = hours + ':' + minutes + ' ' + ampm;
    return strDate + " - " + strTime;
  },
  /* Pull the URL variables out of URL */
  getSearchVariable: function(variable)
  {
    if(typeof location === 'undefined') {
      return;
    }
    var search = decodeURIComponent($(location).attr('search').substring(1));
    var vars = search.split("&");
    for (var i=0;i<vars.length;i++)
    {
      var pair = vars[i].split("=");
      if(pair[0] === variable)
      {
        if(pair[1] === 'true') {
          return true;
        } else if(pair[1] === 'false') {
          return false
        } else {
          return pair[1];
        }
      }
    }
    return undefined;
  },

  contains: function(srcObject, dstObject) {
    return Object.keys(this.pick(srcObject, Object.keys(dstObject))).length;
  },

  containsKey: function(object, value) {
    return this.keyIndex(object, value) !== -1;
  },

  keyIndex: function(object, value) {
    return $.inArray(value, $.map(object, function(key) { return key; }));
  },

  containsValue: function(object, value) {
    return this.valueIndex(object, value) !== -1;
  },

  valueIndex: function(object, value) {
    return $.inArray(value, $.map(object, function(key, value) { return value; }));
  },

  addSelectOptions: function(options, selector, value) {
    $.each(options, function(key, value) {
      $(selector)
        .append($('<option>', { value : value })
        .text(key));
    });
    if(value) {
      selector.val(value);
    }
  },

  // Generate a random userid
  randomUserid: function()
  {
    var chars = "0123456789abcdef";
    var string_length = 10;
    var userid = '';
    for (var i=0; i<string_length; i++)
    {
      var rnum = Math.floor(Math.random() * chars.length);
      userid += chars.substring(rnum,rnum+1);
    }
    return userid;
  },

  whiteboardCompabilityCheck: function()
  {
    var isChrome = this.isChrome();

    // Only Chrome 34+
    if (!isChrome)
    {
      return "Chrome is required for whiteboard feature, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 34)
    {
      return "Your version of Chrome must be upgraded to at least version 34 in order to be able to use the whiteboard<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='https://www.google.com/intl/en/chrome/browser/canary.html'>https://www.google.com/intl/en/chrome/browser/canary.html</a>";
    }
  },

  compatibilityCheck: function()
  {
    var isChrome = this.isChrome();
    var isFirefox = this.isFirefox();

    // Only Chrome 25+ and Firefox 22+ are supported
    if (!isChrome && !isFirefox)
    {
      return "Chrome or Firefox is required, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='http:www.mozilla.org'>http://www.mozilla.org</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 25)
    {
      return "Your version of Chrome must be upgraded to at least version 25<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    else
    {
      if (isFirefox && major < 22)
      {
        return "Your version of Firefox must be upgraded to at least version 22y<br>" +
          "Please go to: <a href='http://www.mozilla.org'>http://www.mozilla.org</a>";
      }
    }
  },

  isValidUsPstn: function(pstn){
    pstn = pstn.replace(/-/g, '').replace(/\(/g, '').replace(/\)/g, '');
    return pstn.match(/^1?\d{10}$/) !== null;
  },

  majorVersion: function(){
    return adapter.webrtcDetectedVersion;
  },

  isChrome: function(){
    return adapter.webrtcDetectedBrowser === 'chrome';
  },

  isFirefox: function(){
    return adapter.webrtcDetectedBrowser === 'firefox';
  },

  toArray: function(elements){
    return $(elements).map (function () {return this.toArray(); } );
  },

  rebindListeners: function(type, elements, listener){
    for(var i=0; i<elements.length; i++) {
      this.rebindListener(type, elements[i], listener);
    }
  },

  rebindListener: function(type, element, listener){
    element.off(type);
    element.on(type, listener);
  },

  pick: function(sourceObject, keys) {
    var newObject = {};
    keys.forEach(function(key) {
      if (typeof sourceObject[key] !== 'undefined') {
        newObject[key] = sourceObject[key];
      }
    });
    return newObject;
  },

  colorNameToHex: function(color){
    if(!color) {
      return false;
    }
    var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
      "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
      "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
      "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
      "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
      "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
      "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
      "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
      "honeydew":"#f0fff0","hotpink":"#ff69b4",
      "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
      "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
      "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
      "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
      "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
      "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
      "navajowhite":"#ffdead","navy":"#000080",
      "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
      "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
      "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
      "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
      "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
      "violet":"#ee82ee",
      "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
      "yellow":"#ffff00","yellowgreen":"#9acd32","transparent":"transparent"};

    if (typeof colors[color.toLowerCase()] !== 'undefined') {
      return colors[color.toLowerCase()];
    }

    return this.isHexColor(color) ? (color.indexOf("#") !== -1 ? color : "#"+color) : false;
  },

  isHexColor: function(color) {
    return (/(^#?[0-9A-F]{6}$)|(^#?[0-9A-F]{3}$)/i.test(color));
  },

  parseDTMFTones: function(destination) {
    if(!destination) {
      return null;
    }
    var dtmfMatch = destination.match(/,[0-9A-D#*,]+/, '');
    return dtmfMatch ? dtmfMatch[0] : null;
  }
};

module.exports = Utils;
},{"./adapter":52,"jquery":98}],74:[function(require,module,exports){
module.exports = VisibleProp;

var Prop = require('./prop');
var C = require('./constants');
var Utils = require('./utils');

function VisibleProp(obj, prop, databinder) {

	var self = {};

	if(!obj.toggle) {
		obj.toggle = function(){
			obj.visible = !obj.visible;
		};
	}
	if(!obj.show) {
		obj.show = function(){
			obj.visible = true;
		};
	}
	if(!obj.hide) {
		obj.hide = function(){
			obj.visible = false;
		};
	}
	var propObj = Prop(obj, prop, databinder);

	return propObj;
}
},{"./constants":57,"./prop":70,"./utils":73}],75:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = window.localStorage;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":76}],76:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":77}],77:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],78:[function(require,module,exports){
(function (Buffer){
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2015 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

'use strict';

function isSpecificValue(val) {
	return (
		val instanceof Buffer
		|| val instanceof Date
		|| val instanceof RegExp
	) ? true : false;
}

function cloneSpecificValue(val) {
	if (val instanceof Buffer) {
		var x = new Buffer(val.length);
		val.copy(x);
		return x;
	} else if (val instanceof Date) {
		return new Date(val.getTime());
	} else if (val instanceof RegExp) {
		return new RegExp(val);
	} else {
		throw new Error('Unexpected situation');
	}
}

/**
 * Recursive cloning array.
 */
function deepCloneArray(arr) {
	var clone = [];
	arr.forEach(function (item, index) {
		if (typeof item === 'object' && item !== null) {
			if (Array.isArray(item)) {
				clone[index] = deepCloneArray(item);
			} else if (isSpecificValue(item)) {
				clone[index] = cloneSpecificValue(item);
			} else {
				clone[index] = deepExtend({}, item);
			}
		} else {
			clone[index] = item;
		}
	});
	return clone;
}

/**
 * Extening object that entered in first argument.
 *
 * Returns extended object or false if have no target object or incorrect type.
 *
 * If you wish to clone source object (without modify it), just use empty new
 * object as first argument, like this:
 *   deepExtend({}, yourObj_1, [yourObj_N]);
 */
var deepExtend = module.exports = function (/*obj_1, [obj_2], [obj_N]*/) {
	if (arguments.length < 1 || typeof arguments[0] !== 'object') {
		return false;
	}

	if (arguments.length < 2) {
		return arguments[0];
	}

	var target = arguments[0];

	// convert arguments to array and cut off target object
	var args = Array.prototype.slice.call(arguments, 1);

	var val, src, clone;

	args.forEach(function (obj) {
		// skip argument if it is array or isn't object
		if (typeof obj !== 'object' || Array.isArray(obj)) {
			return;
		}

		Object.keys(obj).forEach(function (key) {
			src = target[key]; // source value
			val = obj[key]; // new value

			// recursion prevention
			if (val === target) {
				return;

			/**
			 * if new value isn't object then just overwrite by new value
			 * instead of extending.
			 */
			} else if (typeof val !== 'object' || val === null) {
				target[key] = val;
				return;

			// just clone arrays (and recursive clone objects inside)
			} else if (Array.isArray(val)) {
				target[key] = deepCloneArray(val);
				return;

			// custom cloning and overwrite for specific objects
			} else if (isSpecificValue(val)) {
				target[key] = cloneSpecificValue(val);
				return;

			// overwrite by new value if source isn't object or array
			} else if (typeof src !== 'object' || src === null || Array.isArray(src)) {
				target[key] = deepExtend({}, val);
				return;

			// source value and new value is objects both, extending...
			} else {
				target[key] = deepExtend(src, val);
				return;
			}
		});
	});

	return target;
}

}).call(this,require("buffer").Buffer)
},{"buffer":9}],79:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils')
  , path = require('path')
  , dirname = path.dirname
  , extname = path.extname
  , join = path.join
  , fs = require('fs')
  , read = fs.readFileSync;

/**
 * Filters.
 *
 * @type Object
 */

var filters = exports.filters = require('./filters');

/**
 * Intermediate js cache.
 *
 * @type Object
 */

var cache = {};

/**
 * Clear intermediate js cache.
 *
 * @api public
 */

exports.clearCache = function(){
  cache = {};
};

/**
 * Translate filtered code into function calls.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function filtered(js) {
  return js.substr(1).split('|').reduce(function(js, filter){
    var parts = filter.split(':')
      , name = parts.shift()
      , args = parts.join(':') || '';
    if (args) args = ', ' + args;
    return 'filters.' + name + '(' + js + args + ')';
  });
};

/**
 * Re-throw the given `err` in context to the
 * `str` of ejs, `filename`, and `lineno`.
 *
 * @param {Error} err
 * @param {String} str
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

function rethrow(err, str, filename, lineno){
  var lines = str.split('\n')
    , start = Math.max(lineno - 3, 0)
    , end = Math.min(lines.length, lineno + 3);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
}

/**
 * Parse the given `str` of ejs, returning the function body.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

var parse = exports.parse = function(str, options){
  var options = options || {}
    , open = options.open || exports.open || '<%'
    , close = options.close || exports.close || '%>'
    , filename = options.filename
    , compileDebug = options.compileDebug !== false
    , buf = "";

  buf += 'var buf = [];';
  if (false !== options._with) buf += '\nwith (locals || {}) { (function(){ ';
  buf += '\n buf.push(\'';

  var lineno = 1;

  var consumeEOL = false;
  for (var i = 0, len = str.length; i < len; ++i) {
    var stri = str[i];
    if (str.slice(i, open.length + i) == open) {
      i += open.length

      var prefix, postfix, line = (compileDebug ? '__stack.lineno=' : '') + lineno;
      switch (str[i]) {
        case '=':
          prefix = "', escape((" + line + ', ';
          postfix = ")), '";
          ++i;
          break;
        case '-':
          prefix = "', (" + line + ', ';
          postfix = "), '";
          ++i;
          break;
        default:
          prefix = "');" + line + ';';
          postfix = "; buf.push('";
      }

      var end = str.indexOf(close, i);

      if (end < 0){
        throw new Error('Could not find matching close tag "' + close + '".');
      }

      var js = str.substring(i, end)
        , start = i
        , include = null
        , n = 0;

      if ('-' == js[js.length-1]){
        js = js.substring(0, js.length - 2);
        consumeEOL = true;
      }

      if (0 == js.trim().indexOf('include')) {
        var name = js.trim().slice(7).trim();
        if (!filename) throw new Error('filename option is required for includes');
        var path = resolveInclude(name, filename);
        include = read(path, 'utf8');
        include = exports.parse(include, { filename: path, _with: false, open: open, close: close, compileDebug: compileDebug });
        buf += "' + (function(){" + include + "})() + '";
        js = '';
      }

      while (~(n = js.indexOf("\n", n))) n++, lineno++;
      if (js.substr(0, 1) == ':') js = filtered(js);
      if (js) {
        if (js.lastIndexOf('//') > js.lastIndexOf('\n')) js += '\n';
        buf += prefix;
        buf += js;
        buf += postfix;
      }
      i += end - start + close.length - 1;

    } else if (stri == "\\") {
      buf += "\\\\";
    } else if (stri == "'") {
      buf += "\\'";
    } else if (stri == "\r") {
      // ignore
    } else if (stri == "\n") {
      if (consumeEOL) {
        consumeEOL = false;
      } else {
        buf += "\\n";
        lineno++;
      }
    } else {
      buf += stri;
    }
  }

  if (false !== options._with) buf += "'); })();\n} \nreturn buf.join('');";
  else buf += "');\nreturn buf.join('');";
  return buf;
};

/**
 * Compile the given `str` of ejs into a `Function`.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var compile = exports.compile = function(str, options){
  options = options || {};
  var escape = options.escape || utils.escape;

  var input = JSON.stringify(str)
    , compileDebug = options.compileDebug !== false
    , client = options.client
    , filename = options.filename
        ? JSON.stringify(options.filename)
        : 'undefined';

  if (compileDebug) {
    // Adds the fancy stack trace meta info
    str = [
      'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',
      rethrow.toString(),
      'try {',
      exports.parse(str, options),
      '} catch (err) {',
      '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',
      '}'
    ].join("\n");
  } else {
    str = exports.parse(str, options);
  }

  if (options.debug) console.log(str);
  if (client) str = 'escape = escape || ' + escape.toString() + ';\n' + str;

  try {
    var fn = new Function('locals, filters, escape, rethrow', str);
  } catch (err) {
    if ('SyntaxError' == err.name) {
      err.message += options.filename
        ? ' in ' + filename
        : ' while compiling ejs';
    }
    throw err;
  }

  if (client) return fn;

  return function(locals){
    return fn.call(this, locals, filters, escape, rethrow);
  }
};

/**
 * Render the given `str` of ejs.
 *
 * Options:
 *
 *   - `locals`          Local variables object
 *   - `cache`           Compiled functions are cached, requires `filename`
 *   - `filename`        Used by `cache` to key caches
 *   - `scope`           Function execution context
 *   - `debug`           Output generated function body
 *   - `open`            Open tag, defaulting to "<%"
 *   - `close`           Closing tag, defaulting to "%>"
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api public
 */

exports.render = function(str, options){
  var fn
    , options = options || {};

  if (options.cache) {
    if (options.filename) {
      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));
    } else {
      throw new Error('"cache" option requires "filename".');
    }
  } else {
    fn = compile(str, options);
  }

  options.__proto__ = options.locals;
  return fn.call(options.scope, options);
};

/**
 * Render an EJS file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  options.filename = path;

  var str;
  try {
    str = options.cache
      ? cache[key] || (cache[key] = read(path, 'utf8'))
      : read(path, 'utf8');
  } catch (err) {
    fn(err);
    return;
  }
  fn(null, exports.render(str, options));
};

/**
 * Resolve include `name` relative to `filename`.
 *
 * @param {String} name
 * @param {String} filename
 * @return {String}
 * @api private
 */

function resolveInclude(name, filename) {
  var path = join(dirname(filename), name);
  var ext = extname(name);
  if (!ext) path += '.ejs';
  return path;
}

// express support

exports.__express = exports.renderFile;

/**
 * Expose to require().
 */

if (require.extensions) {
  require.extensions['.ejs'] = function (module, filename) {
    filename = filename || module.filename;
    var options = { filename: filename, client: true }
      , template = fs.readFileSync(filename).toString()
      , fn = compile(template, options);
    module._compile('module.exports = ' + fn.toString() + ';', filename);
  };
} else if (require.registerExtension) {
  require.registerExtension('.ejs', function(src) {
    return compile(src, {});
  });
}

},{"./filters":80,"./utils":81,"fs":7,"path":21}],80:[function(require,module,exports){
/*!
 * EJS - Filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * First element of the target `obj`.
 */

exports.first = function(obj) {
  return obj[0];
};

/**
 * Last element of the target `obj`.
 */

exports.last = function(obj) {
  return obj[obj.length - 1];
};

/**
 * Capitalize the first letter of the target `str`.
 */

exports.capitalize = function(str){
  str = String(str);
  return str[0].toUpperCase() + str.substr(1, str.length);
};

/**
 * Downcase the target `str`.
 */

exports.downcase = function(str){
  return String(str).toLowerCase();
};

/**
 * Uppercase the target `str`.
 */

exports.upcase = function(str){
  return String(str).toUpperCase();
};

/**
 * Sort the target `obj`.
 */

exports.sort = function(obj){
  return Object.create(obj).sort();
};

/**
 * Sort the target `obj` by the given `prop` ascending.
 */

exports.sort_by = function(obj, prop){
  return Object.create(obj).sort(function(a, b){
    a = a[prop], b = b[prop];
    if (a > b) return 1;
    if (a < b) return -1;
    return 0;
  });
};

/**
 * Size or length of the target `obj`.
 */

exports.size = exports.length = function(obj) {
  return obj.length;
};

/**
 * Add `a` and `b`.
 */

exports.plus = function(a, b){
  return Number(a) + Number(b);
};

/**
 * Subtract `b` from `a`.
 */

exports.minus = function(a, b){
  return Number(a) - Number(b);
};

/**
 * Multiply `a` by `b`.
 */

exports.times = function(a, b){
  return Number(a) * Number(b);
};

/**
 * Divide `a` by `b`.
 */

exports.divided_by = function(a, b){
  return Number(a) / Number(b);
};

/**
 * Join `obj` with the given `str`.
 */

exports.join = function(obj, str){
  return obj.join(str || ', ');
};

/**
 * Truncate `str` to `len`.
 */

exports.truncate = function(str, len, append){
  str = String(str);
  if (str.length > len) {
    str = str.slice(0, len);
    if (append) str += append;
  }
  return str;
};

/**
 * Truncate `str` to `n` words.
 */

exports.truncate_words = function(str, n){
  var str = String(str)
    , words = str.split(/ +/);
  return words.slice(0, n).join(' ');
};

/**
 * Replace `pattern` with `substitution` in `str`.
 */

exports.replace = function(str, pattern, substitution){
  return String(str).replace(pattern, substitution || '');
};

/**
 * Prepend `val` to `obj`.
 */

exports.prepend = function(obj, val){
  return Array.isArray(obj)
    ? [val].concat(obj)
    : val + obj;
};

/**
 * Append `val` to `obj`.
 */

exports.append = function(obj, val){
  return Array.isArray(obj)
    ? obj.concat(val)
    : obj + val;
};

/**
 * Map the given `prop`.
 */

exports.map = function(arr, prop){
  return arr.map(function(obj){
    return obj[prop];
  });
};

/**
 * Reverse the given `obj`.
 */

exports.reverse = function(obj){
  return Array.isArray(obj)
    ? obj.reverse()
    : String(obj).split('').reverse().join('');
};

/**
 * Get `prop` of the given `obj`.
 */

exports.get = function(obj, prop){
  return obj[prop];
};

/**
 * Packs the given `obj` into json string
 */
exports.json = function(obj){
  return JSON.stringify(obj);
};

},{}],81:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/'/g, '&#39;')
    .replace(/"/g, '&quot;');
};
 

},{}],82:[function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"d":83,"es5-ext/object/valid-callable":92}],83:[function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},{"es5-ext/object/assign":84,"es5-ext/object/is-callable":87,"es5-ext/object/normalize-options":91,"es5-ext/string/#/contains":94}],84:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.assign
	: require('./shim');

},{"./is-implemented":85,"./shim":86}],85:[function(require,module,exports){
'use strict';

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

},{}],86:[function(require,module,exports){
'use strict';

var keys  = require('../keys')
  , value = require('../valid-value')

  , max = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},{"../keys":88,"../valid-value":93}],87:[function(require,module,exports){
// Deprecated

'use strict';

module.exports = function (obj) { return typeof obj === 'function'; };

},{}],88:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.keys
	: require('./shim');

},{"./is-implemented":89,"./shim":90}],89:[function(require,module,exports){
'use strict';

module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};

},{}],90:[function(require,module,exports){
'use strict';

var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

},{}],91:[function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

},{}],92:[function(require,module,exports){
'use strict';

module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

},{}],93:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

},{}],94:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? String.prototype.contains
	: require('./shim');

},{"./is-implemented":95,"./shim":96}],95:[function(require,module,exports){
'use strict';

var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};

},{}],96:[function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],97:[function(require,module,exports){
/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));

},{"jquery":98}],98:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],99:[function(require,module,exports){
(function (global){
/*
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

(function(global) {
  'use strict';

  var testingExposeCycleCount = global.testingExposeCycleCount;

  // Detect and do basic sanity checking on Object/Array.observe.
  function detectObjectObserve() {
    if (typeof Object.observe !== 'function' ||
        typeof Array.observe !== 'function') {
      return false;
    }

    var records = [];

    function callback(recs) {
      records = recs;
    }

    var test = {};
    var arr = [];
    Object.observe(test, callback);
    Array.observe(arr, callback);
    test.id = 1;
    test.id = 2;
    delete test.id;
    arr.push(1, 2);
    arr.length = 0;

    Object.deliverChangeRecords(callback);
    if (records.length !== 5)
      return false;

    if (records[0].type != 'add' ||
        records[1].type != 'update' ||
        records[2].type != 'delete' ||
        records[3].type != 'splice' ||
        records[4].type != 'splice') {
      return false;
    }

    Object.unobserve(test, callback);
    Array.unobserve(arr, callback);

    return true;
  }

  var hasObserve = detectObjectObserve();

  function detectEval() {
    // Don't test for eval if we're running in a Chrome App environment.
    // We check for APIs set that only exist in a Chrome App context.
    if (typeof chrome !== 'undefined' && chrome.app && chrome.app.runtime) {
      return false;
    }

    // Firefox OS Apps do not allow eval. This feature detection is very hacky
    // but even if some other platform adds support for this function this code
    // will continue to work.
    if (typeof navigator != 'undefined' && navigator.getDeviceStorage) {
      return false;
    }

    try {
      var f = new Function('', 'return true;');
      return f();
    } catch (ex) {
      return false;
    }
  }

  var hasEval = detectEval();

  function isIndex(s) {
    return +s === s >>> 0 && s !== '';
  }

  function toNumber(s) {
    return +s;
  }

  function isObject(obj) {
    return obj === Object(obj);
  }

  var numberIsNaN = global.Number.isNaN || function(value) {
    return typeof value === 'number' && global.isNaN(value);
  }

  function areSameValue(left, right) {
    if (left === right)
      return left !== 0 || 1 / left === 1 / right;
    if (numberIsNaN(left) && numberIsNaN(right))
      return true;

    return left !== left && right !== right;
  }

  var createObject = ('__proto__' in {}) ?
    function(obj) { return obj; } :
    function(obj) {
      var proto = obj.__proto__;
      if (!proto)
        return obj;
      var newObject = Object.create(proto);
      Object.getOwnPropertyNames(obj).forEach(function(name) {
        Object.defineProperty(newObject, name,
                             Object.getOwnPropertyDescriptor(obj, name));
      });
      return newObject;
    };

  var identStart = '[\$_a-zA-Z]';
  var identPart = '[\$_a-zA-Z0-9]';
  var identRegExp = new RegExp('^' + identStart + '+' + identPart + '*' + '$');

  function getPathCharType(char) {
    if (char === undefined)
      return 'eof';

    var code = char.charCodeAt(0);

    switch(code) {
      case 0x5B: // [
      case 0x5D: // ]
      case 0x2E: // .
      case 0x22: // "
      case 0x27: // '
      case 0x30: // 0
        return char;

      case 0x5F: // _
      case 0x24: // $
        return 'ident';

      case 0x20: // Space
      case 0x09: // Tab
      case 0x0A: // Newline
      case 0x0D: // Return
      case 0xA0:  // No-break space
      case 0xFEFF:  // Byte Order Mark
      case 0x2028:  // Line Separator
      case 0x2029:  // Paragraph Separator
        return 'ws';
    }

    // a-z, A-Z
    if ((0x61 <= code && code <= 0x7A) || (0x41 <= code && code <= 0x5A))
      return 'ident';

    // 1-9
    if (0x31 <= code && code <= 0x39)
      return 'number';

    return 'else';
  }

  var pathStateMachine = {
    'beforePath': {
      'ws': ['beforePath'],
      'ident': ['inIdent', 'append'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'inPath': {
      'ws': ['inPath'],
      '.': ['beforeIdent'],
      '[': ['beforeElement'],
      'eof': ['afterPath']
    },

    'beforeIdent': {
      'ws': ['beforeIdent'],
      'ident': ['inIdent', 'append']
    },

    'inIdent': {
      'ident': ['inIdent', 'append'],
      '0': ['inIdent', 'append'],
      'number': ['inIdent', 'append'],
      'ws': ['inPath', 'push'],
      '.': ['beforeIdent', 'push'],
      '[': ['beforeElement', 'push'],
      'eof': ['afterPath', 'push']
    },

    'beforeElement': {
      'ws': ['beforeElement'],
      '0': ['afterZero', 'append'],
      'number': ['inIndex', 'append'],
      "'": ['inSingleQuote', 'append', ''],
      '"': ['inDoubleQuote', 'append', '']
    },

    'afterZero': {
      'ws': ['afterElement', 'push'],
      ']': ['inPath', 'push']
    },

    'inIndex': {
      '0': ['inIndex', 'append'],
      'number': ['inIndex', 'append'],
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    },

    'inSingleQuote': {
      "'": ['afterElement'],
      'eof': ['error'],
      'else': ['inSingleQuote', 'append']
    },

    'inDoubleQuote': {
      '"': ['afterElement'],
      'eof': ['error'],
      'else': ['inDoubleQuote', 'append']
    },

    'afterElement': {
      'ws': ['afterElement'],
      ']': ['inPath', 'push']
    }
  }

  function noop() {}

  function parsePath(path) {
    var keys = [];
    var index = -1;
    var c, newChar, key, type, transition, action, typeMap, mode = 'beforePath';

    var actions = {
      push: function() {
        if (key === undefined)
          return;

        keys.push(key);
        key = undefined;
      },

      append: function() {
        if (key === undefined)
          key = newChar
        else
          key += newChar;
      }
    };

    function maybeUnescapeQuote() {
      if (index >= path.length)
        return;

      var nextChar = path[index + 1];
      if ((mode == 'inSingleQuote' && nextChar == "'") ||
          (mode == 'inDoubleQuote' && nextChar == '"')) {
        index++;
        newChar = nextChar;
        actions.append();
        return true;
      }
    }

    while (mode) {
      index++;
      c = path[index];

      if (c == '\\' && maybeUnescapeQuote(mode))
        continue;

      type = getPathCharType(c);
      typeMap = pathStateMachine[mode];
      transition = typeMap[type] || typeMap['else'] || 'error';

      if (transition == 'error')
        return; // parse error;

      mode = transition[0];
      action = actions[transition[1]] || noop;
      newChar = transition[2] === undefined ? c : transition[2];
      action();

      if (mode === 'afterPath') {
        return keys;
      }
    }

    return; // parse error
  }

  function isIdent(s) {
    return identRegExp.test(s);
  }

  var constructorIsPrivate = {};

  function Path(parts, privateToken) {
    if (privateToken !== constructorIsPrivate)
      throw Error('Use Path.get to retrieve path objects');

    for (var i = 0; i < parts.length; i++) {
      this.push(String(parts[i]));
    }

    if (hasEval && this.length) {
      this.getValueFrom = this.compiledGetValueFromFn();
    }
  }

  // TODO(rafaelw): Make simple LRU cache
  var pathCache = {};

  function getPath(pathString) {
    if (pathString instanceof Path)
      return pathString;

    if (pathString == null || pathString.length == 0)
      pathString = '';

    if (typeof pathString != 'string') {
      if (isIndex(pathString.length)) {
        // Constructed with array-like (pre-parsed) keys
        return new Path(pathString, constructorIsPrivate);
      }

      pathString = String(pathString);
    }

    var path = pathCache[pathString];
    if (path)
      return path;

    var parts = parsePath(pathString);
    if (!parts)
      return invalidPath;

    var path = new Path(parts, constructorIsPrivate);
    pathCache[pathString] = path;
    return path;
  }

  Path.get = getPath;

  function formatAccessor(key) {
    if (isIndex(key)) {
      return '[' + key + ']';
    } else {
      return '["' + key.replace(/"/g, '\\"') + '"]';
    }
  }

  Path.prototype = createObject({
    __proto__: [],
    valid: true,

    toString: function() {
      var pathString = '';
      for (var i = 0; i < this.length; i++) {
        var key = this[i];
        if (isIdent(key)) {
          pathString += i ? '.' + key : key;
        } else {
          pathString += formatAccessor(key);
        }
      }

      return pathString;
    },

    getValueFrom: function(obj, directObserver) {
      for (var i = 0; i < this.length; i++) {
        if (obj == null)
          return;
        obj = obj[this[i]];
      }
      return obj;
    },

    iterateObjects: function(obj, observe) {
      for (var i = 0; i < this.length; i++) {
        if (i)
          obj = obj[this[i - 1]];
        if (!isObject(obj))
          return;
        observe(obj, this[i]);
      }
    },

    compiledGetValueFromFn: function() {
      var str = '';
      var pathString = 'obj';
      str += 'if (obj != null';
      var i = 0;
      var key;
      for (; i < (this.length - 1); i++) {
        key = this[i];
        pathString += isIdent(key) ? '.' + key : formatAccessor(key);
        str += ' &&\n     ' + pathString + ' != null';
      }
      str += ')\n';

      var key = this[i];
      pathString += isIdent(key) ? '.' + key : formatAccessor(key);

      str += '  return ' + pathString + ';\nelse\n  return undefined;';
      return new Function('obj', str);
    },

    setValueFrom: function(obj, value) {
      if (!this.length)
        return false;

      for (var i = 0; i < this.length - 1; i++) {
        if (!isObject(obj))
          return false;
        obj = obj[this[i]];
      }

      if (!isObject(obj))
        return false;

      obj[this[i]] = value;
      return true;
    }
  });

  var invalidPath = new Path('', constructorIsPrivate);
  invalidPath.valid = false;
  invalidPath.getValueFrom = invalidPath.setValueFrom = function() {};

  var MAX_DIRTY_CHECK_CYCLES = 1000;

  function dirtyCheck(observer) {
    var cycles = 0;
    while (cycles < MAX_DIRTY_CHECK_CYCLES && observer.check_()) {
      cycles++;
    }
    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    return cycles > 0;
  }

  function objectIsEmpty(object) {
    for (var prop in object)
      return false;
    return true;
  }

  function diffIsEmpty(diff) {
    return objectIsEmpty(diff.added) &&
           objectIsEmpty(diff.removed) &&
           objectIsEmpty(diff.changed);
  }

  function diffObjectFromOldObject(object, oldObject) {
    var added = {};
    var removed = {};
    var changed = {};

    for (var prop in oldObject) {
      var newValue = object[prop];

      if (newValue !== undefined && newValue === oldObject[prop])
        continue;

      if (!(prop in object)) {
        removed[prop] = undefined;
        continue;
      }

      if (newValue !== oldObject[prop])
        changed[prop] = newValue;
    }

    for (var prop in object) {
      if (prop in oldObject)
        continue;

      added[prop] = object[prop];
    }

    if (Array.isArray(object) && object.length !== oldObject.length)
      changed.length = object.length;

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  var eomTasks = [];
  function runEOMTasks() {
    if (!eomTasks.length)
      return false;

    for (var i = 0; i < eomTasks.length; i++) {
      eomTasks[i]();
    }
    eomTasks.length = 0;
    return true;
  }

  var runEOM = hasObserve ? (function(){
    return function(fn) {
      return Promise.resolve().then(fn);
    }
  })() :
  (function() {
    return function(fn) {
      eomTasks.push(fn);
    };
  })();

  var observedObjectCache = [];

  function newObservedObject() {
    var observer;
    var object;
    var discardRecords = false;
    var first = true;

    function callback(records) {
      if (observer && observer.state_ === OPENED && !discardRecords)
        observer.check_(records);
    }

    return {
      open: function(obs) {
        if (observer)
          throw Error('ObservedObject in use');

        if (!first)
          Object.deliverChangeRecords(callback);

        observer = obs;
        first = false;
      },
      observe: function(obj, arrayObserve) {
        object = obj;
        if (arrayObserve)
          Array.observe(object, callback);
        else
          Object.observe(object, callback);
      },
      deliver: function(discard) {
        discardRecords = discard;
        Object.deliverChangeRecords(callback);
        discardRecords = false;
      },
      close: function() {
        observer = undefined;
        Object.unobserve(object, callback);
        observedObjectCache.push(this);
      }
    };
  }

  /*
   * The observedSet abstraction is a perf optimization which reduces the total
   * number of Object.observe observations of a set of objects. The idea is that
   * groups of Observers will have some object dependencies in common and this
   * observed set ensures that each object in the transitive closure of
   * dependencies is only observed once. The observedSet acts as a write barrier
   * such that whenever any change comes through, all Observers are checked for
   * changed values.
   *
   * Note that this optimization is explicitly moving work from setup-time to
   * change-time.
   *
   * TODO(rafaelw): Implement "garbage collection". In order to move work off
   * the critical path, when Observers are closed, their observed objects are
   * not Object.unobserve(d). As a result, it's possible that if the observedSet
   * is kept open, but some Observers have been closed, it could cause "leaks"
   * (prevent otherwise collectable objects from being collected). At some
   * point, we should implement incremental "gc" which keeps a list of
   * observedSets which may need clean-up and does small amounts of cleanup on a
   * timeout until all is clean.
   */

  function getObservedObject(observer, object, arrayObserve) {
    var dir = observedObjectCache.pop() || newObservedObject();
    dir.open(observer);
    dir.observe(object, arrayObserve);
    return dir;
  }

  var observedSetCache = [];

  function newObservedSet() {
    var observerCount = 0;
    var observers = [];
    var objects = [];
    var rootObj;
    var rootObjProps;

    function observe(obj, prop) {
      if (!obj)
        return;

      if (obj === rootObj)
        rootObjProps[prop] = true;

      if (objects.indexOf(obj) < 0) {
        objects.push(obj);
        Object.observe(obj, callback);
      }

      observe(Object.getPrototypeOf(obj), prop);
    }

    function allRootObjNonObservedProps(recs) {
      for (var i = 0; i < recs.length; i++) {
        var rec = recs[i];
        if (rec.object !== rootObj ||
            rootObjProps[rec.name] ||
            rec.type === 'setPrototype') {
          return false;
        }
      }
      return true;
    }

    function callback(recs) {
      if (allRootObjNonObservedProps(recs))
        return;

      var observer;
      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.iterateObjects_(observe);
        }
      }

      for (var i = 0; i < observers.length; i++) {
        observer = observers[i];
        if (observer.state_ == OPENED) {
          observer.check_();
        }
      }
    }

    var record = {
      objects: objects,
      get rootObject() { return rootObj; },
      set rootObject(value) {
        rootObj = value;
        rootObjProps = {};
      },
      open: function(obs, object) {
        observers.push(obs);
        observerCount++;
        obs.iterateObjects_(observe);
      },
      close: function(obs) {
        observerCount--;
        if (observerCount > 0) {
          return;
        }

        for (var i = 0; i < objects.length; i++) {
          Object.unobserve(objects[i], callback);
          Observer.unobservedCount++;
        }

        observers.length = 0;
        objects.length = 0;
        rootObj = undefined;
        rootObjProps = undefined;
        observedSetCache.push(this);
        if (lastObservedSet === this)
          lastObservedSet = null;
      },
    };

    return record;
  }

  var lastObservedSet;

  function getObservedSet(observer, obj) {
    if (!lastObservedSet || lastObservedSet.rootObject !== obj) {
      lastObservedSet = observedSetCache.pop() || newObservedSet();
      lastObservedSet.rootObject = obj;
    }
    lastObservedSet.open(observer, obj);
    return lastObservedSet;
  }

  var UNOPENED = 0;
  var OPENED = 1;
  var CLOSED = 2;
  var RESETTING = 3;

  var nextObserverId = 1;

  function Observer() {
    this.state_ = UNOPENED;
    this.callback_ = undefined;
    this.target_ = undefined; // TODO(rafaelw): Should be WeakRef
    this.directObserver_ = undefined;
    this.value_ = undefined;
    this.id_ = nextObserverId++;
  }

  Observer.prototype = {
    open: function(callback, target) {
      if (this.state_ != UNOPENED)
        throw Error('Observer has already been opened.');

      addToAll(this);
      this.callback_ = callback;
      this.target_ = target;
      this.connect_();
      this.state_ = OPENED;
      return this.value_;
    },

    close: function() {
      if (this.state_ != OPENED)
        return;

      removeFromAll(this);
      this.disconnect_();
      this.value_ = undefined;
      this.callback_ = undefined;
      this.target_ = undefined;
      this.state_ = CLOSED;
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      dirtyCheck(this);
    },

    report_: function(changes) {
      try {
        this.callback_.apply(this.target_, changes);
      } catch (ex) {
        Observer._errorThrownDuringCallback = true;
        console.error('Exception caught during observer callback: ' +
                       (ex.stack || ex));
      }
    },

    discardChanges: function() {
      this.check_(undefined, true);
      return this.value_;
    }
  }

  var collectObservers = !hasObserve;
  var allObservers;
  Observer._allObserversCount = 0;

  if (collectObservers) {
    allObservers = [];
  }

  function addToAll(observer) {
    Observer._allObserversCount++;
    if (!collectObservers)
      return;

    allObservers.push(observer);
  }

  function removeFromAll(observer) {
    Observer._allObserversCount--;
  }

  var runningMicrotaskCheckpoint = false;

  global.Platform = global.Platform || {};

  global.Platform.performMicrotaskCheckpoint = function() {
    if (runningMicrotaskCheckpoint)
      return;

    if (!collectObservers)
      return;

    runningMicrotaskCheckpoint = true;

    var cycles = 0;
    var anyChanged, toCheck;

    do {
      cycles++;
      toCheck = allObservers;
      allObservers = [];
      anyChanged = false;

      for (var i = 0; i < toCheck.length; i++) {
        var observer = toCheck[i];
        if (observer.state_ != OPENED)
          continue;

        if (observer.check_())
          anyChanged = true;

        allObservers.push(observer);
      }
      if (runEOMTasks())
        anyChanged = true;
    } while (cycles < MAX_DIRTY_CHECK_CYCLES && anyChanged);

    if (testingExposeCycleCount)
      global.dirtyCheckCycleCount = cycles;

    runningMicrotaskCheckpoint = false;
  };

  if (collectObservers) {
    global.Platform.clearObservers = function() {
      allObservers = [];
    };
  }

  function ObjectObserver(object) {
    Observer.call(this);
    this.value_ = object;
    this.oldObject_ = undefined;
  }

  ObjectObserver.prototype = createObject({
    __proto__: Observer.prototype,

    arrayObserve: false,

    connect_: function(callback, target) {
      if (hasObserve) {
        this.directObserver_ = getObservedObject(this, this.value_,
                                                 this.arrayObserve);
      } else {
        this.oldObject_ = this.copyObject(this.value_);
      }

    },

    copyObject: function(object) {
      var copy = Array.isArray(object) ? [] : {};
      for (var prop in object) {
        copy[prop] = object[prop];
      };
      if (Array.isArray(object))
        copy.length = object.length;
      return copy;
    },

    check_: function(changeRecords, skipChanges) {
      var diff;
      var oldValues;
      if (hasObserve) {
        if (!changeRecords)
          return false;

        oldValues = {};
        diff = diffObjectFromChangeRecords(this.value_, changeRecords,
                                           oldValues);
      } else {
        oldValues = this.oldObject_;
        diff = diffObjectFromOldObject(this.value_, this.oldObject_);
      }

      if (diffIsEmpty(diff))
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([
        diff.added || {},
        diff.removed || {},
        diff.changed || {},
        function(property) {
          return oldValues[property];
        }
      ]);

      return true;
    },

    disconnect_: function() {
      if (hasObserve) {
        this.directObserver_.close();
        this.directObserver_ = undefined;
      } else {
        this.oldObject_ = undefined;
      }
    },

    deliver: function() {
      if (this.state_ != OPENED)
        return;

      if (hasObserve)
        this.directObserver_.deliver(false);
      else
        dirtyCheck(this);
    },

    discardChanges: function() {
      if (this.directObserver_)
        this.directObserver_.deliver(true);
      else
        this.oldObject_ = this.copyObject(this.value_);

      return this.value_;
    }
  });

  function ArrayObserver(array) {
    if (!Array.isArray(array))
      throw Error('Provided object is not an Array');
    ObjectObserver.call(this, array);
  }

  ArrayObserver.prototype = createObject({

    __proto__: ObjectObserver.prototype,

    arrayObserve: true,

    copyObject: function(arr) {
      return arr.slice();
    },

    check_: function(changeRecords) {
      var splices;
      if (hasObserve) {
        if (!changeRecords)
          return false;
        splices = projectArraySplices(this.value_, changeRecords);
      } else {
        splices = calcSplices(this.value_, 0, this.value_.length,
                              this.oldObject_, 0, this.oldObject_.length);
      }

      if (!splices || !splices.length)
        return false;

      if (!hasObserve)
        this.oldObject_ = this.copyObject(this.value_);

      this.report_([splices]);
      return true;
    }
  });

  ArrayObserver.applySplices = function(previous, current, splices) {
    splices.forEach(function(splice) {
      var spliceArgs = [splice.index, splice.removed.length];
      var addIndex = splice.index;
      while (addIndex < splice.index + splice.addedCount) {
        spliceArgs.push(current[addIndex]);
        addIndex++;
      }

      Array.prototype.splice.apply(previous, spliceArgs);
    });
  };

  function PathObserver(object, path) {
    Observer.call(this);

    this.object_ = object;
    this.path_ = getPath(path);
    this.directObserver_ = undefined;
  }

  PathObserver.prototype = createObject({
    __proto__: Observer.prototype,

    get path() {
      return this.path_;
    },

    connect_: function() {
      if (hasObserve)
        this.directObserver_ = getObservedSet(this, this.object_);

      this.check_(undefined, true);
    },

    disconnect_: function() {
      this.value_ = undefined;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    iterateObjects_: function(observe) {
      this.path_.iterateObjects(this.object_, observe);
    },

    check_: function(changeRecords, skipChanges) {
      var oldValue = this.value_;
      this.value_ = this.path_.getValueFrom(this.object_);
      if (skipChanges || areSameValue(this.value_, oldValue))
        return false;

      this.report_([this.value_, oldValue, this]);
      return true;
    },

    setValue: function(newValue) {
      if (this.path_)
        this.path_.setValueFrom(this.object_, newValue);
    }
  });

  function CompoundObserver(reportChangesOnOpen) {
    Observer.call(this);

    this.reportChangesOnOpen_ = reportChangesOnOpen;
    this.value_ = [];
    this.directObserver_ = undefined;
    this.observed_ = [];
  }

  var observerSentinel = {};

  CompoundObserver.prototype = createObject({
    __proto__: Observer.prototype,

    connect_: function() {
      if (hasObserve) {
        var object;
        var needsDirectObserver = false;
        for (var i = 0; i < this.observed_.length; i += 2) {
          object = this.observed_[i]
          if (object !== observerSentinel) {
            needsDirectObserver = true;
            break;
          }
        }

        if (needsDirectObserver)
          this.directObserver_ = getObservedSet(this, object);
      }

      this.check_(undefined, !this.reportChangesOnOpen_);
    },

    disconnect_: function() {
      for (var i = 0; i < this.observed_.length; i += 2) {
        if (this.observed_[i] === observerSentinel)
          this.observed_[i + 1].close();
      }
      this.observed_.length = 0;
      this.value_.length = 0;

      if (this.directObserver_) {
        this.directObserver_.close(this);
        this.directObserver_ = undefined;
      }
    },

    addPath: function(object, path) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add paths once started.');

      var path = getPath(path);
      this.observed_.push(object, path);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = path.getValueFrom(object);
    },

    addObserver: function(observer) {
      if (this.state_ != UNOPENED && this.state_ != RESETTING)
        throw Error('Cannot add observers once started.');

      this.observed_.push(observerSentinel, observer);
      if (!this.reportChangesOnOpen_)
        return;
      var index = this.observed_.length / 2 - 1;
      this.value_[index] = observer.open(this.deliver, this);
    },

    startReset: function() {
      if (this.state_ != OPENED)
        throw Error('Can only reset while open');

      this.state_ = RESETTING;
      this.disconnect_();
    },

    finishReset: function() {
      if (this.state_ != RESETTING)
        throw Error('Can only finishReset after startReset');
      this.state_ = OPENED;
      this.connect_();

      return this.value_;
    },

    iterateObjects_: function(observe) {
      var object;
      for (var i = 0; i < this.observed_.length; i += 2) {
        object = this.observed_[i]
        if (object !== observerSentinel)
          this.observed_[i + 1].iterateObjects(object, observe)
      }
    },

    check_: function(changeRecords, skipChanges) {
      var oldValues;
      for (var i = 0; i < this.observed_.length; i += 2) {
        var object = this.observed_[i];
        var path = this.observed_[i+1];
        var value;
        if (object === observerSentinel) {
          var observable = path;
          value = this.state_ === UNOPENED ?
              observable.open(this.deliver, this) :
              observable.discardChanges();
        } else {
          value = path.getValueFrom(object);
        }

        if (skipChanges) {
          this.value_[i / 2] = value;
          continue;
        }

        if (areSameValue(value, this.value_[i / 2]))
          continue;

        oldValues = oldValues || [];
        oldValues[i / 2] = this.value_[i / 2];
        this.value_[i / 2] = value;
      }

      if (!oldValues)
        return false;

      // TODO(rafaelw): Having observed_ as the third callback arg here is
      // pretty lame API. Fix.
      this.report_([this.value_, oldValues, this.observed_]);
      return true;
    }
  });

  function identFn(value) { return value; }

  function ObserverTransform(observable, getValueFn, setValueFn,
                             dontPassThroughSet) {
    this.callback_ = undefined;
    this.target_ = undefined;
    this.value_ = undefined;
    this.observable_ = observable;
    this.getValueFn_ = getValueFn || identFn;
    this.setValueFn_ = setValueFn || identFn;
    // TODO(rafaelw): This is a temporary hack. PolymerExpressions needs this
    // at the moment because of a bug in it's dependency tracking.
    this.dontPassThroughSet_ = dontPassThroughSet;
  }

  ObserverTransform.prototype = {
    open: function(callback, target) {
      this.callback_ = callback;
      this.target_ = target;
      this.value_ =
          this.getValueFn_(this.observable_.open(this.observedCallback_, this));
      return this.value_;
    },

    observedCallback_: function(value) {
      value = this.getValueFn_(value);
      if (areSameValue(value, this.value_))
        return;
      var oldValue = this.value_;
      this.value_ = value;
      this.callback_.call(this.target_, this.value_, oldValue);
    },

    discardChanges: function() {
      this.value_ = this.getValueFn_(this.observable_.discardChanges());
      return this.value_;
    },

    deliver: function() {
      return this.observable_.deliver();
    },

    setValue: function(value) {
      value = this.setValueFn_(value);
      if (!this.dontPassThroughSet_ && this.observable_.setValue)
        return this.observable_.setValue(value);
    },

    close: function() {
      if (this.observable_)
        this.observable_.close();
      this.callback_ = undefined;
      this.target_ = undefined;
      this.observable_ = undefined;
      this.value_ = undefined;
      this.getValueFn_ = undefined;
      this.setValueFn_ = undefined;
    }
  }

  var expectedRecordTypes = {
    add: true,
    update: true,
    delete: true
  };

  function diffObjectFromChangeRecords(object, changeRecords, oldValues) {
    var added = {};
    var removed = {};

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      if (!expectedRecordTypes[record.type]) {
        console.error('Unknown changeRecord type: ' + record.type);
        console.error(record);
        continue;
      }

      if (!(record.name in oldValues))
        oldValues[record.name] = record.oldValue;

      if (record.type == 'update')
        continue;

      if (record.type == 'add') {
        if (record.name in removed)
          delete removed[record.name];
        else
          added[record.name] = true;

        continue;
      }

      // type = 'delete'
      if (record.name in added) {
        delete added[record.name];
        delete oldValues[record.name];
      } else {
        removed[record.name] = true;
      }
    }

    for (var prop in added)
      added[prop] = object[prop];

    for (var prop in removed)
      removed[prop] = undefined;

    var changed = {};
    for (var prop in oldValues) {
      if (prop in added || prop in removed)
        continue;

      var newValue = object[prop];
      if (oldValues[prop] !== newValue)
        changed[prop] = newValue;
    }

    return {
      added: added,
      removed: removed,
      changed: changed
    };
  }

  function newSplice(index, removed, addedCount) {
    return {
      index: index,
      removed: removed,
      addedCount: addedCount
    };
  }

  var EDIT_LEAVE = 0;
  var EDIT_UPDATE = 1;
  var EDIT_ADD = 2;
  var EDIT_DELETE = 3;

  function ArraySplice() {}

  ArraySplice.prototype = {

    // Note: This function is *based* on the computation of the Levenshtein
    // "edit" distance. The one change is that "updates" are treated as two
    // edits - not one. With Array splices, an update is really a delete
    // followed by an add. By retaining this, we optimize for "keeping" the
    // maximum array items in the original array. For example:
    //
    //   'xxxx123' -> '123yyyy'
    //
    // With 1-edit updates, the shortest path would be just to update all seven
    // characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
    // leaves the substring '123' intact.
    calcEditDistances: function(current, currentStart, currentEnd,
                                old, oldStart, oldEnd) {
      // "Deletion" columns
      var rowCount = oldEnd - oldStart + 1;
      var columnCount = currentEnd - currentStart + 1;
      var distances = new Array(rowCount);

      // "Addition" rows. Initialize null column.
      for (var i = 0; i < rowCount; i++) {
        distances[i] = new Array(columnCount);
        distances[i][0] = i;
      }

      // Initialize null row
      for (var j = 0; j < columnCount; j++)
        distances[0][j] = j;

      for (var i = 1; i < rowCount; i++) {
        for (var j = 1; j < columnCount; j++) {
          if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
            distances[i][j] = distances[i - 1][j - 1];
          else {
            var north = distances[i - 1][j] + 1;
            var west = distances[i][j - 1] + 1;
            distances[i][j] = north < west ? north : west;
          }
        }
      }

      return distances;
    },

    // This starts at the final weight, and walks "backward" by finding
    // the minimum previous weight recursively until the origin of the weight
    // matrix.
    spliceOperationsFromEditDistances: function(distances) {
      var i = distances.length - 1;
      var j = distances[0].length - 1;
      var current = distances[i][j];
      var edits = [];
      while (i > 0 || j > 0) {
        if (i == 0) {
          edits.push(EDIT_ADD);
          j--;
          continue;
        }
        if (j == 0) {
          edits.push(EDIT_DELETE);
          i--;
          continue;
        }
        var northWest = distances[i - 1][j - 1];
        var west = distances[i - 1][j];
        var north = distances[i][j - 1];

        var min;
        if (west < north)
          min = west < northWest ? west : northWest;
        else
          min = north < northWest ? north : northWest;

        if (min == northWest) {
          if (northWest == current) {
            edits.push(EDIT_LEAVE);
          } else {
            edits.push(EDIT_UPDATE);
            current = northWest;
          }
          i--;
          j--;
        } else if (min == west) {
          edits.push(EDIT_DELETE);
          i--;
          current = west;
        } else {
          edits.push(EDIT_ADD);
          j--;
          current = north;
        }
      }

      edits.reverse();
      return edits;
    },

    /**
     * Splice Projection functions:
     *
     * A splice map is a representation of how a previous array of items
     * was transformed into a new array of items. Conceptually it is a list of
     * tuples of
     *
     *   <index, removed, addedCount>
     *
     * which are kept in ascending index order of. The tuple represents that at
     * the |index|, |removed| sequence of items were removed, and counting forward
     * from |index|, |addedCount| items were added.
     */

    /**
     * Lacking individual splice mutation information, the minimal set of
     * splices can be synthesized given the previous state and final state of an
     * array. The basic approach is to calculate the edit distance matrix and
     * choose the shortest path through it.
     *
     * Complexity: O(l * p)
     *   l: The length of the current array
     *   p: The length of the old array
     */
    calcSplices: function(current, currentStart, currentEnd,
                          old, oldStart, oldEnd) {
      var prefixCount = 0;
      var suffixCount = 0;

      var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
      if (currentStart == 0 && oldStart == 0)
        prefixCount = this.sharedPrefix(current, old, minLength);

      if (currentEnd == current.length && oldEnd == old.length)
        suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);

      currentStart += prefixCount;
      oldStart += prefixCount;
      currentEnd -= suffixCount;
      oldEnd -= suffixCount;

      if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
        return [];

      if (currentStart == currentEnd) {
        var splice = newSplice(currentStart, [], 0);
        while (oldStart < oldEnd)
          splice.removed.push(old[oldStart++]);

        return [ splice ];
      } else if (oldStart == oldEnd)
        return [ newSplice(currentStart, [], currentEnd - currentStart) ];

      var ops = this.spliceOperationsFromEditDistances(
          this.calcEditDistances(current, currentStart, currentEnd,
                                 old, oldStart, oldEnd));

      var splice = undefined;
      var splices = [];
      var index = currentStart;
      var oldIndex = oldStart;
      for (var i = 0; i < ops.length; i++) {
        switch(ops[i]) {
          case EDIT_LEAVE:
            if (splice) {
              splices.push(splice);
              splice = undefined;
            }

            index++;
            oldIndex++;
            break;
          case EDIT_UPDATE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
          case EDIT_ADD:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.addedCount++;
            index++;
            break;
          case EDIT_DELETE:
            if (!splice)
              splice = newSplice(index, [], 0);

            splice.removed.push(old[oldIndex]);
            oldIndex++;
            break;
        }
      }

      if (splice) {
        splices.push(splice);
      }
      return splices;
    },

    sharedPrefix: function(current, old, searchLength) {
      for (var i = 0; i < searchLength; i++)
        if (!this.equals(current[i], old[i]))
          return i;
      return searchLength;
    },

    sharedSuffix: function(current, old, searchLength) {
      var index1 = current.length;
      var index2 = old.length;
      var count = 0;
      while (count < searchLength && this.equals(current[--index1], old[--index2]))
        count++;

      return count;
    },

    calculateSplices: function(current, previous) {
      return this.calcSplices(current, 0, current.length, previous, 0,
                              previous.length);
    },

    equals: function(currentValue, previousValue) {
      return currentValue === previousValue;
    }
  };

  var arraySplice = new ArraySplice();

  function calcSplices(current, currentStart, currentEnd,
                       old, oldStart, oldEnd) {
    return arraySplice.calcSplices(current, currentStart, currentEnd,
                                   old, oldStart, oldEnd);
  }

  function intersect(start1, end1, start2, end2) {
    // Disjoint
    if (end1 < start2 || end2 < start1)
      return -1;

    // Adjacent
    if (end1 == start2 || end2 == start1)
      return 0;

    // Non-zero intersect, span1 first
    if (start1 < start2) {
      if (end1 < end2)
        return end1 - start2; // Overlap
      else
        return end2 - start2; // Contained
    } else {
      // Non-zero intersect, span2 first
      if (end2 < end1)
        return end2 - start1; // Overlap
      else
        return end1 - start1; // Contained
    }
  }

  function mergeSplice(splices, index, removed, addedCount) {

    var splice = newSplice(index, removed, addedCount);

    var inserted = false;
    var insertionOffset = 0;

    for (var i = 0; i < splices.length; i++) {
      var current = splices[i];
      current.index += insertionOffset;

      if (inserted)
        continue;

      var intersectCount = intersect(splice.index,
                                     splice.index + splice.removed.length,
                                     current.index,
                                     current.index + current.addedCount);

      if (intersectCount >= 0) {
        // Merge the two splices

        splices.splice(i, 1);
        i--;

        insertionOffset -= current.addedCount - current.removed.length;

        splice.addedCount += current.addedCount - intersectCount;
        var deleteCount = splice.removed.length +
                          current.removed.length - intersectCount;

        if (!splice.addedCount && !deleteCount) {
          // merged splice is a noop. discard.
          inserted = true;
        } else {
          var removed = current.removed;

          if (splice.index < current.index) {
            // some prefix of splice.removed is prepended to current.removed.
            var prepend = splice.removed.slice(0, current.index - splice.index);
            Array.prototype.push.apply(prepend, removed);
            removed = prepend;
          }

          if (splice.index + splice.removed.length > current.index + current.addedCount) {
            // some suffix of splice.removed is appended to current.removed.
            var append = splice.removed.slice(current.index + current.addedCount - splice.index);
            Array.prototype.push.apply(removed, append);
          }

          splice.removed = removed;
          if (current.index < splice.index) {
            splice.index = current.index;
          }
        }
      } else if (splice.index < current.index) {
        // Insert splice here.

        inserted = true;

        splices.splice(i, 0, splice);
        i++;

        var offset = splice.addedCount - splice.removed.length
        current.index += offset;
        insertionOffset += offset;
      }
    }

    if (!inserted)
      splices.push(splice);
  }

  function createInitialSplices(array, changeRecords) {
    var splices = [];

    for (var i = 0; i < changeRecords.length; i++) {
      var record = changeRecords[i];
      switch(record.type) {
        case 'splice':
          mergeSplice(splices, record.index, record.removed.slice(), record.addedCount);
          break;
        case 'add':
        case 'update':
        case 'delete':
          if (!isIndex(record.name))
            continue;
          var index = toNumber(record.name);
          if (index < 0)
            continue;
          mergeSplice(splices, index, [record.oldValue], 1);
          break;
        default:
          console.error('Unexpected record type: ' + JSON.stringify(record));
          break;
      }
    }

    return splices;
  }

  function projectArraySplices(array, changeRecords) {
    var splices = [];

    createInitialSplices(array, changeRecords).forEach(function(splice) {
      if (splice.addedCount == 1 && splice.removed.length == 1) {
        if (splice.removed[0] !== array[splice.index])
          splices.push(splice);

        return
      };

      splices = splices.concat(calcSplices(array, splice.index, splice.index + splice.addedCount,
                                           splice.removed, 0, splice.removed.length));
    });

    return splices;
  }

  // Export the observe-js object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, export as a global object.

  var expose = global;

  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      expose = exports = module.exports;
    }
    expose = exports;
  } 

  expose.Observer = Observer;
  expose.Observer.runEOM_ = runEOM;
  expose.Observer.observerSentinel_ = observerSentinel; // for testing.
  expose.Observer.hasObjectObserve = hasObserve;
  expose.ArrayObserver = ArrayObserver;
  expose.ArrayObserver.calculateSplices = function(current, previous) {
    return arraySplice.calculateSplices(current, previous);
  };

  expose.ArraySplice = ArraySplice;
  expose.ObjectObserver = ObjectObserver;
  expose.PathObserver = PathObserver;
  expose.CompoundObserver = CompoundObserver;
  expose.Path = Path;
  expose.ObserverTransform = ObserverTransform;
  
})(typeof global !== 'undefined' && global && typeof module !== 'undefined' && module ? global : this || window);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],100:[function(require,module,exports){
// Domain Public by Eric Wendelin http://www.eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)
/*global module, exports, define, ActiveXObject*/
(function(global, factory) {
    if (typeof exports === 'object') {
        // Node
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals
        global.printStackTrace = factory();
    }
}(this, function() {
    /**
     * Main function giving a function stack trace with a forced or passed in Error
     *
     * @cfg {Error} e The error to create a stacktrace from (optional)
     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
     * @return {Array} of Strings with functions, lines, files, and arguments where possible
     */
    function printStackTrace(options) {
        options = options || {guess: true};
        var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;
        var p = new printStackTrace.implementation(), result = p.run(ex, mode);
        return (guess) ? p.guessAnonymousFunctions(result) : result;
    }

    printStackTrace.implementation = function() {
    };

    printStackTrace.implementation.prototype = {
        /**
         * @param {Error} [ex] The error to create a stacktrace from (optional)
         * @param {String} [mode] Forced mode (optional, mostly for unit tests)
         */
        run: function(ex, mode) {
            ex = ex || this.createException();
            mode = mode || this.mode(ex);
            if (mode === 'other') {
                return this.other(arguments.callee);
            } else {
                return this[mode](ex);
            }
        },

        createException: function() {
            try {
                this.undef();
            } catch (e) {
                return e;
            }
        },

        /**
         * Mode could differ for different exception, e.g.
         * exceptions in Chrome may or may not have arguments or stack.
         *
         * @return {String} mode of operation for the exception
         */
        mode: function(e) {
            if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('PhantomJS') > -1) {
                return 'phantomjs';
            }

            if (e['arguments'] && e.stack) {
                return 'chrome';
            }

            if (e.stack && e.sourceURL) {
                return 'safari';
            }

            if (e.stack && e.number) {
                return 'ie';
            }

            if (e.stack && e.fileName) {
                return 'firefox';
            }

            if (e.message && e['opera#sourceloc']) {
                // e.message.indexOf("Backtrace:") > -1 -> opera9
                // 'opera#sourceloc' in e -> opera9, opera10a
                // !e.stacktrace -> opera9
                if (!e.stacktrace) {
                    return 'opera9'; // use e.message
                }
                if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                    // e.message may have more stack entries than e.stacktrace
                    return 'opera9'; // use e.message
                }
                return 'opera10a'; // use e.stacktrace
            }

            if (e.message && e.stack && e.stacktrace) {
                // e.stacktrace && e.stack -> opera10b
                if (e.stacktrace.indexOf("called from line") < 0) {
                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'
                }
                // e.stacktrace && e.stack -> opera11
                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'
            }

            if (e.stack && !e.fileName) {
                // Chrome 27 does not have e.arguments as earlier versions,
                // but still does not have e.fileName as Firefox
                return 'chrome';
            }

            return 'other';
        },

        /**
         * Given a context, function name, and callback function, overwrite it so that it calls
         * printStackTrace() first with a callback and then runs the rest of the body.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to instrument
         * @param {Function} callback function to call with a stack trace on invocation
         */
        instrumentFunction: function(context, functionName, callback) {
            context = context || window;
            var original = context[functionName];
            context[functionName] = function instrumented() {
                callback.call(this, printStackTrace().slice(4));
                return context[functionName]._instrumented.apply(this, arguments);
            };
            context[functionName]._instrumented = original;
        },

        /**
         * Given a context and function name of a function that has been
         * instrumented, revert the function to it's original (non-instrumented)
         * state.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to de-instrument
         */
        deinstrumentFunction: function(context, functionName) {
            if (context[functionName].constructor === Function &&
                context[functionName]._instrumented &&
                context[functionName]._instrumented.constructor === Function) {
                context[functionName] = context[functionName]._instrumented;
            }
        },

        /**
         * Given an Error object, return a formatted Array based on Chrome's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        chrome: function(e) {
            return (e.stack + '\n')
                .replace(/^[\s\S]+?\s+at\s+/, ' at ') // remove message
                .replace(/^\s+(at eval )?at\s+/gm, '') // remove 'at' and indentation
                .replace(/^([^\(]+?)([\n$])/gm, '{anonymous}() ($1)$2')
                .replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}() ($1)')
                .replace(/^(.+) \((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(0, -1);
        },

        /**
         * Given an Error object, return a formatted Array based on Safari's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        safari: function(e) {
            return e.stack.replace(/\[native code\]\n/m, '')
                .replace(/^(?=\w+Error\:).*$\n/m, '')
                .replace(/^@/gm, '{anonymous}()@')
                .split('\n');
        },

        /**
         * Given an Error object, return a formatted Array based on IE's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        ie: function(e) {
            return e.stack
                .replace(/^\s*at\s+(.*)$/gm, '$1')
                .replace(/^Anonymous function\s+/gm, '{anonymous}() ')
                .replace(/^(.+)\s+\((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(1);
        },

        /**
         * Given an Error object, return a formatted Array based on Firefox's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        firefox: function(e) {
            return e.stack.replace(/(?:\n@:0)?\s+$/m, '')
                .replace(/^(?:\((\S*)\))?@/gm, '{anonymous}($1)@')
                .split('\n');
        },

        opera11: function(e) {
            var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var location = match[4] + ':' + match[1] + ':' + match[2];
                    var fnName = match[3] || "global code";
                    fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        opera10b: function(e) {
            // "<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\n" +
            // "printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\n" +
            // "@file://localhost/G:/js/test/functional/testcase1.html:15"
            var lineRE = /^(.*)@(.+):(\d+)$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i++) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[1] ? (match[1] + '()') : "global code";
                    result.push(fnName + '@' + match[2] + ':' + match[3]);
                }
            }

            return result;
        },

        /**
         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        opera10a: function(e) {
            // "  Line 27 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[3] || ANON;
                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        // Opera 7.x-9.2x only!
        opera9: function(e) {
            // "  Line 43 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n'), result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        phantomjs: function(e) {
            var ANON = '{anonymous}', lineRE = /(\S+) \((\S+)\)/i;
            var lines = e.stack.split('\n'), result = [];

            for (var i = 1, len = lines.length; i < len; i++) {
                lines[i] = lines[i].replace(/^\s+at\s+/gm, '');
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(match[1] + '()@' + match[2]);
                }
                else {
                    result.push(ANON + '()@' + lines[i]);
                }
            }

            return result;
        },

        // Safari 5-, IE 9-, and others
        other: function(curr) {
            var ANON = '{anonymous}', fnRE = /function(?:\s+([\w$]+))?\s*\(/, stack = [], fn, args, maxStackSize = 10;
            var slice = Array.prototype.slice;
            while (curr && stack.length < maxStackSize) {
                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
                try {
                    args = slice.call(curr['arguments'] || []);
                } catch (e) {
                    args = ['Cannot access arguments: ' + e];
                }
                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
                try {
                    curr = curr.caller;
                } catch (e) {
                    stack[stack.length] = 'Cannot access caller: ' + e;
                    break;
                }
            }
            return stack;
        },

        /**
         * Given arguments array as a String, substituting type names for non-string types.
         *
         * @param {Arguments,Array} args
         * @return {String} stringified arguments
         */
        stringifyArguments: function(args) {
            var result = [];
            var slice = Array.prototype.slice;
            for (var i = 0; i < args.length; ++i) {
                var arg = args[i];
                if (arg === undefined) {
                    result[i] = 'undefined';
                } else if (arg === null) {
                    result[i] = 'null';
                } else if (arg.constructor) {
                    // TODO constructor comparison does not work for iframes
                    if (arg.constructor === Array) {
                        if (arg.length < 3) {
                            result[i] = '[' + this.stringifyArguments(arg) + ']';
                        } else {
                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                        }
                    } else if (arg.constructor === Object) {
                        result[i] = '#object';
                    } else if (arg.constructor === Function) {
                        result[i] = '#function';
                    } else if (arg.constructor === String) {
                        result[i] = '"' + arg + '"';
                    } else if (arg.constructor === Number) {
                        result[i] = arg;
                    } else {
                        result[i] = '?';
                    }
                }
            }
            return result.join(',');
        },

        sourceCache: {},

        /**
         * @return {String} the text from a given URL
         */
        ajax: function(url) {
            var req = this.createXMLHTTPObject();
            if (req) {
                try {
                    req.open('GET', url, false);
                    //req.overrideMimeType('text/plain');
                    //req.overrideMimeType('text/javascript');
                    req.send(null);
                    //return req.status == 200 ? req.responseText : '';
                    return req.responseText;
                } catch (e) {
                }
            }
            return '';
        },

        /**
         * Try XHR methods in order and store XHR factory.
         *
         * @return {XMLHttpRequest} XHR function or equivalent
         */
        createXMLHTTPObject: function() {
            var xmlhttp, XMLHttpFactories = [
                function() {
                    return new XMLHttpRequest();
                }, function() {
                    return new ActiveXObject('Msxml2.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Msxml3.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                }
            ];
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xmlhttp = XMLHttpFactories[i]();
                    // Use memoization to cache the factory
                    this.createXMLHTTPObject = XMLHttpFactories[i];
                    return xmlhttp;
                } catch (e) {
                }
            }
        },

        /**
         * Given a URL, check if it is in the same domain (so we can get the source
         * via Ajax).
         *
         * @param url {String} source url
         * @return {Boolean} False if we need a cross-domain request
         */
        isSameDomain: function(url) {
            return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.
        },

        /**
         * Get source code from given URL if in the same domain.
         *
         * @param url {String} JS source URL
         * @return {Array} Array of source code lines
         */
        getSource: function(url) {
            // TODO reuse source from script tags?
            if (!(url in this.sourceCache)) {
                this.sourceCache[url] = this.ajax(url).split('\n');
            }
            return this.sourceCache[url];
        },

        guessAnonymousFunctions: function(stack) {
            for (var i = 0; i < stack.length; ++i) {
                var reStack = /\{anonymous\}\(.*\)@(.*)/,
                    reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/,
                    frame = stack[i], ref = reStack.exec(frame);

                if (ref) {
                    var m = reRef.exec(ref[1]);
                    if (m) { // If falsey, we did not get any file/line information
                        var file = m[1], lineno = m[2], charno = m[3] || 0;
                        if (file && this.isSameDomain(file) && lineno) {
                            var functionName = this.guessAnonymousFunction(file, lineno, charno);
                            stack[i] = frame.replace('{anonymous}', functionName);
                        }
                    }
                }
            }
            return stack;
        },

        guessAnonymousFunction: function(url, lineNo, charNo) {
            var ret;
            try {
                ret = this.findFunctionName(this.getSource(url), lineNo);
            } catch (e) {
                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
            }
            return ret;
        },

        findFunctionName: function(source, lineNo) {
            // FIXME findFunctionName fails for compressed source
            // (more than one function on the same line)
            // function {name}({args}) m[1]=name m[2]=args
            var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
            // {name} = function ({args}) TODO args capture
            // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
            var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
            // {name} = eval()
            var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
            // Walk backwards in the source lines until we find
            // the line which matches one of the patterns above
            var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
            for (var i = 0; i < maxLines; ++i) {
                // lineNo is 1-based, source[] is 0-based
                line = source[lineNo - i - 1];
                commentPos = line.indexOf('//');
                if (commentPos >= 0) {
                    line = line.substr(0, commentPos);
                }
                // TODO check other types of comments? Commented code may lead to false positive
                if (line) {
                    code = line + code;
                    m = reFunctionExpression.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                    m = reFunctionDeclaration.exec(code);
                    if (m && m[1]) {
                        //return m[1] + "(" + (m[2] || "") + ")";
                        return m[1];
                    }
                    m = reFunctionEvaluation.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
            return '(?)';
        }
    };

    return printStackTrace;
}));

},{}],101:[function(require,module,exports){
module.exports = {view: require('./lib/views/authentication'), model: require('./lib/models/authentication')};
},{"./lib/models/authentication":105,"./lib/views/authentication":106}],102:[function(require,module,exports){
module.exports = {
    register: false,
    enableAuthenticationUserid: false
};
},{}],103:[function(require,module,exports){
module.exports = {"authentication":".bdsft-webrtc .authenticationView span{color:#999;font-size:14px;line-height:18px}.bdsft-webrtc .authenticationView input{background:#666;border-bottom:1px solid #333;border-left:1px solid #000;border-right:1px solid #333;border-top:1px solid #000;color:#fff;border-radius:3px;font-family:arial;font-size:16px;padding:6px 6px 4px;width:200px}.bdsft-webrtc .authenticationView button{border-color:#999;border-width:1px;border-radius:4px;color:#333;cursor:pointer;padding:6px 6px 4px;margin-top:10px;font-size:12px;width:200px}.bdsft-webrtc .authenticationView .alert{font-size:20px;text-align:center;color:#f00}.bdsft-webrtc .authenticationView .signIn,.bdsft-webrtc .authenticationView .signOut{display:none}.bdsft-webrtc .authenticationView:not(.enableAuthenticationUserid) .authenticationUseridRow{display:none}.bdsft-webrtc .authenticationView:not(.disconnected).authentication-shown,.bdsft-webrtc .authenticationView:not(.registered):not(.registering).register{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .authenticationView.disconnected,.bdsft-webrtc .authenticationView:not(.authentication-shown),.bdsft-webrtc .authenticationView.registered{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .authenticationView:not(.registered) .signIn,.bdsft-webrtc .authenticationView.registered .signOut{display:block}.bdsft-webrtc .authenticationView.registered .userid,.bdsft-webrtc .authenticationView.registered .authenticationUserid,.bdsft-webrtc .authenticationView.registered .password{pointer-events:none;cursor:default;background-color:#999;opacity:.5}.bdsft-webrtc .authenticationView.registering .signIn,.bdsft-webrtc .authenticationView.unregistering .signOut{pointer-events:none;cursor:default;background-color:#999;opacity:.5}"}
},{}],104:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // authentication.jade compiled template
    templatizer["authentication"] = function tmpl_authentication() {
        return '<div class="bdsft-webrtc"><div class="authenticationView fadeable popup classes centered"><span>User ID</span><br/><input type="text" value="" class="userid"/><br/><div class="authenticationUseridRow"><span>Auth User ID</span><br/><input type="text" value="" class="authenticationUserid"/><br/></div><span>Password</span><br/><input type="password" value="" class="password"/><br/><br/><div class="alert"></div><button type="button" class="signIn button">Sign in</button><br/><button type="button" class="signOut button">Sign out</button></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],105:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Authentication, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;

function Authentication(debug, cookieconfig, sipstack) {
  var self = {};

  var signingOut = false;

  self.props = ['userid', 'authenticationUserid', 'password', 'classes', 'visible'];

  self.bindings = {
    'classes': {
      authentication: ['visible', 'register', 'enableAuthenticationUserid'],
      sipstack: ['callState', 'registered', 'registering', 'audioOnly', 'offerToReceiveVideo']
    },
    'cookieconfig': {
      authentication: ['userid', 'password', 'authenticationUserid']
    }
  }

  self.listeners = function(databinder, sipstackDatabinder, cookieconfigDatabinder) {
    cookieconfigDatabinder.onModelPropChange(['userid', 'password', 'authenticationUserid'], function(value, name) {
      if(value) {
        self[name] = value;
      }
    });
    sipstackDatabinder.onModelPropChange('registered', function(value) {
      if(value) {
        self.hide();
      }
    });
    sipstackDatabinder.onModelPropChange('unregistering', function(value) {
      if(!value && signingOut) {
        debug.log('clear authentication after sign out');
        cookieconfig.userid = undefined;
        cookieconfig.authenticationUserid = undefined;
        cookieconfig.password = undefined;
        signingOut = false;
      }
    });
    sipstackDatabinder.onModelPropChange('registrationStatus', function(status) {
      if (status && ((status === "403" && cookieconfig.userid && !cookieconfig.password) || self.register)) {
        self.show();
      }
      // WRTC-16 : use PAI on 404 to register
      if(!self.register && status === '404' && sipstack.pAssertedIdentity) {
        cookieconfig.userid = undefined;
        cookieconfig.authenticationUserid = undefined;
      }
    });
  };

  self.signOut = function() {
    signingOut = true;
    sipstack.unregister();
  };

  self.signIn = function() {
    if (!self.userid) {
      return;
    }
    self.hide();
    cookieconfig.userid = self.userid;
    cookieconfig.authenticationUserid = self.authenticationUserid;
    cookieconfig.password = self.password;
    sipstack.register();
  };

  return self;
}
},{"../../js/config.js":102,"webrtc-core":110}],106:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(AuthenticationView, {
  template: require('../../js/templates'),
  style: require('../../js/styles')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function AuthenticationView(authentication) {
  var self = {};

  self.model = authentication;

  self.elements = ['signIn', 'signOut', 'userid', 'authenticationUserid', 'password'];

  self.listeners = function() {
    self.password.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        self.password.trigger('change');
        authentication.signIn();
      }
    });
    self.signIn.bind('click', function(e) {
      e.preventDefault();
      authentication.signIn();
    });
    self.signOut.bind('click', function(e) {
      e.preventDefault();
      authentication.signOut();
    });

    self.view.bind('keypress', function(e) {
      if (e.which === 13) {
        self.signIn.click();
      }
    });
  };

  return self;
}
},{"../../js/styles":103,"../../js/templates":104,"webrtc-core":110}],107:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],108:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],109:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],110:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":109,"./bdsft":111,"./constants":114,"./cookieconfig":115,"./cookieprop":116,"./dateformat":119,"./debug":120,"./element":121,"./eventbus":122,"./factory":123,"./icon":124,"./loader":125,"./popup":126,"./prop":127,"./urlconfig":129,"./utils":130,"./visibleprop":131,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],111:[function(require,module,exports){
module.exports=require(54)
},{"./app":110,"./binding":112,"./classesbinding":113,"./databinder":118,"./stylesmanager":128,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":155}],112:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":111,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],113:[function(require,module,exports){
module.exports=require(56)
},{"./binding":112,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],114:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],115:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":111,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":155,"jquery.cookie":154}],116:[function(require,module,exports){
module.exports=require(59)
},{"./constants":114,"./prop":127,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":155,"jquery.cookie":154}],117:[function(require,module,exports){
module.exports=require(60)
},{"./constants":114,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":136}],118:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":139}],119:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],120:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":107,"./bdsft":111,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":132,"stacktrace-js":157}],121:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],122:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":111,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":139}],123:[function(require,module,exports){
module.exports=require(66)
},{"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":155}],124:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],125:[function(require,module,exports){
module.exports=require(68)
},{"../":110,"./constants":114,"./factory":123,"./stylesmanager":128,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":135}],126:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":155}],127:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":156}],128:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":108,"./constants":114,"./css":117,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],129:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":107,"./bdsft":111,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],130:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":109,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":155}],131:[function(require,module,exports){
module.exports=require(74)
},{"./constants":114,"./prop":127,"./utils":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],132:[function(require,module,exports){
module.exports=require(75)
},{"./debug":133,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],133:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":134}],134:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],135:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],136:[function(require,module,exports){
module.exports=require(79)
},{"./filters":137,"./utils":138,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],137:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],138:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],139:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":140,"es5-ext/object/valid-callable":149}],140:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":141,"es5-ext/object/is-callable":144,"es5-ext/object/normalize-options":148,"es5-ext/string/#/contains":151}],141:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":142,"./shim":143,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],142:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],143:[function(require,module,exports){
module.exports=require(86)
},{"../keys":145,"../valid-value":150,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],144:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],145:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":146,"./shim":147,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],146:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],147:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],148:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],149:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],150:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],151:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":152,"./shim":153,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],152:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],153:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],154:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":155}],155:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],156:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],157:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],158:[function(require,module,exports){
module.exports = {view: require('./lib/views/callcontrol'), model: require('./lib/models/callcontrol')};
},{"./lib/models/callcontrol":162,"./lib/views/callcontrol":163}],159:[function(require,module,exports){
module.exports = {
    enableCallControl: true,
    allowOutside: true,
    domainTo: 'broadsoftlabs.com',
    messageOutsideDomain: "Invalid Destination",
    messageEmptyDestination: "Invalid Destination"
};
},{}],160:[function(require,module,exports){
module.exports = {"callcontrol":".bdsft-webrtc .callControl{padding:15px;background:#292929;border:1px solid #3c3c3c;position:absolute;bottom:40px;right:auto;top:auto;left:0;letter-spacing:5px;z-index:100;box-sizing:content-box;padding-left:14px}.bdsft-webrtc .callControl .destination::-webkit-input-placeholder{color:#04aff0;font-style:italic;padding-left:5px;font-weight:400}.bdsft-webrtc .callControl hr{border:0;border-bottom:1px solid #3c3c3c}.bdsft-webrtc .callControl input{box-sizing:border-box;width:171px;line-height:30px;padding-left:8px;padding-right:35px}.bdsft-webrtc .callControl .historyButton{font-size:16px!important;padding-top:5px;padding-bottom:5px;outline:0;position:absolute;right:10px;top:23px;width:25px;padding:0;margin:0;background:0;border:0;border-radius:0;color:#b3b3b3}.bdsft-webrtc .callControl .historyButton.active{color:#04aff0}.bdsft-webrtc .callControl .control-bar{margin-top:6px}.bdsft-webrtc .callControl .control-bar .main-button{background:#3da005;border-radius:14px;width:70px;padding:5px;margin:0 3px}.bdsft-webrtc .callControl .control-bar a{color:#fff;text-decoration:none;text-align:center;width:100%;display:inline-block;font-size:14px;font-weight:700;letter-spacing:1}.bdsft-webrtc .callControl .control-bar a span{margin-right:5px}.bdsft-webrtc .callControl .call,.bdsft-webrtc .callControl .callAudio{z-index:10;display:block;position:static;top:auto;left:auto}.bdsft-webrtc .callControl.audioOnly:not(.offerToReceiveVideo){top:45px;bottom:auto}.bdsft-webrtc .callControl.enableCallControl.callcontrol-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callControl.calling .call,.bdsft-webrtc .callControl.calling .callAudio,.bdsft-webrtc .callControl:not(.connected) .call,.bdsft-webrtc .callControl:not(.connected) .callAudio,.bdsft-webrtc .callControl.enableCallControl:not(.callcontrol-shown){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .callControl.enableCallControl.connected .call,.bdsft-webrtc .callControl.enableCallControl.connected .callAudio{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}"}
},{}],161:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // callcontrol.jade compiled template
    templatizer["callcontrol"] = function tmpl_callcontrol() {
        return '<div class="bdsft-webrtc"><div class="callControl destination-container fadeable popup classes"><input type="text" onclick="this.focus();this.select()" class="destination"/><button title="Call History" class="historyButton"><i class="icon-clock"></i></button><hr/><div class="dialpadHolder"></div><div class="control-bar"><div><a href="" class="call main-button">Video</a><a href="" class="callAudio main-button">Audio</a></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],162:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(CallControl, {
  config: require('../../js/config.js')
});

var fs = require('fs');
var C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function CallControl(eventbus, debug, urlconfig, sipstack, sound, messages, history) {
  var self = {};

  self.updateDestination = function(value) {
    var valueFormatted = value && value.replace(/[^a-z0-9()@\.\-\s]+/ig, '');
    if (self.destination !== valueFormatted) {
      debug.log('formatted destination from ' + value + ' to ' + valueFormatted);
      self.destination = valueFormatted;
    }
  };

  self.props = ['destination', 'classes', 'visible'];

  self.bindings = {
    classes: {
      callcontrol: ['visible', 'enableCallControl'],
      sipstack: ['callState', 'audioOnly', 'offerToReceiveVideo']
    },
    enableCallControl: {
      urlconfig: 'enableCallControl'
    },
    destination: {
      callcontrol: 'destination'
    }
  }

  self.listeners = function(databinder, sipstackDatabinder) {
    if (!sipstack.enableConnectLocalMedia && urlconfig.destination) {
      var called = false;
      sipstackDatabinder.onModelPropChange('connected', function(connected) {
        if (connected && !called) {
          called = true;
          self.call(urlconfig.destination);
        }
      });
    } else if (urlconfig.destination) {
      eventbus.once('userMediaUpdated', function(e) {
        self.call(urlconfig.destination);
      });
    }
    eventbus.on('calling', function(e) {
      self.destination = e.destination.replace('sip:', '').replace('@' + self.domainTo, '');
    });
    eventbus.on('digit', function(e) {
      self.processDigitInput(e.digit, e.isFromDestination);
    });
    eventbus.on('started', function(e) {
      self.hide();
      if (!destinationOnStart) {
        destinationOnStart = self.destination;
      }
    });
    eventbus.on('ended', function(e) {
      resetDestination();
    });
  };

  var destinationOnStart = undefined;
  var resetDestination = function() {
    if (!sipstack.sessions.length) {
      self.destination = destinationOnStart;
      destinationOnStart = undefined;
    }
  };

  var appendDigit = function(digit) {
    self.destination = (self.destination || '') + digit;
  };

  self.pressDTMF = function(digit) {
    if (digit.length !== 1) {
      return;
    }
    if (sipstack.isStarted()) {
      appendDigit(digit);
      sound.playClick();
      sipstack.sendDTMF(digit);
    }
  };

  self.processDigitInput = function(digit, isFromDestination) {
    if (!sipstack.isStarted() && self.visible) {
      if (isFromDestination) {
        return;
      }
      appendDigit(digit);
    } else if (digit.match(/^[0-9A-D#*,]+$/i)) {
      self.pressDTMF(digit);
    }
  };

  self.formatDestination = function(destination, domainTo) {
    if (destination.indexOf("@") === -1) {
      destination = (destination + "@" + domainTo);
    }

    var domain = destination.substring(destination.indexOf("@"));
    if (domain.indexOf(".") === -1) {
      destination = destination + "." + domainTo;
    }

    // WEBRTC-35 : filter out dtmf tones from destination
    return destination.replace(/,[0-9A-D#*,]+/, '');
  };

  self.isValidDestination = function(destination, allowOutside, domainTo) {
    if (!allowOutside && !new RegExp("[.||@]" + domainTo).test(destination)) {
      return false;
    }
    return true;
  };


  // Make sure destination allowed and in proper format
  self.validateDestination = function(destination) {
    if (!destination) {
      messages.alert(self.messageEmptyDestination);
      return false;
    }

    if (!self.isValidDestination(destination, self.allowOutside, self.domainTo)) {
      messages.alert(self.messageOutsideDomain);
      return false;
    }

    if (destination.indexOf("sip:") === -1) {
      destination = ("sip:" + destination);
    }

    return self.formatDestination(destination, self.domainTo);
  };

  var call = function(destinationToValidate) {
    var lastCall = history.lastCall();
    if (!destinationToValidate && lastCall) {
      self.destination = lastCall.destinationWithoutSip();
      return;
    }

    if (sipstack.callState !== C.STATE_CONNECTED) {
      debug.info('Already in call with state : ' + sipstack.callState);
      return;
    }

    var destination = self.validateDestination(destinationToValidate);
    if (!destination) {
      debug.warn("destination is not valid : " + destinationToValidate);
      return;
    }

    debug.log("calling destination : " + destination);

    // Start the Call
    sipstack.call(destination);

    var dtmfTones = Utils.parseDTMFTones(destinationToValidate);
    if (dtmfTones) {
      debug.info("DTMF tones found in destination - sending DTMF tones when started : " + dtmfTones);
      eventbus.once("started", function(e) {
        sound.muteDTMF(true);
        sipstack.sendDTMF(dtmfTones);
      });
      eventbus.once("newDTMF", function(e) {
        var digit = e.data.tone;
        if (digit === '#') {
          sound.muteDTMF(false);
        }
      });
    }
  }

  self.callAudio = function(destinationToValidate) {
    sipstack.audioOnly = true;
    sipstack.offerToReceiveVideo = false;
    call(destinationToValidate);
  };

  self.call = function(destinationToValidate) {
    sipstack.audioOnly = false;
    sipstack.offerToReceiveVideo = true;
    call(destinationToValidate);
  };


  return self;
}
},{"../../js/config.js":159,"fs":7,"webrtc-core":167}],163:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(CallControlView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function CallControlView(eventbus, callcontrol, sipstack, sound, dialpadView, history) {
  var self = {};

  self.model = callcontrol;
  

  self.elements = ['historyButton', 'destination', 'call', 'callAudio', 'dialpadHolder'];

  self.init = function() {
    dialpadView.view.appendTo(self.dialpadHolder);
  };

  self.listeners = function(databinder, historyDatabinder) {
    self.destination.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        callcontrol.call(self.destination.val());
      }
    });
    self.historyButton.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.toggle();
    });
    self.call.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      callcontrol.call(self.destination.val());
    });
    self.callAudio.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      callcontrol.callAudio(self.destination.val());
    });
    databinder.onModelPropChange('visible', function(visible){
      visible && self.destination.focus();
    });
    historyDatabinder.onModelPropChange('visible', function(visible){
      if (visible) {
        self.historyButton.removeClass("active");
      } else {
        self.historyButton.addClass("active");
      }
    });
    var isTextInputTarget = function(event) {
      var d = event.srcElement || event.target;
      var type = d.type && d.type.toUpperCase();
      var tagName = d.tagName && d.tagName.toUpperCase();
      return (tagName === 'INPUT' && (type === 'TEXT' || type === 'PASSWORD' || type === 'FILE' || type === 'EMAIL')) || tagName === 'TEXTAREA';
    };
    // Prevent the backspace key from navigating back if callcontrol is shown
    Utils.getElement(document).bind('keydown', function(event) {
      if (self.visible) {
        var doPrevent = false;
        if (event.keyCode === 8) {
          if (isTextInputTarget(event)) {
            doPrevent = d.readOnly || d.disabled;
          } else {
            doPrevent = true;
            var value = self.destination.val();
            if(value) {
              self.destination.val( value.slice(0, value.length - 1));
              self.destination.trigger('change');
            }
          }
        }

        if (doPrevent) {
          event.preventDefault();
          return;
        }
      }

      if(self.destination.is(event.target) || !isTextInputTarget(event)) {
        var digit = String.fromCharCode(event.which);
        eventbus.digit(digit, self.destination.is(event.target));
      }

      // TODO - look how to activate without affecting other inputs
      // var len = self.destination.val().length * 2;
      // self.destination[0].setSelectionRange(len, len);
    });
  };

  return self;
}
},{"../../js/styles":160,"../../js/templates":161,"webrtc-core":167}],164:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],165:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],166:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],167:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":166,"./bdsft":168,"./constants":171,"./cookieconfig":172,"./cookieprop":173,"./dateformat":176,"./debug":177,"./element":178,"./eventbus":179,"./factory":180,"./icon":181,"./loader":182,"./popup":183,"./prop":184,"./urlconfig":186,"./utils":187,"./visibleprop":188,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],168:[function(require,module,exports){
module.exports=require(54)
},{"./app":167,"./binding":169,"./classesbinding":170,"./databinder":175,"./stylesmanager":185,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":212}],169:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":168,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],170:[function(require,module,exports){
module.exports=require(56)
},{"./binding":169,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],171:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],172:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":168,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":212,"jquery.cookie":211}],173:[function(require,module,exports){
module.exports=require(59)
},{"./constants":171,"./prop":184,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":212,"jquery.cookie":211}],174:[function(require,module,exports){
module.exports=require(60)
},{"./constants":171,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":193}],175:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":196}],176:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],177:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":164,"./bdsft":168,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":189,"stacktrace-js":214}],178:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],179:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":168,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":196}],180:[function(require,module,exports){
module.exports=require(66)
},{"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":212}],181:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],182:[function(require,module,exports){
module.exports=require(68)
},{"../":167,"./constants":171,"./factory":180,"./stylesmanager":185,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":192}],183:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":212}],184:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":213}],185:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":165,"./constants":171,"./css":174,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],186:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":164,"./bdsft":168,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],187:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":166,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":212}],188:[function(require,module,exports){
module.exports=require(74)
},{"./constants":171,"./prop":184,"./utils":187,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],189:[function(require,module,exports){
module.exports=require(75)
},{"./debug":190,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],190:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":191}],191:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],192:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],193:[function(require,module,exports){
module.exports=require(79)
},{"./filters":194,"./utils":195,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],194:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],195:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],196:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":197,"es5-ext/object/valid-callable":206}],197:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":198,"es5-ext/object/is-callable":201,"es5-ext/object/normalize-options":205,"es5-ext/string/#/contains":208}],198:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":199,"./shim":200,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],199:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],200:[function(require,module,exports){
module.exports=require(86)
},{"../keys":202,"../valid-value":207,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],201:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],202:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":203,"./shim":204,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],203:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],204:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],205:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],206:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],207:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],208:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":209,"./shim":210,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],209:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],210:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],211:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":212}],212:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],213:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],214:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],215:[function(require,module,exports){
module.exports = {view: require('./lib/views/chat'), model: require('./lib/models/chat')};
},{"./lib/models/chat":219,"./lib/views/chat":221}],216:[function(require,module,exports){
module.exports = {
    enableChat: false
};
},{}],217:[function(require,module,exports){
module.exports = {"chat":".bdsft-webrtc .chat{position:absolute;display:none;border:1px solid #000}.bdsft-webrtc .chat .input{width:100%;box-sizing:border-box;margin:10px 0;display:block;background:#fff;border:1px solid #d6d6d6;color:#606060;font-size:14px;padding:8px;border-radius:0}.bdsft-webrtc .chat .messagesContent{height:auto}.bdsft-webrtc .chat.enableChat.enableDatachannel.started{display:block}.bdsft-webrtc .chat:not(.started) .input{pointer-events:none;cursor:default;background-color:#999;opacity:.5}","message":".bdsft-webrtc .message{padding:3px 0}.bdsft-webrtc .message .body{font-size:12px}.bdsft-webrtc .message.outgoing{text-align:left;background-color:#808080}.bdsft-webrtc .message.incoming{text-align:right;background-color:#d3d3d3}"}
},{}],218:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // chat.jade compiled template
    templatizer["chat"] = function tmpl_chat() {
        return '<div class="bdsft-webrtc"><div class="chat classes bottomleft"><textarea class="input"></textarea><div class="messagesContent"></div></div></div>';
    };

    // message.jade compiled template
    templatizer["message"] = function tmpl_message() {
        return '<div class="message classes"><span class="body"></span></div>';
    };

    return templatizer;
}));
},{"fs":7}],219:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Chat, {
  config: require('../../js/config.js')
});

var Message = require('./message');
var Utils = require('webrtc-core').utils;

function Chat(eventbus, debug, sipstack) {
  var self = {};

  self.props = ['input', 'messages', 'classes', 'visible'];

  self.bindings = {
    classes: {
        self: ['enableChat', 'visible'],
        sipstack: ['callState', 'enableDatachannel']
    }
  }

  var addMessage = function(text, direction) {
    var message = Message.create([text, direction]);
    self.messages[message.id] = message;
  }

  self.send = function(text){
    text = text || self.input;
    debug.log('send : '+text);
    sipstack.sendData("chat:" + text);
    addMessage(text, 'outgoing');
  };

  self.init = function() {
    self.messages = {};
  };

  self.listeners = function() {
    eventbus.on('dataReceived', function(e) {
      var data = e.data && e.data.data;
      var regex = /^chat:/;
      if (data.match(regex)) {
        data = data.replace(regex, '');
        debug.log('received : '+data);
        addMessage(data, 'incoming');
      }
    });
  };

  return self;
}
},{"../../js/config.js":216,"./message":220,"webrtc-core":226}],220:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Message);

function Message(text, direction) {
	var self = {};

	self.props = ['body', 'time', 'id', 'direction', 'classes'];

	self.bindings = {
		classes: {
			self: 'direction'
		}
	};
	
	self.init = function(){
		self.body = text;
		self.time = new Date();
		self.id = new Date().getTime();
		self.direction = direction;
	};

	return self;
}

},{"webrtc-core":226}],221:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ChatView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var MessageView = require('./message');

function ChatView(chat) {
  var self = {};

  self.model = chat;

  self.updateMessagesContent = function(messages){
    self.updateContentView(self.messagesContent, messages, function(message){
      return MessageView.create([message]);
    });
  };

  self.elements = ['messagesContent', 'input'];

  self.bindings = {
    messagesContent: {
      chat: 'messages'
    }
  }

  self.listeners = function(){
  	self.input.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        chat.send(self.input.val());
        self.input.val('');
      }
    });

  }

  return self;
}
},{"../../js/styles":217,"../../js/templates":218,"./message":222,"webrtc-core":226}],222:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MessageView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function MessageView(message) {
  var self = {};

  self.elements = ['body'];

  return self;

}
},{"../../js/styles":217,"../../js/templates":218,"webrtc-core":226}],223:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],224:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],225:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],226:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":225,"./bdsft":227,"./constants":230,"./cookieconfig":231,"./cookieprop":232,"./dateformat":235,"./debug":236,"./element":237,"./eventbus":238,"./factory":239,"./icon":240,"./loader":241,"./popup":242,"./prop":243,"./urlconfig":245,"./utils":246,"./visibleprop":247,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],227:[function(require,module,exports){
module.exports=require(54)
},{"./app":226,"./binding":228,"./classesbinding":229,"./databinder":234,"./stylesmanager":244,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":271}],228:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":227,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],229:[function(require,module,exports){
module.exports=require(56)
},{"./binding":228,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],230:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],231:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":227,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":271,"jquery.cookie":270}],232:[function(require,module,exports){
module.exports=require(59)
},{"./constants":230,"./prop":243,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":271,"jquery.cookie":270}],233:[function(require,module,exports){
module.exports=require(60)
},{"./constants":230,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":252}],234:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":255}],235:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],236:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":223,"./bdsft":227,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":248,"stacktrace-js":273}],237:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],238:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":227,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":255}],239:[function(require,module,exports){
module.exports=require(66)
},{"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":271}],240:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],241:[function(require,module,exports){
module.exports=require(68)
},{"../":226,"./constants":230,"./factory":239,"./stylesmanager":244,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":251}],242:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":271}],243:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":272}],244:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":224,"./constants":230,"./css":233,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],245:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":223,"./bdsft":227,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],246:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":225,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":271}],247:[function(require,module,exports){
module.exports=require(74)
},{"./constants":230,"./prop":243,"./utils":246,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],248:[function(require,module,exports){
module.exports=require(75)
},{"./debug":249,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],249:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":250}],250:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],251:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],252:[function(require,module,exports){
module.exports=require(79)
},{"./filters":253,"./utils":254,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],253:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],254:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],255:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":256,"es5-ext/object/valid-callable":265}],256:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":257,"es5-ext/object/is-callable":260,"es5-ext/object/normalize-options":264,"es5-ext/string/#/contains":267}],257:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":258,"./shim":259,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],258:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],259:[function(require,module,exports){
module.exports=require(86)
},{"../keys":261,"../valid-value":266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],260:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],261:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":262,"./shim":263,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],262:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],263:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],264:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],265:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],266:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],267:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":268,"./shim":269,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],268:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],269:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],270:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":271}],271:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],272:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],273:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],274:[function(require,module,exports){
module.exports = {view: require('./lib/views/connectionstatus'), model: require('./lib/models/connectionstatus')};
},{"./lib/models/connectionstatus":278,"./lib/views/connectionstatus":279}],275:[function(require,module,exports){
module.exports = {
    enableRegistrationStatus: true,
    enableConnectionStatus: true
};
},{}],276:[function(require,module,exports){
module.exports = {"connectionstatus":".bdsft-webrtc .connection-status{position:absolute;top:13px;right:0}.bdsft-webrtc .connection-status .icon{display:inline-block!important}.bdsft-webrtc .connection-status .icon.success{color:#008000}.bdsft-webrtc .connection-status .icon.alert{color:#f00}"}
},{}],277:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // connectionstatus.jade compiled template
    templatizer["connectionstatus"] = function tmpl_connectionstatus() {
        return '<div class="bdsft-webrtc"><div class="connection-status"><div class="icon connectedIcon fadeable"><span title="Websockets Status" class="icon-link exario"></span></div><div class="icon registeredIcon fadeable"><span title="Registered" class="icon-link exario"></span></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],278:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(ConnectionStatus, {
  config: require('../../js/config.js')
})

var Utils = require('webrtc-core').utils;

function ConnectionStatus(options, urlconfig, sipstack) {
  var self = {};

  self.props = ['connected', 'registered'];

  self.bindings = {
    enableRegistrationStatus: {
      urlconfig: 'enableRegistrationStatus'
    },
    enableConnectionStatus: {
      urlconfig: 'enableConnectionStatus'
    }
  };

  self.listeners = function(sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange('connected', function(value){
      if (self.enableConnectionStatus) {
        self.connected = value;
      }
    });
    sipstackDatabinder.onModelPropChange('registered', function(value){
      if (self.enableRegistrationStatus) {
        self.registered = value;
      }
    });
  };

  return self;
}
},{"../../js/config.js":275,"webrtc-core":283}],279:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ConnectionStatusView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function ConnectionStatusView(connectionstatus) {
  var self = {};

  self.model = connectionstatus;
  
  self.elements = ['connectedIcon', 'registeredIcon'];

  var isEnabled = function(icon){
    return icon.hasClass('success');
  };

  var enableIcon = function(icon, enable){
    if(enable) {
      show(icon, 'success', 3000);
    } else {
      show(icon, 'alert');
    }
  };

  self.connected = function(value){
    if(arguments.length === 1) {
      enableIcon(self.connectedIcon, value);
    } else {
      return isEnabled(self.connectedIcon);
    }
  };
  self.registered = function(value){
    if(arguments.length === 1) {
      enableIcon(self.registeredIcon, value);
    } else {
      return isEnabled(self.registeredIcon);
    }
  };

  var levels = ['success', 'alert'];
  var show = function(element, level, hideDelay){
    levels.forEach(function(l){
      element.toggleClass(l, l === level);
    });
    element.toggleClass('fadeOut', false);
    element.toggleClass('fadeIn', true);
    if(hideDelay) {
      window.setTimeout(function(){
        hide(element);
      }, hideDelay);
    }
  };

  var hide = function(element){
    element.toggleClass('fadeIn', false);
    element.toggleClass('fadeOut', true);
  };

  return self;
}
},{"../../js/styles":276,"../../js/templates":277,"webrtc-core":283}],280:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],281:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],282:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],283:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":282,"./bdsft":284,"./constants":287,"./cookieconfig":288,"./cookieprop":289,"./dateformat":292,"./debug":293,"./element":294,"./eventbus":295,"./factory":296,"./icon":297,"./loader":298,"./popup":299,"./prop":300,"./urlconfig":302,"./utils":303,"./visibleprop":304,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],284:[function(require,module,exports){
module.exports=require(54)
},{"./app":283,"./binding":285,"./classesbinding":286,"./databinder":291,"./stylesmanager":301,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":328}],285:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":284,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],286:[function(require,module,exports){
module.exports=require(56)
},{"./binding":285,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],287:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],288:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":284,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":328,"jquery.cookie":327}],289:[function(require,module,exports){
module.exports=require(59)
},{"./constants":287,"./prop":300,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":328,"jquery.cookie":327}],290:[function(require,module,exports){
module.exports=require(60)
},{"./constants":287,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":309}],291:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":312}],292:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],293:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":280,"./bdsft":284,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":305,"stacktrace-js":330}],294:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],295:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":284,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":312}],296:[function(require,module,exports){
module.exports=require(66)
},{"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":328}],297:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],298:[function(require,module,exports){
module.exports=require(68)
},{"../":283,"./constants":287,"./factory":296,"./stylesmanager":301,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":308}],299:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":328}],300:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":329}],301:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":281,"./constants":287,"./css":290,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],302:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":280,"./bdsft":284,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],303:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":282,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":328}],304:[function(require,module,exports){
module.exports=require(74)
},{"./constants":287,"./prop":300,"./utils":303,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],305:[function(require,module,exports){
module.exports=require(75)
},{"./debug":306,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],306:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":307}],307:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],308:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],309:[function(require,module,exports){
module.exports=require(79)
},{"./filters":310,"./utils":311,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],310:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],311:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],312:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":313,"es5-ext/object/valid-callable":322}],313:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":314,"es5-ext/object/is-callable":317,"es5-ext/object/normalize-options":321,"es5-ext/string/#/contains":324}],314:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":315,"./shim":316,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],315:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],316:[function(require,module,exports){
module.exports=require(86)
},{"../keys":318,"../valid-value":323,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],317:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],318:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":319,"./shim":320,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],319:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],320:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],321:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],322:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],323:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],324:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":325,"./shim":326,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],325:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],326:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],327:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":328}],328:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],329:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],330:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],331:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],332:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],333:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],334:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":333,"./bdsft":335,"./constants":338,"./cookieconfig":339,"./cookieprop":340,"./dateformat":343,"./debug":344,"./element":345,"./eventbus":346,"./factory":347,"./icon":348,"./loader":349,"./popup":350,"./prop":351,"./urlconfig":353,"./utils":354,"./visibleprop":355,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],335:[function(require,module,exports){
module.exports=require(54)
},{"./app":334,"./binding":336,"./classesbinding":337,"./databinder":342,"./stylesmanager":352,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":379}],336:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":335,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],337:[function(require,module,exports){
module.exports=require(56)
},{"./binding":336,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],338:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],339:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":335,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":379,"jquery.cookie":378}],340:[function(require,module,exports){
module.exports=require(59)
},{"./constants":338,"./prop":351,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":379,"jquery.cookie":378}],341:[function(require,module,exports){
module.exports=require(60)
},{"./constants":338,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":360}],342:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":363}],343:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],344:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":331,"./bdsft":335,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":356,"stacktrace-js":381}],345:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],346:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":335,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":363}],347:[function(require,module,exports){
module.exports=require(66)
},{"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":379}],348:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],349:[function(require,module,exports){
module.exports=require(68)
},{"../":334,"./constants":338,"./factory":347,"./stylesmanager":352,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":359}],350:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":379}],351:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":380}],352:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":332,"./constants":338,"./css":341,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],353:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":331,"./bdsft":335,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],354:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":333,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":379}],355:[function(require,module,exports){
module.exports=require(74)
},{"./constants":338,"./prop":351,"./utils":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],356:[function(require,module,exports){
module.exports=require(75)
},{"./debug":357,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],357:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":358}],358:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],359:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],360:[function(require,module,exports){
module.exports=require(79)
},{"./filters":361,"./utils":362,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],361:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],362:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],363:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":364,"es5-ext/object/valid-callable":373}],364:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":365,"es5-ext/object/is-callable":368,"es5-ext/object/normalize-options":372,"es5-ext/string/#/contains":375}],365:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":366,"./shim":367,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],366:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],367:[function(require,module,exports){
module.exports=require(86)
},{"../keys":369,"../valid-value":374,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],368:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],369:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":370,"./shim":371,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],370:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],371:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],372:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],373:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],374:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],375:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":376,"./shim":377,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],376:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],377:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],378:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":379}],379:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],380:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],381:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],382:[function(require,module,exports){
module.exports = {view: require('./lib/views/dialpad')};
},{"./lib/views/dialpad":385}],383:[function(require,module,exports){
module.exports = {"dialpad":".bdsft-webrtc .dialpad button{text-align:center;opacity:.8;font-family:arial;font-size:20px;line-height:33px;cursor:pointer;color:#b3b3b3;background:0;font-weight:normal;padding:0;margin:0;border:0;width:50px}.bdsft-webrtc .dialpad button:active{color:#04aff0;background:-webkit-gradient(linear,left top,left bottom,from(#f47a20),to(#faa51a));background:linear-gradient(to left bottom,#f47a20,#faa51a)}.bdsft-webrtc .dialpad button:hover{box-shadow:1px 1px 20px #999;background:#3a3a3a;box-shadow:none}.bdsft-webrtc .dialpad button:focus{outline:0}.bdsft-webrtc .dialpad button span{display:block;font-size:8px;text-align:center;font-weight:bold;margin-top:-13px;color:#2d7b99}.bdsft-webrtc .dialpad .button-row{text-align:center}.bdsft-webrtc .dialpad .btn-star{font-size:30px;vertical-align:middle}"}
},{}],384:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // dialpad.jade compiled template
    templatizer["dialpad"] = function tmpl_dialpad() {
        return '<div class="bdsft-webrtc"><div class="dialpad"><div class="button-row"><button class="keys">1</button><button class="keys">2</button><button class="keys">3</button></div><div class="button-row"><button class="keys">4</button><button class="keys">5</button><button class="keys">6</button></div><div class="button-row"><button class="keys">7</button><button class="keys">8</button><button class="keys">9</button></div><div class="button-row"><button class="keys btn-star">*</button><button class="keys">0</button><button class="keys">#</button></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],385:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(DialpadView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

function DialpadView(eventbus, sound) {
  var self = {};

  self.elements = ['keys'];

  self.listeners = function() {
    self.keys.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      eventbus.digit(this.firstChild.nodeValue);
    });
  };

  return self;
}
},{"../../js/styles":383,"../../js/templates":384,"webrtc-core":389}],386:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],387:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],388:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],389:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":388,"./bdsft":390,"./constants":393,"./cookieconfig":394,"./cookieprop":395,"./dateformat":398,"./debug":399,"./element":400,"./eventbus":401,"./factory":402,"./icon":403,"./loader":404,"./popup":405,"./prop":406,"./urlconfig":408,"./utils":409,"./visibleprop":410,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],390:[function(require,module,exports){
module.exports=require(54)
},{"./app":389,"./binding":391,"./classesbinding":392,"./databinder":397,"./stylesmanager":407,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":434}],391:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":390,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],392:[function(require,module,exports){
module.exports=require(56)
},{"./binding":391,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],393:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],394:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":390,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":434,"jquery.cookie":433}],395:[function(require,module,exports){
module.exports=require(59)
},{"./constants":393,"./prop":406,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":434,"jquery.cookie":433}],396:[function(require,module,exports){
module.exports=require(60)
},{"./constants":393,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":415}],397:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":418}],398:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],399:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":386,"./bdsft":390,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":411,"stacktrace-js":436}],400:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],401:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":390,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":418}],402:[function(require,module,exports){
module.exports=require(66)
},{"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":434}],403:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],404:[function(require,module,exports){
module.exports=require(68)
},{"../":389,"./constants":393,"./factory":402,"./stylesmanager":407,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":414}],405:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":434}],406:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":435}],407:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":387,"./constants":393,"./css":396,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],408:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":386,"./bdsft":390,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],409:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":388,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":434}],410:[function(require,module,exports){
module.exports=require(74)
},{"./constants":393,"./prop":406,"./utils":409,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],411:[function(require,module,exports){
module.exports=require(75)
},{"./debug":412,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],412:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":413}],413:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],414:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],415:[function(require,module,exports){
module.exports=require(79)
},{"./filters":416,"./utils":417,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],416:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],417:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],418:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":419,"es5-ext/object/valid-callable":428}],419:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":420,"es5-ext/object/is-callable":423,"es5-ext/object/normalize-options":427,"es5-ext/string/#/contains":430}],420:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":421,"./shim":422,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],421:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],422:[function(require,module,exports){
module.exports=require(86)
},{"../keys":424,"../valid-value":429,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],423:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],424:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":425,"./shim":426,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],425:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],426:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],427:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],428:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],429:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],430:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":431,"./shim":432,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],431:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],432:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],433:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":434}],434:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],435:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],436:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],437:[function(require,module,exports){
module.exports = {model: require('./lib/models/dms')};
},{"./lib/models/dms":439}],438:[function(require,module,exports){
module.exports = {
	enabled: true,
    xspHosts: ['xsp1.broadsoftlabs.com', 'xsp2.broadsoftlabs.com'],
    port: 443,
    domain: 'broadsoftlabs.com',
    deviceType: 'Business Communicator - PC'
}

},{}],439:[function(require,module,exports){
(function (Buffer){
module.exports = require('webrtc-core').bdsft.Model(DMS, {
  config: require('../../js/config')
});

var Utils = require('webrtc-core').utils;
var http = require('http');
var https = require('https');
var jQuery = require('jquery');
var Q = require('q');
var parseString = require('xml2js').parseString;
var Hashes = require('jshashes');

function DMS(urlconfig, debug) {
  var self = {};

  var currentHost;

  var parseDigest = function(header) {  
    return header.substring(7).split(/,\s+/).reduce(function(obj, s) {
      var parts = s.split('=')
      obj[parts[0]] = parts[1].replace(/"/g, '')
      return obj
    }, {})  
  };

  var renderDigest = function(params) {
    var s = Object.keys(params).reduce(function(s1, ii) {
      return s1 + ', ' + ii + '="' + params[ii] + '"'
    }, '');
    return 'Digest ' + s.substring(2);
  };

  var getNextHost = function() {
    var index = self.xspHosts.indexOf(currentHost);
    var nextIndex = index === -1 ? 0 : index + 1;
    if (nextIndex >= self.xspHosts.length) {
      nextIndex = 0;
    }
    return self.xspHosts[nextIndex];
  };

  var requestOpts = function(options){
    options = options || {};
    currentHost = currentHost || getNextHost();
    var result = {
      host: currentHost,
      port: self.port,
      path: options.path || '/',
      method: options.type || 'GET',
    };
    if(options.user && options.password) {
      result.username = options.user;
      result.password = options.password;
      result.headers = {
           'Authorization': 'Basic ' + new Buffer(options.user + ':' + options.password).toString('base64'),
           'content-type': 'text/plain'
      };
    }
    return result;
  };

  var digestRequest = function(username, password, options){
    var deferred = Q.defer();
    var url = 'https://'+username+':'+password+'@'+options.host+':'+options.port+options.path
    debug.info('requesting... : ' + url);
    var onDone = function(xml){
      debug.info('response : ' + xml);
      parseString(xml, {explicitArray: false}, function (err, resultJson) {
        debug.log('response json : ' + JSON.stringify(resultJson));
        deferred.resolve(resultJson);
      });
    };
    jQuery.ajax({
        type: 'GET',
        url: url,
        cache: false,
        dataType: 'text',
        error: function(xhr, status, error){
          debug.log('digest response : '+xhr.getResponseHeader('www-authenticate'));
          var challengeParams = parseDigest(xhr.getResponseHeader('www-authenticate'));
          var md5 = new Hashes.MD5();
          var ha1 = md5.hex(username + ':' + challengeParams.realm + ':' + password);
          var ha2 = md5.hex('GET:' + options.path);
          var response = md5.hex(ha1 + ':' + challengeParams.nonce + ':1::auth:' + ha2);
          var authRequestParams = {
            username : username,
            realm : challengeParams.realm,
            nonce : challengeParams.nonce,
            uri : options.path, 
            qop : challengeParams.qop,
            response : response,
            nc : '1',
            cnonce : ''
          };
          debug.log('digest request : '+JSON.stringify(options));
          jQuery.ajax({
            type: 'GET',
            url: url,
            cache: false,
            dataType: 'text',
            beforeSend: function (xhr) {
              xhr.setRequestHeader('Authorization', renderDigest(authRequestParams));
            }
          }).done(onDone)
          .fail(function(err){
            console.error('error : ' + JSON.stringify(err));
            currentHost = getNextHost();
            deferred.reject(err);
          });
        }
    }).done(onDone);

  //   https.get(options, function(res) {
  //       // res.setEncoding('utf-8');
  //       var result = ""
  //       res.on('data', function(chunk) {
  //           result += chunk;
  //       });
  //       res.on('end', function() {
  //         debug.log('digest response : '+res.headers['www-authenticate']);
  //         var challengeParams = parseDigest(res.headers['www-authenticate'])
  //         var md5 = new Hashes.MD5();
  //         var ha1 = md5.hex(username + ':' + challengeParams.realm + ':' + password);
  //         var ha2 = md5.hex('GET:' + options.path);
  //         var response = md5.hex(ha1 + ':' + challengeParams.nonce + ':1::auth:' + ha2);
  //         var authRequestParams = {
  //           username : username,
  //           realm : challengeParams.realm,
  //           nonce : challengeParams.nonce,
  //           uri : options.path, 
  //           qop : challengeParams.qop,
  //           response : response,
  //           nc : '1',
  //           cnonce : ''
  //         };
  //         options.headers = { 'Authorization' : renderDigest(authRequestParams) };
  //         debug.log('digest request : '+JSON.stringify(options));
  //         https.get(options, function(res) {
  //           res.setEncoding('utf-8')
  //           var result = ''
  //           res.on('data', function(chunk) {
  //             result += chunk
  //           }).on('end', function() {
  //             debug.info('response : ' + result);
  //             parseString(result, {explicitArray: false}, function (err, resultJson) {
  //               debug.log('response json : ' + JSON.stringify(resultJson));
  //               deferred.resolve(resultJson);
  //             });
  //           });
  //         });
  //     });
  // }).on('error', function(e){
  //   console.error('error : ' + e.message);
  //   currentHost = getNextHost();
  //   deferred.reject(e.message);
  // });
  return deferred.promise;
};

  var ensureDomain = function(value){
    return value.match(/.*@.*/) || (value + '@' + self.domain);
  };
  var request = function(opts){
    var url = 'https://'+opts.host+':'+opts.port+opts.path
    debug.info('requesting... : ' + url);
    jQuery.support.cors = true;
    var deferred = Q.defer();
    jQuery.ajax({
      type: 'GET',
      url: url,
      dataType: 'text',
      cache: false,
      beforeSend: function (xhr) {
        xhr.setRequestHeader("Authorization", "Basic "+new Buffer(opts.username + ':' + opts.password).toString('base64'));
      }
    }).done(function(result){
      parseString(result, {explicitArray: false}, function (err, resultJson) {
        debug.log('response json : ' + JSON.stringify(resultJson));
        deferred.resolve(resultJson);
      });
    }).fail(function(err){
      console.error("error : " + JSON.stringify(err));
      currentHost = getNextHost();
      deferred.reject(err);
    });
    // https.get(opts, function(res) {
    //   var result = ''
    //   res.on('data', function(chunk) {
    //     result += chunk
    //   }).on('end', function() {
    //     debug.info('response : ' + result);
    //     parseString(result, {explicitArray: false}, function (err, resultJson) {
    //       debug.log('response json : ' + JSON.stringify(resultJson));
    //       deferred.resolve(resultJson);
    //     });
    //   });
    // }).on('error', function(err){
    //     console.error("error : " + JSON.stringify(err));
    //     currentHost = getNextHost();
    //     deferred.reject(err);
    // });
    return deferred.promise;
  };

  var requestDevices = function(xsiUser, xsiPassword){
    var opts = requestOpts({user: ensureDomain(xsiUser), password: xsiPassword, path: '/com.broadsoft.xsi-actions/v2.0/user/'+xsiUser+'/profile/device'});
    return request(opts).then(function(res){
      return res.AccessDevices.accessDevice;
    });
  };

  self.requestConfig = function(xsiUser, xsiPassword){
    if(!self.enabled) {
      return Q.reject('DMS disabled');
    }
    return requestDevices(xsiUser, xsiPassword).then(function(devices){
      var btbcDevice = devices.filter(function(device){
        return device.deviceType === self.deviceType;
      });
      if(!btbcDevice || !btbcDevice.length) {
        throw Error('no '+self.deviceType+' deviceType found in : '+JSON.stringify(btbcDevice));
      }

      var deviceUsername = btbcDevice[0].deviceUserNamePassword.userName;
      var devicePassword = btbcDevice[0].deviceUserNamePassword.password;
      debug.debug('using deviceUsername '+deviceUsername+', devicePassword '+devicePassword);

      var opts = requestOpts({path: '/dms/bc/pc/config.xml'});
      return digestRequest(deviceUsername, devicePassword, opts).then(function(res){
        return res.config;
      });
    });
  }

  return self;
}
}).call(this,require("buffer").Buffer)
},{"../../js/config":438,"buffer":9,"http":14,"https":18,"jquery":440,"jshashes":441,"q":442,"webrtc-core":446,"xml2js":496}],440:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-04-28T16:01Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.4",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],441:[function(require,module,exports){
(function (global){
/**
 * jshashes - https://github.com/h2non/jshashes
 * Released under the "New BSD" license
 *
 * Algorithms specification:
 *
 * MD5 - http://www.ietf.org/rfc/rfc1321.txt
 * RIPEMD-160 - http://homes.esat.kuleuven.be/~bosselae/ripemd160.html
 * SHA1   - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 * SHA256 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 * SHA512 - http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf
 * HMAC - http://www.ietf.org/rfc/rfc2104.txt
 */
(function() {
  var Hashes;

  function utf8Encode(str) {
    var x, y, output = '',
      i = -1,
      l;

    if (str && str.length) {
      l = str.length;
      while ((i += 1) < l) {
        /* Decode utf-16 surrogate pairs */
        x = str.charCodeAt(i);
        y = i + 1 < l ? str.charCodeAt(i + 1) : 0;
        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
          x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
          i += 1;
        }
        /* Encode output as utf-8 */
        if (x <= 0x7F) {
          output += String.fromCharCode(x);
        } else if (x <= 0x7FF) {
          output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F),
            0x80 | (x & 0x3F));
        } else if (x <= 0xFFFF) {
          output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),
            0x80 | ((x >>> 6) & 0x3F),
            0x80 | (x & 0x3F));
        } else if (x <= 0x1FFFFF) {
          output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),
            0x80 | ((x >>> 12) & 0x3F),
            0x80 | ((x >>> 6) & 0x3F),
            0x80 | (x & 0x3F));
        }
      }
    }
    return output;
  }

  function utf8Decode(str) {
    var i, ac, c1, c2, c3, arr = [],
      l;
    i = ac = c1 = c2 = c3 = 0;

    if (str && str.length) {
      l = str.length;
      str += '';

      while (i < l) {
        c1 = str.charCodeAt(i);
        ac += 1;
        if (c1 < 128) {
          arr[ac] = String.fromCharCode(c1);
          i += 1;
        } else if (c1 > 191 && c1 < 224) {
          c2 = str.charCodeAt(i + 1);
          arr[ac] = String.fromCharCode(((c1 & 31) << 6) | (c2 & 63));
          i += 2;
        } else {
          c2 = str.charCodeAt(i + 1);
          c3 = str.charCodeAt(i + 2);
          arr[ac] = String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
          i += 3;
        }
      }
    }
    return arr.join('');
  }

  /**
   * Add integers, wrapping at 2^32. This uses 16-bit operations internally
   * to work around bugs in some JS interpreters.
   */

  function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF),
      msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return (msw << 16) | (lsw & 0xFFFF);
  }

  /**
   * Bitwise rotate a 32-bit number to the left.
   */

  function bit_rol(num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt));
  }

  /**
   * Convert a raw string to a hex string
   */

  function rstr2hex(input, hexcase) {
    var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef',
      output = '',
      x, i = 0,
      l = input.length;
    for (; i < l; i += 1) {
      x = input.charCodeAt(i);
      output += hex_tab.charAt((x >>> 4) & 0x0F) + hex_tab.charAt(x & 0x0F);
    }
    return output;
  }

  /**
   * Encode a string as utf-16
   */

  function str2rstr_utf16le(input) {
    var i, l = input.length,
      output = '';
    for (i = 0; i < l; i += 1) {
      output += String.fromCharCode(input.charCodeAt(i) & 0xFF, (input.charCodeAt(i) >>> 8) & 0xFF);
    }
    return output;
  }

  function str2rstr_utf16be(input) {
    var i, l = input.length,
      output = '';
    for (i = 0; i < l; i += 1) {
      output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF, input.charCodeAt(i) & 0xFF);
    }
    return output;
  }

  /**
   * Convert an array of big-endian words to a string
   */

  function binb2rstr(input) {
    var i, l = input.length * 32,
      output = '';
    for (i = 0; i < l; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> (24 - i % 32)) & 0xFF);
    }
    return output;
  }

  /**
   * Convert an array of little-endian words to a string
   */

  function binl2rstr(input) {
    var i, l = input.length * 32,
      output = '';
    for (i = 0; i < l; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
    }
    return output;
  }

  /**
   * Convert a raw string to an array of little-endian words
   * Characters >255 have their high-byte silently ignored.
   */

  function rstr2binl(input) {
    var i, l = input.length * 8,
      output = Array(input.length >> 2),
      lo = output.length;
    for (i = 0; i < lo; i += 1) {
      output[i] = 0;
    }
    for (i = 0; i < l; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
    }
    return output;
  }

  /**
   * Convert a raw string to an array of big-endian words
   * Characters >255 have their high-byte silently ignored.
   */

  function rstr2binb(input) {
    var i, l = input.length * 8,
      output = Array(input.length >> 2),
      lo = output.length;
    for (i = 0; i < lo; i += 1) {
      output[i] = 0;
    }
    for (i = 0; i < l; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);
    }
    return output;
  }

  /**
   * Convert a raw string to an arbitrary string encoding
   */

  function rstr2any(input, encoding) {
    var divisor = encoding.length,
      remainders = Array(),
      i, q, x, ld, quotient, dividend, output, full_length;

    /* Convert to an array of 16-bit big-endian values, forming the dividend */
    dividend = Array(Math.ceil(input.length / 2));
    ld = dividend.length;
    for (i = 0; i < ld; i += 1) {
      dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);
    }

    /**
     * Repeatedly perform a long division. The binary array forms the dividend,
     * the length of the encoding is the divisor. Once computed, the quotient
     * forms the dividend for the next step. We stop when the dividend is zerHashes.
     * All remainders are stored for later use.
     */
    while (dividend.length > 0) {
      quotient = Array();
      x = 0;
      for (i = 0; i < dividend.length; i += 1) {
        x = (x << 16) + dividend[i];
        q = Math.floor(x / divisor);
        x -= q * divisor;
        if (quotient.length > 0 || q > 0) {
          quotient[quotient.length] = q;
        }
      }
      remainders[remainders.length] = x;
      dividend = quotient;
    }

    /* Convert the remainders to the output string */
    output = '';
    for (i = remainders.length - 1; i >= 0; i--) {
      output += encoding.charAt(remainders[i]);
    }

    /* Append leading zero equivalents */
    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
    for (i = output.length; i < full_length; i += 1) {
      output = encoding[0] + output;
    }
    return output;
  }

  /**
   * Convert a raw string to a base-64 string
   */

  function rstr2b64(input, b64pad) {
    var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
      output = '',
      len = input.length,
      i, j, triplet;
    b64pad = b64pad || '=';
    for (i = 0; i < len; i += 3) {
      triplet = (input.charCodeAt(i) << 16) | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
      for (j = 0; j < 4; j += 1) {
        if (i * 8 + j * 6 > input.length * 8) {
          output += b64pad;
        } else {
          output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
        }
      }
    }
    return output;
  }

  Hashes = {
    /**
     * @property {String} version
     * @readonly
     */
    VERSION: '1.0.5',
    /**
     * @member Hashes
     * @class Base64
     * @constructor
     */
    Base64: function() {
      // private properties
      var tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
        pad = '=', // default pad according with the RFC standard
        url = false, // URL encoding support @todo
        utf8 = true; // by default enable UTF-8 support encoding

      // public method for encoding
      this.encode = function(input) {
        var i, j, triplet,
          output = '',
          len = input.length;

        pad = pad || '=';
        input = (utf8) ? utf8Encode(input) : input;

        for (i = 0; i < len; i += 3) {
          triplet = (input.charCodeAt(i) << 16) | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
          for (j = 0; j < 4; j += 1) {
            if (i * 8 + j * 6 > len * 8) {
              output += pad;
            } else {
              output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);
            }
          }
        }
        return output;
      };

      // public method for decoding
      this.decode = function(input) {
        // var b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
        var i, o1, o2, o3, h1, h2, h3, h4, bits, ac,
          dec = '',
          arr = [];
        if (!input) {
          return input;
        }

        i = ac = 0;
        input = input.replace(new RegExp('\\' + pad, 'gi'), ''); // use '='
        //input += '';

        do { // unpack four hexets into three octets using index points in b64
          h1 = tab.indexOf(input.charAt(i += 1));
          h2 = tab.indexOf(input.charAt(i += 1));
          h3 = tab.indexOf(input.charAt(i += 1));
          h4 = tab.indexOf(input.charAt(i += 1));

          bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;

          o1 = bits >> 16 & 0xff;
          o2 = bits >> 8 & 0xff;
          o3 = bits & 0xff;
          ac += 1;

          if (h3 === 64) {
            arr[ac] = String.fromCharCode(o1);
          } else if (h4 === 64) {
            arr[ac] = String.fromCharCode(o1, o2);
          } else {
            arr[ac] = String.fromCharCode(o1, o2, o3);
          }
        } while (i < input.length);

        dec = arr.join('');
        dec = (utf8) ? utf8Decode(dec) : dec;

        return dec;
      };

      // set custom pad string
      this.setPad = function(str) {
        pad = str || pad;
        return this;
      };
      // set custom tab string characters
      this.setTab = function(str) {
        tab = str || tab;
        return this;
      };
      this.setUTF8 = function(bool) {
        if (typeof bool === 'boolean') {
          utf8 = bool;
        }
        return this;
      };
    },

    /**
     * CRC-32 calculation
     * @member Hashes
     * @method CRC32
     * @static
     * @param {String} str Input String
     * @return {String}
     */
    CRC32: function(str) {
      var crc = 0,
        x = 0,
        y = 0,
        table, i, iTop;
      str = utf8Encode(str);

      table = [
        '00000000 77073096 EE0E612C 990951BA 076DC419 706AF48F E963A535 9E6495A3 0EDB8832 ',
        '79DCB8A4 E0D5E91E 97D2D988 09B64C2B 7EB17CBD E7B82D07 90BF1D91 1DB71064 6AB020F2 F3B97148 ',
        '84BE41DE 1ADAD47D 6DDDE4EB F4D4B551 83D385C7 136C9856 646BA8C0 FD62F97A 8A65C9EC 14015C4F ',
        '63066CD9 FA0F3D63 8D080DF5 3B6E20C8 4C69105E D56041E4 A2677172 3C03E4D1 4B04D447 D20D85FD ',
        'A50AB56B 35B5A8FA 42B2986C DBBBC9D6 ACBCF940 32D86CE3 45DF5C75 DCD60DCF ABD13D59 26D930AC ',
        '51DE003A C8D75180 BFD06116 21B4F4B5 56B3C423 CFBA9599 B8BDA50F 2802B89E 5F058808 C60CD9B2 ',
        'B10BE924 2F6F7C87 58684C11 C1611DAB B6662D3D 76DC4190 01DB7106 98D220BC EFD5102A 71B18589 ',
        '06B6B51F 9FBFE4A5 E8B8D433 7807C9A2 0F00F934 9609A88E E10E9818 7F6A0DBB 086D3D2D 91646C97 ',
        'E6635C01 6B6B51F4 1C6C6162 856530D8 F262004E 6C0695ED 1B01A57B 8208F4C1 F50FC457 65B0D9C6 ',
        '12B7E950 8BBEB8EA FCB9887C 62DD1DDF 15DA2D49 8CD37CF3 FBD44C65 4DB26158 3AB551CE A3BC0074 ',
        'D4BB30E2 4ADFA541 3DD895D7 A4D1C46D D3D6F4FB 4369E96A 346ED9FC AD678846 DA60B8D0 44042D73 ',
        '33031DE5 AA0A4C5F DD0D7CC9 5005713C 270241AA BE0B1010 C90C2086 5768B525 206F85B3 B966D409 ',
        'CE61E49F 5EDEF90E 29D9C998 B0D09822 C7D7A8B4 59B33D17 2EB40D81 B7BD5C3B C0BA6CAD EDB88320 ',
        '9ABFB3B6 03B6E20C 74B1D29A EAD54739 9DD277AF 04DB2615 73DC1683 E3630B12 94643B84 0D6D6A3E ',
        '7A6A5AA8 E40ECF0B 9309FF9D 0A00AE27 7D079EB1 F00F9344 8708A3D2 1E01F268 6906C2FE F762575D ',
        '806567CB 196C3671 6E6B06E7 FED41B76 89D32BE0 10DA7A5A 67DD4ACC F9B9DF6F 8EBEEFF9 17B7BE43 ',
        '60B08ED5 D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252 D1BB67F1 A6BC5767 3FB506DD 48B2364B D80D2BDA ',
        'AF0A1B4C 36034AF6 41047A60 DF60EFC3 A867DF55 316E8EEF 4669BE79 CB61B38C BC66831A 256FD2A0 ',
        '5268E236 CC0C7795 BB0B4703 220216B9 5505262F C5BA3BBE B2BD0B28 2BB45A92 5CB36A04 C2D7FFA7 ',
        'B5D0CF31 2CD99E8B 5BDEAE1D 9B64C2B0 EC63F226 756AA39C 026D930A 9C0906A9 EB0E363F 72076785 ',
        '05005713 95BF4A82 E2B87A14 7BB12BAE 0CB61B38 92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21 86D3D2D4 ',
        'F1D4E242 68DDB3F8 1FDA836E 81BE16CD F6B9265B 6FB077E1 18B74777 88085AE6 FF0F6A70 66063BCA ',
        '11010B5C 8F659EFF F862AE69 616BFFD3 166CCF45 A00AE278 D70DD2EE 4E048354 3903B3C2 A7672661 ',
        'D06016F7 4969474D 3E6E77DB AED16A4A D9D65ADC 40DF0B66 37D83BF0 A9BCAE53 DEBB9EC5 47B2CF7F ',
        '30B5FFE9 BDBDF21C CABAC28A 53B39330 24B4A3A6 BAD03605 CDD70693 54DE5729 23D967BF B3667A2E ',
        'C4614AB8 5D681B02 2A6F2B94 B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D'
      ].join('');

      crc = crc ^ (-1);
      for (i = 0, iTop = str.length; i < iTop; i += 1) {
        y = (crc ^ str.charCodeAt(i)) & 0xFF;
        x = '0x' + table.substr(y * 9, 8);
        crc = (crc >>> 8) ^ x;
      }
      // always return a positive number (that's what >>> 0 does)
      return (crc ^ (-1)) >>> 0;
    },
    /**
     * @member Hashes
     * @class MD5
     * @constructor
     * @param {Object} [config]
     *
     * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
     * Digest Algorithm, as defined in RFC 1321.
     * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * See <http://pajhome.org.uk/crypt/md5> for more infHashes.
     */
    MD5: function(options) {
      /**
       * Private config properties. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}
       */
      var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase
        b64pad = (options && typeof options.pad === 'string') ? options.pda : '=', // base-64 pad character. Defaults to '=' for strict RFC compliance
        utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true; // enable/disable utf8 encoding

      // privileged (public) methods
      this.hex = function(s) {
        return rstr2hex(rstr(s, utf8), hexcase);
      };
      this.b64 = function(s) {
        return rstr2b64(rstr(s), b64pad);
      };
      this.any = function(s, e) {
        return rstr2any(rstr(s, utf8), e);
      };
      this.raw = function(s) {
        return rstr(s, utf8);
      };
      this.hex_hmac = function(k, d) {
        return rstr2hex(rstr_hmac(k, d), hexcase);
      };
      this.b64_hmac = function(k, d) {
        return rstr2b64(rstr_hmac(k, d), b64pad);
      };
      this.any_hmac = function(k, d, e) {
        return rstr2any(rstr_hmac(k, d), e);
      };
      /**
       * Perform a simple self-test to see if the VM is working
       * @return {String} Hexadecimal hash sample
       */
      this.vm_test = function() {
        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
      };
      /**
       * Enable/disable uppercase hexadecimal returned string
       * @param {Boolean}
       * @return {Object} this
       */
      this.setUpperCase = function(a) {
        if (typeof a === 'boolean') {
          hexcase = a;
        }
        return this;
      };
      /**
       * Defines a base64 pad string
       * @param {String} Pad
       * @return {Object} this
       */
      this.setPad = function(a) {
        b64pad = a || b64pad;
        return this;
      };
      /**
       * Defines a base64 pad string
       * @param {Boolean}
       * @return {Object} [this]
       */
      this.setUTF8 = function(a) {
        if (typeof a === 'boolean') {
          utf8 = a;
        }
        return this;
      };

      // private methods

      /**
       * Calculate the MD5 of a raw string
       */

      function rstr(s) {
        s = (utf8) ? utf8Encode(s) : s;
        return binl2rstr(binl(rstr2binl(s), s.length * 8));
      }

      /**
       * Calculate the HMAC-MD5, of a key and some data (raw strings)
       */

      function rstr_hmac(key, data) {
        var bkey, ipad, opad, hash, i;

        key = (utf8) ? utf8Encode(key) : key;
        data = (utf8) ? utf8Encode(data) : data;
        bkey = rstr2binl(key);
        if (bkey.length > 16) {
          bkey = binl(bkey, key.length * 8);
        }

        ipad = Array(16), opad = Array(16);
        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl(opad.concat(hash), 512 + 128));
      }

      /**
       * Calculate the MD5 of an array of little-endian words, and a bit length.
       */

      function binl(x, len) {
        var i, olda, oldb, oldc, oldd,
          a = 1732584193,
          b = -271733879,
          c = -1732584194,
          d = 271733878;

        /* append padding */
        x[len >> 5] |= 0x80 << ((len) % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        for (i = 0; i < x.length; i += 16) {
          olda = a;
          oldb = b;
          oldc = c;
          oldd = d;

          a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);
          d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
          c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
          b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
          a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
          d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
          c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
          b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
          a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
          d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
          c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
          b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
          a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
          d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
          c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
          b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

          a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
          d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
          c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
          b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);
          a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
          d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
          c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
          b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
          a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
          d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
          c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
          b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
          a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
          d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
          c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
          b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

          a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
          d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
          c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
          b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
          a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
          d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
          c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
          b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
          a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
          d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);
          c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
          b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
          a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
          d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
          c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
          b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

          a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);
          d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
          c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
          b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
          a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
          d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
          c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
          b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
          a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
          d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
          c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
          b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
          a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
          d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
          c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
          b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd);
        }
        return Array(a, b, c, d);
      }

      /**
       * These functions implement the four basic operations the algorithm uses.
       */

      function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
      }

      function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
      }

      function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
      }

      function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
      }

      function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
      }
    },
    /**
     * @member Hashes
     * @class Hashes.SHA1
     * @param {Object} [config]
     * @constructor
     *
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined in FIPS 180-1
     * Version 2.2 Copyright Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * See http://pajhome.org.uk/crypt/md5 for details.
     */
    SHA1: function(options) {
      /**
       * Private config properties. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       * See {@link Hashes.MD5#method-setUpperCase} and {@link Hashes.SHA1#method-setUpperCase}
       */
      var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase
        b64pad = (options && typeof options.pad === 'string') ? options.pda : '=', // base-64 pad character. Defaults to '=' for strict RFC compliance
        utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true; // enable/disable utf8 encoding

      // public methods
      this.hex = function(s) {
        return rstr2hex(rstr(s, utf8), hexcase);
      };
      this.b64 = function(s) {
        return rstr2b64(rstr(s, utf8), b64pad);
      };
      this.any = function(s, e) {
        return rstr2any(rstr(s, utf8), e);
      };
      this.raw = function(s) {
        return rstr(s, utf8);
      };
      this.hex_hmac = function(k, d) {
        return rstr2hex(rstr_hmac(k, d));
      };
      this.b64_hmac = function(k, d) {
        return rstr2b64(rstr_hmac(k, d), b64pad);
      };
      this.any_hmac = function(k, d, e) {
        return rstr2any(rstr_hmac(k, d), e);
      };
      /**
       * Perform a simple self-test to see if the VM is working
       * @return {String} Hexadecimal hash sample
       * @public
       */
      this.vm_test = function() {
        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
      };
      /**
       * @description Enable/disable uppercase hexadecimal returned string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUpperCase = function(a) {
        if (typeof a === 'boolean') {
          hexcase = a;
        }
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {string} Pad
       * @return {Object} this
       * @public
       */
      this.setPad = function(a) {
        b64pad = a || b64pad;
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUTF8 = function(a) {
        if (typeof a === 'boolean') {
          utf8 = a;
        }
        return this;
      };

      // private methods

      /**
       * Calculate the SHA-512 of a raw string
       */

      function rstr(s) {
        s = (utf8) ? utf8Encode(s) : s;
        return binb2rstr(binb(rstr2binb(s), s.length * 8));
      }

      /**
       * Calculate the HMAC-SHA1 of a key and some data (raw strings)
       */

      function rstr_hmac(key, data) {
        var bkey, ipad, opad, i, hash;
        key = (utf8) ? utf8Encode(key) : key;
        data = (utf8) ? utf8Encode(data) : data;
        bkey = rstr2binb(key);

        if (bkey.length > 16) {
          bkey = binb(bkey, key.length * 8);
        }
        ipad = Array(16), opad = Array(16);
        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
        return binb2rstr(binb(opad.concat(hash), 512 + 160));
      }

      /**
       * Calculate the SHA-1 of an array of big-endian words, and a bit length
       */

      function binb(x, len) {
        var i, j, t, olda, oldb, oldc, oldd, olde,
          w = Array(80),
          a = 1732584193,
          b = -271733879,
          c = -1732584194,
          d = 271733878,
          e = -1009589776;

        /* append padding */
        x[len >> 5] |= 0x80 << (24 - len % 32);
        x[((len + 64 >> 9) << 4) + 15] = len;

        for (i = 0; i < x.length; i += 16) {
          olda = a,
          oldb = b;
          oldc = c;
          oldd = d;
          olde = e;

          for (j = 0; j < 80; j += 1) {
            if (j < 16) {
              w[j] = x[i + j];
            } else {
              w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            }
            t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),
              safe_add(safe_add(e, w[j]), sha1_kt(j)));
            e = d;
            d = c;
            c = bit_rol(b, 30);
            b = a;
            a = t;
          }

          a = safe_add(a, olda);
          b = safe_add(b, oldb);
          c = safe_add(c, oldc);
          d = safe_add(d, oldd);
          e = safe_add(e, olde);
        }
        return Array(a, b, c, d, e);
      }

      /**
       * Perform the appropriate triplet combination function for the current
       * iteration
       */

      function sha1_ft(t, b, c, d) {
        if (t < 20) {
          return (b & c) | ((~b) & d);
        }
        if (t < 40) {
          return b ^ c ^ d;
        }
        if (t < 60) {
          return (b & c) | (b & d) | (c & d);
        }
        return b ^ c ^ d;
      }

      /**
       * Determine the appropriate additive constant for the current iteration
       */

      function sha1_kt(t) {
        return (t < 20) ? 1518500249 : (t < 40) ? 1859775393 :
          (t < 60) ? -1894007588 : -899497514;
      }
    },
    /**
     * @class Hashes.SHA256
     * @param {config}
     *
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined in FIPS 180-2
     * Version 2.2 Copyright Angel Marin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * See http://pajhome.org.uk/crypt/md5 for details.
     * Also http://anmar.eu.org/projects/jssha2/
     */
    SHA256: function(options) {
      /**
       * Private properties configuration variables. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       * @see this.setUpperCase() method
       * @see this.setPad() method
       */
      var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false, // hexadecimal output case format. false - lowercase; true - uppercase  */
        b64pad = (options && typeof options.pad === 'string') ? options.pda : '=',
        /* base-64 pad character. Default '=' for strict RFC compliance   */
        utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
        /* enable/disable utf8 encoding */
        sha256_K;

      /* privileged (public) methods */
      this.hex = function(s) {
        return rstr2hex(rstr(s, utf8));
      };
      this.b64 = function(s) {
        return rstr2b64(rstr(s, utf8), b64pad);
      };
      this.any = function(s, e) {
        return rstr2any(rstr(s, utf8), e);
      };
      this.raw = function(s) {
        return rstr(s, utf8);
      };
      this.hex_hmac = function(k, d) {
        return rstr2hex(rstr_hmac(k, d));
      };
      this.b64_hmac = function(k, d) {
        return rstr2b64(rstr_hmac(k, d), b64pad);
      };
      this.any_hmac = function(k, d, e) {
        return rstr2any(rstr_hmac(k, d), e);
      };
      /**
       * Perform a simple self-test to see if the VM is working
       * @return {String} Hexadecimal hash sample
       * @public
       */
      this.vm_test = function() {
        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
      };
      /**
       * Enable/disable uppercase hexadecimal returned string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUpperCase = function(a) {
        if (typeof a === 'boolean') {
          hexcase = a;
        }
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {string} Pad
       * @return {Object} this
       * @public
       */
      this.setPad = function(a) {
        b64pad = a || b64pad;
        return this;
      };
      /**
       * Defines a base64 pad string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUTF8 = function(a) {
        if (typeof a === 'boolean') {
          utf8 = a;
        }
        return this;
      };

      // private methods

      /**
       * Calculate the SHA-512 of a raw string
       */

      function rstr(s, utf8) {
        s = (utf8) ? utf8Encode(s) : s;
        return binb2rstr(binb(rstr2binb(s), s.length * 8));
      }

      /**
       * Calculate the HMAC-sha256 of a key and some data (raw strings)
       */

      function rstr_hmac(key, data) {
        key = (utf8) ? utf8Encode(key) : key;
        data = (utf8) ? utf8Encode(data) : data;
        var hash, i = 0,
          bkey = rstr2binb(key),
          ipad = Array(16),
          opad = Array(16);

        if (bkey.length > 16) {
          bkey = binb(bkey, key.length * 8);
        }

        for (; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        hash = binb(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
        return binb2rstr(binb(opad.concat(hash), 512 + 256));
      }

      /*
       * Main sha256 function, with its support functions
       */

      function sha256_S(X, n) {
        return (X >>> n) | (X << (32 - n));
      }

      function sha256_R(X, n) {
        return (X >>> n);
      }

      function sha256_Ch(x, y, z) {
        return ((x & y) ^ ((~x) & z));
      }

      function sha256_Maj(x, y, z) {
        return ((x & y) ^ (x & z) ^ (y & z));
      }

      function sha256_Sigma0256(x) {
        return (sha256_S(x, 2) ^ sha256_S(x, 13) ^ sha256_S(x, 22));
      }

      function sha256_Sigma1256(x) {
        return (sha256_S(x, 6) ^ sha256_S(x, 11) ^ sha256_S(x, 25));
      }

      function sha256_Gamma0256(x) {
        return (sha256_S(x, 7) ^ sha256_S(x, 18) ^ sha256_R(x, 3));
      }

      function sha256_Gamma1256(x) {
        return (sha256_S(x, 17) ^ sha256_S(x, 19) ^ sha256_R(x, 10));
      }

      function sha256_Sigma0512(x) {
        return (sha256_S(x, 28) ^ sha256_S(x, 34) ^ sha256_S(x, 39));
      }

      function sha256_Sigma1512(x) {
        return (sha256_S(x, 14) ^ sha256_S(x, 18) ^ sha256_S(x, 41));
      }

      function sha256_Gamma0512(x) {
        return (sha256_S(x, 1) ^ sha256_S(x, 8) ^ sha256_R(x, 7));
      }

      function sha256_Gamma1512(x) {
        return (sha256_S(x, 19) ^ sha256_S(x, 61) ^ sha256_R(x, 6));
      }

      sha256_K = [
        1116352408, 1899447441, -1245643825, -373957723, 961987163, 1508970993, -1841331548, -1424204075, -670586216, 310598401, 607225278, 1426881987,
        1925078388, -2132889090, -1680079193, -1046744716, -459576895, -272742522,
        264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, -1740746414, -1473132947, -1341970488, -1084653625, -958395405, -710438585,
        113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291,
        1695183700, 1986661051, -2117940946, -1838011259, -1564481375, -1474664885, -1035236496, -949202525, -778901479, -694614492, -200395387, 275423344,
        430227734, 506948616, 659060556, 883997877, 958139571, 1322822218,
        1537002063, 1747873779, 1955562222, 2024104815, -2067236844, -1933114872, -1866530822, -1538233109, -1090935817, -965641998
      ];

      function binb(m, l) {
        var HASH = [1779033703, -1150833019, 1013904242, -1521486534,
          1359893119, -1694144372, 528734635, 1541459225
        ];
        var W = new Array(64);
        var a, b, c, d, e, f, g, h;
        var i, j, T1, T2;

        /* append padding */
        m[l >> 5] |= 0x80 << (24 - l % 32);
        m[((l + 64 >> 9) << 4) + 15] = l;

        for (i = 0; i < m.length; i += 16) {
          a = HASH[0];
          b = HASH[1];
          c = HASH[2];
          d = HASH[3];
          e = HASH[4];
          f = HASH[5];
          g = HASH[6];
          h = HASH[7];

          for (j = 0; j < 64; j += 1) {
            if (j < 16) {
              W[j] = m[j + i];
            } else {
              W[j] = safe_add(safe_add(safe_add(sha256_Gamma1256(W[j - 2]), W[j - 7]),
                sha256_Gamma0256(W[j - 15])), W[j - 16]);
            }

            T1 = safe_add(safe_add(safe_add(safe_add(h, sha256_Sigma1256(e)), sha256_Ch(e, f, g)),
              sha256_K[j]), W[j]);
            T2 = safe_add(sha256_Sigma0256(a), sha256_Maj(a, b, c));
            h = g;
            g = f;
            f = e;
            e = safe_add(d, T1);
            d = c;
            c = b;
            b = a;
            a = safe_add(T1, T2);
          }

          HASH[0] = safe_add(a, HASH[0]);
          HASH[1] = safe_add(b, HASH[1]);
          HASH[2] = safe_add(c, HASH[2]);
          HASH[3] = safe_add(d, HASH[3]);
          HASH[4] = safe_add(e, HASH[4]);
          HASH[5] = safe_add(f, HASH[5]);
          HASH[6] = safe_add(g, HASH[6]);
          HASH[7] = safe_add(h, HASH[7]);
        }
        return HASH;
      }

    },

    /**
     * @class Hashes.SHA512
     * @param {config}
     *
     * A JavaScript implementation of the Secure Hash Algorithm, SHA-512, as defined in FIPS 180-2
     * Version 2.2 Copyright Anonymous Contributor, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * See http://pajhome.org.uk/crypt/md5 for details.
     */
    SHA512: function(options) {
      /**
       * Private properties configuration variables. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       * @see this.setUpperCase() method
       * @see this.setPad() method
       */
      var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false,
        /* hexadecimal output case format. false - lowercase; true - uppercase  */
        b64pad = (options && typeof options.pad === 'string') ? options.pda : '=',
        /* base-64 pad character. Default '=' for strict RFC compliance   */
        utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
        /* enable/disable utf8 encoding */
        sha512_k;

      /* privileged (public) methods */
      this.hex = function(s) {
        return rstr2hex(rstr(s));
      };
      this.b64 = function(s) {
        return rstr2b64(rstr(s), b64pad);
      };
      this.any = function(s, e) {
        return rstr2any(rstr(s), e);
      };
      this.raw = function(s) {
        return rstr(s, utf8);
      };
      this.hex_hmac = function(k, d) {
        return rstr2hex(rstr_hmac(k, d));
      };
      this.b64_hmac = function(k, d) {
        return rstr2b64(rstr_hmac(k, d), b64pad);
      };
      this.any_hmac = function(k, d, e) {
        return rstr2any(rstr_hmac(k, d), e);
      };
      /**
       * Perform a simple self-test to see if the VM is working
       * @return {String} Hexadecimal hash sample
       * @public
       */
      this.vm_test = function() {
        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
      };
      /**
       * @description Enable/disable uppercase hexadecimal returned string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUpperCase = function(a) {
        if (typeof a === 'boolean') {
          hexcase = a;
        }
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {string} Pad
       * @return {Object} this
       * @public
       */
      this.setPad = function(a) {
        b64pad = a || b64pad;
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUTF8 = function(a) {
        if (typeof a === 'boolean') {
          utf8 = a;
        }
        return this;
      };

      /* private methods */

      /**
       * Calculate the SHA-512 of a raw string
       */

      function rstr(s) {
        s = (utf8) ? utf8Encode(s) : s;
        return binb2rstr(binb(rstr2binb(s), s.length * 8));
      }
      /*
       * Calculate the HMAC-SHA-512 of a key and some data (raw strings)
       */

      function rstr_hmac(key, data) {
        key = (utf8) ? utf8Encode(key) : key;
        data = (utf8) ? utf8Encode(data) : data;

        var hash, i = 0,
          bkey = rstr2binb(key),
          ipad = Array(32),
          opad = Array(32);

        if (bkey.length > 32) {
          bkey = binb(bkey, key.length * 8);
        }

        for (; i < 32; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }

        hash = binb(ipad.concat(rstr2binb(data)), 1024 + data.length * 8);
        return binb2rstr(binb(opad.concat(hash), 1024 + 512));
      }

      /**
       * Calculate the SHA-512 of an array of big-endian dwords, and a bit length
       */

      function binb(x, len) {
        var j, i, l,
          W = new Array(80),
          hash = new Array(16),
          //Initial hash values
          H = [
            new int64(0x6a09e667, -205731576),
            new int64(-1150833019, -2067093701),
            new int64(0x3c6ef372, -23791573),
            new int64(-1521486534, 0x5f1d36f1),
            new int64(0x510e527f, -1377402159),
            new int64(-1694144372, 0x2b3e6c1f),
            new int64(0x1f83d9ab, -79577749),
            new int64(0x5be0cd19, 0x137e2179)
          ],
          T1 = new int64(0, 0),
          T2 = new int64(0, 0),
          a = new int64(0, 0),
          b = new int64(0, 0),
          c = new int64(0, 0),
          d = new int64(0, 0),
          e = new int64(0, 0),
          f = new int64(0, 0),
          g = new int64(0, 0),
          h = new int64(0, 0),
          //Temporary variables not specified by the document
          s0 = new int64(0, 0),
          s1 = new int64(0, 0),
          Ch = new int64(0, 0),
          Maj = new int64(0, 0),
          r1 = new int64(0, 0),
          r2 = new int64(0, 0),
          r3 = new int64(0, 0);

        if (sha512_k === undefined) {
          //SHA512 constants
          sha512_k = [
            new int64(0x428a2f98, -685199838), new int64(0x71374491, 0x23ef65cd),
            new int64(-1245643825, -330482897), new int64(-373957723, -2121671748),
            new int64(0x3956c25b, -213338824), new int64(0x59f111f1, -1241133031),
            new int64(-1841331548, -1357295717), new int64(-1424204075, -630357736),
            new int64(-670586216, -1560083902), new int64(0x12835b01, 0x45706fbe),
            new int64(0x243185be, 0x4ee4b28c), new int64(0x550c7dc3, -704662302),
            new int64(0x72be5d74, -226784913), new int64(-2132889090, 0x3b1696b1),
            new int64(-1680079193, 0x25c71235), new int64(-1046744716, -815192428),
            new int64(-459576895, -1628353838), new int64(-272742522, 0x384f25e3),
            new int64(0xfc19dc6, -1953704523), new int64(0x240ca1cc, 0x77ac9c65),
            new int64(0x2de92c6f, 0x592b0275), new int64(0x4a7484aa, 0x6ea6e483),
            new int64(0x5cb0a9dc, -1119749164), new int64(0x76f988da, -2096016459),
            new int64(-1740746414, -295247957), new int64(-1473132947, 0x2db43210),
            new int64(-1341970488, -1728372417), new int64(-1084653625, -1091629340),
            new int64(-958395405, 0x3da88fc2), new int64(-710438585, -1828018395),
            new int64(0x6ca6351, -536640913), new int64(0x14292967, 0xa0e6e70),
            new int64(0x27b70a85, 0x46d22ffc), new int64(0x2e1b2138, 0x5c26c926),
            new int64(0x4d2c6dfc, 0x5ac42aed), new int64(0x53380d13, -1651133473),
            new int64(0x650a7354, -1951439906), new int64(0x766a0abb, 0x3c77b2a8),
            new int64(-2117940946, 0x47edaee6), new int64(-1838011259, 0x1482353b),
            new int64(-1564481375, 0x4cf10364), new int64(-1474664885, -1136513023),
            new int64(-1035236496, -789014639), new int64(-949202525, 0x654be30),
            new int64(-778901479, -688958952), new int64(-694614492, 0x5565a910),
            new int64(-200395387, 0x5771202a), new int64(0x106aa070, 0x32bbd1b8),
            new int64(0x19a4c116, -1194143544), new int64(0x1e376c08, 0x5141ab53),
            new int64(0x2748774c, -544281703), new int64(0x34b0bcb5, -509917016),
            new int64(0x391c0cb3, -976659869), new int64(0x4ed8aa4a, -482243893),
            new int64(0x5b9cca4f, 0x7763e373), new int64(0x682e6ff3, -692930397),
            new int64(0x748f82ee, 0x5defb2fc), new int64(0x78a5636f, 0x43172f60),
            new int64(-2067236844, -1578062990), new int64(-1933114872, 0x1a6439ec),
            new int64(-1866530822, 0x23631e28), new int64(-1538233109, -561857047),
            new int64(-1090935817, -1295615723), new int64(-965641998, -479046869),
            new int64(-903397682, -366583396), new int64(-779700025, 0x21c0c207),
            new int64(-354779690, -840897762), new int64(-176337025, -294727304),
            new int64(0x6f067aa, 0x72176fba), new int64(0xa637dc5, -1563912026),
            new int64(0x113f9804, -1090974290), new int64(0x1b710b35, 0x131c471b),
            new int64(0x28db77f5, 0x23047d84), new int64(0x32caab7b, 0x40c72493),
            new int64(0x3c9ebe0a, 0x15c9bebc), new int64(0x431d67c4, -1676669620),
            new int64(0x4cc5d4be, -885112138), new int64(0x597f299c, -60457430),
            new int64(0x5fcb6fab, 0x3ad6faec), new int64(0x6c44198c, 0x4a475817)
          ];
        }

        for (i = 0; i < 80; i += 1) {
          W[i] = new int64(0, 0);
        }

        // append padding to the source string. The format is described in the FIPS.
        x[len >> 5] |= 0x80 << (24 - (len & 0x1f));
        x[((len + 128 >> 10) << 5) + 31] = len;
        l = x.length;
        for (i = 0; i < l; i += 32) { //32 dwords is the block size
          int64copy(a, H[0]);
          int64copy(b, H[1]);
          int64copy(c, H[2]);
          int64copy(d, H[3]);
          int64copy(e, H[4]);
          int64copy(f, H[5]);
          int64copy(g, H[6]);
          int64copy(h, H[7]);

          for (j = 0; j < 16; j += 1) {
            W[j].h = x[i + 2 * j];
            W[j].l = x[i + 2 * j + 1];
          }

          for (j = 16; j < 80; j += 1) {
            //sigma1
            int64rrot(r1, W[j - 2], 19);
            int64revrrot(r2, W[j - 2], 29);
            int64shr(r3, W[j - 2], 6);
            s1.l = r1.l ^ r2.l ^ r3.l;
            s1.h = r1.h ^ r2.h ^ r3.h;
            //sigma0
            int64rrot(r1, W[j - 15], 1);
            int64rrot(r2, W[j - 15], 8);
            int64shr(r3, W[j - 15], 7);
            s0.l = r1.l ^ r2.l ^ r3.l;
            s0.h = r1.h ^ r2.h ^ r3.h;

            int64add4(W[j], s1, W[j - 7], s0, W[j - 16]);
          }

          for (j = 0; j < 80; j += 1) {
            //Ch
            Ch.l = (e.l & f.l) ^ (~e.l & g.l);
            Ch.h = (e.h & f.h) ^ (~e.h & g.h);

            //Sigma1
            int64rrot(r1, e, 14);
            int64rrot(r2, e, 18);
            int64revrrot(r3, e, 9);
            s1.l = r1.l ^ r2.l ^ r3.l;
            s1.h = r1.h ^ r2.h ^ r3.h;

            //Sigma0
            int64rrot(r1, a, 28);
            int64revrrot(r2, a, 2);
            int64revrrot(r3, a, 7);
            s0.l = r1.l ^ r2.l ^ r3.l;
            s0.h = r1.h ^ r2.h ^ r3.h;

            //Maj
            Maj.l = (a.l & b.l) ^ (a.l & c.l) ^ (b.l & c.l);
            Maj.h = (a.h & b.h) ^ (a.h & c.h) ^ (b.h & c.h);

            int64add5(T1, h, s1, Ch, sha512_k[j], W[j]);
            int64add(T2, s0, Maj);

            int64copy(h, g);
            int64copy(g, f);
            int64copy(f, e);
            int64add(e, d, T1);
            int64copy(d, c);
            int64copy(c, b);
            int64copy(b, a);
            int64add(a, T1, T2);
          }
          int64add(H[0], H[0], a);
          int64add(H[1], H[1], b);
          int64add(H[2], H[2], c);
          int64add(H[3], H[3], d);
          int64add(H[4], H[4], e);
          int64add(H[5], H[5], f);
          int64add(H[6], H[6], g);
          int64add(H[7], H[7], h);
        }

        //represent the hash as an array of 32-bit dwords
        for (i = 0; i < 8; i += 1) {
          hash[2 * i] = H[i].h;
          hash[2 * i + 1] = H[i].l;
        }
        return hash;
      }

      //A constructor for 64-bit numbers

      function int64(h, l) {
        this.h = h;
        this.l = l;
        //this.toString = int64toString;
      }

      //Copies src into dst, assuming both are 64-bit numbers

      function int64copy(dst, src) {
        dst.h = src.h;
        dst.l = src.l;
      }

      //Right-rotates a 64-bit number by shift
      //Won't handle cases of shift>=32
      //The function revrrot() is for that

      function int64rrot(dst, x, shift) {
        dst.l = (x.l >>> shift) | (x.h << (32 - shift));
        dst.h = (x.h >>> shift) | (x.l << (32 - shift));
      }

      //Reverses the dwords of the source and then rotates right by shift.
      //This is equivalent to rotation by 32+shift

      function int64revrrot(dst, x, shift) {
        dst.l = (x.h >>> shift) | (x.l << (32 - shift));
        dst.h = (x.l >>> shift) | (x.h << (32 - shift));
      }

      //Bitwise-shifts right a 64-bit number by shift
      //Won't handle shift>=32, but it's never needed in SHA512

      function int64shr(dst, x, shift) {
        dst.l = (x.l >>> shift) | (x.h << (32 - shift));
        dst.h = (x.h >>> shift);
      }

      //Adds two 64-bit numbers
      //Like the original implementation, does not rely on 32-bit operations

      function int64add(dst, x, y) {
        var w0 = (x.l & 0xffff) + (y.l & 0xffff);
        var w1 = (x.l >>> 16) + (y.l >>> 16) + (w0 >>> 16);
        var w2 = (x.h & 0xffff) + (y.h & 0xffff) + (w1 >>> 16);
        var w3 = (x.h >>> 16) + (y.h >>> 16) + (w2 >>> 16);
        dst.l = (w0 & 0xffff) | (w1 << 16);
        dst.h = (w2 & 0xffff) | (w3 << 16);
      }

      //Same, except with 4 addends. Works faster than adding them one by one.

      function int64add4(dst, a, b, c, d) {
        var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff);
        var w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (w0 >>> 16);
        var w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (w1 >>> 16);
        var w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (w2 >>> 16);
        dst.l = (w0 & 0xffff) | (w1 << 16);
        dst.h = (w2 & 0xffff) | (w3 << 16);
      }

      //Same, except with 5 addends

      function int64add5(dst, a, b, c, d, e) {
        var w0 = (a.l & 0xffff) + (b.l & 0xffff) + (c.l & 0xffff) + (d.l & 0xffff) + (e.l & 0xffff),
          w1 = (a.l >>> 16) + (b.l >>> 16) + (c.l >>> 16) + (d.l >>> 16) + (e.l >>> 16) + (w0 >>> 16),
          w2 = (a.h & 0xffff) + (b.h & 0xffff) + (c.h & 0xffff) + (d.h & 0xffff) + (e.h & 0xffff) + (w1 >>> 16),
          w3 = (a.h >>> 16) + (b.h >>> 16) + (c.h >>> 16) + (d.h >>> 16) + (e.h >>> 16) + (w2 >>> 16);
        dst.l = (w0 & 0xffff) | (w1 << 16);
        dst.h = (w2 & 0xffff) | (w3 << 16);
      }
    },
    /**
     * @class Hashes.RMD160
     * @constructor
     * @param {Object} [config]
     *
     * A JavaScript implementation of the RIPEMD-160 Algorithm
     * Version 2.2 Copyright Jeremy Lin, Paul Johnston 2000 - 2009.
     * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
     * See http://pajhome.org.uk/crypt/md5 for details.
     * Also http://www.ocf.berkeley.edu/~jjlin/jsotp/
     */
    RMD160: function(options) {
      /**
       * Private properties configuration variables. You may need to tweak these to be compatible with
       * the server-side, but the defaults work in most cases.
       * @see this.setUpperCase() method
       * @see this.setPad() method
       */
      var hexcase = (options && typeof options.uppercase === 'boolean') ? options.uppercase : false,
        /* hexadecimal output case format. false - lowercase; true - uppercase  */
        b64pad = (options && typeof options.pad === 'string') ? options.pda : '=',
        /* base-64 pad character. Default '=' for strict RFC compliance   */
        utf8 = (options && typeof options.utf8 === 'boolean') ? options.utf8 : true,
        /* enable/disable utf8 encoding */
        rmd160_r1 = [
          0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
          7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
          3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
          1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
          4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
        ],
        rmd160_r2 = [
          5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
          6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
          15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
          8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
          12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
        ],
        rmd160_s1 = [
          11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
          7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
          11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
          11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
          9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
        ],
        rmd160_s2 = [
          8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
          9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
          9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
          15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
          8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
        ];

      /* privileged (public) methods */
      this.hex = function(s) {
        return rstr2hex(rstr(s, utf8));
      };
      this.b64 = function(s) {
        return rstr2b64(rstr(s, utf8), b64pad);
      };
      this.any = function(s, e) {
        return rstr2any(rstr(s, utf8), e);
      };
      this.raw = function(s) {
        return rstr(s, utf8);
      };
      this.hex_hmac = function(k, d) {
        return rstr2hex(rstr_hmac(k, d));
      };
      this.b64_hmac = function(k, d) {
        return rstr2b64(rstr_hmac(k, d), b64pad);
      };
      this.any_hmac = function(k, d, e) {
        return rstr2any(rstr_hmac(k, d), e);
      };
      /**
       * Perform a simple self-test to see if the VM is working
       * @return {String} Hexadecimal hash sample
       * @public
       */
      this.vm_test = function() {
        return hex('abc').toLowerCase() === '900150983cd24fb0d6963f7d28e17f72';
      };
      /**
       * @description Enable/disable uppercase hexadecimal returned string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUpperCase = function(a) {
        if (typeof a === 'boolean') {
          hexcase = a;
        }
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {string} Pad
       * @return {Object} this
       * @public
       */
      this.setPad = function(a) {
        if (typeof a !== 'undefined') {
          b64pad = a;
        }
        return this;
      };
      /**
       * @description Defines a base64 pad string
       * @param {boolean}
       * @return {Object} this
       * @public
       */
      this.setUTF8 = function(a) {
        if (typeof a === 'boolean') {
          utf8 = a;
        }
        return this;
      };

      /* private methods */

      /**
       * Calculate the rmd160 of a raw string
       */

      function rstr(s) {
        s = (utf8) ? utf8Encode(s) : s;
        return binl2rstr(binl(rstr2binl(s), s.length * 8));
      }

      /**
       * Calculate the HMAC-rmd160 of a key and some data (raw strings)
       */

      function rstr_hmac(key, data) {
        key = (utf8) ? utf8Encode(key) : key;
        data = (utf8) ? utf8Encode(data) : data;
        var i, hash,
          bkey = rstr2binl(key),
          ipad = Array(16),
          opad = Array(16);

        if (bkey.length > 16) {
          bkey = binl(bkey, key.length * 8);
        }

        for (i = 0; i < 16; i += 1) {
          ipad[i] = bkey[i] ^ 0x36363636;
          opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl(opad.concat(hash), 512 + 160));
      }

      /**
       * Convert an array of little-endian words to a string
       */

      function binl2rstr(input) {
        var i, output = '',
          l = input.length * 32;
        for (i = 0; i < l; i += 8) {
          output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
      }

      /**
       * Calculate the RIPE-MD160 of an array of little-endian words, and a bit length.
       */

      function binl(x, len) {
        var T, j, i, l,
          h0 = 0x67452301,
          h1 = 0xefcdab89,
          h2 = 0x98badcfe,
          h3 = 0x10325476,
          h4 = 0xc3d2e1f0,
          A1, B1, C1, D1, E1,
          A2, B2, C2, D2, E2;

        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;
        l = x.length;

        for (i = 0; i < l; i += 16) {
          A1 = A2 = h0;
          B1 = B2 = h1;
          C1 = C2 = h2;
          D1 = D2 = h3;
          E1 = E2 = h4;
          for (j = 0; j <= 79; j += 1) {
            T = safe_add(A1, rmd160_f(j, B1, C1, D1));
            T = safe_add(T, x[i + rmd160_r1[j]]);
            T = safe_add(T, rmd160_K1(j));
            T = safe_add(bit_rol(T, rmd160_s1[j]), E1);
            A1 = E1;
            E1 = D1;
            D1 = bit_rol(C1, 10);
            C1 = B1;
            B1 = T;
            T = safe_add(A2, rmd160_f(79 - j, B2, C2, D2));
            T = safe_add(T, x[i + rmd160_r2[j]]);
            T = safe_add(T, rmd160_K2(j));
            T = safe_add(bit_rol(T, rmd160_s2[j]), E2);
            A2 = E2;
            E2 = D2;
            D2 = bit_rol(C2, 10);
            C2 = B2;
            B2 = T;
          }

          T = safe_add(h1, safe_add(C1, D2));
          h1 = safe_add(h2, safe_add(D1, E2));
          h2 = safe_add(h3, safe_add(E1, A2));
          h3 = safe_add(h4, safe_add(A1, B2));
          h4 = safe_add(h0, safe_add(B1, C2));
          h0 = T;
        }
        return [h0, h1, h2, h3, h4];
      }

      // specific algorithm methods

      function rmd160_f(j, x, y, z) {
        return (0 <= j && j <= 15) ? (x ^ y ^ z) :
          (16 <= j && j <= 31) ? (x & y) | (~x & z) :
          (32 <= j && j <= 47) ? (x | ~y) ^ z :
          (48 <= j && j <= 63) ? (x & z) | (y & ~z) :
          (64 <= j && j <= 79) ? x ^ (y | ~z) :
          'rmd160_f: j out of range';
      }

      function rmd160_K1(j) {
        return (0 <= j && j <= 15) ? 0x00000000 :
          (16 <= j && j <= 31) ? 0x5a827999 :
          (32 <= j && j <= 47) ? 0x6ed9eba1 :
          (48 <= j && j <= 63) ? 0x8f1bbcdc :
          (64 <= j && j <= 79) ? 0xa953fd4e :
          'rmd160_K1: j out of range';
      }

      function rmd160_K2(j) {
        return (0 <= j && j <= 15) ? 0x50a28be6 :
          (16 <= j && j <= 31) ? 0x5c4dd124 :
          (32 <= j && j <= 47) ? 0x6d703ef3 :
          (48 <= j && j <= 63) ? 0x7a6d76e9 :
          (64 <= j && j <= 79) ? 0x00000000 :
          'rmd160_K2: j out of range';
      }
    }
  };

  // exposes Hashes
  (function(window, undefined) {
    var freeExports = false;
    if (typeof exports === 'object') {
      freeExports = exports;
      if (exports && typeof global === 'object' && global && global === global.global) {
        window = global;
      }
    }

    if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
      // define as an anonymous module, so, through path mapping, it can be aliased
      define(function() {
        return Hashes;
      });
    } else if (freeExports) {
      // in Node.js or RingoJS v0.8.0+
      if (typeof module === 'object' && module && module.exports === freeExports) {
        module.exports = Hashes;
      }
      // in Narwhal or RingoJS v0.7.0-
      else {
        freeExports.Hashes = Hashes;
      }
    } else {
      // in a browser or Rhino
      window.Hashes = Hashes;
    }
  }(this));
}()); // IIFE

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],442:[function(require,module,exports){
(function (process){
// vim:ts=4:sts=4:sw=4:
/*!
 *
 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
 *
 * With parts by Tyler Close
 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
 * at http://www.opensource.org/licenses/mit-license.html
 * Forked at ref_send.js version: 2009-05-11
 *
 * With parts by Mark Miller
 * Copyright (C) 2011 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

(function (definition) {
    "use strict";

    // This file will function properly as a <script> tag, or a module
    // using CommonJS and NodeJS or RequireJS module formats.  In
    // Common/Node/RequireJS, the module exports the Q API and when
    // executed as a simple <script>, it creates a Q global instead.

    // Montage Require
    if (typeof bootstrap === "function") {
        bootstrap("promise", definition);

    // CommonJS
    } else if (typeof exports === "object" && typeof module === "object") {
        module.exports = definition();

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
        define(definition);

    // SES (Secure EcmaScript)
    } else if (typeof ses !== "undefined") {
        if (!ses.ok()) {
            return;
        } else {
            ses.makeQ = definition;
        }

    // <script>
    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
        // Prefer window over self for add-on scripts. Use self for
        // non-windowed contexts.
        var global = typeof window !== "undefined" ? window : self;

        // Get the `window` object, save the previous Q global
        // and initialize Q as a global.
        var previousQ = global.Q;
        global.Q = definition();

        // Add a noConflict function so Q can be removed from the
        // global namespace.
        global.Q.noConflict = function () {
            global.Q = previousQ;
            return this;
        };

    } else {
        throw new Error("This environment was not anticipated by Q. Please file a bug.");
    }

})(function () {
"use strict";

var hasStacks = false;
try {
    throw new Error();
} catch (e) {
    hasStacks = !!e.stack;
}

// All code after this point will be filtered from stack traces reported
// by Q.
var qStartingLine = captureLine();
var qFileName;

// shims

// used for fallback in "allResolved"
var noop = function () {};

// Use the fastest possible means to execute a task in a future turn
// of the event loop.
var nextTick =(function () {
    // linked list of tasks (single, with head node)
    var head = {task: void 0, next: null};
    var tail = head;
    var flushing = false;
    var requestTick = void 0;
    var isNodeJS = false;
    // queue for late tasks, used by unhandled rejection tracking
    var laterQueue = [];

    function flush() {
        /* jshint loopfunc: true */
        var task, domain;

        while (head.next) {
            head = head.next;
            task = head.task;
            head.task = void 0;
            domain = head.domain;

            if (domain) {
                head.domain = void 0;
                domain.enter();
            }
            runSingle(task, domain);

        }
        while (laterQueue.length) {
            task = laterQueue.pop();
            runSingle(task);
        }
        flushing = false;
    }
    // runs a single function in the async queue
    function runSingle(task, domain) {
        try {
            task();

        } catch (e) {
            if (isNodeJS) {
                // In node, uncaught exceptions are considered fatal errors.
                // Re-throw them synchronously to interrupt flushing!

                // Ensure continuation if the uncaught exception is suppressed
                // listening "uncaughtException" events (as domains does).
                // Continue in next event to avoid tick recursion.
                if (domain) {
                    domain.exit();
                }
                setTimeout(flush, 0);
                if (domain) {
                    domain.enter();
                }

                throw e;

            } else {
                // In browsers, uncaught exceptions are not fatal.
                // Re-throw them asynchronously to avoid slow-downs.
                setTimeout(function () {
                    throw e;
                }, 0);
            }
        }

        if (domain) {
            domain.exit();
        }
    }

    nextTick = function (task) {
        tail = tail.next = {
            task: task,
            domain: isNodeJS && process.domain,
            next: null
        };

        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };

    if (typeof process === "object" &&
        process.toString() === "[object process]" && process.nextTick) {
        // Ensure Q is in a real Node environment, with a `process.nextTick`.
        // To see through fake Node environments:
        // * Mocha test runner - exposes a `process` global without a `nextTick`
        // * Browserify - exposes a `process.nexTick` function that uses
        //   `setTimeout`. In this case `setImmediate` is preferred because
        //    it is faster. Browserify's `process.toString()` yields
        //   "[object Object]", while in a real Node environment
        //   `process.nextTick()` yields "[object process]".
        isNodeJS = true;

        requestTick = function () {
            process.nextTick(flush);
        };

    } else if (typeof setImmediate === "function") {
        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
        if (typeof window !== "undefined") {
            requestTick = setImmediate.bind(window, flush);
        } else {
            requestTick = function () {
                setImmediate(flush);
            };
        }

    } else if (typeof MessageChannel !== "undefined") {
        // modern browsers
        // http://www.nonblocking.io/2011/06/windownexttick.html
        var channel = new MessageChannel();
        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
        // working message ports the first time a page loads.
        channel.port1.onmessage = function () {
            requestTick = requestPortTick;
            channel.port1.onmessage = flush;
            flush();
        };
        var requestPortTick = function () {
            // Opera requires us to provide a message payload, regardless of
            // whether we use it.
            channel.port2.postMessage(0);
        };
        requestTick = function () {
            setTimeout(flush, 0);
            requestPortTick();
        };

    } else {
        // old browsers
        requestTick = function () {
            setTimeout(flush, 0);
        };
    }
    // runs a task after all other tasks have been run
    // this is useful for unhandled rejection tracking that needs to happen
    // after all `then`d tasks have been run.
    nextTick.runAfter = function (task) {
        laterQueue.push(task);
        if (!flushing) {
            flushing = true;
            requestTick();
        }
    };
    return nextTick;
})();

// Attempt to make generics safe in the face of downstream
// modifications.
// There is no situation where this is necessary.
// If you need a security guarantee, these primordials need to be
// deeply frozen anyway, and if you don’t need a security guarantee,
// this is just plain paranoid.
// However, this **might** have the nice side-effect of reducing the size of
// the minified code by reducing x.call() to merely x()
// See Mark Miller’s explanation of what this does.
// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
var call = Function.call;
function uncurryThis(f) {
    return function () {
        return call.apply(f, arguments);
    };
}
// This is equivalent, but slower:
// uncurryThis = Function_bind.bind(Function_bind.call);
// http://jsperf.com/uncurrythis

var array_slice = uncurryThis(Array.prototype.slice);

var array_reduce = uncurryThis(
    Array.prototype.reduce || function (callback, basis) {
        var index = 0,
            length = this.length;
        // concerning the initial value, if one is not provided
        if (arguments.length === 1) {
            // seek to the first value in the array, accounting
            // for the possibility that is is a sparse array
            do {
                if (index in this) {
                    basis = this[index++];
                    break;
                }
                if (++index >= length) {
                    throw new TypeError();
                }
            } while (1);
        }
        // reduce
        for (; index < length; index++) {
            // account for the possibility that the array is sparse
            if (index in this) {
                basis = callback(basis, this[index], index);
            }
        }
        return basis;
    }
);

var array_indexOf = uncurryThis(
    Array.prototype.indexOf || function (value) {
        // not a very good shim, but good enough for our one use of it
        for (var i = 0; i < this.length; i++) {
            if (this[i] === value) {
                return i;
            }
        }
        return -1;
    }
);

var array_map = uncurryThis(
    Array.prototype.map || function (callback, thisp) {
        var self = this;
        var collect = [];
        array_reduce(self, function (undefined, value, index) {
            collect.push(callback.call(thisp, value, index, self));
        }, void 0);
        return collect;
    }
);

var object_create = Object.create || function (prototype) {
    function Type() { }
    Type.prototype = prototype;
    return new Type();
};

var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

var object_keys = Object.keys || function (object) {
    var keys = [];
    for (var key in object) {
        if (object_hasOwnProperty(object, key)) {
            keys.push(key);
        }
    }
    return keys;
};

var object_toString = uncurryThis(Object.prototype.toString);

function isObject(value) {
    return value === Object(value);
}

// generator related shims

// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
function isStopIteration(exception) {
    return (
        object_toString(exception) === "[object StopIteration]" ||
        exception instanceof QReturnValue
    );
}

// FIXME: Remove this helper and Q.return once ES6 generators are in
// SpiderMonkey.
var QReturnValue;
if (typeof ReturnValue !== "undefined") {
    QReturnValue = ReturnValue;
} else {
    QReturnValue = function (value) {
        this.value = value;
    };
}

// long stack traces

var STACK_JUMP_SEPARATOR = "From previous event:";

function makeStackTraceLong(error, promise) {
    // If possible, transform the error stack trace by removing Node and Q
    // cruft, then concatenating with the stack trace of `promise`. See #57.
    if (hasStacks &&
        promise.stack &&
        typeof error === "object" &&
        error !== null &&
        error.stack &&
        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
    ) {
        var stacks = [];
        for (var p = promise; !!p; p = p.source) {
            if (p.stack) {
                stacks.unshift(p.stack);
            }
        }
        stacks.unshift(error.stack);

        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
        error.stack = filterStackString(concatedStacks);
    }
}

function filterStackString(stackString) {
    var lines = stackString.split("\n");
    var desiredLines = [];
    for (var i = 0; i < lines.length; ++i) {
        var line = lines[i];

        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
            desiredLines.push(line);
        }
    }
    return desiredLines.join("\n");
}

function isNodeFrame(stackLine) {
    return stackLine.indexOf("(module.js:") !== -1 ||
           stackLine.indexOf("(node.js:") !== -1;
}

function getFileNameAndLineNumber(stackLine) {
    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
    // In IE10 function name can have spaces ("Anonymous function") O_o
    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
    if (attempt1) {
        return [attempt1[1], Number(attempt1[2])];
    }

    // Anonymous functions: "at filename:lineNumber:columnNumber"
    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
    if (attempt2) {
        return [attempt2[1], Number(attempt2[2])];
    }

    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
    if (attempt3) {
        return [attempt3[1], Number(attempt3[2])];
    }
}

function isInternalFrame(stackLine) {
    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

    if (!fileNameAndLineNumber) {
        return false;
    }

    var fileName = fileNameAndLineNumber[0];
    var lineNumber = fileNameAndLineNumber[1];

    return fileName === qFileName &&
        lineNumber >= qStartingLine &&
        lineNumber <= qEndingLine;
}

// discover own file name and line number range for filtering stack
// traces
function captureLine() {
    if (!hasStacks) {
        return;
    }

    try {
        throw new Error();
    } catch (e) {
        var lines = e.stack.split("\n");
        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
        if (!fileNameAndLineNumber) {
            return;
        }

        qFileName = fileNameAndLineNumber[0];
        return fileNameAndLineNumber[1];
    }
}

function deprecate(callback, name, alternative) {
    return function () {
        if (typeof console !== "undefined" &&
            typeof console.warn === "function") {
            console.warn(name + " is deprecated, use " + alternative +
                         " instead.", new Error("").stack);
        }
        return callback.apply(callback, arguments);
    };
}

// end of shims
// beginning of real work

/**
 * Constructs a promise for an immediate reference, passes promises through, or
 * coerces promises from different systems.
 * @param value immediate reference or promise
 */
function Q(value) {
    // If the object is already a Promise, return it directly.  This enables
    // the resolve function to both be used to created references from objects,
    // but to tolerably coerce non-promises to promises.
    if (value instanceof Promise) {
        return value;
    }

    // assimilate thenables
    if (isPromiseAlike(value)) {
        return coerce(value);
    } else {
        return fulfill(value);
    }
}
Q.resolve = Q;

/**
 * Performs a task in a future turn of the event loop.
 * @param {Function} task
 */
Q.nextTick = nextTick;

/**
 * Controls whether or not long stack traces will be on
 */
Q.longStackSupport = false;

// enable long stacks if Q_DEBUG is set
if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
    Q.longStackSupport = true;
}

/**
 * Constructs a {promise, resolve, reject} object.
 *
 * `resolve` is a callback to invoke with a more resolved value for the
 * promise. To fulfill the promise, invoke `resolve` with any value that is
 * not a thenable. To reject the promise, invoke `resolve` with a rejected
 * thenable, or invoke `reject` with the reason directly. To resolve the
 * promise to another thenable, thus putting it in the same state, invoke
 * `resolve` with that other thenable.
 */
Q.defer = defer;
function defer() {
    // if "messages" is an "Array", that indicates that the promise has not yet
    // been resolved.  If it is "undefined", it has been resolved.  Each
    // element of the messages array is itself an array of complete arguments to
    // forward to the resolved promise.  We coerce the resolution value to a
    // promise using the `resolve` function because it handles both fully
    // non-thenable values and other thenables gracefully.
    var messages = [], progressListeners = [], resolvedPromise;

    var deferred = object_create(defer.prototype);
    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, operands) {
        var args = array_slice(arguments);
        if (messages) {
            messages.push(args);
            if (op === "when" && operands[1]) { // progress operand
                progressListeners.push(operands[1]);
            }
        } else {
            Q.nextTick(function () {
                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
            });
        }
    };

    // XXX deprecated
    promise.valueOf = function () {
        if (messages) {
            return promise;
        }
        var nearerValue = nearer(resolvedPromise);
        if (isPromise(nearerValue)) {
            resolvedPromise = nearerValue; // shorten chain
        }
        return nearerValue;
    };

    promise.inspect = function () {
        if (!resolvedPromise) {
            return { state: "pending" };
        }
        return resolvedPromise.inspect();
    };

    if (Q.longStackSupport && hasStacks) {
        try {
            throw new Error();
        } catch (e) {
            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
            // accessor around; that causes memory leaks as per GH-111. Just
            // reify the stack trace as a string ASAP.
            //
            // At the same time, cut off the first line; it's always just
            // "[object Promise]\n", as per the `toString`.
            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
        }
    }

    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
    // consolidating them into `become`, since otherwise we'd create new
    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

    function become(newPromise) {
        resolvedPromise = newPromise;
        promise.source = newPromise;

        array_reduce(messages, function (undefined, message) {
            Q.nextTick(function () {
                newPromise.promiseDispatch.apply(newPromise, message);
            });
        }, void 0);

        messages = void 0;
        progressListeners = void 0;
    }

    deferred.promise = promise;
    deferred.resolve = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(Q(value));
    };

    deferred.fulfill = function (value) {
        if (resolvedPromise) {
            return;
        }

        become(fulfill(value));
    };
    deferred.reject = function (reason) {
        if (resolvedPromise) {
            return;
        }

        become(reject(reason));
    };
    deferred.notify = function (progress) {
        if (resolvedPromise) {
            return;
        }

        array_reduce(progressListeners, function (undefined, progressListener) {
            Q.nextTick(function () {
                progressListener(progress);
            });
        }, void 0);
    };

    return deferred;
}

/**
 * Creates a Node-style callback that will resolve or reject the deferred
 * promise.
 * @returns a nodeback
 */
defer.prototype.makeNodeResolver = function () {
    var self = this;
    return function (error, value) {
        if (error) {
            self.reject(error);
        } else if (arguments.length > 2) {
            self.resolve(array_slice(arguments, 1));
        } else {
            self.resolve(value);
        }
    };
};

/**
 * @param resolver {Function} a function that returns nothing and accepts
 * the resolve, reject, and notify functions for a deferred.
 * @returns a promise that may be resolved with the given resolve and reject
 * functions, or rejected by a thrown exception in resolver
 */
Q.Promise = promise; // ES6
Q.promise = promise;
function promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function.");
    }
    var deferred = defer();
    try {
        resolver(deferred.resolve, deferred.reject, deferred.notify);
    } catch (reason) {
        deferred.reject(reason);
    }
    return deferred.promise;
}

promise.race = race; // ES6
promise.all = all; // ES6
promise.reject = reject; // ES6
promise.resolve = Q; // ES6

// XXX experimental.  This method is a way to denote that a local value is
// serializable and should be immediately dispatched to a remote upon request,
// instead of passing a reference.
Q.passByCopy = function (object) {
    //freeze(object);
    //passByCopies.set(object, true);
    return object;
};

Promise.prototype.passByCopy = function () {
    //freeze(object);
    //passByCopies.set(object, true);
    return this;
};

/**
 * If two promises eventually fulfill to the same value, promises that value,
 * but otherwise rejects.
 * @param x {Any*}
 * @param y {Any*}
 * @returns {Any*} a promise for x and y if they are the same, but a rejection
 * otherwise.
 *
 */
Q.join = function (x, y) {
    return Q(x).join(y);
};

Promise.prototype.join = function (that) {
    return Q([this, that]).spread(function (x, y) {
        if (x === y) {
            // TODO: "===" should be Object.is or equiv
            return x;
        } else {
            throw new Error("Can't join: not the same: " + x + " " + y);
        }
    });
};

/**
 * Returns a promise for the first of an array of promises to become settled.
 * @param answers {Array[Any*]} promises to race
 * @returns {Any*} the first promise to be settled
 */
Q.race = race;
function race(answerPs) {
    return promise(function (resolve, reject) {
        // Switch to this once we can assume at least ES5
        // answerPs.forEach(function (answerP) {
        //     Q(answerP).then(resolve, reject);
        // });
        // Use this in the meantime
        for (var i = 0, len = answerPs.length; i < len; i++) {
            Q(answerPs[i]).then(resolve, reject);
        }
    });
}

Promise.prototype.race = function () {
    return this.then(Q.race);
};

/**
 * Constructs a Promise with a promise descriptor object and optional fallback
 * function.  The descriptor contains methods like when(rejected), get(name),
 * set(name, value), post(name, args), and delete(name), which all
 * return either a value, a promise for a value, or a rejection.  The fallback
 * accepts the operation name, a resolver, and any further arguments that would
 * have been forwarded to the appropriate method above had a method been
 * provided with the proper name.  The API makes no guarantees about the nature
 * of the returned object, apart from that it is usable whereever promises are
 * bought and sold.
 */
Q.makePromise = Promise;
function Promise(descriptor, fallback, inspect) {
    if (fallback === void 0) {
        fallback = function (op) {
            return reject(new Error(
                "Promise does not support operation: " + op
            ));
        };
    }
    if (inspect === void 0) {
        inspect = function () {
            return {state: "unknown"};
        };
    }

    var promise = object_create(Promise.prototype);

    promise.promiseDispatch = function (resolve, op, args) {
        var result;
        try {
            if (descriptor[op]) {
                result = descriptor[op].apply(promise, args);
            } else {
                result = fallback.call(promise, op, args);
            }
        } catch (exception) {
            result = reject(exception);
        }
        if (resolve) {
            resolve(result);
        }
    };

    promise.inspect = inspect;

    // XXX deprecated `valueOf` and `exception` support
    if (inspect) {
        var inspected = inspect();
        if (inspected.state === "rejected") {
            promise.exception = inspected.reason;
        }

        promise.valueOf = function () {
            var inspected = inspect();
            if (inspected.state === "pending" ||
                inspected.state === "rejected") {
                return promise;
            }
            return inspected.value;
        };
    }

    return promise;
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.then = function (fulfilled, rejected, progressed) {
    var self = this;
    var deferred = defer();
    var done = false;   // ensure the untrusted promise makes at most a
                        // single call to one of the callbacks

    function _fulfilled(value) {
        try {
            return typeof fulfilled === "function" ? fulfilled(value) : value;
        } catch (exception) {
            return reject(exception);
        }
    }

    function _rejected(exception) {
        if (typeof rejected === "function") {
            makeStackTraceLong(exception, self);
            try {
                return rejected(exception);
            } catch (newException) {
                return reject(newException);
            }
        }
        return reject(exception);
    }

    function _progressed(value) {
        return typeof progressed === "function" ? progressed(value) : value;
    }

    Q.nextTick(function () {
        self.promiseDispatch(function (value) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_fulfilled(value));
        }, "when", [function (exception) {
            if (done) {
                return;
            }
            done = true;

            deferred.resolve(_rejected(exception));
        }]);
    });

    // Progress propagator need to be attached in the current tick.
    self.promiseDispatch(void 0, "when", [void 0, function (value) {
        var newValue;
        var threw = false;
        try {
            newValue = _progressed(value);
        } catch (e) {
            threw = true;
            if (Q.onerror) {
                Q.onerror(e);
            } else {
                throw e;
            }
        }

        if (!threw) {
            deferred.notify(newValue);
        }
    }]);

    return deferred.promise;
};

Q.tap = function (promise, callback) {
    return Q(promise).tap(callback);
};

/**
 * Works almost like "finally", but not called for rejections.
 * Original resolution value is passed through callback unaffected.
 * Callback may return a promise that will be awaited for.
 * @param {Function} callback
 * @returns {Q.Promise}
 * @example
 * doSomething()
 *   .then(...)
 *   .tap(console.log)
 *   .then(...);
 */
Promise.prototype.tap = function (callback) {
    callback = Q(callback);

    return this.then(function (value) {
        return callback.fcall(value).thenResolve(value);
    });
};

/**
 * Registers an observer on a promise.
 *
 * Guarantees:
 *
 * 1. that fulfilled and rejected will be called only once.
 * 2. that either the fulfilled callback or the rejected callback will be
 *    called, but not both.
 * 3. that fulfilled and rejected will not be called in this turn.
 *
 * @param value      promise or immediate reference to observe
 * @param fulfilled  function to be called with the fulfilled value
 * @param rejected   function to be called with the rejection exception
 * @param progressed function to be called on any progress notifications
 * @return promise for the return value from the invoked callback
 */
Q.when = when;
function when(value, fulfilled, rejected, progressed) {
    return Q(value).then(fulfilled, rejected, progressed);
}

Promise.prototype.thenResolve = function (value) {
    return this.then(function () { return value; });
};

Q.thenResolve = function (promise, value) {
    return Q(promise).thenResolve(value);
};

Promise.prototype.thenReject = function (reason) {
    return this.then(function () { throw reason; });
};

Q.thenReject = function (promise, reason) {
    return Q(promise).thenReject(reason);
};

/**
 * If an object is not a promise, it is as "near" as possible.
 * If a promise is rejected, it is as "near" as possible too.
 * If it’s a fulfilled promise, the fulfillment value is nearer.
 * If it’s a deferred promise and the deferred has been resolved, the
 * resolution is "nearer".
 * @param object
 * @returns most resolved (nearest) form of the object
 */

// XXX should we re-do this?
Q.nearer = nearer;
function nearer(value) {
    if (isPromise(value)) {
        var inspected = value.inspect();
        if (inspected.state === "fulfilled") {
            return inspected.value;
        }
    }
    return value;
}

/**
 * @returns whether the given object is a promise.
 * Otherwise it is a fulfilled value.
 */
Q.isPromise = isPromise;
function isPromise(object) {
    return object instanceof Promise;
}

Q.isPromiseAlike = isPromiseAlike;
function isPromiseAlike(object) {
    return isObject(object) && typeof object.then === "function";
}

/**
 * @returns whether the given object is a pending promise, meaning not
 * fulfilled or rejected.
 */
Q.isPending = isPending;
function isPending(object) {
    return isPromise(object) && object.inspect().state === "pending";
}

Promise.prototype.isPending = function () {
    return this.inspect().state === "pending";
};

/**
 * @returns whether the given object is a value or fulfilled
 * promise.
 */
Q.isFulfilled = isFulfilled;
function isFulfilled(object) {
    return !isPromise(object) || object.inspect().state === "fulfilled";
}

Promise.prototype.isFulfilled = function () {
    return this.inspect().state === "fulfilled";
};

/**
 * @returns whether the given object is a rejected promise.
 */
Q.isRejected = isRejected;
function isRejected(object) {
    return isPromise(object) && object.inspect().state === "rejected";
}

Promise.prototype.isRejected = function () {
    return this.inspect().state === "rejected";
};

//// BEGIN UNHANDLED REJECTION TRACKING

// This promise library consumes exceptions thrown in handlers so they can be
// handled by a subsequent promise.  The exceptions get added to this array when
// they are created, and removed when they are handled.  Note that in ES6 or
// shimmed environments, this would naturally be a `Set`.
var unhandledReasons = [];
var unhandledRejections = [];
var reportedUnhandledRejections = [];
var trackUnhandledRejections = true;

function resetUnhandledRejections() {
    unhandledReasons.length = 0;
    unhandledRejections.length = 0;

    if (!trackUnhandledRejections) {
        trackUnhandledRejections = true;
    }
}

function trackRejection(promise, reason) {
    if (!trackUnhandledRejections) {
        return;
    }
    if (typeof process === "object" && typeof process.emit === "function") {
        Q.nextTick.runAfter(function () {
            if (array_indexOf(unhandledRejections, promise) !== -1) {
                process.emit("unhandledRejection", reason, promise);
                reportedUnhandledRejections.push(promise);
            }
        });
    }

    unhandledRejections.push(promise);
    if (reason && typeof reason.stack !== "undefined") {
        unhandledReasons.push(reason.stack);
    } else {
        unhandledReasons.push("(no stack) " + reason);
    }
}

function untrackRejection(promise) {
    if (!trackUnhandledRejections) {
        return;
    }

    var at = array_indexOf(unhandledRejections, promise);
    if (at !== -1) {
        if (typeof process === "object" && typeof process.emit === "function") {
            Q.nextTick.runAfter(function () {
                var atReport = array_indexOf(reportedUnhandledRejections, promise);
                if (atReport !== -1) {
                    process.emit("rejectionHandled", unhandledReasons[at], promise);
                    reportedUnhandledRejections.splice(atReport, 1);
                }
            });
        }
        unhandledRejections.splice(at, 1);
        unhandledReasons.splice(at, 1);
    }
}

Q.resetUnhandledRejections = resetUnhandledRejections;

Q.getUnhandledReasons = function () {
    // Make a copy so that consumers can't interfere with our internal state.
    return unhandledReasons.slice();
};

Q.stopUnhandledRejectionTracking = function () {
    resetUnhandledRejections();
    trackUnhandledRejections = false;
};

resetUnhandledRejections();

//// END UNHANDLED REJECTION TRACKING

/**
 * Constructs a rejected promise.
 * @param reason value describing the failure
 */
Q.reject = reject;
function reject(reason) {
    var rejection = Promise({
        "when": function (rejected) {
            // note that the error has been handled
            if (rejected) {
                untrackRejection(this);
            }
            return rejected ? rejected(reason) : this;
        }
    }, function fallback() {
        return this;
    }, function inspect() {
        return { state: "rejected", reason: reason };
    });

    // Note that the reason has not been handled.
    trackRejection(rejection, reason);

    return rejection;
}

/**
 * Constructs a fulfilled promise for an immediate reference.
 * @param value immediate reference
 */
Q.fulfill = fulfill;
function fulfill(value) {
    return Promise({
        "when": function () {
            return value;
        },
        "get": function (name) {
            return value[name];
        },
        "set": function (name, rhs) {
            value[name] = rhs;
        },
        "delete": function (name) {
            delete value[name];
        },
        "post": function (name, args) {
            // Mark Miller proposes that post with no name should apply a
            // promised function.
            if (name === null || name === void 0) {
                return value.apply(void 0, args);
            } else {
                return value[name].apply(value, args);
            }
        },
        "apply": function (thisp, args) {
            return value.apply(thisp, args);
        },
        "keys": function () {
            return object_keys(value);
        }
    }, void 0, function inspect() {
        return { state: "fulfilled", value: value };
    });
}

/**
 * Converts thenables to Q promises.
 * @param promise thenable promise
 * @returns a Q promise
 */
function coerce(promise) {
    var deferred = defer();
    Q.nextTick(function () {
        try {
            promise.then(deferred.resolve, deferred.reject, deferred.notify);
        } catch (exception) {
            deferred.reject(exception);
        }
    });
    return deferred.promise;
}

/**
 * Annotates an object such that it will never be
 * transferred away from this process over any promise
 * communication channel.
 * @param object
 * @returns promise a wrapping of that object that
 * additionally responds to the "isDef" message
 * without a rejection.
 */
Q.master = master;
function master(object) {
    return Promise({
        "isDef": function () {}
    }, function fallback(op, args) {
        return dispatch(object, op, args);
    }, function () {
        return Q(object).inspect();
    });
}

/**
 * Spreads the values of a promised array of arguments into the
 * fulfillment callback.
 * @param fulfilled callback that receives variadic arguments from the
 * promised array
 * @param rejected callback that receives the exception if the promise
 * is rejected.
 * @returns a promise for the return value or thrown exception of
 * either callback.
 */
Q.spread = spread;
function spread(value, fulfilled, rejected) {
    return Q(value).spread(fulfilled, rejected);
}

Promise.prototype.spread = function (fulfilled, rejected) {
    return this.all().then(function (array) {
        return fulfilled.apply(void 0, array);
    }, rejected);
};

/**
 * The async function is a decorator for generator functions, turning
 * them into asynchronous generators.  Although generators are only part
 * of the newest ECMAScript 6 drafts, this code does not cause syntax
 * errors in older engines.  This code should continue to work and will
 * in fact improve over time as the language improves.
 *
 * ES6 generators are currently part of V8 version 3.19 with the
 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
 * for longer, but under an older Python-inspired form.  This function
 * works on both kinds of generators.
 *
 * Decorates a generator function such that:
 *  - it may yield promises
 *  - execution will continue when that promise is fulfilled
 *  - the value of the yield expression will be the fulfilled value
 *  - it returns a promise for the return value (when the generator
 *    stops iterating)
 *  - the decorated function returns a promise for the return value
 *    of the generator or the first rejected promise among those
 *    yielded.
 *  - if an error is thrown in the generator, it propagates through
 *    every following yield until it is caught, or until it escapes
 *    the generator function altogether, and is translated into a
 *    rejection for the promise returned by the decorated generator.
 */
Q.async = async;
function async(makeGenerator) {
    return function () {
        // when verb is "send", arg is a value
        // when verb is "throw", arg is an exception
        function continuer(verb, arg) {
            var result;

            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
            // engine that has a deployed base of browsers that support generators.
            // However, SM's generators use the Python-inspired semantics of
            // outdated ES6 drafts.  We would like to support ES6, but we'd also
            // like to make it possible to use generators in deployed browsers, so
            // we also support Python-style generators.  At some point we can remove
            // this block.

            if (typeof StopIteration === "undefined") {
                // ES6 Generators
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    return reject(exception);
                }
                if (result.done) {
                    return Q(result.value);
                } else {
                    return when(result.value, callback, errback);
                }
            } else {
                // SpiderMonkey Generators
                // FIXME: Remove this case when SM does ES6 generators.
                try {
                    result = generator[verb](arg);
                } catch (exception) {
                    if (isStopIteration(exception)) {
                        return Q(exception.value);
                    } else {
                        return reject(exception);
                    }
                }
                return when(result, callback, errback);
            }
        }
        var generator = makeGenerator.apply(this, arguments);
        var callback = continuer.bind(continuer, "next");
        var errback = continuer.bind(continuer, "throw");
        return callback();
    };
}

/**
 * The spawn function is a small wrapper around async that immediately
 * calls the generator and also ends the promise chain, so that any
 * unhandled errors are thrown instead of forwarded to the error
 * handler. This is useful because it's extremely common to run
 * generators at the top-level to work with libraries.
 */
Q.spawn = spawn;
function spawn(makeGenerator) {
    Q.done(Q.async(makeGenerator)());
}

// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
/**
 * Throws a ReturnValue exception to stop an asynchronous generator.
 *
 * This interface is a stop-gap measure to support generator return
 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
 * generators like Chromium 29, just use "return" in your generator
 * functions.
 *
 * @param value the return value for the surrounding generator
 * @throws ReturnValue exception with the value.
 * @example
 * // ES6 style
 * Q.async(function* () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      return foo + bar;
 * })
 * // Older SpiderMonkey style
 * Q.async(function () {
 *      var foo = yield getFooPromise();
 *      var bar = yield getBarPromise();
 *      Q.return(foo + bar);
 * })
 */
Q["return"] = _return;
function _return(value) {
    throw new QReturnValue(value);
}

/**
 * The promised function decorator ensures that any promise arguments
 * are settled and passed as values (`this` is also settled and passed
 * as a value).  It will also ensure that the result of a function is
 * always a promise.
 *
 * @example
 * var add = Q.promised(function (a, b) {
 *     return a + b;
 * });
 * add(Q(a), Q(B));
 *
 * @param {function} callback The function to decorate
 * @returns {function} a function that has been decorated.
 */
Q.promised = promised;
function promised(callback) {
    return function () {
        return spread([this, all(arguments)], function (self, args) {
            return callback.apply(self, args);
        });
    };
}

/**
 * sends a message to a value in a future turn
 * @param object* the recipient
 * @param op the name of the message operation, e.g., "when",
 * @param args further arguments to be forwarded to the operation
 * @returns result {Promise} a promise for the result of the operation
 */
Q.dispatch = dispatch;
function dispatch(object, op, args) {
    return Q(object).dispatch(op, args);
}

Promise.prototype.dispatch = function (op, args) {
    var self = this;
    var deferred = defer();
    Q.nextTick(function () {
        self.promiseDispatch(deferred.resolve, op, args);
    });
    return deferred.promise;
};

/**
 * Gets the value of a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to get
 * @return promise for the property value
 */
Q.get = function (object, key) {
    return Q(object).dispatch("get", [key]);
};

Promise.prototype.get = function (key) {
    return this.dispatch("get", [key]);
};

/**
 * Sets the value of a property in a future turn.
 * @param object    promise or immediate reference for object object
 * @param name      name of property to set
 * @param value     new value of property
 * @return promise for the return value
 */
Q.set = function (object, key, value) {
    return Q(object).dispatch("set", [key, value]);
};

Promise.prototype.set = function (key, value) {
    return this.dispatch("set", [key, value]);
};

/**
 * Deletes a property in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of property to delete
 * @return promise for the return value
 */
Q.del = // XXX legacy
Q["delete"] = function (object, key) {
    return Q(object).dispatch("delete", [key]);
};

Promise.prototype.del = // XXX legacy
Promise.prototype["delete"] = function (key) {
    return this.dispatch("delete", [key]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param value     a value to post, typically an array of
 *                  invocation arguments for promises that
 *                  are ultimately backed with `resolve` values,
 *                  as opposed to those backed with URLs
 *                  wherein the posted value can be any
 *                  JSON serializable object.
 * @return promise for the return value
 */
// bound locally because it is used by other methods
Q.mapply = // XXX As proposed by "Redsandro"
Q.post = function (object, name, args) {
    return Q(object).dispatch("post", [name, args]);
};

Promise.prototype.mapply = // XXX As proposed by "Redsandro"
Promise.prototype.post = function (name, args) {
    return this.dispatch("post", [name, args]);
};

/**
 * Invokes a method in a future turn.
 * @param object    promise or immediate reference for target object
 * @param name      name of method to invoke
 * @param ...args   array of invocation arguments
 * @return promise for the return value
 */
Q.send = // XXX Mark Miller's proposed parlance
Q.mcall = // XXX As proposed by "Redsandro"
Q.invoke = function (object, name /*...args*/) {
    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
};

Promise.prototype.send = // XXX Mark Miller's proposed parlance
Promise.prototype.mcall = // XXX As proposed by "Redsandro"
Promise.prototype.invoke = function (name /*...args*/) {
    return this.dispatch("post", [name, array_slice(arguments, 1)]);
};

/**
 * Applies the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param args      array of application arguments
 */
Q.fapply = function (object, args) {
    return Q(object).dispatch("apply", [void 0, args]);
};

Promise.prototype.fapply = function (args) {
    return this.dispatch("apply", [void 0, args]);
};

/**
 * Calls the promised function in a future turn.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q["try"] =
Q.fcall = function (object /* ...args*/) {
    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
};

Promise.prototype.fcall = function (/*...args*/) {
    return this.dispatch("apply", [void 0, array_slice(arguments)]);
};

/**
 * Binds the promised function, transforming return values into a fulfilled
 * promise and thrown errors into a rejected one.
 * @param object    promise or immediate reference for target function
 * @param ...args   array of application arguments
 */
Q.fbind = function (object /*...args*/) {
    var promise = Q(object);
    var args = array_slice(arguments, 1);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};
Promise.prototype.fbind = function (/*...args*/) {
    var promise = this;
    var args = array_slice(arguments);
    return function fbound() {
        return promise.dispatch("apply", [
            this,
            args.concat(array_slice(arguments))
        ]);
    };
};

/**
 * Requests the names of the owned properties of a promised
 * object in a future turn.
 * @param object    promise or immediate reference for target object
 * @return promise for the keys of the eventually settled object
 */
Q.keys = function (object) {
    return Q(object).dispatch("keys", []);
};

Promise.prototype.keys = function () {
    return this.dispatch("keys", []);
};

/**
 * Turns an array of promises into a promise for an array.  If any of
 * the promises gets rejected, the whole array is rejected immediately.
 * @param {Array*} an array (or promise for an array) of values (or
 * promises for values)
 * @returns a promise for an array of the corresponding values
 */
// By Mark Miller
// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
Q.all = all;
function all(promises) {
    return when(promises, function (promises) {
        var pendingCount = 0;
        var deferred = defer();
        array_reduce(promises, function (undefined, promise, index) {
            var snapshot;
            if (
                isPromise(promise) &&
                (snapshot = promise.inspect()).state === "fulfilled"
            ) {
                promises[index] = snapshot.value;
            } else {
                ++pendingCount;
                when(
                    promise,
                    function (value) {
                        promises[index] = value;
                        if (--pendingCount === 0) {
                            deferred.resolve(promises);
                        }
                    },
                    deferred.reject,
                    function (progress) {
                        deferred.notify({ index: index, value: progress });
                    }
                );
            }
        }, void 0);
        if (pendingCount === 0) {
            deferred.resolve(promises);
        }
        return deferred.promise;
    });
}

Promise.prototype.all = function () {
    return all(this);
};

/**
 * Returns the first resolved promise of an array. Prior rejected promises are
 * ignored.  Rejects only if all promises are rejected.
 * @param {Array*} an array containing values or promises for values
 * @returns a promise fulfilled with the value of the first resolved promise,
 * or a rejected promise if all promises are rejected.
 */
Q.any = any;

function any(promises) {
    if (promises.length === 0) {
        return Q.resolve();
    }

    var deferred = Q.defer();
    var pendingCount = 0;
    array_reduce(promises, function (prev, current, index) {
        var promise = promises[index];

        pendingCount++;

        when(promise, onFulfilled, onRejected, onProgress);
        function onFulfilled(result) {
            deferred.resolve(result);
        }
        function onRejected() {
            pendingCount--;
            if (pendingCount === 0) {
                deferred.reject(new Error(
                    "Can't get fulfillment value from any promise, all " +
                    "promises were rejected."
                ));
            }
        }
        function onProgress(progress) {
            deferred.notify({
                index: index,
                value: progress
            });
        }
    }, undefined);

    return deferred.promise;
}

Promise.prototype.any = function () {
    return any(this);
};

/**
 * Waits for all promises to be settled, either fulfilled or
 * rejected.  This is distinct from `all` since that would stop
 * waiting at the first rejection.  The promise returned by
 * `allResolved` will never be rejected.
 * @param promises a promise for an array (or an array) of promises
 * (or values)
 * @return a promise for an array of promises
 */
Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
function allResolved(promises) {
    return when(promises, function (promises) {
        promises = array_map(promises, Q);
        return when(all(array_map(promises, function (promise) {
            return when(promise, noop, noop);
        })), function () {
            return promises;
        });
    });
}

Promise.prototype.allResolved = function () {
    return allResolved(this);
};

/**
 * @see Promise#allSettled
 */
Q.allSettled = allSettled;
function allSettled(promises) {
    return Q(promises).allSettled();
}

/**
 * Turns an array of promises into a promise for an array of their states (as
 * returned by `inspect`) when they have all settled.
 * @param {Array[Any*]} values an array (or promise for an array) of values (or
 * promises for values)
 * @returns {Array[State]} an array of states for the respective values.
 */
Promise.prototype.allSettled = function () {
    return this.then(function (promises) {
        return all(array_map(promises, function (promise) {
            promise = Q(promise);
            function regardless() {
                return promise.inspect();
            }
            return promise.then(regardless, regardless);
        }));
    });
};

/**
 * Captures the failure of a promise, giving an oportunity to recover
 * with a callback.  If the given promise is fulfilled, the returned
 * promise is fulfilled.
 * @param {Any*} promise for something
 * @param {Function} callback to fulfill the returned promise if the
 * given promise is rejected
 * @returns a promise for the return value of the callback
 */
Q.fail = // XXX legacy
Q["catch"] = function (object, rejected) {
    return Q(object).then(void 0, rejected);
};

Promise.prototype.fail = // XXX legacy
Promise.prototype["catch"] = function (rejected) {
    return this.then(void 0, rejected);
};

/**
 * Attaches a listener that can respond to progress notifications from a
 * promise's originating deferred. This listener receives the exact arguments
 * passed to ``deferred.notify``.
 * @param {Any*} promise for something
 * @param {Function} callback to receive any progress notifications
 * @returns the given promise, unchanged
 */
Q.progress = progress;
function progress(object, progressed) {
    return Q(object).then(void 0, void 0, progressed);
}

Promise.prototype.progress = function (progressed) {
    return this.then(void 0, void 0, progressed);
};

/**
 * Provides an opportunity to observe the settling of a promise,
 * regardless of whether the promise is fulfilled or rejected.  Forwards
 * the resolution to the returned promise when the callback is done.
 * The callback can return a promise to defer completion.
 * @param {Any*} promise
 * @param {Function} callback to observe the resolution of the given
 * promise, takes no arguments.
 * @returns a promise for the resolution of the given promise when
 * ``fin`` is done.
 */
Q.fin = // XXX legacy
Q["finally"] = function (object, callback) {
    return Q(object)["finally"](callback);
};

Promise.prototype.fin = // XXX legacy
Promise.prototype["finally"] = function (callback) {
    callback = Q(callback);
    return this.then(function (value) {
        return callback.fcall().then(function () {
            return value;
        });
    }, function (reason) {
        // TODO attempt to recycle the rejection with "this".
        return callback.fcall().then(function () {
            throw reason;
        });
    });
};

/**
 * Terminates a chain of promises, forcing rejections to be
 * thrown as exceptions.
 * @param {Any*} promise at the end of a chain of promises
 * @returns nothing
 */
Q.done = function (object, fulfilled, rejected, progress) {
    return Q(object).done(fulfilled, rejected, progress);
};

Promise.prototype.done = function (fulfilled, rejected, progress) {
    var onUnhandledError = function (error) {
        // forward to a future turn so that ``when``
        // does not catch it and turn it into a rejection.
        Q.nextTick(function () {
            makeStackTraceLong(error, promise);
            if (Q.onerror) {
                Q.onerror(error);
            } else {
                throw error;
            }
        });
    };

    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
    var promise = fulfilled || rejected || progress ?
        this.then(fulfilled, rejected, progress) :
        this;

    if (typeof process === "object" && process && process.domain) {
        onUnhandledError = process.domain.bind(onUnhandledError);
    }

    promise.then(void 0, onUnhandledError);
};

/**
 * Causes a promise to be rejected if it does not get fulfilled before
 * some milliseconds time out.
 * @param {Any*} promise
 * @param {Number} milliseconds timeout
 * @param {Any*} custom error message or Error object (optional)
 * @returns a promise for the resolution of the given promise if it is
 * fulfilled before the timeout, otherwise rejected.
 */
Q.timeout = function (object, ms, error) {
    return Q(object).timeout(ms, error);
};

Promise.prototype.timeout = function (ms, error) {
    var deferred = defer();
    var timeoutId = setTimeout(function () {
        if (!error || "string" === typeof error) {
            error = new Error(error || "Timed out after " + ms + " ms");
            error.code = "ETIMEDOUT";
        }
        deferred.reject(error);
    }, ms);

    this.then(function (value) {
        clearTimeout(timeoutId);
        deferred.resolve(value);
    }, function (exception) {
        clearTimeout(timeoutId);
        deferred.reject(exception);
    }, deferred.notify);

    return deferred.promise;
};

/**
 * Returns a promise for the given value (or promised value), some
 * milliseconds after it resolved. Passes rejections immediately.
 * @param {Any*} promise
 * @param {Number} milliseconds
 * @returns a promise for the resolution of the given promise after milliseconds
 * time has elapsed since the resolution of the given promise.
 * If the given promise rejects, that is passed immediately.
 */
Q.delay = function (object, timeout) {
    if (timeout === void 0) {
        timeout = object;
        object = void 0;
    }
    return Q(object).delay(timeout);
};

Promise.prototype.delay = function (timeout) {
    return this.then(function (value) {
        var deferred = defer();
        setTimeout(function () {
            deferred.resolve(value);
        }, timeout);
        return deferred.promise;
    });
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided as an array, and returns a promise.
 *
 *      Q.nfapply(FS.readFile, [__filename])
 *      .then(function (content) {
 *      })
 *
 */
Q.nfapply = function (callback, args) {
    return Q(callback).nfapply(args);
};

Promise.prototype.nfapply = function (args) {
    var deferred = defer();
    var nodeArgs = array_slice(args);
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Passes a continuation to a Node function, which is called with the given
 * arguments provided individually, and returns a promise.
 * @example
 * Q.nfcall(FS.readFile, __filename)
 * .then(function (content) {
 * })
 *
 */
Q.nfcall = function (callback /*...args*/) {
    var args = array_slice(arguments, 1);
    return Q(callback).nfapply(args);
};

Promise.prototype.nfcall = function (/*...args*/) {
    var nodeArgs = array_slice(arguments);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.fapply(nodeArgs).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Wraps a NodeJS continuation passing function and returns an equivalent
 * version that returns a promise.
 * @example
 * Q.nfbind(FS.readFile, __filename)("utf-8")
 * .then(console.log)
 * .done()
 */
Q.nfbind =
Q.denodeify = function (callback /*...args*/) {
    var baseArgs = array_slice(arguments, 1);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        Q(callback).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nfbind =
Promise.prototype.denodeify = function (/*...args*/) {
    var args = array_slice(arguments);
    args.unshift(this);
    return Q.denodeify.apply(void 0, args);
};

Q.nbind = function (callback, thisp /*...args*/) {
    var baseArgs = array_slice(arguments, 2);
    return function () {
        var nodeArgs = baseArgs.concat(array_slice(arguments));
        var deferred = defer();
        nodeArgs.push(deferred.makeNodeResolver());
        function bound() {
            return callback.apply(thisp, arguments);
        }
        Q(bound).fapply(nodeArgs).fail(deferred.reject);
        return deferred.promise;
    };
};

Promise.prototype.nbind = function (/*thisp, ...args*/) {
    var args = array_slice(arguments, 0);
    args.unshift(this);
    return Q.nbind.apply(void 0, args);
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback with a given array of arguments, plus a provided callback.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param {Array} args arguments to pass to the method; the callback
 * will be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nmapply = // XXX As proposed by "Redsandro"
Q.npost = function (object, name, args) {
    return Q(object).npost(name, args);
};

Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
Promise.prototype.npost = function (name, args) {
    var nodeArgs = array_slice(args || []);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * Calls a method of a Node-style object that accepts a Node-style
 * callback, forwarding the given variadic arguments, plus a provided
 * callback argument.
 * @param object an object that has the named method
 * @param {String} name name of the method of object
 * @param ...args arguments to pass to the method; the callback will
 * be provided by Q and appended to these arguments.
 * @returns a promise for the value or error
 */
Q.nsend = // XXX Based on Mark Miller's proposed "send"
Q.nmcall = // XXX Based on "Redsandro's" proposal
Q.ninvoke = function (object, name /*...args*/) {
    var nodeArgs = array_slice(arguments, 2);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
Promise.prototype.ninvoke = function (name /*...args*/) {
    var nodeArgs = array_slice(arguments, 1);
    var deferred = defer();
    nodeArgs.push(deferred.makeNodeResolver());
    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
    return deferred.promise;
};

/**
 * If a function would like to support both Node continuation-passing-style and
 * promise-returning-style, it can end its internal promise chain with
 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
 * elects to use a nodeback, the result will be sent there.  If they do not
 * pass a nodeback, they will receive the result promise.
 * @param object a result (or a promise for a result)
 * @param {Function} nodeback a Node.js-style callback
 * @returns either the promise or nothing
 */
Q.nodeify = nodeify;
function nodeify(object, nodeback) {
    return Q(object).nodeify(nodeback);
}

Promise.prototype.nodeify = function (nodeback) {
    if (nodeback) {
        this.then(function (value) {
            Q.nextTick(function () {
                nodeback(null, value);
            });
        }, function (error) {
            Q.nextTick(function () {
                nodeback(error);
            });
        });
    } else {
        return this;
    }
};

Q.noConflict = function() {
    throw new Error("Q.noConflict only works when Q is used as a global");
};

// All code before this point will be filtered from stack traces.
var qEndingLine = captureLine();

return Q;

});

}).call(this,require('_process'))
},{"_process":22}],443:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],444:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],445:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],446:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":445,"./bdsft":447,"./constants":450,"./cookieconfig":451,"./cookieprop":452,"./dateformat":455,"./debug":456,"./element":457,"./eventbus":458,"./factory":459,"./icon":460,"./loader":461,"./popup":462,"./prop":463,"./urlconfig":465,"./utils":466,"./visibleprop":467,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],447:[function(require,module,exports){
module.exports=require(54)
},{"./app":446,"./binding":448,"./classesbinding":449,"./databinder":454,"./stylesmanager":464,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":491}],448:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":447,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],449:[function(require,module,exports){
module.exports=require(56)
},{"./binding":448,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],450:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],451:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":447,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":491,"jquery.cookie":490}],452:[function(require,module,exports){
module.exports=require(59)
},{"./constants":450,"./prop":463,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":491,"jquery.cookie":490}],453:[function(require,module,exports){
module.exports=require(60)
},{"./constants":450,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":472}],454:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":475}],455:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],456:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":443,"./bdsft":447,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":468,"stacktrace-js":493}],457:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],458:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":447,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":475}],459:[function(require,module,exports){
module.exports=require(66)
},{"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":491}],460:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],461:[function(require,module,exports){
module.exports=require(68)
},{"../":446,"./constants":450,"./factory":459,"./stylesmanager":464,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":471}],462:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":491}],463:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":492}],464:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":444,"./constants":450,"./css":453,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],465:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":443,"./bdsft":447,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],466:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":445,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":491}],467:[function(require,module,exports){
module.exports=require(74)
},{"./constants":450,"./prop":463,"./utils":466,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],468:[function(require,module,exports){
module.exports=require(75)
},{"./debug":469,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],469:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":470}],470:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],471:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],472:[function(require,module,exports){
module.exports=require(79)
},{"./filters":473,"./utils":474,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],473:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],474:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],475:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":476,"es5-ext/object/valid-callable":485}],476:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":477,"es5-ext/object/is-callable":480,"es5-ext/object/normalize-options":484,"es5-ext/string/#/contains":487}],477:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":478,"./shim":479,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],478:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],479:[function(require,module,exports){
module.exports=require(86)
},{"../keys":481,"../valid-value":486,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],480:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],481:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":482,"./shim":483,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],482:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],483:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],484:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],485:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],486:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],487:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":488,"./shim":489,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],488:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],489:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],490:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":491}],491:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],492:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],493:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],494:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var xml2js;

  xml2js = require('../lib/xml2js');

  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);

},{"../lib/xml2js":496}],495:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

}).call(this);

},{}],496:[function(require,module,exports){
// Generated by CoffeeScript 1.9.2
(function() {
  var bom, builder, escapeCDATA, events, isEmpty, processName, processors, requiresCDATA, sax, wrapCDATA,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  sax = require('sax');

  events = require('events');

  builder = require('xmlbuilder');

  bom = require('./bom');

  processors = require('./processors');

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processName = function(processors, processedName) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      processedName = process(processedName);
    }
    return processedName;
  };

  requiresCDATA = function(entry) {
    return entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0;
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.processors = processors;

  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = exports.defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === exports.defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = arguments.callee(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = arguments.callee(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = exports.defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk;
      if (this.remaining.length <= this.options.chunkSize) {
        chunk = this.remaining;
        this.remaining = '';
        this.saxParser = this.saxParser.write(chunk);
        return this.saxParser.close();
      } else {
        chunk = this.remaining.substr(0, this.options.chunkSize);
        this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
        this.saxParser = this.saxParser.write(chunk);
        return setImmediate(this.processAsync);
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processName(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processName(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, err, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processName(_this.options.valueProcessors, obj[charkey]) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            try {
              obj = _this.options.validator(xpath, s && s[nodeName], obj);
            } catch (_error) {
              err = _error;
              _this.emit("error", err);
            }
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && text.replace(/\\n/g, '').trim() !== '') {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      str = str.toString();
      if (str.trim() === '') {
        this.emit("end", null);
        return true;
      }
      try {
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (_error) {
        err = _error;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;

  })(events.EventEmitter);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

}).call(this);

},{"./bom":494,"./processors":495,"events":13,"sax":497,"xmlbuilder":514}],497:[function(require,module,exports){
(function (Buffer){
// wrapper for non-node envs
;(function (sax) {

sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
sax.SAXParser = SAXParser
sax.SAXStream = SAXStream
sax.createStream = createStream

// When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
// When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
// since that's the earliest that a buffer overrun could occur.  This way, checks are
// as rare as required, but as often as necessary to ensure never crossing this bound.
// Furthermore, buffers are only tested at most once per write(), so passing a very
// large string into write() might have undesirable effects, but this is manageable by
// the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
// edge case, result in creating at most one complete copy of the string passed in.
// Set to Infinity to have unlimited buffers.
sax.MAX_BUFFER_LENGTH = 64 * 1024

var buffers = [
  "comment", "sgmlDecl", "textNode", "tagName", "doctype",
  "procInstName", "procInstBody", "entity", "attribName",
  "attribValue", "cdata", "script"
]

sax.EVENTS = // for discoverability.
  [ "text"
  , "processinginstruction"
  , "sgmldeclaration"
  , "doctype"
  , "comment"
  , "attribute"
  , "opentag"
  , "closetag"
  , "opencdata"
  , "cdata"
  , "closecdata"
  , "error"
  , "end"
  , "ready"
  , "script"
  , "opennamespace"
  , "closenamespace"
  ]

function SAXParser (strict, opt) {
  if (!(this instanceof SAXParser)) return new SAXParser(strict, opt)

  var parser = this
  clearBuffers(parser)
  parser.q = parser.c = ""
  parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
  parser.opt = opt || {}
  parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
  parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase"
  parser.tags = []
  parser.closed = parser.closedRoot = parser.sawRoot = false
  parser.tag = parser.error = null
  parser.strict = !!strict
  parser.noscript = !!(strict || parser.opt.noscript)
  parser.state = S.BEGIN
  parser.ENTITIES = Object.create(sax.ENTITIES)
  parser.attribList = []

  // namespaces form a prototype chain.
  // it always points at the current tag,
  // which protos to its parent tag.
  if (parser.opt.xmlns) parser.ns = Object.create(rootNS)

  // mostly just for error reporting
  parser.trackPosition = parser.opt.position !== false
  if (parser.trackPosition) {
    parser.position = parser.line = parser.column = 0
  }
  emit(parser, "onready")
}

if (!Object.create) Object.create = function (o) {
  function f () { this.__proto__ = o }
  f.prototype = o
  return new f
}

if (!Object.getPrototypeOf) Object.getPrototypeOf = function (o) {
  return o.__proto__
}

if (!Object.keys) Object.keys = function (o) {
  var a = []
  for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
  return a
}

function checkBufferLength (parser) {
  var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    , maxActual = 0
  for (var i = 0, l = buffers.length; i < l; i ++) {
    var len = parser[buffers[i]].length
    if (len > maxAllowed) {
      // Text/cdata nodes can get big, and since they're buffered,
      // we can get here under normal conditions.
      // Avoid issues by emitting the text node now,
      // so at least it won't get any bigger.
      switch (buffers[i]) {
        case "textNode":
          closeText(parser)
        break

        case "cdata":
          emitNode(parser, "oncdata", parser.cdata)
          parser.cdata = ""
        break

        case "script":
          emitNode(parser, "onscript", parser.script)
          parser.script = ""
        break

        default:
          error(parser, "Max buffer length exceeded: "+buffers[i])
      }
    }
    maxActual = Math.max(maxActual, len)
  }
  // schedule the next check for the earliest possible buffer overrun.
  parser.bufferCheckPosition = (sax.MAX_BUFFER_LENGTH - maxActual)
                             + parser.position
}

function clearBuffers (parser) {
  for (var i = 0, l = buffers.length; i < l; i ++) {
    parser[buffers[i]] = ""
  }
}

function flushBuffers (parser) {
  closeText(parser)
  if (parser.cdata !== "") {
    emitNode(parser, "oncdata", parser.cdata)
    parser.cdata = ""
  }
  if (parser.script !== "") {
    emitNode(parser, "onscript", parser.script)
    parser.script = ""
  }
}

SAXParser.prototype =
  { end: function () { end(this) }
  , write: write
  , resume: function () { this.error = null; return this }
  , close: function () { return this.write(null) }
  , flush: function () { flushBuffers(this) }
  }

try {
  var Stream = require("stream").Stream
} catch (ex) {
  var Stream = function () {}
}


var streamWraps = sax.EVENTS.filter(function (ev) {
  return ev !== "error" && ev !== "end"
})

function createStream (strict, opt) {
  return new SAXStream(strict, opt)
}

function SAXStream (strict, opt) {
  if (!(this instanceof SAXStream)) return new SAXStream(strict, opt)

  Stream.apply(this)

  this._parser = new SAXParser(strict, opt)
  this.writable = true
  this.readable = true


  var me = this

  this._parser.onend = function () {
    me.emit("end")
  }

  this._parser.onerror = function (er) {
    me.emit("error", er)

    // if didn't throw, then means error was handled.
    // go ahead and clear error, so we can write again.
    me._parser.error = null
  }

  this._decoder = null;

  streamWraps.forEach(function (ev) {
    Object.defineProperty(me, "on" + ev, {
      get: function () { return me._parser["on" + ev] },
      set: function (h) {
        if (!h) {
          me.removeAllListeners(ev)
          return me._parser["on"+ev] = h
        }
        me.on(ev, h)
      },
      enumerable: true,
      configurable: false
    })
  })
}

SAXStream.prototype = Object.create(Stream.prototype,
  { constructor: { value: SAXStream } })

SAXStream.prototype.write = function (data) {
  if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
    if (!this._decoder) {
      var SD = require('string_decoder').StringDecoder
      this._decoder = new SD('utf8')
    }
    data = this._decoder.write(data);
  }

  this._parser.write(data.toString())
  this.emit("data", data)
  return true
}

SAXStream.prototype.end = function (chunk) {
  if (chunk && chunk.length) this.write(chunk)
  this._parser.end()
  return true
}

SAXStream.prototype.on = function (ev, handler) {
  var me = this
  if (!me._parser["on"+ev] && streamWraps.indexOf(ev) !== -1) {
    me._parser["on"+ev] = function () {
      var args = arguments.length === 1 ? [arguments[0]]
               : Array.apply(null, arguments)
      args.splice(0, 0, ev)
      me.emit.apply(me, args)
    }
  }

  return Stream.prototype.on.call(me, ev, handler)
}



// character classes and tokens
var whitespace = "\r\n\t "
  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  , number = "0124356789"
  , letter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
  // (Letter | "_" | ":")
  , quote = "'\""
  , entity = number+letter+"#"
  , attribEnd = whitespace + ">"
  , CDATA = "[CDATA["
  , DOCTYPE = "DOCTYPE"
  , XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace"
  , XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/"
  , rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

// turn all the string character sets into character class objects.
whitespace = charClass(whitespace)
number = charClass(number)
letter = charClass(letter)

// http://www.w3.org/TR/REC-xml/#NT-NameStartChar
// This implementation works on strings, a single character at a time
// as such, it cannot ever support astral-plane characters (10000-EFFFF)
// without a significant breaking change to either this  parser, or the
// JavaScript language.  Implementation of an emoji-capable xml parser
// is left as an exercise for the reader.
var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040\.\d-]/

quote = charClass(quote)
entity = charClass(entity)
attribEnd = charClass(attribEnd)

function charClass (str) {
  return str.split("").reduce(function (s, c) {
    s[c] = true
    return s
  }, {})
}

function isRegExp (c) {
  return Object.prototype.toString.call(c) === '[object RegExp]'
}

function is (charclass, c) {
  return isRegExp(charclass) ? !!c.match(charclass) : charclass[c]
}

function not (charclass, c) {
  return !is(charclass, c)
}

var S = 0
sax.STATE =
{ BEGIN                     : S++
, TEXT                      : S++ // general stuff
, TEXT_ENTITY               : S++ // &amp and such.
, OPEN_WAKA                 : S++ // <
, SGML_DECL                 : S++ // <!BLARG
, SGML_DECL_QUOTED          : S++ // <!BLARG foo "bar
, DOCTYPE                   : S++ // <!DOCTYPE
, DOCTYPE_QUOTED            : S++ // <!DOCTYPE "//blah
, DOCTYPE_DTD               : S++ // <!DOCTYPE "//blah" [ ...
, DOCTYPE_DTD_QUOTED        : S++ // <!DOCTYPE "//blah" [ "foo
, COMMENT_STARTING          : S++ // <!-
, COMMENT                   : S++ // <!--
, COMMENT_ENDING            : S++ // <!-- blah -
, COMMENT_ENDED             : S++ // <!-- blah --
, CDATA                     : S++ // <![CDATA[ something
, CDATA_ENDING              : S++ // ]
, CDATA_ENDING_2            : S++ // ]]
, PROC_INST                 : S++ // <?hi
, PROC_INST_BODY            : S++ // <?hi there
, PROC_INST_ENDING          : S++ // <?hi "there" ?
, OPEN_TAG                  : S++ // <strong
, OPEN_TAG_SLASH            : S++ // <strong /
, ATTRIB                    : S++ // <a
, ATTRIB_NAME               : S++ // <a foo
, ATTRIB_NAME_SAW_WHITE     : S++ // <a foo _
, ATTRIB_VALUE              : S++ // <a foo=
, ATTRIB_VALUE_QUOTED       : S++ // <a foo="bar
, ATTRIB_VALUE_CLOSED       : S++ // <a foo="bar"
, ATTRIB_VALUE_UNQUOTED     : S++ // <a foo=bar
, ATTRIB_VALUE_ENTITY_Q     : S++ // <foo bar="&quot;"
, ATTRIB_VALUE_ENTITY_U     : S++ // <foo bar=&quot;
, CLOSE_TAG                 : S++ // </a
, CLOSE_TAG_SAW_WHITE       : S++ // </a   >
, SCRIPT                    : S++ // <script> ...
, SCRIPT_ENDING             : S++ // <script> ... <
}

sax.ENTITIES =
{ "amp" : "&"
, "gt" : ">"
, "lt" : "<"
, "quot" : "\""
, "apos" : "'"
, "AElig" : 198
, "Aacute" : 193
, "Acirc" : 194
, "Agrave" : 192
, "Aring" : 197
, "Atilde" : 195
, "Auml" : 196
, "Ccedil" : 199
, "ETH" : 208
, "Eacute" : 201
, "Ecirc" : 202
, "Egrave" : 200
, "Euml" : 203
, "Iacute" : 205
, "Icirc" : 206
, "Igrave" : 204
, "Iuml" : 207
, "Ntilde" : 209
, "Oacute" : 211
, "Ocirc" : 212
, "Ograve" : 210
, "Oslash" : 216
, "Otilde" : 213
, "Ouml" : 214
, "THORN" : 222
, "Uacute" : 218
, "Ucirc" : 219
, "Ugrave" : 217
, "Uuml" : 220
, "Yacute" : 221
, "aacute" : 225
, "acirc" : 226
, "aelig" : 230
, "agrave" : 224
, "aring" : 229
, "atilde" : 227
, "auml" : 228
, "ccedil" : 231
, "eacute" : 233
, "ecirc" : 234
, "egrave" : 232
, "eth" : 240
, "euml" : 235
, "iacute" : 237
, "icirc" : 238
, "igrave" : 236
, "iuml" : 239
, "ntilde" : 241
, "oacute" : 243
, "ocirc" : 244
, "ograve" : 242
, "oslash" : 248
, "otilde" : 245
, "ouml" : 246
, "szlig" : 223
, "thorn" : 254
, "uacute" : 250
, "ucirc" : 251
, "ugrave" : 249
, "uuml" : 252
, "yacute" : 253
, "yuml" : 255
, "copy" : 169
, "reg" : 174
, "nbsp" : 160
, "iexcl" : 161
, "cent" : 162
, "pound" : 163
, "curren" : 164
, "yen" : 165
, "brvbar" : 166
, "sect" : 167
, "uml" : 168
, "ordf" : 170
, "laquo" : 171
, "not" : 172
, "shy" : 173
, "macr" : 175
, "deg" : 176
, "plusmn" : 177
, "sup1" : 185
, "sup2" : 178
, "sup3" : 179
, "acute" : 180
, "micro" : 181
, "para" : 182
, "middot" : 183
, "cedil" : 184
, "ordm" : 186
, "raquo" : 187
, "frac14" : 188
, "frac12" : 189
, "frac34" : 190
, "iquest" : 191
, "times" : 215
, "divide" : 247
, "OElig" : 338
, "oelig" : 339
, "Scaron" : 352
, "scaron" : 353
, "Yuml" : 376
, "fnof" : 402
, "circ" : 710
, "tilde" : 732
, "Alpha" : 913
, "Beta" : 914
, "Gamma" : 915
, "Delta" : 916
, "Epsilon" : 917
, "Zeta" : 918
, "Eta" : 919
, "Theta" : 920
, "Iota" : 921
, "Kappa" : 922
, "Lambda" : 923
, "Mu" : 924
, "Nu" : 925
, "Xi" : 926
, "Omicron" : 927
, "Pi" : 928
, "Rho" : 929
, "Sigma" : 931
, "Tau" : 932
, "Upsilon" : 933
, "Phi" : 934
, "Chi" : 935
, "Psi" : 936
, "Omega" : 937
, "alpha" : 945
, "beta" : 946
, "gamma" : 947
, "delta" : 948
, "epsilon" : 949
, "zeta" : 950
, "eta" : 951
, "theta" : 952
, "iota" : 953
, "kappa" : 954
, "lambda" : 955
, "mu" : 956
, "nu" : 957
, "xi" : 958
, "omicron" : 959
, "pi" : 960
, "rho" : 961
, "sigmaf" : 962
, "sigma" : 963
, "tau" : 964
, "upsilon" : 965
, "phi" : 966
, "chi" : 967
, "psi" : 968
, "omega" : 969
, "thetasym" : 977
, "upsih" : 978
, "piv" : 982
, "ensp" : 8194
, "emsp" : 8195
, "thinsp" : 8201
, "zwnj" : 8204
, "zwj" : 8205
, "lrm" : 8206
, "rlm" : 8207
, "ndash" : 8211
, "mdash" : 8212
, "lsquo" : 8216
, "rsquo" : 8217
, "sbquo" : 8218
, "ldquo" : 8220
, "rdquo" : 8221
, "bdquo" : 8222
, "dagger" : 8224
, "Dagger" : 8225
, "bull" : 8226
, "hellip" : 8230
, "permil" : 8240
, "prime" : 8242
, "Prime" : 8243
, "lsaquo" : 8249
, "rsaquo" : 8250
, "oline" : 8254
, "frasl" : 8260
, "euro" : 8364
, "image" : 8465
, "weierp" : 8472
, "real" : 8476
, "trade" : 8482
, "alefsym" : 8501
, "larr" : 8592
, "uarr" : 8593
, "rarr" : 8594
, "darr" : 8595
, "harr" : 8596
, "crarr" : 8629
, "lArr" : 8656
, "uArr" : 8657
, "rArr" : 8658
, "dArr" : 8659
, "hArr" : 8660
, "forall" : 8704
, "part" : 8706
, "exist" : 8707
, "empty" : 8709
, "nabla" : 8711
, "isin" : 8712
, "notin" : 8713
, "ni" : 8715
, "prod" : 8719
, "sum" : 8721
, "minus" : 8722
, "lowast" : 8727
, "radic" : 8730
, "prop" : 8733
, "infin" : 8734
, "ang" : 8736
, "and" : 8743
, "or" : 8744
, "cap" : 8745
, "cup" : 8746
, "int" : 8747
, "there4" : 8756
, "sim" : 8764
, "cong" : 8773
, "asymp" : 8776
, "ne" : 8800
, "equiv" : 8801
, "le" : 8804
, "ge" : 8805
, "sub" : 8834
, "sup" : 8835
, "nsub" : 8836
, "sube" : 8838
, "supe" : 8839
, "oplus" : 8853
, "otimes" : 8855
, "perp" : 8869
, "sdot" : 8901
, "lceil" : 8968
, "rceil" : 8969
, "lfloor" : 8970
, "rfloor" : 8971
, "lang" : 9001
, "rang" : 9002
, "loz" : 9674
, "spades" : 9824
, "clubs" : 9827
, "hearts" : 9829
, "diams" : 9830
}

Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
})

for (var S in sax.STATE) sax.STATE[sax.STATE[S]] = S

// shorthand
S = sax.STATE

function emit (parser, event, data) {
  parser[event] && parser[event](data)
}

function emitNode (parser, nodeType, data) {
  if (parser.textNode) closeText(parser)
  emit(parser, nodeType, data)
}

function closeText (parser) {
  parser.textNode = textopts(parser.opt, parser.textNode)
  if (parser.textNode) emit(parser, "ontext", parser.textNode)
  parser.textNode = ""
}

function textopts (opt, text) {
  if (opt.trim) text = text.trim()
  if (opt.normalize) text = text.replace(/\s+/g, " ")
  return text
}

function error (parser, er) {
  closeText(parser)
  if (parser.trackPosition) {
    er += "\nLine: "+parser.line+
          "\nColumn: "+parser.column+
          "\nChar: "+parser.c
  }
  er = new Error(er)
  parser.error = er
  emit(parser, "onerror", er)
  return parser
}

function end (parser) {
  if (!parser.closedRoot) strictFail(parser, "Unclosed root tag")
  if ((parser.state !== S.BEGIN) && (parser.state !== S.TEXT)) error(parser, "Unexpected end")
  closeText(parser)
  parser.c = ""
  parser.closed = true
  emit(parser, "onend")
  SAXParser.call(parser, parser.strict, parser.opt)
  return parser
}

function strictFail (parser, message) {
  if (typeof parser !== 'object' || !(parser instanceof SAXParser))
    throw new Error('bad call to strictFail');
  if (parser.strict) error(parser, message)
}

function newTag (parser) {
  if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
  var parent = parser.tags[parser.tags.length - 1] || parser
    , tag = parser.tag = { name : parser.tagName, attributes : {} }

  // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
  if (parser.opt.xmlns) tag.ns = parent.ns
  parser.attribList.length = 0
}

function qname (name, attribute) {
  var i = name.indexOf(":")
    , qualName = i < 0 ? [ "", name ] : name.split(":")
    , prefix = qualName[0]
    , local = qualName[1]

  // <x "xmlns"="http://foo">
  if (attribute && name === "xmlns") {
    prefix = "xmlns"
    local = ""
  }

  return { prefix: prefix, local: local }
}

function attrib (parser) {
  if (!parser.strict) parser.attribName = parser.attribName[parser.looseCase]()

  if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
    return parser.attribName = parser.attribValue = ""
  }

  if (parser.opt.xmlns) {
    var qn = qname(parser.attribName, true)
      , prefix = qn.prefix
      , local = qn.local

    if (prefix === "xmlns") {
      // namespace binding attribute; push the binding into scope
      if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
        strictFail( parser
                  , "xml: prefix must be bound to " + XML_NAMESPACE + "\n"
                  + "Actual: " + parser.attribValue )
      } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
        strictFail( parser
                  , "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\n"
                  + "Actual: " + parser.attribValue )
      } else {
        var tag = parser.tag
          , parent = parser.tags[parser.tags.length - 1] || parser
        if (tag.ns === parent.ns) {
          tag.ns = Object.create(parent.ns)
        }
        tag.ns[local] = parser.attribValue
      }
    }

    // defer onattribute events until all attributes have been seen
    // so any new bindings can take effect; preserve attribute order
    // so deferred events can be emitted in document order
    parser.attribList.push([parser.attribName, parser.attribValue])
  } else {
    // in non-xmlns mode, we can emit the event right away
    parser.tag.attributes[parser.attribName] = parser.attribValue
    emitNode( parser
            , "onattribute"
            , { name: parser.attribName
              , value: parser.attribValue } )
  }

  parser.attribName = parser.attribValue = ""
}

function openTag (parser, selfClosing) {
  if (parser.opt.xmlns) {
    // emit namespace binding events
    var tag = parser.tag

    // add namespace info to tag
    var qn = qname(parser.tagName)
    tag.prefix = qn.prefix
    tag.local = qn.local
    tag.uri = tag.ns[qn.prefix] || ""

    if (tag.prefix && !tag.uri) {
      strictFail(parser, "Unbound namespace prefix: "
                       + JSON.stringify(parser.tagName))
      tag.uri = qn.prefix
    }

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (tag.ns && parent.ns !== tag.ns) {
      Object.keys(tag.ns).forEach(function (p) {
        emitNode( parser
                , "onopennamespace"
                , { prefix: p , uri: tag.ns[p] } )
      })
    }

    // handle deferred onattribute events
    // Note: do not apply default ns to attributes:
    //   http://www.w3.org/TR/REC-xml-names/#defaulting
    for (var i = 0, l = parser.attribList.length; i < l; i ++) {
      var nv = parser.attribList[i]
      var name = nv[0]
        , value = nv[1]
        , qualName = qname(name, true)
        , prefix = qualName.prefix
        , local = qualName.local
        , uri = prefix == "" ? "" : (tag.ns[prefix] || "")
        , a = { name: name
              , value: value
              , prefix: prefix
              , local: local
              , uri: uri
              }

      // if there's any attributes with an undefined namespace,
      // then fail on them now.
      if (prefix && prefix != "xmlns" && !uri) {
        strictFail(parser, "Unbound namespace prefix: "
                         + JSON.stringify(prefix))
        a.uri = prefix
      }
      parser.tag.attributes[name] = a
      emitNode(parser, "onattribute", a)
    }
    parser.attribList.length = 0
  }

  parser.tag.isSelfClosing = !!selfClosing

  // process the tag
  parser.sawRoot = true
  parser.tags.push(parser.tag)
  emitNode(parser, "onopentag", parser.tag)
  if (!selfClosing) {
    // special case for <script> in non-strict mode.
    if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
      parser.state = S.SCRIPT
    } else {
      parser.state = S.TEXT
    }
    parser.tag = null
    parser.tagName = ""
  }
  parser.attribName = parser.attribValue = ""
  parser.attribList.length = 0
}

function closeTag (parser) {
  if (!parser.tagName) {
    strictFail(parser, "Weird empty close tag.")
    parser.textNode += "</>"
    parser.state = S.TEXT
    return
  }

  if (parser.script) {
    if (parser.tagName !== "script") {
      parser.script += "</" + parser.tagName + ">"
      parser.tagName = ""
      parser.state = S.SCRIPT
      return
    }
    emitNode(parser, "onscript", parser.script)
    parser.script = ""
  }

  // first make sure that the closing tag actually exists.
  // <a><b></c></b></a> will close everything, otherwise.
  var t = parser.tags.length
  var tagName = parser.tagName
  if (!parser.strict) tagName = tagName[parser.looseCase]()
  var closeTo = tagName
  while (t --) {
    var close = parser.tags[t]
    if (close.name !== closeTo) {
      // fail the first time in strict mode
      strictFail(parser, "Unexpected close tag")
    } else break
  }

  // didn't find it.  we already failed for strict, so just abort.
  if (t < 0) {
    strictFail(parser, "Unmatched closing tag: "+parser.tagName)
    parser.textNode += "</" + parser.tagName + ">"
    parser.state = S.TEXT
    return
  }
  parser.tagName = tagName
  var s = parser.tags.length
  while (s --> t) {
    var tag = parser.tag = parser.tags.pop()
    parser.tagName = parser.tag.name
    emitNode(parser, "onclosetag", parser.tagName)

    var x = {}
    for (var i in tag.ns) x[i] = tag.ns[i]

    var parent = parser.tags[parser.tags.length - 1] || parser
    if (parser.opt.xmlns && tag.ns !== parent.ns) {
      // remove namespace bindings introduced by tag
      Object.keys(tag.ns).forEach(function (p) {
        var n = tag.ns[p]
        emitNode(parser, "onclosenamespace", { prefix: p, uri: n })
      })
    }
  }
  if (t === 0) parser.closedRoot = true
  parser.tagName = parser.attribValue = parser.attribName = ""
  parser.attribList.length = 0
  parser.state = S.TEXT
}

function parseEntity (parser) {
  var entity = parser.entity
    , entityLC = entity.toLowerCase()
    , num
    , numStr = ""
  if (parser.ENTITIES[entity])
    return parser.ENTITIES[entity]
  if (parser.ENTITIES[entityLC])
    return parser.ENTITIES[entityLC]
  entity = entityLC
  if (entity.charAt(0) === "#") {
    if (entity.charAt(1) === "x") {
      entity = entity.slice(2)
      num = parseInt(entity, 16)
      numStr = num.toString(16)
    } else {
      entity = entity.slice(1)
      num = parseInt(entity, 10)
      numStr = num.toString(10)
    }
  }
  entity = entity.replace(/^0+/, "")
  if (numStr.toLowerCase() !== entity) {
    strictFail(parser, "Invalid character entity")
    return "&"+parser.entity + ";"
  }

  return String.fromCodePoint(num)
}

function write (chunk) {
  var parser = this
  if (this.error) throw this.error
  if (parser.closed) return error(parser,
    "Cannot write after close. Assign an onready handler.")
  if (chunk === null) return end(parser)
  var i = 0, c = ""
  while (parser.c = c = chunk.charAt(i++)) {
    if (parser.trackPosition) {
      parser.position ++
      if (c === "\n") {
        parser.line ++
        parser.column = 0
      } else parser.column ++
    }
    switch (parser.state) {

      case S.BEGIN:
        if (c === "<") {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
        } else if (not(whitespace,c)) {
          // have to process this as a text node.
          // weird, but happens.
          strictFail(parser, "Non-whitespace before first tag.")
          parser.textNode = c
          parser.state = S.TEXT
        }
      continue

      case S.TEXT:
        if (parser.sawRoot && !parser.closedRoot) {
          var starti = i-1
          while (c && c!=="<" && c!=="&") {
            c = chunk.charAt(i++)
            if (c && parser.trackPosition) {
              parser.position ++
              if (c === "\n") {
                parser.line ++
                parser.column = 0
              } else parser.column ++
            }
          }
          parser.textNode += chunk.substring(starti, i-1)
        }
        if (c === "<") {
          parser.state = S.OPEN_WAKA
          parser.startTagPosition = parser.position
        } else {
          if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot))
            strictFail(parser, "Text data outside of root node.")
          if (c === "&") parser.state = S.TEXT_ENTITY
          else parser.textNode += c
        }
      continue

      case S.SCRIPT:
        // only non-strict
        if (c === "<") {
          parser.state = S.SCRIPT_ENDING
        } else parser.script += c
      continue

      case S.SCRIPT_ENDING:
        if (c === "/") {
          parser.state = S.CLOSE_TAG
        } else {
          parser.script += "<" + c
          parser.state = S.SCRIPT
        }
      continue

      case S.OPEN_WAKA:
        // either a /, ?, !, or text is coming next.
        if (c === "!") {
          parser.state = S.SGML_DECL
          parser.sgmlDecl = ""
        } else if (is(whitespace, c)) {
          // wait for it...
        } else if (is(nameStart,c)) {
          parser.state = S.OPEN_TAG
          parser.tagName = c
        } else if (c === "/") {
          parser.state = S.CLOSE_TAG
          parser.tagName = ""
        } else if (c === "?") {
          parser.state = S.PROC_INST
          parser.procInstName = parser.procInstBody = ""
        } else {
          strictFail(parser, "Unencoded <")
          // if there was some whitespace, then add that in.
          if (parser.startTagPosition + 1 < parser.position) {
            var pad = parser.position - parser.startTagPosition
            c = new Array(pad).join(" ") + c
          }
          parser.textNode += "<" + c
          parser.state = S.TEXT
        }
      continue

      case S.SGML_DECL:
        if ((parser.sgmlDecl+c).toUpperCase() === CDATA) {
          emitNode(parser, "onopencdata")
          parser.state = S.CDATA
          parser.sgmlDecl = ""
          parser.cdata = ""
        } else if (parser.sgmlDecl+c === "--") {
          parser.state = S.COMMENT
          parser.comment = ""
          parser.sgmlDecl = ""
        } else if ((parser.sgmlDecl+c).toUpperCase() === DOCTYPE) {
          parser.state = S.DOCTYPE
          if (parser.doctype || parser.sawRoot) strictFail(parser,
            "Inappropriately located doctype declaration")
          parser.doctype = ""
          parser.sgmlDecl = ""
        } else if (c === ">") {
          emitNode(parser, "onsgmldeclaration", parser.sgmlDecl)
          parser.sgmlDecl = ""
          parser.state = S.TEXT
        } else if (is(quote, c)) {
          parser.state = S.SGML_DECL_QUOTED
          parser.sgmlDecl += c
        } else parser.sgmlDecl += c
      continue

      case S.SGML_DECL_QUOTED:
        if (c === parser.q) {
          parser.state = S.SGML_DECL
          parser.q = ""
        }
        parser.sgmlDecl += c
      continue

      case S.DOCTYPE:
        if (c === ">") {
          parser.state = S.TEXT
          emitNode(parser, "ondoctype", parser.doctype)
          parser.doctype = true // just remember that we saw it.
        } else {
          parser.doctype += c
          if (c === "[") parser.state = S.DOCTYPE_DTD
          else if (is(quote, c)) {
            parser.state = S.DOCTYPE_QUOTED
            parser.q = c
          }
        }
      continue

      case S.DOCTYPE_QUOTED:
        parser.doctype += c
        if (c === parser.q) {
          parser.q = ""
          parser.state = S.DOCTYPE
        }
      continue

      case S.DOCTYPE_DTD:
        parser.doctype += c
        if (c === "]") parser.state = S.DOCTYPE
        else if (is(quote,c)) {
          parser.state = S.DOCTYPE_DTD_QUOTED
          parser.q = c
        }
      continue

      case S.DOCTYPE_DTD_QUOTED:
        parser.doctype += c
        if (c === parser.q) {
          parser.state = S.DOCTYPE_DTD
          parser.q = ""
        }
      continue

      case S.COMMENT:
        if (c === "-") parser.state = S.COMMENT_ENDING
        else parser.comment += c
      continue

      case S.COMMENT_ENDING:
        if (c === "-") {
          parser.state = S.COMMENT_ENDED
          parser.comment = textopts(parser.opt, parser.comment)
          if (parser.comment) emitNode(parser, "oncomment", parser.comment)
          parser.comment = ""
        } else {
          parser.comment += "-" + c
          parser.state = S.COMMENT
        }
      continue

      case S.COMMENT_ENDED:
        if (c !== ">") {
          strictFail(parser, "Malformed comment")
          // allow <!-- blah -- bloo --> in non-strict mode,
          // which is a comment of " blah -- bloo "
          parser.comment += "--" + c
          parser.state = S.COMMENT
        } else parser.state = S.TEXT
      continue

      case S.CDATA:
        if (c === "]") parser.state = S.CDATA_ENDING
        else parser.cdata += c
      continue

      case S.CDATA_ENDING:
        if (c === "]") parser.state = S.CDATA_ENDING_2
        else {
          parser.cdata += "]" + c
          parser.state = S.CDATA
        }
      continue

      case S.CDATA_ENDING_2:
        if (c === ">") {
          if (parser.cdata) emitNode(parser, "oncdata", parser.cdata)
          emitNode(parser, "onclosecdata")
          parser.cdata = ""
          parser.state = S.TEXT
        } else if (c === "]") {
          parser.cdata += "]"
        } else {
          parser.cdata += "]]" + c
          parser.state = S.CDATA
        }
      continue

      case S.PROC_INST:
        if (c === "?") parser.state = S.PROC_INST_ENDING
        else if (is(whitespace, c)) parser.state = S.PROC_INST_BODY
        else parser.procInstName += c
      continue

      case S.PROC_INST_BODY:
        if (!parser.procInstBody && is(whitespace, c)) continue
        else if (c === "?") parser.state = S.PROC_INST_ENDING
        else parser.procInstBody += c
      continue

      case S.PROC_INST_ENDING:
        if (c === ">") {
          emitNode(parser, "onprocessinginstruction", {
            name : parser.procInstName,
            body : parser.procInstBody
          })
          parser.procInstName = parser.procInstBody = ""
          parser.state = S.TEXT
        } else {
          parser.procInstBody += "?" + c
          parser.state = S.PROC_INST_BODY
        }
      continue

      case S.OPEN_TAG:
        if (is(nameBody, c)) parser.tagName += c
        else {
          newTag(parser)
          if (c === ">") openTag(parser)
          else if (c === "/") parser.state = S.OPEN_TAG_SLASH
          else {
            if (not(whitespace, c)) strictFail(
              parser, "Invalid character in tag name")
            parser.state = S.ATTRIB
          }
        }
      continue

      case S.OPEN_TAG_SLASH:
        if (c === ">") {
          openTag(parser, true)
          closeTag(parser)
        } else {
          strictFail(parser, "Forward-slash in opening tag not followed by >")
          parser.state = S.ATTRIB
        }
      continue

      case S.ATTRIB:
        // haven't read the attribute name yet.
        if (is(whitespace, c)) continue
        else if (c === ">") openTag(parser)
        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c)) {
          parser.attribName = c
          parser.attribValue = ""
          parser.state = S.ATTRIB_NAME
        } else strictFail(parser, "Invalid attribute name")
      continue

      case S.ATTRIB_NAME:
        if (c === "=") parser.state = S.ATTRIB_VALUE
        else if (c === ">") {
          strictFail(parser, "Attribute without value")
          parser.attribValue = parser.attribName
          attrib(parser)
          openTag(parser)
        }
        else if (is(whitespace, c)) parser.state = S.ATTRIB_NAME_SAW_WHITE
        else if (is(nameBody, c)) parser.attribName += c
        else strictFail(parser, "Invalid attribute name")
      continue

      case S.ATTRIB_NAME_SAW_WHITE:
        if (c === "=") parser.state = S.ATTRIB_VALUE
        else if (is(whitespace, c)) continue
        else {
          strictFail(parser, "Attribute without value")
          parser.tag.attributes[parser.attribName] = ""
          parser.attribValue = ""
          emitNode(parser, "onattribute",
                   { name : parser.attribName, value : "" })
          parser.attribName = ""
          if (c === ">") openTag(parser)
          else if (is(nameStart, c)) {
            parser.attribName = c
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, "Invalid attribute name")
            parser.state = S.ATTRIB
          }
        }
      continue

      case S.ATTRIB_VALUE:
        if (is(whitespace, c)) continue
        else if (is(quote, c)) {
          parser.q = c
          parser.state = S.ATTRIB_VALUE_QUOTED
        } else {
          strictFail(parser, "Unquoted attribute value")
          parser.state = S.ATTRIB_VALUE_UNQUOTED
          parser.attribValue = c
        }
      continue

      case S.ATTRIB_VALUE_QUOTED:
        if (c !== parser.q) {
          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_Q
          else parser.attribValue += c
          continue
        }
        attrib(parser)
        parser.q = ""
        parser.state = S.ATTRIB_VALUE_CLOSED
      continue

      case S.ATTRIB_VALUE_CLOSED:
        if (is(whitespace, c)) {
          parser.state = S.ATTRIB
        } else if (c === ">") openTag(parser)
        else if (c === "/") parser.state = S.OPEN_TAG_SLASH
        else if (is(nameStart, c)) {
          strictFail(parser, "No whitespace between attributes")
          parser.attribName = c
          parser.attribValue = ""
          parser.state = S.ATTRIB_NAME
        } else strictFail(parser, "Invalid attribute name")
      continue

      case S.ATTRIB_VALUE_UNQUOTED:
        if (not(attribEnd,c)) {
          if (c === "&") parser.state = S.ATTRIB_VALUE_ENTITY_U
          else parser.attribValue += c
          continue
        }
        attrib(parser)
        if (c === ">") openTag(parser)
        else parser.state = S.ATTRIB
      continue

      case S.CLOSE_TAG:
        if (!parser.tagName) {
          if (is(whitespace, c)) continue
          else if (not(nameStart, c)) {
            if (parser.script) {
              parser.script += "</" + c
              parser.state = S.SCRIPT
            } else {
              strictFail(parser, "Invalid tagname in closing tag.")
            }
          } else parser.tagName = c
        }
        else if (c === ">") closeTag(parser)
        else if (is(nameBody, c)) parser.tagName += c
        else if (parser.script) {
          parser.script += "</" + parser.tagName
          parser.tagName = ""
          parser.state = S.SCRIPT
        } else {
          if (not(whitespace, c)) strictFail(parser,
            "Invalid tagname in closing tag")
          parser.state = S.CLOSE_TAG_SAW_WHITE
        }
      continue

      case S.CLOSE_TAG_SAW_WHITE:
        if (is(whitespace, c)) continue
        if (c === ">") closeTag(parser)
        else strictFail(parser, "Invalid characters in closing tag")
      continue

      case S.TEXT_ENTITY:
      case S.ATTRIB_VALUE_ENTITY_Q:
      case S.ATTRIB_VALUE_ENTITY_U:
        switch(parser.state) {
          case S.TEXT_ENTITY:
            var returnState = S.TEXT, buffer = "textNode"
          break

          case S.ATTRIB_VALUE_ENTITY_Q:
            var returnState = S.ATTRIB_VALUE_QUOTED, buffer = "attribValue"
          break

          case S.ATTRIB_VALUE_ENTITY_U:
            var returnState = S.ATTRIB_VALUE_UNQUOTED, buffer = "attribValue"
          break
        }
        if (c === ";") {
          parser[buffer] += parseEntity(parser)
          parser.entity = ""
          parser.state = returnState
        }
        else if (is(entity, c)) parser.entity += c
        else {
          strictFail(parser, "Invalid character entity")
          parser[buffer] += "&" + parser.entity + c
          parser.entity = ""
          parser.state = returnState
        }
      continue

      default:
        throw new Error(parser, "Unknown state: " + parser.state)
    }
  } // while
  // cdata blocks can get very big under normal conditions. emit and move on.
  // if (parser.state === S.CDATA && parser.cdata) {
  //   emitNode(parser, "oncdata", parser.cdata)
  //   parser.cdata = ""
  // }
  if (parser.position >= parser.bufferCheckPosition) checkBufferLength(parser)
  return parser
}

/*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
if (!String.fromCodePoint) {
        (function() {
                var stringFromCharCode = String.fromCharCode;
                var floor = Math.floor;
                var fromCodePoint = function() {
                        var MAX_SIZE = 0x4000;
                        var codeUnits = [];
                        var highSurrogate;
                        var lowSurrogate;
                        var index = -1;
                        var length = arguments.length;
                        if (!length) {
                                return '';
                        }
                        var result = '';
                        while (++index < length) {
                                var codePoint = Number(arguments[index]);
                                if (
                                        !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
                                        codePoint < 0 || // not a valid Unicode code point
                                        codePoint > 0x10FFFF || // not a valid Unicode code point
                                        floor(codePoint) != codePoint // not an integer
                                ) {
                                        throw RangeError('Invalid code point: ' + codePoint);
                                }
                                if (codePoint <= 0xFFFF) { // BMP code point
                                        codeUnits.push(codePoint);
                                } else { // Astral code point; split in surrogate halves
                                        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                                        codePoint -= 0x10000;
                                        highSurrogate = (codePoint >> 10) + 0xD800;
                                        lowSurrogate = (codePoint % 0x400) + 0xDC00;
                                        codeUnits.push(highSurrogate, lowSurrogate);
                                }
                                if (index + 1 == length || codeUnits.length > MAX_SIZE) {
                                        result += stringFromCharCode.apply(null, codeUnits);
                                        codeUnits.length = 0;
                                }
                        }
                        return result;
                };
                if (Object.defineProperty) {
                        Object.defineProperty(String, 'fromCodePoint', {
                                'value': fromCodePoint,
                                'configurable': true,
                                'writable': true
                        });
                } else {
                        String.fromCodePoint = fromCodePoint;
                }
        }());
}

})(typeof exports === "undefined" ? sax = {} : exports);

}).call(this,require("buffer").Buffer)
},{"buffer":9,"stream":39,"string_decoder":40}],498:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, create;

  create = require('lodash/object/create');

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return create(XMLAttribute.prototype, this);
    };

    XMLAttribute.prototype.toString = function(options, level) {
      return ' ' + this.name + '="' + this.value + '"';
    };

    return XMLAttribute;

  })();

}).call(this);

},{"lodash/object/create":568}],499:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;

  XMLStringifier = require('./XMLStringifier');

  XMLDeclaration = require('./XMLDeclaration');

  XMLDocType = require('./XMLDocType');

  XMLElement = require('./XMLElement');

  module.exports = XMLBuilder = (function() {
    function XMLBuilder(name, options) {
      var root, temp;
      if (name == null) {
        throw new Error("Root element needs a name");
      }
      if (options == null) {
        options = {};
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      temp = new XMLElement(this, 'doc');
      root = temp.element(name);
      root.isRoot = true;
      root.documentObject = this;
      this.rootObject = root;
      if (!options.headless) {
        root.declaration(options);
        if ((options.pubID != null) || (options.sysID != null)) {
          root.doctype(options);
        }
      }
    }

    XMLBuilder.prototype.root = function() {
      return this.rootObject;
    };

    XMLBuilder.prototype.end = function(options) {
      return this.toString(options);
    };

    XMLBuilder.prototype.toString = function(options) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      r = '';
      if (this.xmldec != null) {
        r += this.xmldec.toString(options);
      }
      if (this.doctype != null) {
        r += this.doctype.toString(options);
      }
      r += this.rootObject.toString(options);
      if (pretty && r.slice(-newline.length) === newline) {
        r = r.slice(0, -newline.length);
      }
      return r;
    };

    return XMLBuilder;

  })();

}).call(this);

},{"./XMLDeclaration":506,"./XMLDocType":507,"./XMLElement":508,"./XMLStringifier":512}],500:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return create(XMLCData.prototype, this);
    };

    XMLCData.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<![CDATA[' + this.text + ']]>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLCData;

  })(XMLNode);

}).call(this);

},{"./XMLNode":509,"lodash/object/create":568}],501:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLComment, XMLNode, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return create(XMLComment.prototype, this);
    };

    XMLComment.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!-- ' + this.text + ' -->';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLComment;

  })(XMLNode);

}).call(this);

},{"./XMLNode":509,"lodash/object/create":568}],502:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDAttList, create;

  create = require('lodash/object/create');

  module.exports = XMLDTDAttList = (function() {
    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      this.stringify = parent.stringify;
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.clone = function() {
      return create(XMLDTDAttList.prototype, this);
    };

    XMLDTDAttList.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;
      if (this.defaultValueType !== '#DEFAULT') {
        r += ' ' + this.defaultValueType;
      }
      if (this.defaultValue) {
        r += ' "' + this.defaultValue + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDAttList;

  })();

}).call(this);

},{"lodash/object/create":568}],503:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDElement, create, isArray;

  create = require('lodash/object/create');

  isArray = require('lodash/lang/isArray');

  module.exports = XMLDTDElement = (function() {
    function XMLDTDElement(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.clone = function() {
      return create(XMLDTDElement.prototype, this);
    };

    XMLDTDElement.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ELEMENT ' + this.name + ' ' + this.value + '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDElement;

  })();

}).call(this);

},{"lodash/lang/isArray":560,"lodash/object/create":568}],504:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDEntity, create, isObject;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  module.exports = XMLDTDEntity = (function() {
    function XMLDTDEntity(parent, pe, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.clone = function() {
      return create(XMLDTDEntity.prototype, this);
    };

    XMLDTDEntity.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!ENTITY';
      if (this.pe) {
        r += ' %';
      }
      r += ' ' + this.name;
      if (this.value) {
        r += ' "' + this.value + '"';
      } else {
        if (this.pubID && this.sysID) {
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
        } else if (this.sysID) {
          r += ' SYSTEM "' + this.sysID + '"';
        }
        if (this.nData) {
          r += ' NDATA ' + this.nData;
        }
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDEntity;

  })();

}).call(this);

},{"lodash/lang/isObject":564,"lodash/object/create":568}],505:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDTDNotation, create;

  create = require('lodash/object/create');

  module.exports = XMLDTDNotation = (function() {
    function XMLDTDNotation(parent, name, value) {
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.clone = function() {
      return create(XMLDTDNotation.prototype, this);
    };

    XMLDTDNotation.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!NOTATION ' + this.name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.pubID) {
        r += ' PUBLIC "' + this.pubID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDTDNotation;

  })();

}).call(this);

},{"lodash/object/create":568}],506:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLDeclaration, XMLNode, create, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  XMLNode = require('./XMLNode');

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      if (version != null) {
        this.version = this.stringify.xmlVersion(version);
      }
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.clone = function() {
      return create(XMLDeclaration.prototype, this);
    };

    XMLDeclaration.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?xml';
      if (this.version != null) {
        r += ' version="' + this.version + '"';
      }
      if (this.encoding != null) {
        r += ' encoding="' + this.encoding + '"';
      }
      if (this.standalone != null) {
        r += ' standalone="' + this.standalone + '"';
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);

},{"./XMLNode":509,"lodash/lang/isObject":564,"lodash/object/create":568}],507:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  XMLCData = require('./XMLCData');

  XMLComment = require('./XMLComment');

  XMLDTDAttList = require('./XMLDTDAttList');

  XMLDTDEntity = require('./XMLDTDEntity');

  XMLDTDElement = require('./XMLDTDElement');

  XMLDTDNotation = require('./XMLDTDNotation');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLDocType = (function() {
    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      this.documentObject = parent;
      this.stringify = this.documentObject.stringify;
      this.children = [];
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.clone = function() {
      return create(XMLDocType.prototype, this);
    };

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.instruction = function(target, value) {
      var child;
      child = new XMLProcessingInstruction(this, target, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.root = function() {
      return this.documentObject.root();
    };

    XMLDocType.prototype.document = function() {
      return this.documentObject;
    };

    XMLDocType.prototype.toString = function(options, level) {
      var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<!DOCTYPE ' + this.root().name;
      if (this.pubID && this.sysID) {
        r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';
      } else if (this.sysID) {
        r += ' SYSTEM "' + this.sysID + '"';
      }
      if (this.children.length > 0) {
        r += ' [';
        if (pretty) {
          r += newline;
        }
        ref3 = this.children;
        for (i = 0, len = ref3.length; i < len; i++) {
          child = ref3[i];
          r += child.toString(options, level + 1);
        }
        r += ']';
      }
      r += '>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocType.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocType.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root();
    };

    XMLDocType.prototype.doc = function() {
      return this.document();
    };

    return XMLDocType;

  })();

}).call(this);

},{"./XMLCData":500,"./XMLComment":501,"./XMLDTDAttList":502,"./XMLDTDElement":503,"./XMLDTDEntity":504,"./XMLDTDNotation":505,"./XMLProcessingInstruction":510,"lodash/lang/isObject":564,"lodash/object/create":568}],508:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isArray, isFunction, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  isObject = require('lodash/lang/isObject');

  isArray = require('lodash/lang/isArray');

  isFunction = require('lodash/lang/isFunction');

  every = require('lodash/collection/every');

  XMLNode = require('./XMLNode');

  XMLAttribute = require('./XMLAttribute');

  XMLProcessingInstruction = require('./XMLProcessingInstruction');

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.children = [];
      this.instructions = [];
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, i, len, pi, ref, ref1;
      clonedSelf = create(XMLElement.prototype, this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref = this.attributes;
      for (attName in ref) {
        if (!hasProp.call(ref, attName)) continue;
        att = ref[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.instructions = [];
      ref1 = this.instructions;
      for (i = 0, len = ref1.length; i < len; i++) {
        pi = ref1[i];
        clonedSelf.instructions.push(pi.clone());
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, instruction, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.instructions.push(instruction);
      }
      return this;
    };

    XMLElement.prototype.toString = function(options, level) {
      var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      ref3 = this.instructions;
      for (i = 0, len = ref3.length; i < len; i++) {
        instruction = ref3[i];
        r += instruction.toString(options, level + 1);
      }
      if (pretty) {
        r += space;
      }
      r += '<' + this.name;
      ref4 = this.attributes;
      for (name in ref4) {
        if (!hasProp.call(ref4, name)) continue;
        att = ref4[name];
        r += att.toString(options);
      }
      if (this.children.length === 0 || every(this.children, function(e) {
        return e.value === '';
      })) {
        r += '/>';
        if (pretty) {
          r += newline;
        }
      } else if (pretty && this.children.length === 1 && (this.children[0].value != null)) {
        r += '>';
        r += this.children[0].value;
        r += '</' + this.name + '>';
        r += newline;
      } else {
        r += '>';
        if (pretty) {
          r += newline;
        }
        ref5 = this.children;
        for (j = 0, len1 = ref5.length; j < len1; j++) {
          child = ref5[j];
          r += child.toString(options, level + 1);
        }
        if (pretty) {
          r += space;
        }
        r += '</' + this.name + '>';
        if (pretty) {
          r += newline;
        }
      }
      return r;
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);

},{"./XMLAttribute":498,"./XMLNode":509,"./XMLProcessingInstruction":510,"lodash/collection/every":516,"lodash/lang/isArray":560,"lodash/lang/isFunction":562,"lodash/lang/isObject":564,"lodash/object/create":568}],509:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isArray, isEmpty, isFunction, isObject,
    hasProp = {}.hasOwnProperty;

  isObject = require('lodash/lang/isObject');

  isArray = require('lodash/lang/isArray');

  isFunction = require('lodash/lang/isFunction');

  isEmpty = require('lodash/lang/isEmpty');

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      this.options = this.parent.options;
      this.stringify = this.parent.stringify;
      if (XMLElement === null) {
        XMLElement = require('./XMLElement');
        XMLCData = require('./XMLCData');
        XMLComment = require('./XMLComment');
        XMLDeclaration = require('./XMLDeclaration');
        XMLDocType = require('./XMLDocType');
        XMLRaw = require('./XMLRaw');
        XMLText = require('./XMLText');
      }
    }

    XMLNode.prototype.clone = function() {
      throw new Error("Cannot clone generic XMLNode");
    };

    XMLNode.prototype.element = function(name, attributes, text) {
      var item, j, key, lastChild, len, ref, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && key.indexOf(this.stringify.convertPIKey) === 0) {
            lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);
          } else if (isObject(val)) {
            if (!this.options.ignoreDecorators && this.stringify.convertListKey && key.indexOf(this.stringify.convertListKey) === 0 && isArray(val)) {
              lastChild = this.element(val);
            } else {
              lastChild = this.element(key);
              lastChild.element(val);
            }
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref;
      if (name != null) {
        name = name.valueOf();
      }
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref = [attributes, text], text = ref[0], attributes = ref[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      doc.xmldec = xmldec;
      return doc.root();
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var doc, doctype;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      doc.doctype = doctype;
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var child;
      if (this.isRoot) {
        return this;
      }
      child = this.parent;
      while (!child.isRoot) {
        child = child.parent;
      }
      return child;
    };

    XMLNode.prototype.document = function() {
      return this.root().documentObject;
    };

    XMLNode.prototype.end = function(options) {
      return this.document().toString(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      if (this.isRoot) {
        throw new Error("Root node has no siblings");
      }
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {
      var clonedRoot;
      clonedRoot = xmlbuilder.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    return XMLNode;

  })();

}).call(this);

},{"./XMLCData":500,"./XMLComment":501,"./XMLDeclaration":506,"./XMLDocType":507,"./XMLElement":508,"./XMLRaw":511,"./XMLText":513,"lodash/lang/isArray":560,"lodash/lang/isEmpty":561,"lodash/lang/isFunction":562,"lodash/lang/isObject":564}],510:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLProcessingInstruction, create;

  create = require('lodash/object/create');

  module.exports = XMLProcessingInstruction = (function() {
    function XMLProcessingInstruction(parent, target, value) {
      this.stringify = parent.stringify;
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return create(XMLProcessingInstruction.prototype, this);
    };

    XMLProcessingInstruction.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += '<?';
      r += this.target;
      if (this.value) {
        r += ' ' + this.value;
      }
      r += '?>';
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLProcessingInstruction;

  })();

}).call(this);

},{"lodash/object/create":568}],511:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLRaw, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return create(XMLRaw.prototype, this);
    };

    XMLRaw.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);

},{"./XMLNode":509,"lodash/object/create":568}],512:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;
      ref = (options != null ? options.stringify : void 0) || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      if (val.match(/]]>/)) {
        throw new Error("Invalid CDATA text: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.convertListKey = '#list';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var chars, chr;
      if (this.allowSurrogateChars) {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;
      } else {
        chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;
      }
      chr = str.match(chars);
      if (chr) {
        throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);

},{}],513:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLNode, XMLText, create,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  create = require('lodash/object/create');

  XMLNode = require('./XMLNode');

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return create(XMLText.prototype, this);
    };

    XMLText.prototype.toString = function(options, level) {
      var indent, newline, offset, pretty, r, ref, ref1, ref2, space;
      pretty = (options != null ? options.pretty : void 0) || false;
      indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';
      offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;
      newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';
      level || (level = 0);
      space = new Array(level + offset + 1).join(indent);
      r = '';
      if (pretty) {
        r += space;
      }
      r += this.value;
      if (pretty) {
        r += newline;
      }
      return r;
    };

    return XMLText;

  })(XMLNode);

}).call(this);

},{"./XMLNode":509,"lodash/object/create":568}],514:[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
(function() {
  var XMLBuilder, assign;

  assign = require('lodash/object/assign');

  XMLBuilder = require('./XMLBuilder');

  module.exports.create = function(name, xmldec, doctype, options) {
    options = assign({}, xmldec, doctype, options);
    return new XMLBuilder(name, options).root();
  };

}).call(this);

},{"./XMLBuilder":499,"lodash/object/assign":567}],515:[function(require,module,exports){
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

module.exports = last;

},{}],516:[function(require,module,exports){
var arrayEvery = require('../internal/arrayEvery'),
    baseCallback = require('../internal/baseCallback'),
    baseEvery = require('../internal/baseEvery'),
    isArray = require('../lang/isArray'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * The predicate is bound to `thisArg` and invoked with three arguments:
 * (value, index|key, collection).
 *
 * If a property name is provided for `predicate` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `predicate` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * @static
 * @memberOf _
 * @alias all
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [predicate=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `predicate`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'active': false },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // using the `_.matches` callback shorthand
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // using the `_.matchesProperty` callback shorthand
 * _.every(users, 'active', false);
 * // => true
 *
 * // using the `_.property` callback shorthand
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, thisArg) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (thisArg && isIterateeCall(collection, predicate, thisArg)) {
    predicate = undefined;
  }
  if (typeof predicate != 'function' || thisArg !== undefined) {
    predicate = baseCallback(predicate, thisArg, 3);
  }
  return func(collection, predicate);
}

module.exports = every;

},{"../internal/arrayEvery":518,"../internal/baseCallback":522,"../internal/baseEvery":526,"../internal/isIterateeCall":551,"../lang/isArray":560}],517:[function(require,module,exports){
/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Native method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that invokes `func` with the `this` binding of the
 * created function and arguments from `start` and beyond provided as an array.
 *
 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
 *
 * @static
 * @memberOf _
 * @category Function
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var say = _.restParam(function(what, names) {
 *   return what + ' ' + _.initial(names).join(', ') +
 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
 * });
 *
 * say('hello', 'fred', 'barney', 'pebbles');
 * // => 'hello fred, barney, & pebbles'
 */
function restParam(func, start) {
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        rest = Array(length);

    while (++index < length) {
      rest[index] = args[start + index];
    }
    switch (start) {
      case 0: return func.call(this, rest);
      case 1: return func.call(this, args[0], rest);
      case 2: return func.call(this, args[0], args[1], rest);
    }
    var otherArgs = Array(start + 1);
    index = -1;
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = rest;
    return func.apply(this, otherArgs);
  };
}

module.exports = restParam;

},{}],518:[function(require,module,exports){
/**
 * A specialized version of `_.every` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

module.exports = arrayEvery;

},{}],519:[function(require,module,exports){
/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;

},{}],520:[function(require,module,exports){
var keys = require('../object/keys');

/**
 * A specialized version of `_.assign` for customizing assigned values without
 * support for argument juggling, multiple sources, and `this` binding `customizer`
 * functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {Function} customizer The function to customize assigned values.
 * @returns {Object} Returns `object`.
 */
function assignWith(object, source, customizer) {
  var index = -1,
      props = keys(source),
      length = props.length;

  while (++index < length) {
    var key = props[index],
        value = object[key],
        result = customizer(value, source[key], key, object, source);

    if ((result === result ? (result !== value) : (value === value)) ||
        (value === undefined && !(key in object))) {
      object[key] = result;
    }
  }
  return object;
}

module.exports = assignWith;

},{"../object/keys":569}],521:[function(require,module,exports){
var baseCopy = require('./baseCopy'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.assign` without support for argument juggling,
 * multiple sources, and `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return source == null
    ? object
    : baseCopy(source, keys(source), object);
}

module.exports = baseAssign;

},{"../object/keys":569,"./baseCopy":523}],522:[function(require,module,exports){
var baseMatches = require('./baseMatches'),
    baseMatchesProperty = require('./baseMatchesProperty'),
    bindCallback = require('./bindCallback'),
    identity = require('../utility/identity'),
    property = require('../utility/property');

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return thisArg === undefined
      ? func
      : bindCallback(func, thisArg, argCount);
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return thisArg === undefined
    ? property(func)
    : baseMatchesProperty(func, thisArg);
}

module.exports = baseCallback;

},{"../utility/identity":572,"../utility/property":573,"./baseMatches":533,"./baseMatchesProperty":534,"./bindCallback":539}],523:[function(require,module,exports){
/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property names to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @returns {Object} Returns `object`.
 */
function baseCopy(source, props, object) {
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];
    object[key] = source[key];
  }
  return object;
}

module.exports = baseCopy;

},{}],524:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(prototype) {
    if (isObject(prototype)) {
      object.prototype = prototype;
      var result = new object;
      object.prototype = undefined;
    }
    return result || {};
  };
}());

module.exports = baseCreate;

},{"../lang/isObject":564}],525:[function(require,module,exports){
var baseForOwn = require('./baseForOwn'),
    createBaseEach = require('./createBaseEach');

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;

},{"./baseForOwn":528,"./createBaseEach":541}],526:[function(require,module,exports){
var baseEach = require('./baseEach');

/**
 * The base implementation of `_.every` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

module.exports = baseEvery;

},{"./baseEach":525}],527:[function(require,module,exports){
var createBaseFor = require('./createBaseFor');

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;

},{"./createBaseFor":542}],528:[function(require,module,exports){
var baseFor = require('./baseFor'),
    keys = require('../object/keys');

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;

},{"../object/keys":569,"./baseFor":527}],529:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;

},{"./toObject":557}],530:[function(require,module,exports){
var baseIsEqualDeep = require('./baseIsEqualDeep'),
    isObject = require('../lang/isObject'),
    isObjectLike = require('./isObjectLike');

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
}

module.exports = baseIsEqual;

},{"../lang/isObject":564,"./baseIsEqualDeep":531,"./isObjectLike":554}],531:[function(require,module,exports){
var equalArrays = require('./equalArrays'),
    equalByTag = require('./equalByTag'),
    equalObjects = require('./equalObjects'),
    isArray = require('../lang/isArray'),
    isTypedArray = require('../lang/isTypedArray');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  if (!isLoose) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
    }
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

module.exports = baseIsEqualDeep;

},{"../lang/isArray":560,"../lang/isTypedArray":566,"./equalArrays":543,"./equalByTag":544,"./equalObjects":545}],532:[function(require,module,exports){
var baseIsEqual = require('./baseIsEqual'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} matchData The propery names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = toObject(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;

},{"./baseIsEqual":530,"./toObject":557}],533:[function(require,module,exports){
var baseIsMatch = require('./baseIsMatch'),
    getMatchData = require('./getMatchData'),
    toObject = require('./toObject');

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    var key = matchData[0][0],
        value = matchData[0][1];

    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === value && (value !== undefined || (key in toObject(object)));
    };
  }
  return function(object) {
    return baseIsMatch(object, matchData);
  };
}

module.exports = baseMatches;

},{"./baseIsMatch":532,"./getMatchData":547,"./toObject":557}],534:[function(require,module,exports){
var baseGet = require('./baseGet'),
    baseIsEqual = require('./baseIsEqual'),
    baseSlice = require('./baseSlice'),
    isArray = require('../lang/isArray'),
    isKey = require('./isKey'),
    isStrictComparable = require('./isStrictComparable'),
    last = require('../array/last'),
    toObject = require('./toObject'),
    toPath = require('./toPath');

/**
 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(path, srcValue) {
  var isArr = isArray(path),
      isCommon = isKey(path) && isStrictComparable(srcValue),
      pathKey = (path + '');

  path = toPath(path);
  return function(object) {
    if (object == null) {
      return false;
    }
    var key = pathKey;
    object = toObject(object);
    if ((isArr || !isCommon) && !(key in object)) {
      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
      if (object == null) {
        return false;
      }
      key = last(path);
      object = toObject(object);
    }
    return object[key] === srcValue
      ? (srcValue !== undefined || (key in object))
      : baseIsEqual(srcValue, object[key], undefined, true);
  };
}

module.exports = baseMatchesProperty;

},{"../array/last":515,"../lang/isArray":560,"./baseGet":529,"./baseIsEqual":530,"./baseSlice":537,"./isKey":552,"./isStrictComparable":555,"./toObject":557,"./toPath":558}],535:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],536:[function(require,module,exports){
var baseGet = require('./baseGet'),
    toPath = require('./toPath');

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

module.exports = basePropertyDeep;

},{"./baseGet":529,"./toPath":558}],537:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  start = start == null ? 0 : (+start || 0);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : (+end || 0);
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],538:[function(require,module,exports){
/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  return value == null ? '' : (value + '');
}

module.exports = baseToString;

},{}],539:[function(require,module,exports){
var identity = require('../utility/identity');

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

module.exports = bindCallback;

},{"../utility/identity":572}],540:[function(require,module,exports){
var bindCallback = require('./bindCallback'),
    isIterateeCall = require('./isIterateeCall'),
    restParam = require('../function/restParam');

/**
 * Creates a `_.assign`, `_.defaults`, or `_.merge` function.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return restParam(function(object, sources) {
    var index = -1,
        length = object == null ? 0 : sources.length,
        customizer = length > 2 ? sources[length - 2] : undefined,
        guard = length > 2 ? sources[2] : undefined,
        thisArg = length > 1 ? sources[length - 1] : undefined;

    if (typeof customizer == 'function') {
      customizer = bindCallback(customizer, thisArg, 5);
      length -= 2;
    } else {
      customizer = typeof thisArg == 'function' ? thisArg : undefined;
      length -= (customizer ? 1 : 0);
    }
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;

},{"../function/restParam":517,"./bindCallback":539,"./isIterateeCall":551}],541:[function(require,module,exports){
var getLength = require('./getLength'),
    isLength = require('./isLength'),
    toObject = require('./toObject');

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    var length = collection ? getLength(collection) : 0;
    if (!isLength(length)) {
      return eachFunc(collection, iteratee);
    }
    var index = fromRight ? length : -1,
        iterable = toObject(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;

},{"./getLength":546,"./isLength":553,"./toObject":557}],542:[function(require,module,exports){
var toObject = require('./toObject');

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;

},{"./toObject":557}],543:[function(require,module,exports){
var arraySome = require('./arraySome');

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
    return false;
  }
  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index],
        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

    if (result !== undefined) {
      if (result) {
        continue;
      }
      return false;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (isLoose) {
      if (!arraySome(other, function(othValue) {
            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          })) {
        return false;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
      return false;
    }
  }
  return true;
}

module.exports = equalArrays;

},{"./arraySome":519}],544:[function(require,module,exports){
/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

module.exports = equalByTag;

},{}],545:[function(require,module,exports){
var keys = require('../object/keys');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isLoose) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  var skipCtor = isLoose;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key],
        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

    // Recursively compare objects (susceptible to call stack limits).
    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
      return false;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (!skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

module.exports = equalObjects;

},{"../object/keys":569}],546:[function(require,module,exports){
var baseProperty = require('./baseProperty');

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

module.exports = getLength;

},{"./baseProperty":535}],547:[function(require,module,exports){
var isStrictComparable = require('./isStrictComparable'),
    pairs = require('../object/pairs');

/**
 * Gets the propery names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = pairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

module.exports = getMatchData;

},{"../object/pairs":571,"./isStrictComparable":555}],548:[function(require,module,exports){
var isNative = require('../lang/isNative');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

module.exports = getNative;

},{"../lang/isNative":563}],549:[function(require,module,exports){
var getLength = require('./getLength'),
    isLength = require('./isLength');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

module.exports = isArrayLike;

},{"./getLength":546,"./isLength":553}],550:[function(require,module,exports){
/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

module.exports = isIndex;

},{}],551:[function(require,module,exports){
var isArrayLike = require('./isArrayLike'),
    isIndex = require('./isIndex'),
    isObject = require('../lang/isObject');

/**
 * Checks if the provided arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
      ? (isArrayLike(object) && isIndex(index, object.length))
      : (type == 'string' && index in object)) {
    var other = object[index];
    return value === value ? (value === other) : (other !== other);
  }
  return false;
}

module.exports = isIterateeCall;

},{"../lang/isObject":564,"./isArrayLike":549,"./isIndex":550}],552:[function(require,module,exports){
var isArray = require('../lang/isArray'),
    toObject = require('./toObject');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

module.exports = isKey;

},{"../lang/isArray":560,"./toObject":557}],553:[function(require,module,exports){
/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;

},{}],554:[function(require,module,exports){
/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],555:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;

},{"../lang/isObject":564}],556:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('./isIndex'),
    isLength = require('./isLength'),
    keysIn = require('../object/keysIn');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = shimKeys;

},{"../lang/isArguments":559,"../lang/isArray":560,"../object/keysIn":570,"./isIndex":550,"./isLength":553}],557:[function(require,module,exports){
var isObject = require('../lang/isObject');

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

module.exports = toObject;

},{"../lang/isObject":564}],558:[function(require,module,exports){
var baseToString = require('./baseToString'),
    isArray = require('../lang/isArray');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

module.exports = toPath;

},{"../lang/isArray":560,"./baseToString":538}],559:[function(require,module,exports){
var isArrayLike = require('../internal/isArrayLike'),
    isObjectLike = require('../internal/isObjectLike');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{"../internal/isArrayLike":549,"../internal/isObjectLike":554}],560:[function(require,module,exports){
var getNative = require('../internal/getNative'),
    isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var arrayTag = '[object Array]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

module.exports = isArray;

},{"../internal/getNative":548,"../internal/isLength":553,"../internal/isObjectLike":554}],561:[function(require,module,exports){
var isArguments = require('./isArguments'),
    isArray = require('./isArray'),
    isArrayLike = require('../internal/isArrayLike'),
    isFunction = require('./isFunction'),
    isObjectLike = require('../internal/isObjectLike'),
    isString = require('./isString'),
    keys = require('../object/keys');

/**
 * Checks if `value` is empty. A value is considered empty unless it is an
 * `arguments` object, array, string, or jQuery-like collection with a length
 * greater than `0` or an object with own enumerable properties.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {Array|Object|string} value The value to inspect.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) && (isArray(value) || isString(value) || isArguments(value) ||
      (isObjectLike(value) && isFunction(value.splice)))) {
    return !value.length;
  }
  return !keys(value).length;
}

module.exports = isEmpty;

},{"../internal/isArrayLike":549,"../internal/isObjectLike":554,"../object/keys":569,"./isArguments":559,"./isArray":560,"./isFunction":562,"./isString":565}],562:[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

module.exports = isFunction;

},{"./isObject":564}],563:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObjectLike = require('../internal/isObjectLike');

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isNative;

},{"../internal/isObjectLike":554,"./isFunction":562}],564:[function(require,module,exports){
/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],565:[function(require,module,exports){
var isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag);
}

module.exports = isString;

},{"../internal/isObjectLike":554}],566:[function(require,module,exports){
var isLength = require('../internal/isLength'),
    isObjectLike = require('../internal/isObjectLike');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{"../internal/isLength":553,"../internal/isObjectLike":554}],567:[function(require,module,exports){
var assignWith = require('../internal/assignWith'),
    baseAssign = require('../internal/baseAssign'),
    createAssigner = require('../internal/createAssigner');

/**
 * Assigns own enumerable properties of source object(s) to the destination
 * object. Subsequent sources overwrite property assignments of previous sources.
 * If `customizer` is provided it is invoked to produce the assigned values.
 * The `customizer` is bound to `thisArg` and invoked with five arguments:
 * (objectValue, sourceValue, key, object, source).
 *
 * **Note:** This method mutates `object` and is based on
 * [`Object.assign`](http://ecma-international.org/ecma-262/6.0/#sec-object.assign).
 *
 * @static
 * @memberOf _
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {*} [thisArg] The `this` binding of `customizer`.
 * @returns {Object} Returns `object`.
 * @example
 *
 * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
 * // => { 'user': 'fred', 'age': 40 }
 *
 * // using a customizer callback
 * var defaults = _.partialRight(_.assign, function(value, other) {
 *   return _.isUndefined(value) ? other : value;
 * });
 *
 * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
 * // => { 'user': 'barney', 'age': 36 }
 */
var assign = createAssigner(function(object, source, customizer) {
  return customizer
    ? assignWith(object, source, customizer)
    : baseAssign(object, source);
});

module.exports = assign;

},{"../internal/assignWith":520,"../internal/baseAssign":521,"../internal/createAssigner":540}],568:[function(require,module,exports){
var baseAssign = require('../internal/baseAssign'),
    baseCreate = require('../internal/baseCreate'),
    isIterateeCall = require('../internal/isIterateeCall');

/**
 * Creates an object that inherits from the given `prototype` object. If a
 * `properties` object is provided its own enumerable properties are assigned
 * to the created object.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} prototype The object to inherit from.
 * @param {Object} [properties] The properties to assign to the object.
 * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
 * @returns {Object} Returns the new object.
 * @example
 *
 * function Shape() {
 *   this.x = 0;
 *   this.y = 0;
 * }
 *
 * function Circle() {
 *   Shape.call(this);
 * }
 *
 * Circle.prototype = _.create(Shape.prototype, {
 *   'constructor': Circle
 * });
 *
 * var circle = new Circle;
 * circle instanceof Circle;
 * // => true
 *
 * circle instanceof Shape;
 * // => true
 */
function create(prototype, properties, guard) {
  var result = baseCreate(prototype);
  if (guard && isIterateeCall(prototype, properties, guard)) {
    properties = undefined;
  }
  return properties ? baseAssign(result, properties) : result;
}

module.exports = create;

},{"../internal/baseAssign":521,"../internal/baseCreate":524,"../internal/isIterateeCall":551}],569:[function(require,module,exports){
var getNative = require('../internal/getNative'),
    isArrayLike = require('../internal/isArrayLike'),
    isObject = require('../lang/isObject'),
    shimKeys = require('../internal/shimKeys');

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

module.exports = keys;

},{"../internal/getNative":548,"../internal/isArrayLike":549,"../internal/shimKeys":556,"../lang/isObject":564}],570:[function(require,module,exports){
var isArguments = require('../lang/isArguments'),
    isArray = require('../lang/isArray'),
    isIndex = require('../internal/isIndex'),
    isLength = require('../internal/isLength'),
    isObject = require('../lang/isObject');

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keysIn;

},{"../internal/isIndex":550,"../internal/isLength":553,"../lang/isArguments":559,"../lang/isArray":560,"../lang/isObject":564}],571:[function(require,module,exports){
var keys = require('./keys'),
    toObject = require('../internal/toObject');

/**
 * Creates a two dimensional array of the key-value pairs for `object`,
 * e.g. `[[key1, value1], [key2, value2]]`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the new array of key-value pairs.
 * @example
 *
 * _.pairs({ 'barney': 36, 'fred': 40 });
 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 */
function pairs(object) {
  object = toObject(object);

  var index = -1,
      props = keys(object),
      length = props.length,
      result = Array(length);

  while (++index < length) {
    var key = props[index];
    result[index] = [key, object[key]];
  }
  return result;
}

module.exports = pairs;

},{"../internal/toObject":557,"./keys":569}],572:[function(require,module,exports){
/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],573:[function(require,module,exports){
var baseProperty = require('../internal/baseProperty'),
    basePropertyDeep = require('../internal/basePropertyDeep'),
    isKey = require('../internal/isKey');

/**
 * Creates a function that returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = property;

},{"../internal/baseProperty":535,"../internal/basePropertyDeep":536,"../internal/isKey":552}],574:[function(require,module,exports){
module.exports = {view: require('./lib/views/fullscreen'), model: require('./lib/models/fullscreen')};
},{"./lib/models/fullscreen":578,"./lib/views/fullscreen":579}],575:[function(require,module,exports){
module.exports = {
	enableFullscreen: true
}

},{}],576:[function(require,module,exports){
module.exports = {"fullscreen":".bdsft-webrtc .enableFullscreen:not(.fullscreen-shown) .fullscreenExpand,.bdsft-webrtc .enableFullscreen.fullscreen-shown .fullscreenContract{transition:all 1s linear;opacity:1;z-index:20}.bdsft-webrtc .enableFullscreen.fullscreen-shown .fullscreenExpand,.bdsft-webrtc .enableFullscreen:not(.fullscreen-shown) .fullscreenContract{transition:all 1s linear;opacity:0;z-index:-1}.bdsft-webrtc :not(.enableFullscreen).cell-fullScreen{display:none!important}.bdsft-webrtc .conference .fullscreenExpand,.bdsft-webrtc .conference .fullscreenContract{text-align:left!important}.bdsft-webrtc .audioOnly .fullscreenExpand,.bdsft-webrtc .audioOnly .fullscreenContract,.bdsft-webrtc .audioOnly .cell-fullScreen{display:none!important}"}
},{}],577:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // fullscreen.jade compiled template
    templatizer["fullscreen"] = function tmpl_fullscreen() {
        return '<div class="bdsft-webrtc"><div class="cell cell-fullScreen classes"><div class="fullscreenExpand icon fadeable"><a href="" title="Expand Full Screen" class="icon-fullscreenExpand"></a></div><div class="fullscreenContract icon fadeable"><a href="" title="Contract Full Screen" class="icon-fullscreenContract"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],578:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Fullscreen, {
  config: require('../../js/config')
})

var Utils = require('webrtc-core').utils;

function Fullscreen(eventbus, urlconfig) {
  var self = {};

  self.updateWebkitFullscreen = function(){
    if(!self.visible) {
      if (document.webkitCancelFullScreen) {
        document.webkitCancelFullScreen();
      }
    } else {
      if (document.webkitRequestFullScreen) {
        document.webkitRequestFullScreen();
      }      
    }
  };

  self.props = ['visible', 'classes'];

  self.bindings = {
    classes: {
      fullscreen: ['visible', 'enableFullscreen'],
      urlconfig: ['view']
    },
    enableFullscreen: {
      urlconfig: 'enableFullscreen'
    },
    webkitFullscreen: {
      fullscreen: 'visible'
    }
  }

  self.start = function() {
    self.visible = true;
  };
  self.stop = function(){
    self.visible = false;
  };

  self.listeners = function() {
    Utils.getElement(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function(e) {
      var enable = document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen;
      if(enable) {
        self.start();
      } else {
        self.stop();
      }
    });
    eventbus.on('endCall', function(){
      self.stop();
    });
  };

  return self;
}
},{"../../js/config":575,"webrtc-core":583}],579:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(FullscreenView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

function FullscreenView(fullscreen, sound) {
  var self = {};

  self.elements = ['fullscreenExpand', 'fullscreenContract'];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.listeners = function() {
    self.fullscreenExpand.bind('click', clickHander(function() {
      fullscreen.start();
    }));
    self.fullscreenContract.bind('click', clickHander(function() {
      fullscreen.stop();
    }));
  };

  return self;
}
},{"../../js/styles":576,"../../js/templates":577,"webrtc-core":583}],580:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],581:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],582:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],583:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":582,"./bdsft":584,"./constants":587,"./cookieconfig":588,"./cookieprop":589,"./dateformat":592,"./debug":593,"./element":594,"./eventbus":595,"./factory":596,"./icon":597,"./loader":598,"./popup":599,"./prop":600,"./urlconfig":602,"./utils":603,"./visibleprop":604,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],584:[function(require,module,exports){
module.exports=require(54)
},{"./app":583,"./binding":585,"./classesbinding":586,"./databinder":591,"./stylesmanager":601,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":628}],585:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":584,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],586:[function(require,module,exports){
module.exports=require(56)
},{"./binding":585,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],587:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],588:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":584,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":628,"jquery.cookie":627}],589:[function(require,module,exports){
module.exports=require(59)
},{"./constants":587,"./prop":600,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":628,"jquery.cookie":627}],590:[function(require,module,exports){
module.exports=require(60)
},{"./constants":587,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":609}],591:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":612}],592:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],593:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":580,"./bdsft":584,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":605,"stacktrace-js":630}],594:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],595:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":584,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":612}],596:[function(require,module,exports){
module.exports=require(66)
},{"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":628}],597:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],598:[function(require,module,exports){
module.exports=require(68)
},{"../":583,"./constants":587,"./factory":596,"./stylesmanager":601,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":608}],599:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":628}],600:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":629}],601:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":581,"./constants":587,"./css":590,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],602:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":580,"./bdsft":584,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],603:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":582,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":628}],604:[function(require,module,exports){
module.exports=require(74)
},{"./constants":587,"./prop":600,"./utils":603,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],605:[function(require,module,exports){
module.exports=require(75)
},{"./debug":606,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],606:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":607}],607:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],608:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],609:[function(require,module,exports){
module.exports=require(79)
},{"./filters":610,"./utils":611,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],610:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],611:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],612:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":613,"es5-ext/object/valid-callable":622}],613:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":614,"es5-ext/object/is-callable":617,"es5-ext/object/normalize-options":621,"es5-ext/string/#/contains":624}],614:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":615,"./shim":616,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],615:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],616:[function(require,module,exports){
module.exports=require(86)
},{"../keys":618,"../valid-value":623,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],617:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],618:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":619,"./shim":620,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],619:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],620:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],621:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],622:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],623:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],624:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":625,"./shim":626,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],625:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],626:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],627:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":628}],628:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],629:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],630:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],631:[function(require,module,exports){
module.exports = {view: require('./lib/views/history'), model: require('./lib/models/history')};

},{"./lib/models/history":636,"./lib/views/history":637}],632:[function(require,module,exports){
module.exports = {
    enableCallHistory: true
};
},{}],633:[function(require,module,exports){
module.exports = {"history":".bdsft-webrtc .callHistory{position:absolute;right:auto;left:200px;bottom:40px;top:auto;background:#292929;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:10px}.bdsft-webrtc .callHistory .details{display:none}.bdsft-webrtc .callHistory .rowSpace{padding:.5em}.bdsft-webrtc .callHistory .actions,.bdsft-webrtc .callHistory .classHistoryActions{text-align:center;vertical-align:middle;height:40px}.bdsft-webrtc .callHistory .classHistoryActions{min-width:160px}.bdsft-webrtc .callHistory .classHistoryActions .paging{display:inline-block;width:20px;text-align:center}.bdsft-webrtc .callHistory .content{padding:0;margin-bottom:10px}.bdsft-webrtc .callHistory .close a{color:#04aff0;font-size:14px;font-weight:700;text-decoration:none;margin-left:8px}.bdsft-webrtc .callHistory .close a:hover{color:#017ead}.bdsft-webrtc .callHistory .callLink{display:inline-block;background:#6f6f6f;padding:6px 10px 6px 10px;text-decoration:none;font-weight:bold;color:#fff!important;border-radius:50px}.bdsft-webrtc .callHistory .callHistoryDetails{padding:10px;background:#292929;vertical-align:top;font-size:14px!important;box-shadow:2px 0 0 0 #888,0 2px 0 0 #888,2px 2px 0 0 #888,2px 0 0 0 #888 inset,0 2px 0 0 #888 inset}.bdsft-webrtc .callHistory .callHistoryDetails .detailsClose a{text-decoration:none;outline-color:rgba(0,0,0,0);color:#aaa;font-size:18px}.bdsft-webrtc .callHistory .clear a{text-decoration:none;color:#fff;font-size:14px;font-weight:700;background:#6f6f6f;border-radius:20px;padding:5px 10px;margin-left:15px}.bdsft-webrtc .callHistory .clear a:hover{background:#4e4e4e}.bdsft-webrtc .callHistory .statsHolder .stats{position:static;opacity:1;border:0;padding:0}.bdsft-webrtc .callHistory .statsHolder .stats .statsVar{color:#2ba6cb;display:block}.bdsft-webrtc .callHistory .statsHolder .stats span{display:inline!important}.bdsft-webrtc .callHistory .statsHolder .stats .col{width:115px;display:inline-block;white-space:nowrap}.bdsft-webrtc .callHistory.audioOnly:not(.offerToReceiveVideo){top:45px;bottom:auto}.bdsft-webrtc .callHistory.started .hist-details-arrow,.bdsft-webrtc .callHistory.started .callHistoryDetails{display:none!important}.bdsft-webrtc .callHistory.enableCallHistory.history-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callHistory.enableCallHistory:not(.history-shown){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .callHistory.enableCallHistory:not(.connected) .callLink{display:none}.bdsft-webrtc .callHistory[class*=\"call-selected\"] .details{display:table-cell}.bdsft-webrtc .callHistory[class*=\"call-selected-0\"] #call_0,.bdsft-webrtc .callHistory[class*=\"call-selected-1\"] #call_1,.bdsft-webrtc .callHistory[class*=\"call-selected-2\"] #call_2,.bdsft-webrtc .callHistory[class*=\"call-selected-3\"] #call_3,.bdsft-webrtc .callHistory[class*=\"call-selected-4\"] #call_4,.bdsft-webrtc .callHistory[class*=\"call-selected-5\"] #call_5,.bdsft-webrtc .callHistory[class*=\"call-selected-6\"] #call_6,.bdsft-webrtc .callHistory[class*=\"call-selected-7\"] #call_7,.bdsft-webrtc .callHistory[class*=\"call-selected-8\"] #call_8,.bdsft-webrtc .callHistory[class*=\"call-selected-9\"] #call_9,.bdsft-webrtc .callHistory[class*=\"call-selected-10\"] #call_10,.bdsft-webrtc .callHistory[class*=\"call-selected-11\"] #call_11,.bdsft-webrtc .callHistory[class*=\"call-selected-12\"] #call_12,.bdsft-webrtc .callHistory[class*=\"call-selected-13\"] #call_13,.bdsft-webrtc .callHistory[class*=\"call-selected-14\"] #call_14,.bdsft-webrtc .callHistory[class*=\"call-selected-15\"] #call_15,.bdsft-webrtc .callHistory[class*=\"call-selected-16\"] #call_16,.bdsft-webrtc .callHistory[class*=\"call-selected-17\"] #call_17,.bdsft-webrtc .callHistory[class*=\"call-selected-18\"] #call_18,.bdsft-webrtc .callHistory[class*=\"call-selected-19\"] #call_19,.bdsft-webrtc .callHistory[class*=\"call-selected-20\"] #call_20,.bdsft-webrtc .callHistory[class*=\"call-selected-21\"] #call_21,.bdsft-webrtc .callHistory[class*=\"call-selected-22\"] #call_22,.bdsft-webrtc .callHistory[class*=\"call-selected-23\"] #call_23,.bdsft-webrtc .callHistory[class*=\"call-selected-24\"] #call_24,.bdsft-webrtc .callHistory[class*=\"call-selected-25\"] #call_25,.bdsft-webrtc .callHistory[class*=\"call-selected-26\"] #call_26,.bdsft-webrtc .callHistory[class*=\"call-selected-27\"] #call_27,.bdsft-webrtc .callHistory[class*=\"call-selected-28\"] #call_28,.bdsft-webrtc .callHistory[class*=\"call-selected-29\"] #call_29,.bdsft-webrtc .callHistory[class*=\"call-selected-30\"] #call_30{box-shadow:2px 0 0 0 #292929,0 2px 0 0 #888,2px 2px 0 0 #888,2px 0 0 0 #888 inset,0 2px 0 0 #888 inset;position:relative}","historyrow":".bdsft-webrtc .history-row:hover,.bdsft-webrtc .history-row.active{background:#353535}.bdsft-webrtc .history-row{cursor:pointer;position:relative;padding:5px}.bdsft-webrtc .history-row span{padding:0 5px}.bdsft-webrtc .history-row .row{height:46px}.bdsft-webrtc .history-row .direction{color:#3da005;font-size:18px}.bdsft-webrtc .history-row .icon-arrow-down-thick{color:#e9651d}.bdsft-webrtc .history-row .destination{color:#b3b3b3;font-size:18px;text-decoration:none}.bdsft-webrtc .history-row .date{color:#b3b3b3;font-size:10px}.bdsft-webrtc .history-row .length{color:#b3b3b3;font-size:10px}.bdsft-webrtc .history-row .details-arrow{font-size:16px}"}
},{}],634:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // history.jade compiled template
    templatizer["history"] = function tmpl_history() {
        return '<div class="bdsft-webrtc"><div class="callHistory popup fadeable classes"><div class="table"><div class="row"><div class="cell"><div class="content"></div></div><div class="cell callHistoryDetails details"><div id="history-dt-close-container"><span class="detailsClose cell"><a href="" title="Close" class="icon-cancel3"></a></span></div><div class="statsHolder"></div></div></div><div class="row"><div class="cell classHistoryActions"><span class="paging"><div class="forward"><a href="" title="Next" class="historyForwardIcon icon-arrow-down-thick"></a></div></span><span class="paging"><div class="back"><a href="" title="Previous" class="historyBackIcon icon-arrow-up-thick"></a></div></span><span class="clear"><a href="" title="Clear History">Clear</a></span><span class="close"><a href="" title="Close History">Close</a></span></div><div class="cell actions details"><a href="" title="Call" class="callLink"></a></div></div></div></div></div>';
    };

    // historyrow.jade compiled template
    templatizer["historyrow"] = function tmpl_historyrow() {
        return '<div class="bdsft-webrtc"><div class="history-row"><div class="row"><span class="direction"></span><a href="" title="Number" class="destination"></a><span class="details-arrow icon-angle-right"></span><div>         <span class="length"></span><span class="date"></span></div></div></div></div>';
    };

    // stats.jade compiled template
    templatizer["stats"] = function tmpl_stats() {
        return '<div class="bdsft-webrtc"><div class="stats classes"><div class="avgVideoGoogFrameWidthReceivedRow"><div class="col">Resolution In</div><div class="col"><span class="statsVar avgVideoGoogFrameWidthReceived"></span> x <span class="statsVar avgVideoGoogFrameHeightReceived"></span></div></div><div class="avgVideoGoogFrameWidthSentRow"><div class="col">Resolution Out</div><div class="col"><span class="statsVar avgVideoGoogFrameWidthSent"></span> x <span class="statsVar avgVideoGoogFrameHeightSent"></span></div></div><div class="avgVideoKiloBitsReceivedPerSecondRow"><div class="col">Video Bitrate In</div><div class="col"><div class="statsVar avgVideoKiloBitsReceivedPerSecond"></div></div></div><div class="avgVideoKiloBitsSentPerSecondRow"><div class="col">Video Bitrate Out</div><div class="col"><div class="statsVar avgVideoKiloBitsSentPerSecond"></div></div></div><div class="avgAudioKiloBitsReceivedPerSecondRow"><div class="col">Audio Bitrate In</div><div class="col"><div class="statsVar avgAudioKiloBitsReceivedPerSecond"></div></div></div><div class="avgAudioKiloBitsSentPerSecondRow"><div class="col">Audio Bitrate Out</div><div class="col"><div class="statsVar avgAudioKiloBitsSentPerSecond"></div></div></div><div class="avgVideoGoogFrameRateReceivedRow"><div class="col">Frame Rate In</div><div class="col"><div class="statsVar avgVideoGoogFrameRateReceived"></div></div></div><div class="avgVideoGoogFrameRateSentRow"><div class="col">Frame Rate Out</div><div class="col"><div class="statsVar avgVideoGoogFrameRateSent"></div></div></div><div class="avgVideoPacketsLostPerRow"><div class="col">Video Lost</div><div class="col"><div class="statsVar avgVideoPacketsLostPer">%</div></div></div><div class="avgAudioPacketsLostPerRow"><div class="col">Audio Lost</div><div class="col"><div class="statsVar avgAudioPacketsLostPer">%</div></div></div><div class="avgAudioGoogJitterReceivedRow"><div class="col">Jitter</div><div class="col"><div class="statsVar avgAudioGoogJitterReceived"></div></div></div><div class="videoGoogFrameWidthReceived hidden"></div><div class="videoGoogFrameHeightReceived hidden"></div><div class="videoGoogFrameWidthSent hidden"></div><div class="videoGoogFrameHeightSent hidden"></div><div class="videoKiloBitsReceivedPerSecond hidden"></div><div class="videoKiloBitsSentPerSecond hidden"></div><div class="audioKiloBitsReceivedPerSecond hidden"></div><div class="audioKiloBitsSentPerSecond hidden"></div><div class="videoGoogFrameRateReceived hidden"></div><div class="videoGoogFrameRateSent hidden"></div><div class="videoPacketsLostPer hidden"></div><div class="audioPacketsLostPer hidden"></div><div class="videoPacketsLost hidden"></div><div class="audioPacketsLost hidden"></div><div class="audioAudioInputLevel hidden"></div><div class="audioAudioOutputLevel hidden"></div><div class="audioGoogRtt hidden"></div><div class="avgVideoPacketsLost hidden"></div><div class="avgAudioPacketsLost hidden"></div><div class="avgAudioAudioInputLevel hidden"></div><div class="avgAudioAudioOutputLevel hidden"></div><div class="avgAudioGoogRtt hidden"></div><div class="audioGoogJitterReceived hidden"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],635:[function(require,module,exports){
var C = {};
module.exports = C;

C.HISTORY_PAGE_PREFIX = 'bdsft_webrtc_page_';

},{}],636:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(History, {
  config: require('../../js/config.js')
})

var Utils = require('webrtc-core').utils;
var Constants = require('../constants');

function Page(number, callsValue) {
  var self = {};

  self.callsAsString = function() {
    return self.calls.map(function(call) {
      return call.toString();
    }).join("~");
  };
  self.parseCalls = function(callsValue) {
    var calls = [];
    if (callsValue.trim().length > 0) {
      var callsArray = callsValue.split("~");
      for (var i = 0; i < callsArray.length; i++) {
        calls.push(new Call(i, callsArray[i]));
      }
    }
    return calls;
  };

  self.calls = self.parseCalls(callsValue);
  self.number = number;

  return self;
}

function Call(id, value) {
  var self = {};

  var values = value ? value.split("|") : [];
  self.id = id;
  self.startTime = values[0];
  self.destination = values[1];
  self.direction = values[2];
  self.stats = values[3] && JSON.parse(values[3]);
  self.length = values[4];

  self.startDate = function() {
    var date = new Date();
    date.setTime(self.startTime);
    return date.toLocaleString();
  };
  self.destinationWithoutSip = function() {
    return self.destination.replace(/sip:([^@]+)@.+/, "$1");
  };
  self.toString = function() {
    var values = [self.startTime, self.destination, self.direction, JSON.stringify(self.stats), self.length];
    return values.join("|");
  };

  return self;
}

function History(stats, eventbus, sipstack, urlconfig) {
  var self = {};

  self.props = ['isForwardEnabled', 'isBackEnabled', 'calls', 'classes', 'visible', 'pageNumber', 'callsPerPage', 'maxPages', 'callSelected'];

  self.bindings = {
    classes: {
      history: ['visible', 'enableCallHistory', 'callSelected'],
      sipstack: ['callState', 'audioOnly', 'offerToReceiveVideo']
    },
    content: {
      history: ['visible', 'pageNumber']
    },
    enableCallHistory: {
      urlconfig: 'enableCallHistory'
    }
  }

  var createCall = function(rtcSession) {
    var call = new Call(self.calls.length);
    var start = rtcSession.start_time;
    call.startTime = new Date(start).getTime();
    call.destination = rtcSession.remote_identity.uri;
    if (rtcSession.direction === "outgoing") {
      call.direction = "up";
    } else {
      call.direction = "down";
    }
    call.stats = stats.getAllAvg();
    call.length = Utils.format(Math.round(Math.abs((rtcSession.end_time - start) / 1000)));
    return call;
  };

  var updateNavigation = function() {
    var pages = self.pages();
    var pagesCount = pages ? pages.length - 1 : 0;
    self.isForwardEnabled = self.pageNumber < pagesCount;
    self.isBackEnabled = self.pageNumber > 0;
  };

  self.updateContent = function() {
    updateNavigation();
    var allCalls = self.getAllCalls();
    var startPos = self.callsPerPage * self.pageNumber;
    var endPos = Math.min(startPos + self.callsPerPage, allCalls.length);
    self.calls = allCalls.slice(startPos, endPos);
  };

  self.pagesAsString = function() {
    return self.pages().map(function(page) {
      return page.callsAsString();
    });
  };

  self.pages = function() {
    var pages = [];
    for (var i = 0; i < localStorage.length; i++) {
      var key = localStorage.key(i);
      var regex = new RegExp(Constants.HISTORY_PAGE_PREFIX + '(.*)', 'g');
      var match = regex.exec(key);
      if (match !== null && match.length > 1) {
        var value = localStorage.getItem(key);
        var page = new Page(parseInt(match[1], 10), value);
        pages.push(page);
      }
    }
    // sort pages descendingly
    pages.sort(function(page1, page2) {
      return page2.number - page1.number;
    });
    return pages;
  };

  self.deselectCall = function() {
    self.callSelected = undefined;
  };

  self.selectCall = function(index) {
    self.callSelected = 'call-selected-'+index;
  };

  self.lastCall = function() {
    return self.getAllCalls().shift();
  };

  self.getAllCalls = function() {
    var pages = self.pages();
    var calls = [];
    for (var i = 0; i < pages.length; i++) {
      calls = calls.concat(pages[i].calls);
    }
    return calls;
  };

  self.forward = function() {
    self.deselectCall();
    self.pageNumber = self.pageNumber + 1;
  };

  self.back = function() {
    self.deselectCall();
    self.pageNumber = self.pageNumber - 1;
  };

  self.clear = function() {
    var pages = self.pages();
    for (var i = 0; i < pages.length; i++) {
      localStorage.removeItem(Constants.HISTORY_PAGE_PREFIX + (pages[i].number));
    }
    self.pageNumber = 0;
    self.updateContent();
  };

  self.init = function() {
    self.pageNumber = 0;
    self.callsPerPage = 4;
    self.maxPages = 10;
  };

  self.listeners = function() {
    eventbus.on("ended", function(e) {
      self.persistCall(e.sender);
    });
  };

  self.setStats = function(call) {
    stats.setAllAvg(call.stats);
  };

  self.persistPage = function(page) {
    var key = (Constants.HISTORY_PAGE_PREFIX + page.number);
    var value = page.callsAsString();
    localStorage[key] = value;
  };

  self.persistCall = function(rtcSession) {
    if (!self.enableCallHistory) {
      return;
    }
    // Get latest cookie
    var pages = self.pages();
    var page = null;
    if (pages.length > 0) {
      page = pages[0];
    } else {
      page = new Page(0, "");
    }

    if (page.calls.length >= self.callsPerPage) {
      if (page.number + 1 >= self.maxPages) {
        // remove oldest call and reorder calls to each page
        for (var i = 0; i < pages.length; i++) {
          var lastPageCall = pages[i].calls.pop();
          if (i + 1 < pages.length) {
            pages[i + 1].calls.unshift(lastPageCall);
          }
          self.persistPage(pages[i]);
        }
      } else {
        page = new Page(page.number + 1, "");
      }
    }

    // cookie vars
    var call = createCall(rtcSession);
    page.calls.unshift(call);
    self.persistPage(page);
    self.updateContent();
  };

  return self;

}
},{"../../js/config.js":632,"../constants":635,"webrtc-core":642}],637:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(HistoryView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var HistoryRow = require('./historyrow');
// var Factory = require('webrtc-core').factory;
var Constants = require('webrtc-core').constants;

function HistoryView(sound, history, statsView, callcontrol) {
  var self = {};

  self.model = history;

  self.rows = [];

  var updateContent = function(calls) {
    self.content.html("");
    self.rows = [];
    calls.forEach(function(call, i){
      var row = HistoryRow.create([call, history, self, i]);
      self.rows.push(row);
      row.view.appendTo(self.content);
    });
  };

  self.elements = ['content', 'forward', 'back', 'detailsClose', 'clear', 'callLink', 'close', 'statsHolder'];

  self.init = function() {
    statsView.view.appendTo(self.statsHolder);
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange('isForwardEnabled', function(value){
      self.forward.toggle(value);
    });
    databinder.onModelPropChange('isBackEnabled', function(value){
      self.back.toggle(value);
    });
    databinder.onModelPropChange('calls', function(calls){
      updateContent(calls);
    });
    self.forward.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.forward();
    });

    self.back.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.back();
    });

    self.close.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.hide();
    });

    self.detailsClose.bind('click', function(e) {
      e.preventDefault();
      history.deselectCall();
    });

    self.callLink.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      var destination = self.callLink.attr("data-destination");
      callcontrol.call(destination);
      history.hide();
      history.deselectCall();
    });

    self.clear.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      history.clear();
    });
  };

  return self;

}
},{"../../js/styles":633,"../../js/templates":634,"./historyrow":638,"webrtc-core":642}],638:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(HistoryRowView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function HistoryRowView(call, history, historyView, index) {
  var self = {};

  self.elements = ['destination', 'direction', 'date', 'length'];

  self.init = function() {
    self.view.attr('id', 'call_'+index);
    self.destination.text(call.destinationWithoutSip())
    self.direction.append("<i class='icon-arrow-" + call.direction + "-thick'></i>");
    self.date.text(Utils.formatDateTime(call.startDate()));
    self.length.text(call.length);
  };

  self.listeners = function(databinder) {
    self.view.on('click', function(e){
      e.preventDefault();
      history.setStats(call);
      historyView.callLink.attr("data-destination", call.destinationWithoutSip());
      historyView.callLink.text("Call " + call.destinationWithoutSip());
      history.selectCall(index);
    });
  };

  return self;

}
},{"../../js/styles":633,"../../js/templates":634,"webrtc-core":642}],639:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],640:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],641:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],642:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":641,"./bdsft":643,"./constants":646,"./cookieconfig":647,"./cookieprop":648,"./dateformat":651,"./debug":652,"./element":653,"./eventbus":654,"./factory":655,"./icon":656,"./loader":657,"./popup":658,"./prop":659,"./urlconfig":661,"./utils":662,"./visibleprop":663,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],643:[function(require,module,exports){
module.exports=require(54)
},{"./app":642,"./binding":644,"./classesbinding":645,"./databinder":650,"./stylesmanager":660,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":687}],644:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":643,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],645:[function(require,module,exports){
module.exports=require(56)
},{"./binding":644,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],646:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],647:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":643,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":687,"jquery.cookie":686}],648:[function(require,module,exports){
module.exports=require(59)
},{"./constants":646,"./prop":659,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":687,"jquery.cookie":686}],649:[function(require,module,exports){
module.exports=require(60)
},{"./constants":646,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":668}],650:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":671}],651:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],652:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":639,"./bdsft":643,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":664,"stacktrace-js":689}],653:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],654:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":643,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":671}],655:[function(require,module,exports){
module.exports=require(66)
},{"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":687}],656:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],657:[function(require,module,exports){
module.exports=require(68)
},{"../":642,"./constants":646,"./factory":655,"./stylesmanager":660,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":667}],658:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":687}],659:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":688}],660:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":640,"./constants":646,"./css":649,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],661:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":639,"./bdsft":643,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],662:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":641,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":687}],663:[function(require,module,exports){
module.exports=require(74)
},{"./constants":646,"./prop":659,"./utils":662,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],664:[function(require,module,exports){
module.exports=require(75)
},{"./debug":665,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],665:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":666}],666:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],667:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],668:[function(require,module,exports){
module.exports=require(79)
},{"./filters":669,"./utils":670,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],669:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],670:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],671:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":672,"es5-ext/object/valid-callable":681}],672:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":673,"es5-ext/object/is-callable":676,"es5-ext/object/normalize-options":680,"es5-ext/string/#/contains":683}],673:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":674,"./shim":675,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],674:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],675:[function(require,module,exports){
module.exports=require(86)
},{"../keys":677,"../valid-value":682,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],676:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],677:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":678,"./shim":679,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],678:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],679:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],680:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],681:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],682:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],683:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":684,"./shim":685,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],684:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],685:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],686:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":687}],687:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],688:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],689:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],690:[function(require,module,exports){
module.exports = {view: require('./lib/views/incomingcall'), model: require('./lib/models/incomingcall')};
},{"./lib/models/incomingcall":693,"./lib/views/incomingcall":694}],691:[function(require,module,exports){
module.exports = {"incomingcall":".bdsft-webrtc .callPopup{padding:0;background:#292929;border:1px solid #3c3c3c;box-shadow:none;border-radius:0;min-width:170px}.bdsft-webrtc .callPopup button{margin:10px;display:none}.bdsft-webrtc .callPopup span{color:#999;font-size:22px}.bdsft-webrtc .callPopup .col{display:inline-block;vertical-align:top}.bdsft-webrtc .callPopup .displayName,.bdsft-webrtc .callPopup .user{display:block;margin-left:10px;margin-bottom:18px}.bdsft-webrtc .callPopup .incomingCallTitle{display:block;padding:8px;font-size:18px;font-weight:bold;background:#3c3c3c;margin-bottom:18px;color:#e4e4e4}.bdsft-webrtc .callPopup .reject{background:#f00}.bdsft-webrtc .callPopup #rejectContainer{text-align:right}.bdsft-webrtc .callPopup.started .holdAndAccept,.bdsft-webrtc .callPopup.started .dropAndAccept,.bdsft-webrtc .callPopup:not(.started).hasRemoteVideo .accept,.bdsft-webrtc .callPopup:not(.started) .acceptAudio,.bdsft-webrtc .callPopup .reject{display:block}.bdsft-webrtc .callPopup.incomingcall-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .callPopup:not(.incomingcall-shown),.bdsft-webrtc .callPopup.failed{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1;transition:none}"}
},{}],692:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // incomingcall.jade compiled template
    templatizer["incomingcall"] = function tmpl_incomingcall() {
        return '<div class="bdsft-webrtc"><div class="callPopup fadeable popup classes centered"><span class="incomingCallTitle">Incoming Call</span><span class="displayName"></span><span class="user"></span><div><div class="col"><button type="button" class="accept button">Video</button><button type="button" class="acceptAudio button">Audio</button><button type="button" class="holdAndAccept button">Hold And Answer</button><button type="button" class="dropAndAccept button">Drop And Answer</button></div><div id="rejectContainer" class="col"><button type="button" class="reject button">Decline</button></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],693:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(IncomingCall)

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function IncomingCall(eventbus, sound, sipstack, urlconfig) {
  var self = {};

  self.props = ['displayName', 'user', 'classes', 'visible', 'hasRemoteVideo'];

  self.bindings = {
    'classes': {
        incomingcall: ['visible', 'hasRemoteVideo'],
        sipstack: ['callState', 'failed', 'audioOnly', 'offerToReceiveVideo']
    }
  }

  var incomingSession;

  var handle = function(){
    self.hide();
    sound.pause();
  };

  self.accept = function() {
    handle();
    sipstack.audioOnly = false;
    sipstack.offerToReceiveVideo = true;
    sipstack.answer(incomingSession)
  };

  self.acceptAudio = function() {
    handle();
    sipstack.audioOnly = true;
    sipstack.offerToReceiveVideo = false;
    sipstack.answer(incomingSession)
  };

  self.dropAndAccept = function() {
    handle();
    sipstack.terminateSession();
    sipstack.answer(incomingSession);
  };

  self.holdAndAccept = function() {
    handle();
    sipstack.holdAndAccept(incomingSession);
  };

  self.reject = function() {
    handle();
    sipstack.terminateSession(incomingSession);
  };

  self.listeners = function() {
    eventbus.on("incomingCall", function(evt) {
      incomingSession = evt.data.session;
      self.hasRemoteVideo = incomingSession.hasRemoteVideo();
      var from = evt.data && evt.data.request && evt.data.request.from || {};
      self.displayName = from.display_name || '';
      self.user = from.uri && from.uri.user || '';
      self.show();
      sound.playRingtone();
    });
  };

  return self;
}
},{"webrtc-core":698}],694:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(IncomingCallView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
})

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function IncomingCallView(incomingcall) {
  var self = {};

  self.model = incomingcall;
  
  self.elements = ['displayName', 'user', 'accept', 'acceptAudio', 'reject', 'holdAndAccept', 'dropAndAccept'];

  self.listeners = function() {
    self.accept.on('click', function(e) {
      e.preventDefault();
      incomingcall.accept();
    });
    self.acceptAudio.on('click', function(e) {
      e.preventDefault();
      incomingcall.acceptAudio();
    });
    self.reject.on('click', function(e) {
      e.preventDefault();
      incomingcall.reject();
    });
    self.holdAndAccept.on('click', function(e) {
      e.preventDefault();
      incomingcall.holdAndAccept();
    });
    self.dropAndAccept.on('click', function(e) {
      e.preventDefault();
      incomingcall.dropAndAccept();
    });
  };

  return self;
}
},{"../../js/styles":691,"../../js/templates":692,"webrtc-core":698}],695:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],696:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],697:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],698:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":697,"./bdsft":699,"./constants":702,"./cookieconfig":703,"./cookieprop":704,"./dateformat":707,"./debug":708,"./element":709,"./eventbus":710,"./factory":711,"./icon":712,"./loader":713,"./popup":714,"./prop":715,"./urlconfig":717,"./utils":718,"./visibleprop":719,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],699:[function(require,module,exports){
module.exports=require(54)
},{"./app":698,"./binding":700,"./classesbinding":701,"./databinder":706,"./stylesmanager":716,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":743}],700:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":699,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],701:[function(require,module,exports){
module.exports=require(56)
},{"./binding":700,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],702:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],703:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":699,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":743,"jquery.cookie":742}],704:[function(require,module,exports){
module.exports=require(59)
},{"./constants":702,"./prop":715,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":743,"jquery.cookie":742}],705:[function(require,module,exports){
module.exports=require(60)
},{"./constants":702,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":724}],706:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":727}],707:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],708:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":695,"./bdsft":699,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":720,"stacktrace-js":745}],709:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],710:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":699,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":727}],711:[function(require,module,exports){
module.exports=require(66)
},{"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":743}],712:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],713:[function(require,module,exports){
module.exports=require(68)
},{"../":698,"./constants":702,"./factory":711,"./stylesmanager":716,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":723}],714:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":743}],715:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":744}],716:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":696,"./constants":702,"./css":705,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],717:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":695,"./bdsft":699,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],718:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":697,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":743}],719:[function(require,module,exports){
module.exports=require(74)
},{"./constants":702,"./prop":715,"./utils":718,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],720:[function(require,module,exports){
module.exports=require(75)
},{"./debug":721,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],721:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":722}],722:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],723:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],724:[function(require,module,exports){
module.exports=require(79)
},{"./filters":725,"./utils":726,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],725:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],726:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],727:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":728,"es5-ext/object/valid-callable":737}],728:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":729,"es5-ext/object/is-callable":732,"es5-ext/object/normalize-options":736,"es5-ext/string/#/contains":739}],729:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":730,"./shim":731,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],730:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],731:[function(require,module,exports){
module.exports=require(86)
},{"../keys":733,"../valid-value":738,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],732:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],733:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":734,"./shim":735,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],734:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],735:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],736:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],737:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],738:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],739:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":740,"./shim":741,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],740:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],741:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],742:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":743}],743:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],744:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],745:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],746:[function(require,module,exports){
module.exports = {view: require('./lib/views/messages'), model: require('./lib/models/messages')};
},{"./lib/models/messages":751,"./lib/views/messages":752}],747:[function(require,module,exports){
module.exports = {
	enableMessages: true,
    messageIncomingCall: "Incoming Call",
    messageProgress: "Ringing",
    messageStarted: "Call Started",
    messageHold: "Call placed on hold",
    messageResume: "Call removed from hold",
    messageEnded: "Call Ended",
    messageCall: "Performing NAT Tests",
    messageFailed: "Call Failed : {0}",
    messageConnected: "Connected",
    messageConnectionFailed: "Connection failed",
    messageUnregistered: "Unregistered",
    messageRegistered: "Registration successful",
    messageRegistrationNotFound: "Registration : Not Found",
    messageRegistrationWrongPassword: "Registration : Wrong Password",
    messageGetUserMedia: "Unable to Access Camera and/or Microphone",
    messageRegistering: "Registering...",
    messageUnregistering: "Unregistering...",
    messageConnecting: "Connecting to WRS..."
};
},{}],748:[function(require,module,exports){
module.exports = {"messages":".bdsft-webrtc .messages{position:absolute;font-family:arial;text-align:left;width:auto;font-size:12px;bottom:auto;top:10px;left:10px}.bdsft-webrtc .messages.audioOnly:not(.offerToReceiveVideo){left:10px!important;top:48px!important;font-weight:bold;font-size:14px}.bdsft-webrtc .messages .msg{display:none}.bdsft-webrtc .messages:not(.connecting).connected.registering.enableMessages .messageRegistering,.bdsft-webrtc .messages:not(.connecting).connected.unregistering.enableMessages .messageUnregistering,.bdsft-webrtc .messages.connecting.enableMessages .messageConnecting,.bdsft-webrtc .messages.failed.enableMessages .messageFailed,.bdsft-webrtc .messages:not(.registering)._403.enableMessages .messageRegistrationWrongPassword,.bdsft-webrtc .messages:not(.registering)._404.enableMessages .messageRegistrationNotFound,.bdsft-webrtc .messages.userMediaFailed.enableMessages .messageGetUserMedia{display:block}.bdsft-webrtc .messages.hasMessageAlert.enableMessages .messageAlert,.bdsft-webrtc .messages.hasMessageNormal.enableMessages .messageNormal,.bdsft-webrtc .messages.hasMessageWarning.enableMessages .messageWarning,.bdsft-webrtc .messages.hasMessageSuccess.enableMessages .messageSuccess,.bdsft-webrtc .messages:not(.registered):not(.connecting):not(.registering):not(.unregistering):not(._403):not(._404).enableMessages .messageUnregistered,.bdsft-webrtc .messages:not(.connecting):not(.registering).registered.enableMessages .messageRegistered,.bdsft-webrtc .messages:not(.connecting):not(.connected).enableMessages .messageConnectionFailed,.bdsft-webrtc .messages:not(.connecting).connected.enableMessages .messageConnected{opacity:0;height:0;display:block;animation:flickerAnimation 3s;-webkit-animation:flickerAnimation 3s;-moz-animation:flickerAnimation 3s;-o-animation:flickerAnimation 3s}.bdsft-webrtc .messages .normal{color:<%= infoMessageColor %>}.bdsft-webrtc .messages .success{color:<%= successMessageColor %>}.bdsft-webrtc .messages .warning{color:<%= warningMessageColor %>}.bdsft-webrtc .messages .alert{color:<%= alertMessageColor %>}"}
},{}],749:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // messages.jade compiled template
    templatizer["messages"] = function tmpl_messages() {
        return '<div class="bdsft-webrtc"><div class="messages classes"><div class="messageGetUserMedia alert msg"></div><div class="messageConnectionFailed alert msg"></div><div class="messageRegistrationNotFound alert msg"></div><div class="messageRegistrationWrongPassword alert msg"></div><div class="messageFailed alert msg"></div><div class="messageAlert alert msg"></div><div class="messageWarning warning msg"></div><div class="messageSuccess success msg"></div><div class="messageConnected success msg"></div><div class="messageRegistered success msg"></div><div class="messageUnregistered success msg"></div><div class="messageNormal normal msg"></div><div class="messageConnecting normal msg"></div><div class="messageRegistering normal msg"></div><div class="messageUnregistering normal msg"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],750:[function(require,module,exports){
var C = {
  STYLES: {
    infoMessageColor: '#999999',
    successMessageColor: '#00FF00',
    warningMessageColor: '#FFFF00',
    alertMessageColor: '#FF0000'
  }
};

module.exports = C;
},{}],751:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Messages, {
  config: require('../../js/config.js')
})

var utils = require('webrtc-core').utils;

function Messages(eventbus, urlconfig, sipstack) {
  var self = {};

  self.props = ['messageAlert', 'messageWarning', 'messageSuccess', 'messageNormal', 'hasMessageAlert', 'hasMessageWarning', 'hasMessageSuccess', 'hasMessageNormal', 'classes'];

  self.updateMessageFailed = function(cause){
    self.messageFailed = require('../../js/config.js').messageFailed.replace('{0}', cause);
  };

  self.updateHasMessage = function(value, name){
    self[utils.camelize('has '+name)] = !!value;
  };

  self.bindings = {
    classes: {
        sipstack: ['registering', 'unregistering', 'connected', 'connecting', 'registered', 'registrationStatus', 'failed', 'userMediaFailed', 'audioOnly', 'offerToReceiveVideo'],
        messages: ['hasMessageAlert', 'hasMessageWarning', 'hasMessageSuccess', 'hasMessageNormal', 'enableMessages']
    },
    enableMessages: {
      urlconfig: 'enableMessages'
    },
    messageFailed: {
      sipstack: 'failedCause'
    },
    hasMessage: {
      messages: ['messageAlert', 'messageWarning', 'messageSuccess', 'messageNormal']
    }
  }

  var showMessage = function(level, text){
    self['message'+level] = ((self['message'+level] || '') +  ' ' + text).trim();
  }
  self.alert = function(text){
    showMessage('Alert', text);
  };
  self.normal = function(text){
    showMessage('Normal', text);
  };
  self.success = function(text){
    showMessage('Success', text);
  };
  self.warning = function(text){
    showMessage('Warning', text);
  };

  self.getRemoteUser = function(rtcSession) {
    return rtcSession && rtcSession.remote_identity && rtcSession.remote_identity.uri && (rtcSession.remote_identity.uri.user || rtcSession.remote_identity.uri.host);
  };

  self.showErrorPopup = function(error) {
    window.alert(error);
  };

  self.listeners = function(databinder, sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange("failedCause", function(cause) {
      if (cause === "User Denied Media Access") {
        self.showErrorPopup("WebRTC was not able to access your microphone/camera!");
      }
    });
    eventbus.on("ended", function(e) {
      self.normal(self.messageEnded.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("resumed", function(e) {
      self.success(self.messageResume.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.success(self.messageStarted.replace('{0}', self.getRemoteUser(e.sender)));
      }
    });
    eventbus.on("held", function(e) {
      self.success(self.messageHold.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("progress", function(e) {
      self.normal(self.messageProgress.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("calling", function(e) {
      self.normal(self.messageCall.replace('{0}', self.getRemoteUser(e.sender)));
    });
    eventbus.on("incomingCall", function(e) {
      self.success(self.messageIncomingCall.replace('{0}', self.getRemoteUser(e.sender)));
    });

  };

  return self;
}
},{"../../js/config.js":747,"webrtc-core":756}],752:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MessagesView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
})

var utils = require('webrtc-core').utils;

function MessagesView(messages) {
  var self = {};

  self.model = messages;
  
  self.elements = ['messageAlert', 'messageSuccess', 'messageWarning', 'messageNormal', 'messageRegistering', 'messageRegistered', 'messageUnregistered', 
  'messageConnectionFailed', 'messageConnected', 'messageConnecting', 'messageUnregistering', 'messageRegistrationNotFound', 
  'messageRegistrationWrongPassword', 'messageFailed', 'messageGetUserMedia'];

  self.listeners = function(){
  	var onAnimationEnd = function(e){
  		$(e.target).text('');
  		$(e.target).trigger('change');
  	};
  	self.messageAlert.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageSuccess.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageWarning.on('webkitAnimationEnd', onAnimationEnd);
  	self.messageNormal.on('webkitAnimationEnd', onAnimationEnd);
  };
  return self;
}
},{"../../js/styles":748,"../../js/templates":749,"../constants":750,"webrtc-core":756}],753:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],754:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],755:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],756:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":755,"./bdsft":757,"./constants":760,"./cookieconfig":761,"./cookieprop":762,"./dateformat":765,"./debug":766,"./element":767,"./eventbus":768,"./factory":769,"./icon":770,"./loader":771,"./popup":772,"./prop":773,"./urlconfig":775,"./utils":776,"./visibleprop":777,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],757:[function(require,module,exports){
module.exports=require(54)
},{"./app":756,"./binding":758,"./classesbinding":759,"./databinder":764,"./stylesmanager":774,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":801}],758:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":757,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],759:[function(require,module,exports){
module.exports=require(56)
},{"./binding":758,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],760:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],761:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":757,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":801,"jquery.cookie":800}],762:[function(require,module,exports){
module.exports=require(59)
},{"./constants":760,"./prop":773,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":801,"jquery.cookie":800}],763:[function(require,module,exports){
module.exports=require(60)
},{"./constants":760,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":782}],764:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":785}],765:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],766:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":753,"./bdsft":757,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":778,"stacktrace-js":803}],767:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],768:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":757,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":785}],769:[function(require,module,exports){
module.exports=require(66)
},{"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":801}],770:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],771:[function(require,module,exports){
module.exports=require(68)
},{"../":756,"./constants":760,"./factory":769,"./stylesmanager":774,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":781}],772:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":801}],773:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":802}],774:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":754,"./constants":760,"./css":763,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],775:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":753,"./bdsft":757,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],776:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":755,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":801}],777:[function(require,module,exports){
module.exports=require(74)
},{"./constants":760,"./prop":773,"./utils":776,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],778:[function(require,module,exports){
module.exports=require(75)
},{"./debug":779,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],779:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":780}],780:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],781:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],782:[function(require,module,exports){
module.exports=require(79)
},{"./filters":783,"./utils":784,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],783:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],784:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],785:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":786,"es5-ext/object/valid-callable":795}],786:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":787,"es5-ext/object/is-callable":790,"es5-ext/object/normalize-options":794,"es5-ext/string/#/contains":797}],787:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":788,"./shim":789,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],788:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],789:[function(require,module,exports){
module.exports=require(86)
},{"../keys":791,"../valid-value":796,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],790:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],791:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":792,"./shim":793,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],792:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],793:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],794:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],795:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],796:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],797:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":798,"./shim":799,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],798:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],799:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],800:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":801}],801:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],802:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],803:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],804:[function(require,module,exports){
module.exports = {view: require('./lib/views/settings'), model: require('./lib/models/settings')};
},{"./lib/models/settings":809,"./lib/views/settings":810}],805:[function(require,module,exports){
module.exports = {
    enableSettings: false
};
},{}],806:[function(require,module,exports){
module.exports = {"settings":".bdsft-webrtc .settingsPopup{padding:2px;position:absolute;line-height:28px;border:1px solid #3c3c3c;background:#292929;border-radius:0;box-shadow:none;bottom:40px;right:0;top:auto;left:auto;width:280px!important;font-size:14px;height:250px;overflow:hidden}.bdsft-webrtc .settingsPopup span{color:#999;font-size:20px;font-size:14px;line-height:28px;width:110px}.bdsft-webrtc .settingsPopup [type=\"checkbox\"]{width:18;height:18;vertical-align:middle}.bdsft-webrtc .settingsPopup .short{width:36px}.bdsft-webrtc .settingsPopup input{background:#333;border:1px solid #414141;color:#eee;padding:1px 1px 1px 5px;line-height:22px;font-size:13px;margin-left:14px;border-radius:0;width:auto}.bdsft-webrtc .settingsPopup select{margin-left:14px}.bdsft-webrtc .settingsPopup input,.bdsft-webrtc .settingsPopup select{width:140px}.bdsft-webrtc .settingsPopup .tabs span{margin-right:5px;color:#fff}.bdsft-webrtc .settingsPopup .btn{display:none;background:#04aff0;color:#fff;padding:5px 10px;text-decoration:none;border-radius:20px;margin-left:9px;margin-top:15px;font-weight:700;text-align:center}.bdsft-webrtc .settingsPopup .btn:hover{background:#017ead}.bdsft-webrtc .settingsPopup .resolutionSubType{display:none}.bdsft-webrtc .settingsPopup .tabs{width:250px;padding-left:0}.bdsft-webrtc .settingsPopup .tabs li{list-style:none;display:inline}.bdsft-webrtc .settingsPopup .tabs a{padding:5px 10px;display:inline-block;color:#fff;text-decoration:none}.bdsft-webrtc .settingsPopup .tabs a.active{color:#fff}.bdsft-webrtc .settingsPopup .tabs ~div p,.bdsft-webrtc .settingsPopup .tabs ~div h3{margin-bottom:15px;color:#999;font-size:14px}.bdsft-webrtc .settingsPopup .tabs ~ div{padding:10px;margin-bottom:10px}.bdsft-webrtc .settingsPopup.audioOnly:not(.offerToReceiveVideo){bottom:auto}.bdsft-webrtc .settingsPopup.standard .displayResolutionStandard,.bdsft-webrtc .settingsPopup.standard .encodingResolutionStandard,.bdsft-webrtc .settingsPopup.widescreen .displayResolutionWidescreen,.bdsft-webrtc .settingsPopup.widescreen .encodingResolutionWidescreen{display:inline-block}.bdsft-webrtc .settingsPopup #tab2{display:none}.bdsft-webrtc .settingsPopup.hd .resolutionRow{display:none}.bdsft-webrtc .settingsPopup .authentication-hidden{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .settingsPopup.enableSettings.settings-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .settingsPopup.enableSettings:not(.settings-shown){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .settingsPopup .tabs a.active{background:<%= settingsTabActiveColor %>}.bdsft-webrtc .settingsPopup .tabs a{background:<%= settingsTabInactiveColor %>}"}
},{}],807:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // authentication.jade compiled template
    templatizer["authentication"] = function tmpl_authentication() {
        return '<div class="bdsft-webrtc"><div class="authenticationView fadeable classes"><div class="useridRow row"><span class="cell">User ID</span><input type="text" value="" class="userid cell"/></div><div class="authenticationUseridRow row"><span class="cell">Auth User ID</span><input type="text" value="" class="authenticationUserid authUserid cell"/></div><div class="passwordRow row"><span class="cell">Password</span><input type="password" value="" class="password cell"/></div><div class="row"><div class="alert"></div></div><div class="row"><span class="cell"><a href="" title="Sign In" class="btn signIn">Sign In</a><a href="" title="Sign Out" class="btn signOut">Sign Out</a></span></div></div></div>';
    };

    // settings.jade compiled template
    templatizer["settings"] = function tmpl_settings() {
        return '<div class="bdsft-webrtc"><div class="settingsPopup table collapse fixed fadeable popup classes"><div class="row"><ul class="tabs"><li><a href="#tab1" class="configure"><span class="icon-cog"></span>Configure</a></li><li><a href="#tab2" class="layout"><span class="icon-th"></span>Layout</a></li></ul><div id="tab1"><div class="enableAutoAnswerRow row"><span class="cell">Auto Answer</span><input type="checkbox" class="enableAutoAnswer cell"/></div><div class="bandwidthRow row"><span class="cell">Bandwidth</span><span class="cell"><input type="text" maxlength="4" value="" placeholder="low" class="bandwidthLow short"/><input type="text" maxlength="4" value="" placeholder="medium" class="bandwidthMed short"/><input type="text" maxlength="4" value="" placeholder="high" class="bandwidthHigh short"/></span></div><div class="displayNameRow row"><span class="cell">Display Name</span><input type="text" value="" class="displayName cell"/></div><div class="authenticationRow"></div></div><div id="tab2"><div class="enableSelfViewRow row"><span class="cell">Enable Self View</span><input type="checkbox" class="enableSelfView cell"/></div><div class="hdRow row"><span class="cell">Use HD</span><input type="checkbox" class="hd cell"/></div><div class="resolutionRow"><div class="row"><span class="resolutionTypeRow cell">Mode</span><select class="resolutionType cell"><option value="standard">standard</option><option value="widescreen">widescreen</option></select></div><div class="row"><span class="displayResolutionRow cell">Resolution</span><span class="cell"><select class="displayResolutionStandard resolutionSubType"></select><select class="displayResolutionWidescreen resolutionSubType"></select></span></div><div class="row"><span class="encodingResolutionRow cell">Encoding</span><span class="cell"><select class="encodingResolutionStandard resolutionSubType"></select><select class="encodingResolutionWidescreen resolutionSubType"></select></span></div></div></div></div></div></div>';
    };

    // settingscontrol.jade compiled template
    templatizer["settingscontrol"] = function tmpl_settingscontrol() {
        return '<div class="bdsft-webrtc"><div class="cell cell-settings"><div class="settings icon fadeable"><a href="" title="Settings" class="icon-settings"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],808:[function(require,module,exports){
function reverse(array){
  var copy = Array.prototype.slice.call(array);  //local copy of the colors array
  copy.reverse();
  return copy;
}

var Constants = require('webrtc-core').constants;
var C = {};
module.exports = C;

C.STYLES = {
	settingsTabActiveColor: '#04aff0',
	settingsTabInactiveColor: '#494949'
};
C.STANDARD_RESOLUTIONS = {
  '960 x 720': Constants.R_960x720,
  '640 x 480': Constants.R_640x480,
  '320 x 240': Constants.R_320x240
};
C.standard = [Constants.R_960x720,Constants.R_640x480,Constants.R_320x240];
C.standardreverse = reverse(C.standard);

C.WIDESCREEN_RESOLUTIONS  = {
  // '1920 x 1080': Constants.R_1920x1080,
  '1280 x 720': Constants.R_1280x720,
  '640 x 360': Constants.R_640x360,
  '320 x 180': Constants.R_320x180
};
C.widescreen = [Constants.R_1280x720,Constants.R_640x360,Constants.R_320x180];
C.widescreenreverse = reverse(C.widescreen);

},{"webrtc-core":814}],809:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Settings, {
  config: require('../../js/config.js')
});

var Constants = require('../constants');
var coreConstants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Settings(debug, cookieconfig, urlconfig, sipstack, authentication, video) {
  var self = {};

  var getResolution = function(resolution, resolutionType){
    var standards = Constants.standardreverse;
    var widescreens = Constants.widescreenreverse;

    var index = 1;

    if(standards.indexOf(resolution) !== -1) {
      index = standards.indexOf(resolution);
    } else if(widescreens.indexOf(resolution) !== -1){
      index = widescreens.indexOf(resolution);
    } else if(resolution) {
      debug.error(resolution+' not found in standards or widescreen');
      return;
    }

    if(resolutionType === 'standard') {
      return index >= standards.length ? standards[standards.length-1] : standards[index];
    } else {
      return widescreens[index];
    }
  };

  self.updateResolutions = function(resolutionType){
    if(resolutionType) {
      self.displayResolution = getResolution(self.displayResolution, resolutionType);
      self.encodingResolution = getResolution(self.encodingResolution, resolutionType);
    }
  };

  self.updateResolutionType = function(value){
    if(!value) {
      self.resolutionType = undefined;
    } else if (Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.resolutionType = coreConstants.STANDARD;
    } else if (Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.resolutionType = coreConstants.WIDESCREEN;
    } else {
      throw Error('no resolution type for ' + value);
    }
  };

  self.updateDisplayResolutionStandard = function(value){
    if(Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.displayResolutionStandard = value;
    }
  };
  self.updateDisplayResolutionWidescreen = function(value){
    if(Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.displayResolutionWidescreen = value;
    }
  };
  self.updateEncodingResolutionStandard = function(value){
    if(Utils.containsKey(Constants.STANDARD_RESOLUTIONS, value)) {
      self.encodingResolutionStandard = value;
    }
  };
  self.updateEncodingResolutionWidescreen = function(value){
    if(Utils.containsKey(Constants.WIDESCREEN_RESOLUTIONS, value)) {
      self.encodingResolutionWidescreen = value;
    }
  };

  self.props = ['classes', 'visible', 'displayName', 'displayResolutionStandard', 'displayResolutionWidescreen',
    'encodingResolutionStandard', 'encodingResolutionWidescreen', 'resolutionType', 'displayResolution', 'encodingResolution', 'enableSelfView',
    'hd', 'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer'];

  self.bindings = {
    classes: {
      settings: ['visible', 'enableSettings', 'hd', 'resolutionType'],
      sipstack: ['registered', 'audioOnly', 'offerToReceiveVideo']
    },
    enableSettings: {
      urlconfig: 'enableSettings'
    },
    displayName: {
      cookieconfig: 'displayName',
      urlconfig: 'displayName'
    },
    resolutions: {
      settings: 'resolutionType'
    },
    resolutionType: {
      settings: ['displayResolution', 'displayResolutionStandard', 'displayResolutionWidescreen', 
      'encodingResolution', 'encodingResolutionStandard', 'encodingResolutionWidescreen']
    },
    displayResolution: {
      settings: ['displayResolutionStandard', 'displayResolutionWidescreen']
    },
    displayResolutionStandard: {
      settings: 'displayResolution'
    },
    displayResolutionWidescreen: {
      settings: 'displayResolution'
    },
    encodingResolution: {
      settings: ['encodingResolutionStandard', 'encodingResolutionWidescreen']
    },
    encodingResolutionStandard: {
      settings: 'encodingResolution'
    },
    encodingResolutionWidescreen: {
      settings: 'encodingResolution'
    }
  }

  self.listeners = function(databinder, cookieconfigDatabinder, videoDatabinder, sipstackDatabinder) {
    sipstackDatabinder.onModelPropChange(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'enableAutoAnswer', 'encodingResolution'], function(value, name) {
      self[name] = value;
    });
    videoDatabinder.onModelPropChange(['displayResolution', 'enableSelfView'], function(value, name) {
      self[name] = value;
    });
    cookieconfigDatabinder.onModelPropChange(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh',
      'displayResolution', 'encodingResolution', 'displayName', 'enableSelfView', 'hd', 'size', 'enableAutoAnswer'
    ], function(value, name) {
      self[name] = value;
    });
    databinder.onViewElChangeListener(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayResolution', 'encodingResolution', 
      'displayName', 'enableSelfView', 'hd', 'enableAutoAnswer'
    ], function(value, name) {
      cookieconfig[name] = value;
    });
    databinder.onModelPropChangeListener(['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayResolution', 'encodingResolution', 
      'displayName', 'enableSelfView', 'hd', 'enableAutoAnswer'
    ], function(value, name) {
      cookieconfig[name] = value;
    });
  };

  return self;
}
},{"../../js/config.js":805,"../constants":808,"webrtc-core":814}],810:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(SettingsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

var WebRTC_C = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;
var Constants = require('../constants');

function SettingsView(options, debug, sound, settings, authenticationView) {
  var self = {};

  self.model = settings;

  var updateRowVisibility = function() {
    self.enableAutoAnswerRow.toggleClass('hidden', options.hasOwnProperty("enableAutoAnswer"));
    self.enableSelfViewRow.toggleClass('hidden', options.hasOwnProperty("enableSelfView"));
    self.hdRow.toggleClass('hidden', options.hasOwnProperty("hd"));
    self.resolutionRow.toggleClass('hidden', options.hasOwnProperty("displayResolution") && options.hasOwnProperty("encodingResolution"));
    self.displayResolutionRow.toggleClass('hidden', options.hasOwnProperty("displayResolution"));
    self.encodingResolutionRow.toggleClass('hidden', options.hasOwnProperty("encodingResolution"));
    self.resolutionTypeRow.toggleClass('hidden', options.hasOwnProperty("displayResolution") || options.hasOwnProperty("encodingResolution"));
    // hide bandwidth rows because it's too technical to offer in view
    self.bandwidthLow.toggleClass('hidden', options.hasOwnProperty("bandwidthLow"));
    self.bandwidthMed.toggleClass('hidden', options.hasOwnProperty("bandwidthMed"));
    self.bandwidthHigh.toggleClass('hidden', options.hasOwnProperty("bandwidthHigh"));
    self.bandwidthRow.toggleClass('hidden', true);
    self.displayNameRow.toggleClass('hidden', options.hasOwnProperty("displayName"));
  };

  self.elements = ['displayName', 'resolutionType', 'displayResolutionWidescreen', 'displayResolutionStandard', 'encodingResolutionWidescreen',
    'encodingResolutionStandard', 'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayNameRow', 'enableSelfViewRow',
    'hdRow', 'enableAutoAnswerRow', 'resolutionTypeRow', 'displayResolutionRow', 'encodingResolutionRow', 'resolutionRow', 'bandwidthRow',
    'enableSelfView', 'hd', 'enableAutoAnswer', 'tabs', 'authenticationRow'
  ];

  self.init = function(options) {
    Utils.addSelectOptions(Constants.STANDARD_RESOLUTIONS, self.displayResolutionStandard, settings.displayResolutionStandard);
    Utils.addSelectOptions(Constants.STANDARD_RESOLUTIONS, self.encodingResolutionStandard, settings.encodingResolutionStandard);
    Utils.addSelectOptions(Constants.WIDESCREEN_RESOLUTIONS, self.displayResolutionWidescreen, settings.displayResolutionWidescreen);
    Utils.addSelectOptions(Constants.WIDESCREEN_RESOLUTIONS, self.encodingResolutionWidescreen, settings.encodingResolutionWidescreen);
    authenticationView.view.appendTo(self.authenticationRow);
    updateRowVisibility();
  };

  self.listeners = function() {
    self.tabs.each(function() {
      var active, activeTabSel, links = Utils.getElement(this).find('a');
      active = Utils.getElement(links.filter('[href="' + location.hash + '"]')[0] || links[0]);
      active.addClass('active');
      activeTabSel = active[0].hash;
      links.not(active).each(function() {
        Utils.getElement(this.hash).hide();
      });
      Utils.getElement(this).on('click', 'a', function(e) {
        e.preventDefault();
        active.removeClass('active');
        Utils.getElement(activeTabSel).hide();
        active = Utils.getElement(this);
        activeTabSel = this.hash;
        active.addClass('active');
        Utils.getElement(activeTabSel).show();
      });
    });
  };

  return self;
}
},{"../../js/styles":806,"../../js/templates":807,"../constants":808,"webrtc-core":814}],811:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],812:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],813:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],814:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":813,"./bdsft":815,"./constants":818,"./cookieconfig":819,"./cookieprop":820,"./dateformat":823,"./debug":824,"./element":825,"./eventbus":826,"./factory":827,"./icon":828,"./loader":829,"./popup":830,"./prop":831,"./urlconfig":833,"./utils":834,"./visibleprop":835,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],815:[function(require,module,exports){
module.exports=require(54)
},{"./app":814,"./binding":816,"./classesbinding":817,"./databinder":822,"./stylesmanager":832,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":859}],816:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":815,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],817:[function(require,module,exports){
module.exports=require(56)
},{"./binding":816,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],818:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],819:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":815,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":859,"jquery.cookie":858}],820:[function(require,module,exports){
module.exports=require(59)
},{"./constants":818,"./prop":831,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":859,"jquery.cookie":858}],821:[function(require,module,exports){
module.exports=require(60)
},{"./constants":818,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":840}],822:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":843}],823:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],824:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":811,"./bdsft":815,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":836,"stacktrace-js":861}],825:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],826:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":815,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":843}],827:[function(require,module,exports){
module.exports=require(66)
},{"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":859}],828:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],829:[function(require,module,exports){
module.exports=require(68)
},{"../":814,"./constants":818,"./factory":827,"./stylesmanager":832,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":839}],830:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":859}],831:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":860}],832:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":812,"./constants":818,"./css":821,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],833:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":811,"./bdsft":815,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],834:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":813,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":859}],835:[function(require,module,exports){
module.exports=require(74)
},{"./constants":818,"./prop":831,"./utils":834,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],836:[function(require,module,exports){
module.exports=require(75)
},{"./debug":837,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],837:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":838}],838:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],839:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],840:[function(require,module,exports){
module.exports=require(79)
},{"./filters":841,"./utils":842,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],841:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],842:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],843:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":844,"es5-ext/object/valid-callable":853}],844:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":845,"es5-ext/object/is-callable":848,"es5-ext/object/normalize-options":852,"es5-ext/string/#/contains":855}],845:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":846,"./shim":847,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],846:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],847:[function(require,module,exports){
module.exports=require(86)
},{"../keys":849,"../valid-value":854,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],848:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],849:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":850,"./shim":851,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],850:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],851:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],852:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],853:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],854:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],855:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":856,"./shim":857,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],856:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],857:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],858:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":859}],859:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],860:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],861:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],862:[function(require,module,exports){
module.exports = {model: require('./lib/models/sipstack'), exsip: require('exsip')};
},{"./lib/models/sipstack":864,"exsip":876}],863:[function(require,module,exports){
module.exports = {
	enabled: true,
    enableConnectLocalMedia: true,
    enableIms: false,
    enableAutoAnswer: false,
    enableDatachannel: false,
    endCallURL: false,
	encodingResolution: '640x480',
    websocketsServers: [{'ws_uri':'wss://webrtc-gw.broadsoftlabs.com:8443', 'weight':0}],
    stunServer: 'stun.broadsoftlabs.com',
	stunPort: 3478,
	domainFrom: 'broadsoftlabs.com',
    bandwidthLow: 128,
    bandwidthMed: 512,
    bandwidthHigh: 2048,
    pAssertedIdentity: '<sip:webguest@broadsoftlabs.com>',
    disableICE: true,
    audioOnly: false,
    offerToReceiveVideo: true,
    networkUserId: false,
    debug: false,
    dtmfDuration: 500,
    dtmfInterToneGap: 100
}

},{}],864:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(SIPStack, {
  config: require('../../js/config')
});

var ExSIP = require('exsip');
var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function SIPStack(eventbus, debug, urlconfig, cookieconfig) {
  var self = {};

  self.ua = null;
  self.activeSession = null;
  self.sessions = [];

  self.updateOfferToReceiveVideo = function(audioOnlyView){
    self.offerToReceiveVideo = !audioOnlyView;
  };

  self.updateUaConfig = function(){
    self.ua && self.ua.loadConfig(self.getExSIPConfig());
  };

  self.updateRtcMediaHandlerOptions = function() {
    self.ua && self.ua.setRtcMediaHandlerOptions(self.getRtcMediaHandlerOptions());
  };

  self.updateMediaConstraints = function() {
    self.mediaConstraints = {
        audio: true,
        video: getVideoConstraints()
      };
  };

  self.updateUserMedia = function(value, name, userMediaCallback, failureCallback) {
    if (!self.ua) {
      return;
    }

    self.userMediaFailed = false;

    if (self.enabled && (self.enableConnectLocalMedia || self.activeSession)) {
      var options = self.getExSIPOptions();
      var isWaitingForAnswer = self.activeSession && self.activeSession.status === ExSIP.RTCSession.C.STATUS_WAITING_FOR_ANSWER;
      self.ua.getUserMedia(options, function(localStream) {
        eventbus.userMediaUpdated(localStream);

        // don't change on incoming call to avoid  : Failed to set local offer sdp: Called in wrong state: STATE_RECEIVEDINITIATE
        if (self.activeSession && !isWaitingForAnswer) {
          debug.log("changing active session ...");
          self.activeSession.changeSession({
            localMedia: localStream,
            createOfferConstraints: options.createOfferConstraints
          }, function() {
            debug.log('change session succeeded');
          }, function() {
            debug.log('change session failed');
          });
        }

        if (userMediaCallback) {
          userMediaCallback(localStream);
        }
      }, function(e) {
        self.userMediaFailed = true;
        if (failureCallback) {
          failureCallback(e);
        }
      }, true);
    }
  };

  self.updateBandwidth = function(value, name){
    value = parseInt(value, 10);
    self[name] = value;
  };

  self.bindings = {
    mediaConstraints: {
      sipstack: ['audioOnly', 'encodingResolution', 'hd']
    },
    uaConfig: {
      sipstack: ['networkUserId', 'enableIms', 'domainFrom', 'debug', 'enableDatachannel', 'pAssertedIdentity', 'mediaConstraints'],
      cookieconfig: ['userid', 'authenticationUserid', 'password', 'displayName']
    },
    rtcMediaHandlerOptions: {
      sipstack: ['bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'encodingResolution']
    },
    userMedia: {
      sipstack: ['audioOnly', 'encodingResolution', 'enableConnectLocalMedia', 'offerToReceiveVideo']
    },
    bandwidth: {
      cookieconfig: ['bandwidthLow', 'bandwidthMed', 'bandwidthHigh']
    },
    hd: {
      cookieconfig: 'hd',
      urlconfig: 'hd'
    },
    encodingResolution: {
      cookieconfig: 'encodingResolution'
    },
    enableAutoAnswer: {
      cookieconfig: 'enableAutoAnswer',
      urlconfig: 'enableAutoAnswer'
    },
    networkUserId: {
      urlconfig: 'networkUserId'
    },
    enableIms: {
      urlconfig: 'enableIms'
    },
    enableConnectLocalMedia: {
      urlconfig: 'enableConnectLocalMedia'
    },
    audioOnly: {
      urlconfig: ['audioOnly', 'audioOnlyView']
    },
    offerToReceiveVideo: {
      urlconfig: 'audioOnlyView'
    }
  };

  self.props = ['callState', 'registered', 'hd', 'connected', 'registrationStatus', 'connecting', 'registering', 'unregistering', 'failed', 'failedCause',
  'userMediaFailed', 'mediaConstraints'];

  var checkEndCallURL = function() {
    if (self.endCallURL && self.enabled) {
      window.location = self.endCallURL;
    }
  };

  var getBandwidth = function() {
    var height = self.encodingResolutionHeight();
    if (height <= 240) {
      return self.bandwidthLow;
    } else if (height <= 480) {
      return self.bandwidthMed;
    } else if (height <= 1080) {
      return self.bandwidthHigh;
    } else {
      debug.log('getBandwidth : no encoding height matches : ', height);
    }
  };

  var getResolutionConstraints = function() {
    var width = self.encodingResolutionWidth();
    var height = self.encodingResolutionHeight();
    if (width && height) {
      if (height <= 480) {
        return {
          mandatory: {
            maxWidth: width,
            maxHeight: height
          }
        };
      } else {
        return {
          mandatory: {
            minWidth: width,
            minHeight: height
          }
        };
      }
    } else {
      return false;
    }
  };

  var getVideoConstraints = function() {
    if (self.audioOnly) {
      return false;
    } else {
      var constraints = getResolutionConstraints();
      return constraints ? constraints : true;
    }
  };

  var setActiveSession = function(session) {
    debug.log("setting active session to " + session.id);
    self.activeSession = session;
  };

  var updateCallState = function() {
    if (self.sessions.length > 0) {
      if (self.sessions.length === 1 && !self.sessions[0].isStarted()) {
        self.callState = Constants.STATE_CALLING;
      } else {
        if (self.activeSession && self.activeSession.isHeld()) {
          self.callState = [Constants.STATE_STARTED, Constants.STATE_HELD];
        } else {
          self.callState = Constants.STATE_STARTED;
        }
      }
    } else {
      if (self.ua && self.ua.isConnected && self.ua.isConnected()) {
        self.callState = Constants.STATE_CONNECTED;
      } else {
        self.callState = Constants.STATE_DISCONNECTED;
      }
    }
  };

  self.endCall = function(options) {
    options = options || {};
    var rtcSession = options.rtcSession;
    if (rtcSession === 'all') {
      self.terminateSessions();
    } else if (rtcSession) {
      self.terminateSession(rtcSession);
    } else {
      self.terminateSession();
    }
    // stop localMedia to turn off light
    if(!self.enableConnectLocalMedia && self.ua && self.ua.localMedia) {
      debug.log('endCall : stopping local media');
      self.ua.localMedia.stop();
    }
  };
  self.getLocalStreams = function() {
    return self.activeSession ? self.activeSession.getLocalStreams() : null;
  };
  self.getRemoteStreams = function() {
    return self.activeSession ? self.activeSession.getRemoteStreams() : null;
  };
  self.getSessionId = function() {
    return self.activeSession.id.replace(/\./g, '');
  };
  self.terminateSession = function(session) {
    session = session || self.activeSession;
    if (!session) {
      return;
    }
    var index = self.sessions.indexOf(session);
    if (index !== -1) {
      self.sessions.splice(index, index + 1);
    }
    if (session.status !== ExSIP.RTCSession.C.STATUS_TERMINATED) {
      session.terminate();
    }
    if (session === self.activeSession) {
      debug.log("clearing active session");
      self.activeSession = null;
    }
    updateCallState();
  };
  self.terminateSessions = function() {
    var allSessions = [];
    allSessions = allSessions.concat(self.sessions);
    for (var i = 0; i < allSessions.length; i++) {
      self.terminateSession(allSessions[i]);
    }
  };
  self.holdAndAccept = function(session) {
    var firstSession = self.activeSession;
    session.on('ended', function() {
      // eventbus.emit('message', {
      //   text: 'Resuming with ' + firstSession.remote_identity.uri.user,
      //   level: 'normal'
      // });
      debug.info("incoming call ended - unholding first call");
      firstSession.unhold(function() {
        debug.info("unhold first call successful");
      });
    });
    self.activeSession.hold(function() {
      debug.info("hold successful - answering incoming call");
      self.answer(session);
    });
  };
  self.answer = function(session) {
    session.answer(self.getExSIPOptions());
  };
  self.hold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.hold(function() {
        successCallback && successCallback();
      }, function(e) {
        failureCallback && failureCallback();
      });
    }
  };
  self.unhold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.unhold(function() {
        successCallback && successCallback();
      }, function(e) {
        failureCallback && failureCallback();
      });
    }
  };
  self.reconnectUserMedia = function(successCallback, failureCallback) {
    var onUserMediaUpdateSuccess = function(localMedia) {
      debug.log("reconnect user media successful");
      if (self.activeSession) {
        self.activeSession.changeSession({
          localMedia: localMedia
        }, function() {
          debug.log("session changed successfully");
          if (successCallback) {
            successCallback(localMedia);
          }
        }, failureCallback);
      } else if (successCallback) {
        successCallback(localMedia);
      }
    };
    self.updateUserMedia(null, null, onUserMediaUpdateSuccess, failureCallback);
  };
  self.call = function(destination) {
    var session = self.ua.call(destination, self.getExSIPOptions());
    eventbus.calling(destination, session);
  };
  self.sendDTMF = function(digit) {
    self.activeSession.sendDTMF(digit, self.getDTMFOptions());
  };
  self.isStarted = function() {
    return self.getCallState() === Constants.STATE_STARTED;
  };
  self.unregister = function() {
    self.unregistering = true;
    self.ua && self.ua.unregister();
    // eventbus.once('unregistered', function() {
    //   updateUA();
    // });
  };
  self.register = function() {
    self.registering = true;
    self.ua && self.ua.register();
    // updateUA(data);
  };
  self.sendData = function(data) {
    if (self.activeSession) {
      self.activeSession.sendData(data);
    }
  };
  self.transfer = function(transferTarget, isAttended) {
    if (isAttended) {
      self.ua.attendedTransfer(transferTarget, self.activeSession);
    } else {
      self.ua.transfer(transferTarget, self.activeSession);
    }
  };
  self.getCallState = function() {
    return self.callState;
  }

  // Incoming reinvite function
  self.incomingReInvite = function(e) {
    debug.log("auto accepting reInvite");
    e.data.session.acceptReInvite();
  };

  self.getExSIPOptions = function() {
    // Options Passed to ExSIP
    var options = {
      mediaConstraints: self.mediaConstraints,
      createOfferConstraints: {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: self.offerToReceiveVideo
        }
      }
    };
    return options;
  };

  self.setAudioOnlyOfferAndRec = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = !audioOnly;
    self.updateUserMedia();
  };

  self.setAudioOnly = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = true;
    self.updateUserMedia();
  };

  self.encodingResolutionWidth = function() {
    return Utils.resolutionWidth(self.hd && Constants.R_1280x720 || self.encodingResolution);
  };

  self.encodingResolutionHeight = function() {
    return Utils.resolutionHeight(self.hd && Constants.R_1280x720 || self.encodingResolution);
  };

  self.getExSIPConfig = function(data) {
    data = data || {};
    var userid = data.userId || cookieconfig.userid || self.networkUserId || Utils.randomUserid();

    var sip_uri = encodeURI(userid);
    if ((sip_uri.indexOf("@") === -1)) {
      sip_uri = (sip_uri + "@" + self.domainFrom);
    }

    var config = {
      'uri': sip_uri,
      'authorization_user': data.authenticationUserId || cookieconfig.authenticationUserid || userid,
      'password': data.password || cookieconfig.password,
      'ws_servers': self.websocketsServers,
      'stun_servers': 'stun:' + self.stunServer + ':' + self.stunPort,
      'trace_sip': self.debug,
      'enable_ims': self.enableIms,
      'enable_datachannel': self.enableDatachannel
    };

    // Add Display Name if set
    if (cookieconfig.displayName) {
      config.display_name = cookieconfig.displayName;
    }

    // do registration if User ID or register is set
    var register = data.authenticationUserId || cookieconfig.authenticationUserid || data.userId || cookieconfig.userid;
    if (register) {
      config.register = true;
    } else {
       // only set PAI if user is not registered
      config.p_asserted_identity = self.pAssertedIdentity;
      config.register = false;
    }
    return config;
  };

  self.getRtcMediaHandlerOptions = function() {
    var options = {
      reuseLocalMedia: self.enableConnectLocalMedia,
      videoBandwidth: getBandwidth(),
      disableICE: self.disableICE,
      RTCConstraints: {
        'optional': [],
        'mandatory': {}
      }
    };
    return options;
  };

  self.getDTMFOptions = function() {
    return {
      duration: self.dtmfDuration,
      interToneGap: self.dtmfInterToneGap
    };
  };

  self.createUA = function(config) {
    return new ExSIP.UA(config);
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange(['websocketsServers'], function(){
      self.ua && updateUA();
    });
    window.onbeforeunload = function(e) {
      self.endCall({
        rtcSession: 'all'
      });
      return null;
    };
    eventbus.on(["disconnected", "endCall", "ended"], function(e) {
      checkEndCallURL();
    });
    eventbus.on(["ended", "endCall"], function(e) {
      self.endCall({
        rtcSession: e.sender
      });
    });
    eventbus.on("resumed", function(e) {
      setActiveSession(e.sender);
    });
    eventbus.on("started", function(e) {
      setActiveSession(e.sender);
    });
  };

  self.init = function() {
    updateUA();
  };

  var updateUA = function() {
    try {
      if (self.callState && (self.callState !== Constants.STATE_CONNECTED && self.callState !== Constants.STATE_DISCONNECTED)) {
        debug.warn('not able to restart UA - call state is ' + self.callState);
        return;
      }

      if (self.ua) {
        debug.log('stopping existing UA');
        self.ua.stop();
      }

      if (!self.enabled) {
        debug.warn('sipstack disabled');
        return;
      }
      self.connecting = true;
      var config = self.getExSIPConfig();
      self.registering = config.register;
      self.ua = self.createUA(config);

      self.updateRtcMediaHandlerOptions();

      // Start SIP Stack
      self.ua.start();

      // sipStack callbacks
      self.ua.on('connected', function(e) {
        self.connecting = false;
        updateCallState();
        self.connected = true;
        self.updateUserMedia();
      });
      self.ua.on('disconnected', function(e) {
        self.connecting = false;
        updateCallState();
        self.connected = false;
        self.endCall({
          rtcSession: 'all'
        });
      });
      self.ua.on('onReInvite', function(e) {
        debug.log("incoming onReInvite event");
        self.incomingReInvite(e);
        eventbus.reInvite(e);
      });
      self.ua.on('newRTCSession', function(e) {
        self.failed = undefined;
        self.failedCause = undefined;

        var session = e.data.session;
        self.sessions.push(session);
        updateCallState();

        // call event handlers
        session.on('progress', function(e) {
          eventbus.progress(e);
        });
        session.on('failed', function(e) {
          var data = e.data;
          data.sender = e.sender;
          self.failed = true;
          self.failedCause = data.cause;
          self.endCall({
            rtcSession: e.sender
          });
          eventbus.failed(e);
        });
        session.on('started', function(e) {
          updateCallState();
          eventbus.started(e);
        });
        session.on('resumed', function(e) {
          updateCallState();
          eventbus.resumed(e);
        });
        session.on('held', function(e) {
          updateCallState();
          eventbus.held(e);
        });
        session.on('ended', function(e) {
          updateCallState();
          eventbus.ended(e);
        });
        session.on('newDTMF', function(e) {
          eventbus.newDTMF(e);
        });
        session.on('dataSent', function(e) {
          eventbus.dataSent(e);
        });
        session.on('dataReceived', function(e) {
          eventbus.dataReceived(e);
        });
        session.on('iceconnected', function(e) {
          eventbus.iceconnected(e.sender, e.data);
        });
        session.on('icecompleted', function(e) {
          eventbus.icecompleted(e.sender, e.data);
        });
        session.on('iceclosed', function(e) {
          eventbus.iceclosed(e.sender, e.data);
        });

        // handle incoming call
        if (e.data.session.direction === "incoming") {
          if (!self.activeSession && self.enableAutoAnswer) {
            session.answer(self.getExSIPOptions());
            return;
          } else {
            eventbus.incomingCall(e);
          }
        }

        if (!self.activeSession) {
          setActiveSession(session);
        }
      });

      self.ua.on('registered', function() {
        self.registering = false;
        self.registered = true;
        self.registrationStatus = undefined;
      });
      self.ua.on('unregistered', function() {
        self.unregistering = false;
        self.registered = false;
        self.registrationStatus = undefined;
      });
      self.ua.on('registrationFailed', function(e) {
        self.unregistering = false;
        self.registering = false;
        self.registered = false;
        self.registrationStatus = e.data && e.data.response && e.data.response.status_code+"";
      });
    } catch (e) {
      console.error(e.stack);
      debug.error('could not init sip stack');
    }
  };

  return self;
}
},{"../../js/config":863,"exsip":876,"webrtc-core":902}],865:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
      name: 'version',
      reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: "%d %d"
  }],
  c: [{ //c=IN IP4 10.47.197.26
      name: 'connection',
      reg: /^IN IP(\d) (\S*)/,
      names: ['version', 'ip'],
      format: "IN IP%d %s"
  }],
  b: [{ //b=AS:4000
      push: 'bandwidth',
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ['type', 'limit'],
      format: "%s:%s"
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
      names: ['type', 'port', 'protocol', 'payloads'],
      format: "%s %d %s %s"
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          "rtpmap:%d %s/%s/%s":
          "rtpmap:%d %s/%s";
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      push: 'fmtp',
      reg: /^fmtp:(\d*) (\S*)/,
      names: ['payload', 'config'],
      format: "fmtp:%d %s"
    },
    { //a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: "control:%s"
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          "rtcp:%d %s IP%d %s":
          "rtcp:%d";
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: "rtcp-fb:%d trr-int %d"
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          "rtcp-fb:%s %s %s":
          "rtcp-fb:%s %s";
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['value', 'uri', 'config'], // value may include "/direction" suffix
      format: function (o) {
        return (o.config != null) ?
          "extmap:%s %s %s":
          "extmap:%s %s"
      }
    },
    {
      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          "crypto:%d %s %s %s":
          "crypto:%d %s %s";
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:(\w*)/,
      format: "mid:%s"
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: "ptime:%d"
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: "maxptime:%d"
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/,
      format: "%s"
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: "fingerprint:%s %s"
    },
    {
      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'generation'],
      format: function (o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        // NB: candidate has two optional chunks, so %void middle one if it's missing
        str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
        if (o.generation != null) {
          str += " generation %d";
        }
        return str;
      }
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
      names: ['id', 'attribute', 'value'],
      format: "ssrc:%d %s:%s"
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic: (\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: "msid-semantic: %s %s" // space after ":" is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: "group:%s %s"
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ["value"]
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
}); 

},{}],866:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;

},{"./parser":867,"./writer":868}],867:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split('\r\n').filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var fmtpReducer = function (acc, expr) {
  var s = expr.split('=');
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseFmtpConfig = function (str) {
  return str.split(';').reduce(fmtpReducer, {});
};

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

},{"./grammar":865}],868:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // "v=0" must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = " "; // "s= " must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":865}],869:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],870:[function(require,module,exports){
module.exports={
  "name": "exsip",
  "title": "ExSIP",
  "description": "BroadSoft Javascript SIP library",
  "version": "2.0.0",
  "homepage": "http://www.broadsoft.com",
  "author": "BroadSoft, Inc.",
  "contributors": [
    {
      "url": ""
    }
  ],
  "main": "src/ExSIP.js",
  "repository": {
    "type": "git",
    "url": ""
  },
  "keywords": [
    "sip",
    "websocket",
    "webrtc",
    "library"
  ],
  "dependencies": {
    "sdp-transform": "0.6.1",
    "ws": "0.4.32"
  },
  "devDependencies": {
    "nodeunit": "0.9.0",
    "grunt": "0.4.5",
    "grunt-contrib-jshint": "0.10.0",
    "grunt-contrib-concat": "0.5.0",
    "grunt-contrib-uglify": "0.6.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-contrib-symlink": "0.3.0",
    "grunt-browserify": "3.0.1",
    "grunt-jsdoc": "0.5.7",
    "grunt-notify": ">=0.2.6",
    "grunt-bumpx": "0.1.5",
    "pegjs": "0.7.0",
    "grunt-mocha-test": "0.12.7",
    "expect": "1.6.0",
    "mocha": "2.1.0"
  },
  "engines": {
    "node": ">=0.8"
  },
  "license": "MIT",
  "scripts": {
    "test": "grunt travis --verbose"
  }
}

},{}],871:[function(require,module,exports){
var pkg = require('../package.json');

var C = {
  USER_AGENT: 'BroadSoft WebRTC Client - ' +  pkg.version,

  // SIP scheme
  SIP:  'sip',
  SIPS: 'sips',

  // End and Failure causes
  causes: {
    // Generic error causes
    CONNECTION_ERROR:         'Connection Error',
    REQUEST_TIMEOUT:          'Request Timeout',
    SIP_FAILURE_CODE:         'SIP Failure Code',
    INTERNAL_ERROR:           'Internal Error',

    // SIP error causes
    BUSY:                     'Busy',
    REJECTED:                 'Rejected',
    REDIRECTED:               'Redirected',
    UNAVAILABLE:              'Unavailable',
    NOT_FOUND:                'Not Found',
    ADDRESS_INCOMPLETE:       'Address Incomplete',
    INCOMPATIBLE_SDP:         'Incompatible SDP',
    MISSING_SDP:              'Missing SDP',
    AUTHENTICATION_ERROR:     'Authentication Error',
    DIALOG_ERROR:             'Dialog Error',

    // Session error causes
    BYE:                      'Terminated',
    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
    WEBRTC_ERROR:             'WebRTC Error',
    CANCELED:                 'Canceled',
    NO_ANSWER:                'No Answer',
    EXPIRES:                  'Expires',
    NO_ACK:                   'No ACK',
    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
    RTP_TIMEOUT:              'RTP Timeout',
    NOT_ACCEPTABLE_ERROR:     'Not Acceptable'
  },

  SIP_ERROR_CAUSES: {
    REDIRECTED: [300,301,302,305,380],
    BUSY: [486,600],
    REJECTED: [403,603],
    NOT_FOUND: [404,604],
    UNAVAILABLE: [480,410,408,430],
    ADDRESS_INCOMPLETE: [484],
    INCOMPATIBLE_SDP: [488],
    AUTHENTICATION_ERROR:[401,407],
    NOT_ACCEPTABLE_ERROR:[606]
  },

  // SIP Methods
  ACK:        'ACK',
  BYE:        'BYE',
  CANCEL:     'CANCEL',
  INFO:       'INFO',
  INVITE:     'INVITE',
  REFER:      'REFER',
  MESSAGE:    'MESSAGE',
  NOTIFY:     'NOTIFY',
  OPTIONS:    'OPTIONS',
  REGISTER:   'REGISTER',
  UPDATE:     'UPDATE',
  SUBSCRIBE:  'SUBSCRIBE',

  // MODES
  SENDONLY:  'sendonly',
  RECVONLY:  'recvonly',
  SENDRECV:  'sendrecv',
  INACTIVE:  'inactive',

  /* SIP Response Reasons
   * DOC: http://www.iana.org/assignments/sip-parameters
   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
   */
  REASON_PHRASE: {
    100: 'Trying',
    180: 'Ringing',
    181: 'Call Is Being Forwarded',
    182: 'Queued',
    183: 'Session Progress',
    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
    200: 'OK',
    202: 'Accepted',  // RFC 3265
    204: 'No Notification',  //RFC 5839
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    305: 'Use Proxy',
    380: 'Alternative Service',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    410: 'Gone',
    412: 'Conditional Request Failed',  // RFC 3903
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Unsupported URI Scheme',
    417: 'Unknown Resource-Priority',  // RFC 4412
    420: 'Bad Extension',
    421: 'Extension Required',
    422: 'Session Interval Too Small',  // RFC 4028
    423: 'Interval Too Brief',
    428: 'Use Identity Header',  // RFC 4474
    429: 'Provide Referrer Identity',  // RFC 3892
    430: 'Flow Failed',  // RFC 5626
    433: 'Anonymity Disallowed',  // RFC 5079
    436: 'Bad Identity-Info',  // RFC 4474
    437: 'Unsupported Certificate',  // RFC 4744
    438: 'Invalid Identity Header',  // RFC 4744
    439: 'First Hop Lacks Outbound Support',  // RFC 5626
    440: 'Max-Breadth Exceeded',  // RFC 5393
    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
    470: 'Consent Needed',  // RFC 5360
    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
    480: 'Temporarily Unavailable',
    481: 'Call/Transaction Does Not Exist',
    482: 'Loop Detected',
    483: 'Too Many Hops',
    484: 'Address Incomplete',
    485: 'Ambiguous',
    486: 'Busy Here',
    487: 'Request Terminated',
    488: 'Not Acceptable Here',
    489: 'Bad Event',  // RFC 3265
    491: 'Request Pending',
    493: 'Undecipherable',
    494: 'Security Agreement Required',  // RFC 3329
    500: 'ExSIP Internal Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Server Time-out',
    505: 'Version Not Supported',
    513: 'Message Too Large',
    580: 'Precondition Failure',  // RFC 3312
    600: 'Busy Everywhere',
    603: 'Decline',
    604: 'Does Not Exist Anywhere',
    606: 'Not Acceptable'
  },

  ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS',
  ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',
  MAX_FORWARDS: 69
};


module.exports = C;

},{"../package.json":870}],872:[function(require,module,exports){
module.exports = Dialog;


var C = {
  // Dialog states
  STATUS_EARLY:       1,
  STATUS_CONFIRMED:   2
};

/**
 * Expose C object.
 */
Dialog.C = C;


/**
 * Dependencies.
 */
var SIPMessage = require('./SIPMessage');
var ExSIP_C = require('./Constants');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var Dialog_RequestSender = require('./Dialog/RequestSender');


// RFC 3261 12.1
function Dialog(owner, message, type, state) {
  var contact;

  this.uac_pending_reply = false;
  this.uas_pending_reply = false;
  this.is_acknowledged = false;
  this.type = type;

  if(!message.hasHeader('contact')) {
    return {
      error: 'unable to create a Dialog without Contact header field'
    };
  }

  if(message instanceof SIPMessage.IncomingResponse) {
    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
  } else {
    // Create confirmed dialog if state is not defined
    state = state || C.STATUS_CONFIRMED;
  }

  contact = message.parseHeader('contact');

  // RFC 3261 12.1.1
  if(type === 'UAS') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.to_tag,
      remote_tag: message.from_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.remote_seqnum = message.cseq;
    this.local_uri = message.parseHeader('to').uri;
    this.remote_uri = message.parseHeader('from').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route');
  }
  // RFC 3261 12.1.2
  else if(type === 'UAC') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.from_tag,
      remote_tag: message.to_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.local_seqnum = message.cseq;
    this.local_uri = message.parseHeader('from').uri;
    this.remote_uri = message.parseHeader('to').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route').reverse();
  }

  this.logger = owner.ua.getLogger('ExSIP.dialog', this.id.toString());
  this.owner = owner;
  owner.ua.dialogs[this.id.toString()] = this;
  this.logger.debug('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
}


Dialog.prototype = {
  isUAS: function() {
    return this.type === 'UAS';
  },

  isUAC: function() {
    return this.type === 'UAC';
  },

  update: function(message, type) {
    this.state = C.STATUS_CONFIRMED;

    this.logger.debug('dialog '+ this.id.toString() +'  changed to CONFIRMED state');

    if(type === 'UAC') {
      // RFC 3261 13.2.2.4
      this.route_set = message.getHeaders('record-route').reverse();
    }
  },

  terminate: function() {
    this.logger.debug('dialog ' + this.id.toString() + ' deleted');
    delete this.owner.ua.dialogs[this.id.toString()];
  },

  // RFC 3261 12.2.1.1
  createRequest: function(method, extraHeaders, body) {
    var cseq, request;
    extraHeaders = extraHeaders && extraHeaders.slice() || [];

    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }

    cseq = (method === ExSIP_C.CANCEL || method === ExSIP_C.ACK) ? this.local_seqnum : this.local_seqnum += 1;

    request = new SIPMessage.OutgoingRequest(
      method,
      this.remote_target,
      this.owner.ua, {
        'cseq': cseq,
        'call_id': this.id.call_id,
        'from_uri': this.local_uri,
        'from_tag': this.id.local_tag,
        'to_uri': this.remote_uri,
        'to_tag': this.id.remote_tag,
        'route_set': this.route_set
      }, extraHeaders, body);

  this.logger.debug('createRequest : dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    request.dialog = this;

    return request;
  },

  // RFC 3261 12.2.2
  checkInDialogRequest: function(request) {
    var self = this;

    // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
    if (request.method === ExSIP_C.INVITE || (request.method === ExSIP_C.UPDATE && request.body)) {
      if (this.uac_pending_reply === true) {
        request.reply(491);
      } else if (this.uas_pending_reply === true || (this.type === 'UAS' && !this.is_acknowledged)) {
        var retryAfter = (Math.random() * 10 | 0) + 1;
        request.reply(500, null, ['Retry-After:'+ retryAfter]);
        return false;
      } else {
        this.uas_pending_reply = true;
        request.server_transaction.on('stateChanged', function stateChanged(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
              e.sender.state === Transactions.C.STATUS_COMPLETED ||
              e.sender.state === Transactions.C.STATUS_TERMINATED) {

            request.server_transaction.removeListener('stateChanged', stateChanged);
            self.uas_pending_reply = false;

            if (self.uac_pending_reply === false) {
              self.owner.onReadyToReinvite();
            }
          }
        });
      }

      // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.NOTIFY) {
      // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_COMPLETED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.ACK) {
      this.is_acknowledged = true;
    }

    if(!this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    } else if(request.cseq < this.remote_seqnum) {
        //Do not try to reply to an ACK request.
        if (request.method !== ExSIP_C.ACK) {
          request.reply(500);
        }
        return false;
    } else if(request.cseq > this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    }

    return true;
  },

  createRequestSender: function(applicant, method, options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
      body = options.body || null,
      request = this.createRequest(method, extraHeaders, body),
      request_sender = new Dialog_RequestSender(this, applicant, request);
  this.logger.debug('dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    return request_sender;  
  },

  sendRequest: function(applicant, method, options) {
      var request_sender = this.createRequestSender(applicant, method, options);
      request_sender.send();
  },

  receiveRequest: function(request) {
    //Check in-dialog request
    if(!this.checkInDialogRequest(request)) {
      return;
    }

    this.owner.receiveRequest(request);
  }
};

},{"./Constants":871,"./Dialog/RequestSender":873,"./SIPMessage":890,"./Transactions":892,"./Utils":896}],873:[function(require,module,exports){
module.exports = DialogRequestSender;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var Transactions = require('../Transactions');
var RTCSession = require('../RTCSession');
var RequestSender = require('../RequestSender');


function DialogRequestSender(dialog, applicant, request) {

  this.dialog = dialog;
  this.applicant = applicant;
  this.request = request;

  this.logger = dialog.owner.ua.getLogger('ExSIP.dialog.requestsender', dialog.id);

  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
  this.reattempt = false;
  this.reattemptTimer = null;
}


DialogRequestSender.prototype = {
  send: function(callbacks) {
    var
      self = this,
      request_sender = new RequestSender(this, this.dialog.owner.ua);

    request_sender.send(callbacks);

    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
    if (this.request.method === ExSIP_C.INVITE && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {
      this.dialog.uac_pending_reply = true;
      request_sender.clientTransaction.on('stateChanged', function stateChanged(e) {
        if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
          e.sender.state === Transactions.C.STATUS_COMPLETED ||
          e.sender.state === Transactions.C.STATUS_TERMINATED) {

          request_sender.clientTransaction.removeListener('stateChanged', stateChanged);
          self.dialog.uac_pending_reply = false;

          if (self.dialog.uas_pending_reply === false) {
            self.dialog.owner.onReadyToReinvite();
          }
        }
      });
    }
  },

  onRequestTimeout: function() {
    this.logger.log('********* onRequestTimeout : ', this.applicant);
    this.applicant.onRequestTimeout();
  },

  onTransportError: function() {
    this.applicant.onTransportError();
  },

  // RFC3261 14.1
  getReattemptTimeout: function() {
    if(this.applicant.direction === 'outgoing') {
      return (Math.random() * (4 - 2.1) + 2.1).toFixed(2);
    } else {
      return (Math.random() * 2).toFixed(2);
    }
  },

  receiveResponse: function(response) {
    var self = this;

    this.logger.debug('receiveResponse : ' + response);

    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
    if (response.status_code === 408 || response.status_code === 481) {
      this.applicant.onDialogError(response);
    } else if (response.method === ExSIP_C.INVITE && response.status_code === 491) {
      if (this.reattempt) {
        this.applicant.receiveResponse(response);
      } else {
        this.request.cseq.value = this.dialog.local_seqnum += 1;
        this.reattemptTimer = setTimeout(
          function() {
            if (self.applicant.owner.status !== RTCSession.C.STATUS_TERMINATED) {
              self.reattempt = true;
              self.request_sender.send();
            }
          },
          this.getReattemptTimeout()
        );
      }
    } else {
      this.applicant.receiveResponse(response);
    }
  }
};
},{"../Constants":871,"../RTCSession":884,"../RequestSender":889,"../Transactions":892}],874:[function(require,module,exports){
module.exports = DigestAuthentication;


function DigestAuthentication(ua) {
  this.logger = ua.getLogger('ExSIP.digestauthentication');
  this.username = ua.configuration.authorization_user;
  this.password = ua.configuration.password;
  this.cnonce = null;
  this.nc = 0;
  this.ncHex = '00000000';
  this.response = null;
}


/**
 * Dependencies.
 */
var Utils = require('./Utils');


/**
* Performs Digest authentication given a SIP request and the challenge
* received in a response to that request.
* Returns true if credentials were successfully generated, false otherwise.
<<<<<<< HEAD
* 
* @param {ExSIP.OutgoingRequest} request
* @param {Object} challenge
=======
>>>>>>> ExSIP050
*/
DigestAuthentication.prototype.authenticate = function(request, challenge) {
  // Inspect and validate the challenge.

  this.algorithm = challenge.algorithm;
  this.realm = challenge.realm;
  this.nonce = challenge.nonce;
  this.opaque = challenge.opaque;
  this.stale = challenge.stale;

  if (this.algorithm) {
    if (this.algorithm !== 'MD5') {
      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
      return false;
    }
  } else {
    this.algorithm = 'MD5';
  }

  if (! this.realm) {
    this.logger.warn('challenge without Digest realm, authentication aborted');
    return false;
  }

  if (! this.nonce) {
    this.logger.warn('challenge without Digest nonce, authentication aborted');
    return false;
  }

  // 'qop' can contain a list of values (Array). Let's choose just one.
  if (challenge.qop) {
    if (challenge.qop.indexOf('auth') > -1) {
      this.qop = 'auth';
    } else if (challenge.qop.indexOf('auth-int') > -1) {
      this.qop = 'auth-int';
    } else {
      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
      return false;
    }
  } else {
    this.qop = null;
  }

  // Fill other attributes.

  this.method = request.method;
  this.uri = request.ruri;
  this.cnonce = Utils.createRandomToken(12);
  this.nc += 1;
  this.updateNcHex();

  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
  if (this.nc === 4294967296) {
    this.nc = 1;
    this.ncHex = '00000001';
  }

  // Calculate the Digest "response" value.
  this.calculateResponse();

  return true;
};


/**
* Generate Digest 'response' value.
*/
DigestAuthentication.prototype.calculateResponse = function() {
  var ha1, ha2;

  // HA1 = MD5(A1) = MD5(username:realm:password)
  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);

  if (this.qop === 'auth') {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);

  } else if (this.qop === 'auth-int') {
    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);

  } else if (this.qop === null) {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
  }
};


/**
* Return the Proxy-Authorization or WWW-Authorization header value.
*/
DigestAuthentication.prototype.toString = function() {
  var auth_params = [];

  if (! this.response) {
    throw new Error('response field does not exist, cannot generate Authorization header');
  }

  auth_params.push('algorithm=' + this.algorithm);
  auth_params.push('username="' + this.username + '"');
  auth_params.push('realm="' + this.realm + '"');
  auth_params.push('nonce="' + this.nonce + '"');
  auth_params.push('uri="' + this.uri + '"');
  auth_params.push('response="' + this.response + '"');
  if (this.opaque) {
    auth_params.push('opaque="' + this.opaque + '"');
  }
  if (this.qop) {
    auth_params.push('qop=' + this.qop);
    auth_params.push('cnonce="' + this.cnonce + '"');
    auth_params.push('nc=' + this.ncHex);
  }

  return 'Digest ' + auth_params.join(', ');
};


/**
* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
*/
DigestAuthentication.prototype.updateNcHex = function() {
  var hex = Number(this.nc).toString(16);
  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
};
},{"./Utils":896}],875:[function(require,module,exports){
module.exports = EventEmitter;


function EventEmitter() {}


/**
 * Dependencies.
 */
var LoggerFactory = require('./LoggerFactory');


function Event(type, sender, data) {
  this.type = type;
  this.sender= sender;
  this.data = data;
}


var
  logger = new LoggerFactory().getLogger('ExSIP.eventemitter'),
  C = {
    MAX_LISTENERS: 50
  };


EventEmitter.prototype = {
  /**
   * Initialize events dictionaries.
   * -param {Array} events
   */
  initEvents: function(events) {
    var idx, length;

    if (!this.logger) {
      this.logger = logger;
    }

    this.maxListeners = C.MAX_LISTENERS;

    this.events = {};
    this.oneTimeListeners = {};

    length = events.length;
    for (idx = 0; idx < length; idx++) {
      this.events[events[idx]] = [];
      this.oneTimeListeners[events[idx]] = [];
    }
  },

  /**
   * Check whether an event exists or not.
   */
  checkEvent: function(event) {
    return !!this.events[event];
  },

  /**
   * Add a listener to the end of the listeners array for the specified event.
   */
  addListener: function(event, listener) {
    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to add a listener to a nonexistent event ' + event);
      return;
    }

    if (this.events[event].length >= this.maxListeners) {
      this.logger.warn('max listeners exceeded for event ' + event);
    }

    this.events[event].push(listener);
  },

  on: function(event, listener) {
    this.addListener(event, listener);
  },

  /**
   * Add a one time listener for the specified event.
   * The listener is invoked only the next time the event is fired, then it is removed.
   */
  once: function(event, listener) {
    this.on(event, listener);
    this.oneTimeListeners[event].push(listener);
  },

  /**
   * Remove a listener from the listener array for the specified event.
   * Note that the order of the array elements will change after removing the listener
   */
  removeListener: function(event, listener) {
    var events, length,
      idx = 0;

    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to remove a listener from a nonexistent event'+ event);
      return;
    }

    events = this.events[event];
    length = events.length;

    while (idx < length) {
      if (events[idx] === listener) {
        events.splice(idx,1);
      } else {
        idx ++;
      }
    }
  },

  /**
   * Remove all listeners from the listener array for the specified event.
   */
  removeAllListener: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('unable to remove listeners from a nonexistent event'+ event);
      return;
    }

    this.events[event] = [];
    this.oneTimeListeners[event] = [];
  },

  /**
   * By default EventEmitter will print a warning
   * if more than C.MAX_LISTENERS listeners are added for a particular event.
   * This function allows that limit to be modified.
   */
  setMaxListeners: function(listeners) {
    if (typeof listeners !== 'number' || listeners < 0) {
      this.logger.error('listeners must be a positive number');
      return;
    }

    this.maxListeners = listeners;
  },

  /**
   * Get the listeners for a specific event.
   */
  listeners: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('no event '+ event);
      return;
    }

    return this.events[event];
  },

  /**
   * Execute each of the listeners in order with the supplied arguments.
   */
  emit: function(event, sender, data) {
    var listeners, length, e, idx,
      self = this;

    if (!this.checkEvent(event)) {
      this.logger.error('unable to emit a nonexistent event'+ event);
      return;
    }

    this.logger.debug('emitting event '+ event);

    listeners = this.events[event];
    length = listeners.length;

    e = new Event(event, sender, data);

    listeners.map(function(listener) {
      return function() {
        listener.call(null, e);
      };
    }).forEach(function(callback) {
      try {
        callback();
      } catch(err) {
        self.logger.error(err.stack);
      }
    });

    // Remove one time listeners
    for (idx in this.oneTimeListeners[event]) {
      this.removeListener(event, this.oneTimeListeners[event][idx]);
    }

    this.oneTimeListeners[event] = [];
  }
};
},{"./LoggerFactory":880}],876:[function(require,module,exports){
var ExSIP = {
  C: require('./Constants'),
  Exceptions: require('./Exceptions'),
  Utils: require('./Utils'),
  UA: require('./UA'),
  URI: require('./URI'),
  NameAddrHeader: require('./NameAddrHeader'),
  Grammar: require('./Grammar'),
  WebRTC: require('./WebRTC'),
  RTCSession: require('./RTCSession')
};

module.exports = ExSIP;


var pkg = require('../package.json');


Object.defineProperties(ExSIP, {
  name: {
    get: function(){ return pkg.title; }
  },

  /**
   * Retrieve the version of ExSIP.
   * @memberof ExSIP
   * @method
   * @returns {String} Version in the form "X.Y.Z"
   * @example
   * // prints "1.0.0"
   * console.log(ExSIP.version)
   */
  version: {
    get: function(){ return pkg.version; }
  }
});

},{"../package.json":870,"./Constants":871,"./Exceptions":877,"./Grammar":878,"./NameAddrHeader":882,"./RTCSession":884,"./UA":894,"./URI":895,"./Utils":896,"./WebRTC":897}],877:[function(require,module,exports){
/**
 * @namespace Exceptions
 * @memberOf ExSIP
 */
var Exceptions = {
  /**
   * Exception thrown when a valid parameter is given to the ExSIP.UA constructor.
   * @class ConfigurationError
   * @memberOf ExSIP.Exceptions
   */
  ConfigurationError: (function(){
    var exception = function(parameter, value) {
      console.trace('----------------------ConfigurationError : '+parameter+', '+value);
      this.code = 1;
      this.name = 'CONFIGURATION_ERROR';
      this.parameter = parameter;
      this.value = value;
      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
    };
    exception.prototype = new Error();
    return exception;
  }()),

  InvalidStateError: (function(){
    var exception = function(status) {
      console.trace('----------------------InvalidStateError : '+status);
      this.code = 2;
      this.name = 'INVALID_STATE_ERROR';
      this.status = status;
      this.message = 'Invalid status: '+ status;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotSupportedError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotSupportedError : '+message);
      this.code = 3;
      this.name = 'NOT_SUPPORTED_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotReadyError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotReadyError : '+message);
      this.code = 4;
      this.name = 'NOT_READY_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }())
};

module.exports = Exceptions;
},{}],878:[function(require,module,exports){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "CRLF": parse_CRLF,
        "DIGIT": parse_DIGIT,
        "ALPHA": parse_ALPHA,
        "HEXDIG": parse_HEXDIG,
        "WSP": parse_WSP,
        "OCTET": parse_OCTET,
        "DQUOTE": parse_DQUOTE,
        "SP": parse_SP,
        "HTAB": parse_HTAB,
        "alphanum": parse_alphanum,
        "reserved": parse_reserved,
        "unreserved": parse_unreserved,
        "mark": parse_mark,
        "escaped": parse_escaped,
        "LWS": parse_LWS,
        "SWS": parse_SWS,
        "HCOLON": parse_HCOLON,
        "TEXT_UTF8_TRIM": parse_TEXT_UTF8_TRIM,
        "TEXT_UTF8char": parse_TEXT_UTF8char,
        "UTF8_NONASCII": parse_UTF8_NONASCII,
        "UTF8_CONT": parse_UTF8_CONT,
        "LHEX": parse_LHEX,
        "token": parse_token,
        "token_nodot": parse_token_nodot,
        "separators": parse_separators,
        "word": parse_word,
        "STAR": parse_STAR,
        "SLASH": parse_SLASH,
        "EQUAL": parse_EQUAL,
        "LPAREN": parse_LPAREN,
        "RPAREN": parse_RPAREN,
        "RAQUOT": parse_RAQUOT,
        "LAQUOT": parse_LAQUOT,
        "COMMA": parse_COMMA,
        "SEMI": parse_SEMI,
        "COLON": parse_COLON,
        "LDQUOT": parse_LDQUOT,
        "RDQUOT": parse_RDQUOT,
        "comment": parse_comment,
        "ctext": parse_ctext,
        "quoted_string": parse_quoted_string,
        "quoted_string_clean": parse_quoted_string_clean,
        "qdtext": parse_qdtext,
        "quoted_pair": parse_quoted_pair,
        "SIP_URI_noparams": parse_SIP_URI_noparams,
        "SIP_URI": parse_SIP_URI,
        "uri_scheme": parse_uri_scheme,
        "userinfo": parse_userinfo,
        "user": parse_user,
        "user_unreserved": parse_user_unreserved,
        "password": parse_password,
        "hostport": parse_hostport,
        "host": parse_host,
        "hostname": parse_hostname,
        "domainlabel": parse_domainlabel,
        "toplabel": parse_toplabel,
        "IPv6reference": parse_IPv6reference,
        "IPv6address": parse_IPv6address,
        "h16": parse_h16,
        "ls32": parse_ls32,
        "IPv4address": parse_IPv4address,
        "dec_octet": parse_dec_octet,
        "port": parse_port,
        "uri_parameters": parse_uri_parameters,
        "uri_parameter": parse_uri_parameter,
        "transport_param": parse_transport_param,
        "user_param": parse_user_param,
        "method_param": parse_method_param,
        "ttl_param": parse_ttl_param,
        "maddr_param": parse_maddr_param,
        "lr_param": parse_lr_param,
        "other_param": parse_other_param,
        "pname": parse_pname,
        "pvalue": parse_pvalue,
        "paramchar": parse_paramchar,
        "param_unreserved": parse_param_unreserved,
        "headers": parse_headers,
        "header": parse_header,
        "hname": parse_hname,
        "hvalue": parse_hvalue,
        "hnv_unreserved": parse_hnv_unreserved,
        "Request_Response": parse_Request_Response,
        "Request_Line": parse_Request_Line,
        "Request_URI": parse_Request_URI,
        "absoluteURI": parse_absoluteURI,
        "hier_part": parse_hier_part,
        "net_path": parse_net_path,
        "abs_path": parse_abs_path,
        "opaque_part": parse_opaque_part,
        "uric": parse_uric,
        "uric_no_slash": parse_uric_no_slash,
        "path_segments": parse_path_segments,
        "segment": parse_segment,
        "param": parse_param,
        "pchar": parse_pchar,
        "scheme": parse_scheme,
        "authority": parse_authority,
        "srvr": parse_srvr,
        "reg_name": parse_reg_name,
        "query": parse_query,
        "SIP_Version": parse_SIP_Version,
        "INVITEm": parse_INVITEm,
        "ACKm": parse_ACKm,
        "OPTIONSm": parse_OPTIONSm,
        "BYEm": parse_BYEm,
        "CANCELm": parse_CANCELm,
        "REGISTERm": parse_REGISTERm,
        "SUBSCRIBEm": parse_SUBSCRIBEm,
        "NOTIFYm": parse_NOTIFYm,
        "Method": parse_Method,
        "Status_Line": parse_Status_Line,
        "Status_Code": parse_Status_Code,
        "extension_code": parse_extension_code,
        "Reason_Phrase": parse_Reason_Phrase,
        "Allow_Events": parse_Allow_Events,
        "Call_ID": parse_Call_ID,
        "Contact": parse_Contact,
        "contact_param": parse_contact_param,
        "name_addr": parse_name_addr,
        "display_name": parse_display_name,
        "contact_params": parse_contact_params,
        "c_p_q": parse_c_p_q,
        "c_p_expires": parse_c_p_expires,
        "delta_seconds": parse_delta_seconds,
        "qvalue": parse_qvalue,
        "generic_param": parse_generic_param,
        "gen_value": parse_gen_value,
        "Content_Disposition": parse_Content_Disposition,
        "disp_type": parse_disp_type,
        "disp_param": parse_disp_param,
        "handling_param": parse_handling_param,
        "Content_Encoding": parse_Content_Encoding,
        "Content_Length": parse_Content_Length,
        "Content_Type": parse_Content_Type,
        "media_type": parse_media_type,
        "m_type": parse_m_type,
        "discrete_type": parse_discrete_type,
        "composite_type": parse_composite_type,
        "extension_token": parse_extension_token,
        "x_token": parse_x_token,
        "m_subtype": parse_m_subtype,
        "m_parameter": parse_m_parameter,
        "m_value": parse_m_value,
        "CSeq": parse_CSeq,
        "CSeq_value": parse_CSeq_value,
        "Expires": parse_Expires,
        "Event": parse_Event,
        "event_type": parse_event_type,
        "From": parse_From,
        "from_param": parse_from_param,
        "tag_param": parse_tag_param,
        "Max_Forwards": parse_Max_Forwards,
        "Min_Expires": parse_Min_Expires,
        "Name_Addr_Header": parse_Name_Addr_Header,
        "Proxy_Authenticate": parse_Proxy_Authenticate,
        "challenge": parse_challenge,
        "other_challenge": parse_other_challenge,
        "auth_param": parse_auth_param,
        "digest_cln": parse_digest_cln,
        "realm": parse_realm,
        "realm_value": parse_realm_value,
        "domain": parse_domain,
        "URI": parse_URI,
        "nonce": parse_nonce,
        "nonce_value": parse_nonce_value,
        "opaque": parse_opaque,
        "stale": parse_stale,
        "algorithm": parse_algorithm,
        "qop_options": parse_qop_options,
        "qop_value": parse_qop_value,
        "Proxy_Require": parse_Proxy_Require,
        "Record_Route": parse_Record_Route,
        "rec_route": parse_rec_route,
        "Require": parse_Require,
        "Route": parse_Route,
        "route_param": parse_route_param,
        "Subscription_State": parse_Subscription_State,
        "substate_value": parse_substate_value,
        "subexp_params": parse_subexp_params,
        "event_reason_value": parse_event_reason_value,
        "Subject": parse_Subject,
        "Supported": parse_Supported,
        "To": parse_To,
        "to_param": parse_to_param,
        "Via": parse_Via,
        "via_parm": parse_via_parm,
        "via_params": parse_via_params,
        "via_ttl": parse_via_ttl,
        "via_maddr": parse_via_maddr,
        "via_received": parse_via_received,
        "via_branch": parse_via_branch,
        "response_port": parse_response_port,
        "sent_protocol": parse_sent_protocol,
        "protocol_name": parse_protocol_name,
        "transport": parse_transport,
        "sent_by": parse_sent_by,
        "via_host": parse_via_host,
        "via_port": parse_via_port,
        "ttl": parse_ttl,
        "WWW_Authenticate": parse_WWW_Authenticate,
        "extension_header": parse_extension_header,
        "header_value": parse_header_value,
        "message_body": parse_message_body,
        "stun_URI": parse_stun_URI,
        "stun_scheme": parse_stun_scheme,
        "stun_host_port": parse_stun_host_port,
        "stun_host": parse_stun_host,
        "reg_name": parse_reg_name,
        "stun_unreserved": parse_stun_unreserved,
        "sub_delims": parse_sub_delims,
        "turn_URI": parse_turn_URI,
        "turn_scheme": parse_turn_scheme,
        "turn_transport": parse_turn_transport,
        "uuid_URI": parse_uuid_URI,
        "uuid": parse_uuid,
        "hex4": parse_hex4,
        "hex8": parse_hex8,
        "hex12": parse_hex12
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "CRLF";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_CRLF() {
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        return result0;
      }
      
      function parse_DIGIT() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_ALPHA() {
        var result0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        return result0;
      }
      
      function parse_HEXDIG() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_WSP() {
        var result0;
        
        result0 = parse_SP();
        if (result0 === null) {
          result0 = parse_HTAB();
        }
        return result0;
      }
      
      function parse_OCTET() {
        var result0;
        
        if (/^[\0-\xFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\0-\\xFF]");
          }
        }
        return result0;
      }
      
      function parse_DQUOTE() {
        var result0;
        
        if (/^["]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\"]");
          }
        }
        return result0;
      }
      
      function parse_SP() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        return result0;
      }
      
      function parse_HTAB() {
        var result0;
        
        if (input.charCodeAt(pos) === 9) {
          result0 = "\t";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\t\"");
          }
        }
        return result0;
      }
      
      function parse_alphanum() {
        var result0;
        
        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9]");
          }
        }
        return result0;
      }
      
      function parse_reserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 63) {
              result0 = "?";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 38) {
                    result0 = "&";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"&\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 61) {
                      result0 = "=";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 36) {
                          result0 = "$";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"$\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result0 = ",";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unreserved() {
        var result0;
        
        result0 = parse_alphanum();
        if (result0 === null) {
          result0 = parse_mark();
        }
        return result0;
      }
      
      function parse_mark() {
        var result0;
        
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 46) {
              result0 = ".";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 33) {
                result0 = "!";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result0 = "*";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      result0 = "'";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 40) {
                        result0 = "(";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"(\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 41) {
                          result0 = ")";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_escaped() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, escaped) {return escaped.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LWS() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        result0 = [];
        result1 = parse_WSP();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WSP();
        }
        if (result0 !== null) {
          result1 = parse_CRLF();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_WSP();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_WSP();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SWS() {
        var result0;
        
        result0 = parse_LWS();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_HCOLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_SP();
        if (result1 === null) {
          result1 = parse_HTAB();
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SP();
          if (result1 === null) {
            result1 = parse_HTAB();
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ':'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8_TRIM() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_TEXT_UTF8char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_TEXT_UTF8char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = [];
          result3 = parse_LWS();
          while (result3 !== null) {
            result2.push(result3);
            result3 = parse_LWS();
          }
          if (result2 !== null) {
            result3 = parse_TEXT_UTF8char();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = [];
            result3 = parse_LWS();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LWS();
            }
            if (result2 !== null) {
              result3 = parse_TEXT_UTF8char();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8char() {
        var result0;
        
        if (/^[!-~]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-~]");
          }
        }
        if (result0 === null) {
          result0 = parse_UTF8_NONASCII();
        }
        return result0;
      }
      
      function parse_UTF8_NONASCII() {
        var result0;
        
        if (/^[\x80-\uFFFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\uFFFF]");
          }
        }
        return result0;
      }
      
      function parse_UTF8_CONT() {
        var result0;
        
        if (/^[\x80-\xBF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\xBF]");
          }
        }
        return result0;
      }
      
      function parse_LHEX() {
        var result0;
        
        result0 = parse_DIGIT();
        if (result0 === null) {
          if (/^[a-f]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[a-f]");
            }
          }
        }
        return result0;
      }
      
      function parse_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_token_nodot() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 33) {
              result1 = "!";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 37) {
                result1 = "%";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"%\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 42) {
                  result1 = "*";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"*\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 95) {
                    result1 = "_";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"_\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result1 = "+";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 96) {
                        result1 = "`";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"`\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          result1 = "'";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            result1 = "~";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"~\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 33) {
                  result1 = "!";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 37) {
                    result1 = "%";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"%\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result1 = "*";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result1 = "_";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result1 = "+";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 96) {
                            result1 = "`";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"`\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              result1 = "'";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"'\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 126) {
                                result1 = "~";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"~\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_separators() {
        var result0;
        
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 60) {
              result0 = "<";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 62) {
                result0 = ">";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result0 = ";";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 92) {
                          result0 = "\\";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\\"");
                          }
                        }
                        if (result0 === null) {
                          result0 = parse_DQUOTE();
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 47) {
                              result0 = "/";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"/\"");
                              }
                            }
                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 91) {
                                result0 = "[";
                                pos++;
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"[\"");
                                }
                              }
                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 93) {
                                  result0 = "]";
                                  pos++;
                                } else {
                                  result0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"]\"");
                                  }
                                }
                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 63) {
                                    result0 = "?";
                                    pos++;
                                  } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"?\"");
                                    }
                                  }
                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 61) {
                                      result0 = "=";
                                      pos++;
                                    } else {
                                      result0 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                      }
                                    }
                                    if (result0 === null) {
                                      if (input.charCodeAt(pos) === 123) {
                                        result0 = "{";
                                        pos++;
                                      } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"{\"");
                                        }
                                      }
                                      if (result0 === null) {
                                        if (input.charCodeAt(pos) === 125) {
                                          result0 = "}";
                                          pos++;
                                        } else {
                                          result0 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"}\"");
                                          }
                                        }
                                        if (result0 === null) {
                                          result0 = parse_SP();
                                          if (result0 === null) {
                                            result0 = parse_HTAB();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_word() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 40) {
                                result1 = "(";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"(\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 41) {
                                  result1 = ")";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 60) {
                                    result1 = "<";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"<\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 62) {
                                      result1 = ">";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\">\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 92) {
                                          result1 = "\\";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\\\\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          result1 = parse_DQUOTE();
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 47) {
                                              result1 = "/";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"/\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 91) {
                                                result1 = "[";
                                                pos++;
                                              } else {
                                                result1 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"[\"");
                                                }
                                              }
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 93) {
                                                  result1 = "]";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"]\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 63) {
                                                    result1 = "?";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"?\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 123) {
                                                      result1 = "{";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"{\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 125) {
                                                        result1 = "}";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"}\"");
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 40) {
                                    result1 = "(";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"(\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 41) {
                                      result1 = ")";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\")\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 60) {
                                        result1 = "<";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"<\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 62) {
                                          result1 = ">";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\">\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result1 = ":";
                                            pos++;
                                          } else {
                                            result1 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 92) {
                                              result1 = "\\";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"\\\\\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              result1 = parse_DQUOTE();
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 47) {
                                                  result1 = "/";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"/\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 91) {
                                                    result1 = "[";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"[\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      result1 = "]";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"]\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 63) {
                                                        result1 = "?";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"?\"");
                                                        }
                                                      }
                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 123) {
                                                          result1 = "{";
                                                          pos++;
                                                        } else {
                                                          result1 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"{\"");
                                                          }
                                                        }
                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 125) {
                                                            result1 = "}";
                                                            pos++;
                                                          } else {
                                                            result1 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"}\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_STAR() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 42) {
            result1 = "*";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"*\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SLASH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_EQUAL() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 40) {
            result1 = "(";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ">"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 60) {
            result1 = "<";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"<\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "<"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COMMA() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SEMI() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DQUOTE();
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_LPAREN();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ctext();
          if (result2 === null) {
            result2 = parse_quoted_pair();
            if (result2 === null) {
              result2 = parse_comment();
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ctext();
            if (result2 === null) {
              result2 = parse_quoted_pair();
              if (result2 === null) {
                result2 = parse_comment();
              }
            }
          }
          if (result1 !== null) {
            result2 = parse_RPAREN();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ctext() {
        var result0;
        
        if (/^[!-']/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-']");
          }
        }
        if (result0 === null) {
          if (/^[*-[]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[*-[]");
            }
          }
          if (result0 === null) {
            if (/^[\]-~]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[\\]-~]");
              }
            }
            if (result0 === null) {
              result0 = parse_UTF8_NONASCII();
              if (result0 === null) {
                result0 = parse_LWS();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_string() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_quoted_string_clean() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return input.substring(pos-1, offset+1); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qdtext() {
        var result0;
        
        result0 = parse_LWS();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 === null) {
            if (/^[#-[]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[#-[]");
              }
            }
            if (result0 === null) {
              if (/^[\]-~]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\]-~]");
                }
              }
              if (result0 === null) {
                result0 = parse_UTF8_NONASCII();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_pair() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          if (/^[\0-\t]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[\\0-\\t]");
            }
          }
          if (result1 === null) {
            if (/^[\x0B-\f]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[\\x0B-\\f]");
              }
            }
            if (result1 === null) {
              if (/^[\x0E-]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\x0E-]");
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI_noparams() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result4 = parse_uri_parameters();
                if (result4 !== null) {
                  result5 = parse_headers();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            var header;
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                                delete data.uri_params;
        
                                if (startRule === 'SIP_URI') { data = data.uri;}
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_scheme() {
        var result0;
        var pos0;
        
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"sip\"");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 4).toLowerCase() === "sips") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"sips\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {
                              data.scheme = uri_scheme.toLowerCase(); })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_userinfo() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_user();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_password();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result2 = "@";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.user = decodeURIComponent(input.substring(pos-1, offset));})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_user_unreserved();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_user_unreserved();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_user_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 61) {
            result0 = "=";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 43) {
              result0 = "+";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 36) {
                result0 = "$";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"$\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 44) {
                  result0 = ",";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 59) {
                    result0 = ";";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 63) {
                      result0 = "?";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"?\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 47) {
                        result0 = "/";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"/\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_password() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 38) {
              result1 = "&";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 61) {
                result1 = "=";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result1 = "+";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result1 = "$";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 44) {
                      result1 = ",";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 38) {
                result1 = "&";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 61) {
                  result1 = "=";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result1 = "+";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result1 = "$";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 44) {
                        result1 = ",";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.password = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host = input.substring(pos, offset).toLowerCase();
                            return data.host; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostname() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        pos2 = pos;
        result1 = parse_domainlabel();
        if (result1 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos2;
          }
        } else {
          result1 = null;
          pos = pos2;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos2 = pos;
          result1 = parse_domainlabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
        }
        if (result0 !== null) {
          result1 = parse_toplabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'domain';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domainlabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_toplabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_IPv6reference() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_IPv6address();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv6';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_IPv6address() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_h16();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result5 = ":";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_h16();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result7 = ":";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_h16();
                        if (result8 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result9 = ":";
                            pos++;
                          } else {
                            result9 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result9 !== null) {
                            result10 = parse_h16();
                            if (result10 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result11 = ":";
                                pos++;
                              } else {
                                result11 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result11 !== null) {
                                result12 = parse_ls32();
                                if (result12 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          if (input.substr(pos, 2) === "::") {
            result0 = "::";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"::\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_h16();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result2 = ":";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result2 !== null) {
                result3 = parse_h16();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result4 = ":";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result4 !== null) {
                    result5 = parse_h16();
                    if (result5 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result6 = ":";
                        pos++;
                      } else {
                        result6 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result6 !== null) {
                        result7 = parse_h16();
                        if (result7 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result8 = ":";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result8 !== null) {
                            result9 = parse_h16();
                            if (result9 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result10 = ":";
                                pos++;
                              } else {
                                result10 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result10 !== null) {
                                result11 = parse_ls32();
                                if (result11 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            if (input.substr(pos, 2) === "::") {
              result0 = "::";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"::\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_h16();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 58) {
                  result2 = ":";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse_h16();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result4 = ":";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result4 !== null) {
                      result5 = parse_h16();
                      if (result5 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result6 = ":";
                          pos++;
                        } else {
                          result6 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result6 !== null) {
                          result7 = parse_h16();
                          if (result7 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result8 = ":";
                              pos++;
                            } else {
                              result8 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result8 !== null) {
                              result9 = parse_ls32();
                              if (result9 !== null) {
                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              if (input.substr(pos, 2) === "::") {
                result0 = "::";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"::\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_h16();
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result2 = ":";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result2 !== null) {
                    result3 = parse_h16();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result4 = ":";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result4 !== null) {
                        result5 = parse_h16();
                        if (result5 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result6 = ":";
                            pos++;
                          } else {
                            result6 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result6 !== null) {
                            result7 = parse_ls32();
                            if (result7 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_h16();
                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result2 = ":";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result2 !== null) {
                      result3 = parse_h16();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result4 = ":";
                          pos++;
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result4 !== null) {
                          result5 = parse_ls32();
                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  if (input.substr(pos, 2) === "::") {
                    result0 = "::";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }
                  if (result0 !== null) {
                    result1 = parse_h16();
                    if (result1 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result2 = ":";
                        pos++;
                      } else {
                        result2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result2 !== null) {
                        result3 = parse_ls32();
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 === null) {
                    pos1 = pos;
                    if (input.substr(pos, 2) === "::") {
                      result0 = "::";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"::\"");
                      }
                    }
                    if (result0 !== null) {
                      result1 = parse_ls32();
                      if (result1 !== null) {
                        result0 = [result0, result1];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                    if (result0 === null) {
                      pos1 = pos;
                      if (input.substr(pos, 2) === "::") {
                        result0 = "::";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"::\"");
                        }
                      }
                      if (result0 !== null) {
                        result1 = parse_h16();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                      if (result0 === null) {
                        pos1 = pos;
                        result0 = parse_h16();
                        if (result0 !== null) {
                          if (input.substr(pos, 2) === "::") {
                            result1 = "::";
                            pos += 2;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }
                          if (result1 !== null) {
                            result2 = parse_h16();
                            if (result2 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result3 = ":";
                                pos++;
                              } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result3 !== null) {
                                result4 = parse_h16();
                                if (result4 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result5 = ":";
                                    pos++;
                                  } else {
                                    result5 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result5 !== null) {
                                    result6 = parse_h16();
                                    if (result6 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result7 = ":";
                                        pos++;
                                      } else {
                                        result7 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result7 !== null) {
                                        result8 = parse_h16();
                                        if (result8 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result9 = ":";
                                            pos++;
                                          } else {
                                            result9 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result9 !== null) {
                                            result10 = parse_ls32();
                                            if (result10 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                        if (result0 === null) {
                          pos1 = pos;
                          result0 = parse_h16();
                          if (result0 !== null) {
                            pos2 = pos;
                            if (input.charCodeAt(pos) === 58) {
                              result1 = ":";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result1 !== null) {
                              result2 = parse_h16();
                              if (result2 !== null) {
                                result1 = [result1, result2];
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                            } else {
                              result1 = null;
                              pos = pos2;
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                              if (input.substr(pos, 2) === "::") {
                                result2 = "::";
                                pos += 2;
                              } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"::\"");
                                }
                              }
                              if (result2 !== null) {
                                result3 = parse_h16();
                                if (result3 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result4 = ":";
                                    pos++;
                                  } else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result4 !== null) {
                                    result5 = parse_h16();
                                    if (result5 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result6 = ":";
                                        pos++;
                                      } else {
                                        result6 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result6 !== null) {
                                        result7 = parse_h16();
                                        if (result7 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result8 = ":";
                                            pos++;
                                          } else {
                                            result8 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result8 !== null) {
                                            result9 = parse_ls32();
                                            if (result9 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 === null) {
                            pos1 = pos;
                            result0 = parse_h16();
                            if (result0 !== null) {
                              pos2 = pos;
                              if (input.charCodeAt(pos) === 58) {
                                result1 = ":";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result1 !== null) {
                                result2 = parse_h16();
                                if (result2 !== null) {
                                  result1 = [result1, result2];
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                              result1 = result1 !== null ? result1 : "";
                              if (result1 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result2 = ":";
                                  pos++;
                                } else {
                                  result2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result2 !== null) {
                                  result3 = parse_h16();
                                  if (result3 !== null) {
                                    result2 = [result2, result3];
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result2 = null;
                                  pos = pos2;
                                }
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                  if (input.substr(pos, 2) === "::") {
                                    result3 = "::";
                                    pos += 2;
                                  } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"::\"");
                                    }
                                  }
                                  if (result3 !== null) {
                                    result4 = parse_h16();
                                    if (result4 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result5 = ":";
                                        pos++;
                                      } else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result5 !== null) {
                                        result6 = parse_h16();
                                        if (result6 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result7 = ":";
                                            pos++;
                                          } else {
                                            result7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result7 !== null) {
                                            result8 = parse_ls32();
                                            if (result8 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                            if (result0 === null) {
                              pos1 = pos;
                              result0 = parse_h16();
                              if (result0 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result1 = ":";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result1 !== null) {
                                  result2 = parse_h16();
                                  if (result2 !== null) {
                                    result1 = [result1, result2];
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result2 = ":";
                                    pos++;
                                  } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result2 !== null) {
                                    result3 = parse_h16();
                                    if (result3 !== null) {
                                      result2 = [result2, result3];
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                  result2 = result2 !== null ? result2 : "";
                                  if (result2 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result3 = ":";
                                      pos++;
                                    } else {
                                      result3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result3 !== null) {
                                      result4 = parse_h16();
                                      if (result4 !== null) {
                                        result3 = [result3, result4];
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result3 = null;
                                      pos = pos2;
                                    }
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                      if (input.substr(pos, 2) === "::") {
                                        result4 = "::";
                                        pos += 2;
                                      } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"::\"");
                                        }
                                      }
                                      if (result4 !== null) {
                                        result5 = parse_h16();
                                        if (result5 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result6 = ":";
                                            pos++;
                                          } else {
                                            result6 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result6 !== null) {
                                            result7 = parse_ls32();
                                            if (result7 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                              if (result0 === null) {
                                pos1 = pos;
                                result0 = parse_h16();
                                if (result0 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result1 = ":";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result1 !== null) {
                                    result2 = parse_h16();
                                    if (result2 !== null) {
                                      result1 = [result1, result2];
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                  result1 = result1 !== null ? result1 : "";
                                  if (result1 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result2 = ":";
                                      pos++;
                                    } else {
                                      result2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result2 !== null) {
                                      result3 = parse_h16();
                                      if (result3 !== null) {
                                        result2 = [result2, result3];
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                    result2 = result2 !== null ? result2 : "";
                                    if (result2 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result3 = ":";
                                        pos++;
                                      } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result3 !== null) {
                                        result4 = parse_h16();
                                        if (result4 !== null) {
                                          result3 = [result3, result4];
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                      result3 = result3 !== null ? result3 : "";
                                      if (result3 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result4 = ":";
                                          pos++;
                                        } else {
                                          result4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result4 !== null) {
                                          result5 = parse_h16();
                                          if (result5 !== null) {
                                            result4 = [result4, result5];
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result4 = null;
                                          pos = pos2;
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                          if (input.substr(pos, 2) === "::") {
                                            result5 = "::";
                                            pos += 2;
                                          } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"::\"");
                                            }
                                          }
                                          if (result5 !== null) {
                                            result6 = parse_ls32();
                                            if (result6 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                                if (result0 === null) {
                                  pos1 = pos;
                                  result0 = parse_h16();
                                  if (result0 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result1 = ":";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result1 !== null) {
                                      result2 = parse_h16();
                                      if (result2 !== null) {
                                        result1 = [result1, result2];
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                    result1 = result1 !== null ? result1 : "";
                                    if (result1 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result2 = ":";
                                        pos++;
                                      } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result2 !== null) {
                                        result3 = parse_h16();
                                        if (result3 !== null) {
                                          result2 = [result2, result3];
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                      result2 = result2 !== null ? result2 : "";
                                      if (result2 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result3 = ":";
                                          pos++;
                                        } else {
                                          result3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result3 !== null) {
                                          result4 = parse_h16();
                                          if (result4 !== null) {
                                            result3 = [result3, result4];
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                        result3 = result3 !== null ? result3 : "";
                                        if (result3 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result4 = ":";
                                            pos++;
                                          } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result4 !== null) {
                                            result5 = parse_h16();
                                            if (result5 !== null) {
                                              result4 = [result4, result5];
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                          result4 = result4 !== null ? result4 : "";
                                          if (result4 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result5 = ":";
                                              pos++;
                                            } else {
                                              result5 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result5 !== null) {
                                              result6 = parse_h16();
                                              if (result6 !== null) {
                                                result5 = [result5, result6];
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result5 = null;
                                              pos = pos2;
                                            }
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                              if (input.substr(pos, 2) === "::") {
                                                result6 = "::";
                                                pos += 2;
                                              } else {
                                                result6 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"::\"");
                                                }
                                              }
                                              if (result6 !== null) {
                                                result7 = parse_h16();
                                                if (result7 !== null) {
                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                  if (result0 === null) {
                                    pos1 = pos;
                                    result0 = parse_h16();
                                    if (result0 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 !== null) {
                                        result2 = parse_h16();
                                        if (result2 !== null) {
                                          result1 = [result1, result2];
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                      result1 = result1 !== null ? result1 : "";
                                      if (result1 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result2 = ":";
                                          pos++;
                                        } else {
                                          result2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result2 !== null) {
                                          result3 = parse_h16();
                                          if (result3 !== null) {
                                            result2 = [result2, result3];
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                        result2 = result2 !== null ? result2 : "";
                                        if (result2 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result3 = ":";
                                            pos++;
                                          } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result3 !== null) {
                                            result4 = parse_h16();
                                            if (result4 !== null) {
                                              result3 = [result3, result4];
                                            } else {
                                              result3 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                          result3 = result3 !== null ? result3 : "";
                                          if (result3 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result4 = ":";
                                              pos++;
                                            } else {
                                              result4 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result4 !== null) {
                                              result5 = parse_h16();
                                              if (result5 !== null) {
                                                result4 = [result4, result5];
                                              } else {
                                                result4 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                            result4 = result4 !== null ? result4 : "";
                                            if (result4 !== null) {
                                              pos2 = pos;
                                              if (input.charCodeAt(pos) === 58) {
                                                result5 = ":";
                                                pos++;
                                              } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }
                                              if (result5 !== null) {
                                                result6 = parse_h16();
                                                if (result6 !== null) {
                                                  result5 = [result5, result6];
                                                } else {
                                                  result5 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                              result5 = result5 !== null ? result5 : "";
                                              if (result5 !== null) {
                                                pos2 = pos;
                                                if (input.charCodeAt(pos) === 58) {
                                                  result6 = ":";
                                                  pos++;
                                                } else {
                                                  result6 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }
                                                if (result6 !== null) {
                                                  result7 = parse_h16();
                                                  if (result7 !== null) {
                                                    result6 = [result6, result7];
                                                  } else {
                                                    result6 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result6 = null;
                                                  pos = pos2;
                                                }
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                  if (input.substr(pos, 2) === "::") {
                                                    result7 = "::";
                                                    pos += 2;
                                                  } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"::\"");
                                                    }
                                                  }
                                                  if (result7 !== null) {
                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'IPv6';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_h16() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ls32() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_IPv4address();
        }
        return result0;
      }
      
      function parse_IPv4address() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_dec_octet();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_dec_octet();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_dec_octet();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result5 = ".";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_dec_octet();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv4';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dec_octet() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "25") {
          result0 = "25";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"25\"");
          }
        }
        if (result0 !== null) {
          if (/^[0-5]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[0-5]");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 50) {
            result0 = "2";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"2\"");
            }
          }
          if (result0 !== null) {
            if (/^[0-4]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-4]");
              }
            }
            if (result1 !== null) {
              result2 = parse_DIGIT();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.charCodeAt(pos) === 49) {
              result0 = "1";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"1\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_DIGIT();
              if (result1 !== null) {
                result2 = parse_DIGIT();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (/^[1-9]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result0 !== null) {
                result1 = parse_DIGIT();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_DIGIT();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port) {
                            port = parseInt(port.join(''));
                            data.port = port;
                            return port; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_parameters() {
        var result0, result1, result2;
        var pos0;
        
        result0 = [];
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result1 = ";";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result1 !== null) {
          result2 = parse_uri_parameter();
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos0;
          }
        } else {
          result1 = null;
          pos = pos0;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos0 = pos;
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_uri_parameter();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos0;
            }
          } else {
            result1 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_uri_parameter() {
        var result0;
        
        result0 = parse_transport_param();
        if (result0 === null) {
          result0 = parse_user_param();
          if (result0 === null) {
            result0 = parse_method_param();
            if (result0 === null) {
              result0 = parse_ttl_param();
              if (result0 === null) {
                result0 = parse_maddr_param();
                if (result0 === null) {
                  result0 = parse_lr_param();
                  if (result0 === null) {
                    result0 = parse_other_param();
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_transport_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 10).toLowerCase() === "transport=") {
          result0 = input.substr(pos, 10);
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"transport=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result1 = input.substr(pos, 4);
                pos += 4;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"sctp\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 3).toLowerCase() === "tls") {
                  result1 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"tls\"");
                  }
                }
                if (result1 === null) {
                  result1 = parse_token();
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, transport) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['transport'] = transport.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "user=") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"user=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 5).toLowerCase() === "phone") {
            result1 = input.substr(pos, 5);
            pos += 5;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"phone\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2).toLowerCase() === "ip") {
              result1 = input.substr(pos, 2);
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"ip\"");
              }
            }
            if (result1 === null) {
              result1 = parse_token();
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, user) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['user'] = user.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_method_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "method=") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"method=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Method();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, method) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['method'] = method; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 4).toLowerCase() === "ttl=") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_ttl();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              if(!data.params) data.params={};
                              data.params['ttl'] = ttl; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_maddr_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "maddr=") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_host();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, maddr) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['maddr'] = maddr; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lr_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "lr") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"lr\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['lr'] = undefined; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_other_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_pname();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_pvalue();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                              if(!data.uri_params) data.uri_params = {};
                              if (typeof value === 'undefined'){
                                value = undefined;
                              }
                              else {
                                value = value[1];
                              }
                              data.uri_params[param.toLowerCase()] = value && value.toLowerCase();})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pname() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pname) {return pname.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pvalue() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pvalue) {return pvalue.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_paramchar() {
        var result0;
        
        result0 = parse_param_unreserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_param_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_headers() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_header();
          if (result1 !== null) {
            result2 = [];
            pos1 = pos;
            if (input.charCodeAt(pos) === 38) {
              result3 = "&";
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result3 !== null) {
              result4 = parse_header();
              if (result4 !== null) {
                result3 = [result3, result4];
              } else {
                result3 = null;
                pos = pos1;
              }
            } else {
              result3 = null;
              pos = pos1;
            }
            while (result3 !== null) {
              result2.push(result3);
              pos1 = pos;
              if (input.charCodeAt(pos) === 38) {
                result3 = "&";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_header();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hname();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hname, hvalue) {
                              hname = hname.join('').toLowerCase();
                              hvalue = hvalue.join('');
                              if(!data.uri_headers) data.uri_headers = {};
                              if (!data.uri_headers[hname]) {
                                data.uri_headers[hname] = [hvalue];
                              } else {
                                data.uri_headers[hname].push(hvalue);
                              }})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hname() {
        var result0, result1;
        
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_hnv_unreserved();
            if (result1 === null) {
              result1 = parse_unreserved();
              if (result1 === null) {
                result1 = parse_escaped();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_hvalue() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_hnv_unreserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
            }
          }
        }
        return result0;
      }
      
      function parse_hnv_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Request_Response() {
        var result0;
        
        result0 = parse_Status_Line();
        if (result0 === null) {
          result0 = parse_Request_Line();
        }
        return result0;
      }
      
      function parse_Request_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Method();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Request_URI();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_SIP_Version();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Request_URI() {
        var result0;
        
        result0 = parse_SIP_URI();
        if (result0 === null) {
          result0 = parse_absoluteURI();
        }
        return result0;
      }
      
      function parse_absoluteURI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hier_part();
            if (result2 === null) {
              result2 = parse_opaque_part();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hier_part() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_net_path();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 63) {
            result1 = "?";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"?\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_query();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_net_path() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_authority();
          if (result1 !== null) {
            result2 = parse_abs_path();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_abs_path() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path_segments();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque_part() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_uric_no_slash();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_uric();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_uric();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uric() {
        var result0;
        
        result0 = parse_reserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_uric_no_slash() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 59) {
              result0 = ";";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 64) {
                    result0 = "@";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 38) {
                      result0 = "&";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 61) {
                        result0 = "=";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result0 = "+";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 36) {
                            result0 = "$";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"$\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 44) {
                              result0 = ",";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_path_segments() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_segment();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 47) {
            result2 = "/";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_segment();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 47) {
              result2 = "/";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 59) {
            result2 = ";";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 59) {
              result2 = ";";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_param() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        return result0;
      }
      
      function parse_pchar() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 64) {
                result0 = "@";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result0 = "+";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 36) {
                        result0 = "$";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"$\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_scheme() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ALPHA();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ALPHA();
          if (result2 === null) {
            result2 = parse_DIGIT();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 43) {
                result2 = "+";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 45) {
                  result2 = "-";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ALPHA();
            if (result2 === null) {
              result2 = parse_DIGIT();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result2 = "+";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result2 = "-";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.scheme= input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_authority() {
        var result0;
        
        result0 = parse_srvr();
        if (result0 === null) {
          result0 = parse_reg_name();
        }
        return result0;
      }
      
      function parse_srvr() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_userinfo();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_hostport();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 36) {
              result1 = "$";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 44) {
                result1 = ",";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 59) {
                  result1 = ";";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 64) {
                      result1 = "@";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"@\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 38) {
                        result1 = "&";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 61) {
                          result1 = "=";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"=\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result1 = "$";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result1 = ",";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result1 = ";";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result1 = ":";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result1 = "@";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 38) {
                            result1 = "&";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"&\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result1 = "=";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_query() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_uric();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_uric();
        }
        return result0;
      }
      
      function parse_SIP_Version() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_DIGIT();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_DIGIT();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result5 = parse_DIGIT();
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    result5 = parse_DIGIT();
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.sip_version = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_INVITEm() {
        var result0;
        
        if (input.substr(pos, 6) === "INVITE") {
          result0 = "INVITE";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"INVITE\"");
          }
        }
        return result0;
      }
      
      function parse_ACKm() {
        var result0;
        
        if (input.substr(pos, 3) === "ACK") {
          result0 = "ACK";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ACK\"");
          }
        }
        return result0;
      }
      
      function parse_OPTIONSm() {
        var result0;
        
        if (input.substr(pos, 7) === "OPTIONS") {
          result0 = "OPTIONS";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"OPTIONS\"");
          }
        }
        return result0;
      }
      
      function parse_BYEm() {
        var result0;
        
        if (input.substr(pos, 3) === "BYE") {
          result0 = "BYE";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"BYE\"");
          }
        }
        return result0;
      }
      
      function parse_CANCELm() {
        var result0;
        
        if (input.substr(pos, 6) === "CANCEL") {
          result0 = "CANCEL";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"CANCEL\"");
          }
        }
        return result0;
      }
      
      function parse_REGISTERm() {
        var result0;
        
        if (input.substr(pos, 8) === "REGISTER") {
          result0 = "REGISTER";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"REGISTER\"");
          }
        }
        return result0;
      }
      
      function parse_SUBSCRIBEm() {
        var result0;
        
        if (input.substr(pos, 9) === "SUBSCRIBE") {
          result0 = "SUBSCRIBE";
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SUBSCRIBE\"");
          }
        }
        return result0;
      }
      
      function parse_NOTIFYm() {
        var result0;
        
        if (input.substr(pos, 6) === "NOTIFY") {
          result0 = "NOTIFY";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"NOTIFY\"");
          }
        }
        return result0;
      }
      
      function parse_Method() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_INVITEm();
        if (result0 === null) {
          result0 = parse_ACKm();
          if (result0 === null) {
            result0 = parse_OPTIONSm();
            if (result0 === null) {
              result0 = parse_BYEm();
              if (result0 === null) {
                result0 = parse_CANCELm();
                if (result0 === null) {
                  result0 = parse_REGISTERm();
                  if (result0 === null) {
                    result0 = parse_SUBSCRIBEm();
                    if (result0 === null) {
                      result0 = parse_NOTIFYm();
                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.method = input.substring(pos, offset);
                            return data.method; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_SIP_Version();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Status_Code();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_Reason_Phrase();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Code() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_extension_code();
        if (result0 !== null) {
          result0 = (function(offset, status_code) {
                          data.status_code = parseInt(status_code.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_extension_code() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          if (result1 !== null) {
            result2 = parse_DIGIT();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Reason_Phrase() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_reserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_UTF8_NONASCII();
              if (result1 === null) {
                result1 = parse_UTF8_CONT();
                if (result1 === null) {
                  result1 = parse_SP();
                  if (result1 === null) {
                    result1 = parse_HTAB();
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_reserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_UTF8_NONASCII();
                if (result1 === null) {
                  result1 = parse_UTF8_CONT();
                  if (result1 === null) {
                    result1 = parse_SP();
                    if (result1 === null) {
                      result1 = parse_HTAB();
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.reason_phrase = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Allow_Events() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_event_type();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_event_type();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Call_ID() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_word();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_word();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Contact() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        result0 = parse_STAR();
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_contact_param();
          if (result0 !== null) {
            result1 = [];
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_contact_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_COMMA();
              if (result2 !== null) {
                result3 = parse_contact_param();
                if (result3 !== null) {
                  result2 = [result2, result3];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var idx, length;
                                length = data.multi_header.length;
                                for (idx = 0; idx < length; idx++) {
                                  if (data.multi_header[idx].parsed === null) {
                                    data = null;
                                    break;
                                  }
                                }
                                if (data !== null) {
                                  data = data.multi_header;
                                } else {
                                  data = -1;
                                }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_param() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_contact_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_contact_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var header;
                                if(!data.multi_header) data.multi_header = [];
                                try {
                                  header = new NameAddrHeader(data.uri, data.display_name, data.params);
                                  delete data.uri;
                                  delete data.display_name;
                                  delete data.params;
                                } catch(e) {
                                  header = null;
                                }
                                data.multi_header.push( { 'possition': pos,
                                                          'offset': offset,
                                                          'parsed': header
                                                        });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_name_addr() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_display_name();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_display_name() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_LWS();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_LWS();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        if (result0 !== null) {
          result0 = (function(offset, display_name) {
                                display_name = input.substring(pos, offset).trim();
                                if (display_name[0] === '\"') {
                                  display_name = display_name.substring(1, display_name.length-1);
                                }
                                data.display_name = display_name; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_params() {
        var result0;
        
        result0 = parse_c_p_q();
        if (result0 === null) {
          result0 = parse_c_p_expires();
          if (result0 === null) {
            result0 = parse_generic_param();
          }
        }
        return result0;
      }
      
      function parse_c_p_q() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "q") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"q\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_qvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, q) {
                                if(!data.params) data.params = {};
                                data.params['q'] = q; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_c_p_expires() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "expires") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"expires\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_delta_seconds();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expires) {
                                if(!data.params) data.params = {};
                                data.params['expires'] = expires; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_delta_seconds() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, delta_seconds) {
                                return parseInt(delta_seconds.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qvalue() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result1 = [result1, result2, result3, result4];
                } else {
                  result1 = null;
                  pos = pos2;
                }
              } else {
                result1 = null;
                pos = pos2;
              }
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return parseFloat(input.substring(pos, offset)); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_generic_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_gen_value();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                                if(!data.params) data.params = {};
                                if (typeof value === 'undefined'){
                                  value = undefined;
                                }
                                else {
                                  value = value[1];
                                }
                                data.params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gen_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_host();
          if (result0 === null) {
            result0 = parse_quoted_string();
          }
        }
        return result0;
      }
      
      function parse_Content_Disposition() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_disp_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_disp_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_disp_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_disp_type() {
        var result0;
        
        if (input.substr(pos, 6).toLowerCase() === "render") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"render\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "session") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"session\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 4).toLowerCase() === "icon") {
              result0 = input.substr(pos, 4);
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"icon\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "alert") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"alert\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_disp_param() {
        var result0;
        
        result0 = parse_handling_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_handling_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "handling") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"handling\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 8).toLowerCase() === "optional") {
              result2 = input.substr(pos, 8);
              pos += 8;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"optional\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "required") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"required\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Encoding() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Length() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, length) {
                                data = parseInt(length.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Type() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_media_type();
        if (result0 !== null) {
          result0 = (function(offset) {
                                data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_media_type() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_m_type();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_m_subtype();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_m_parameter();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_m_parameter();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_type() {
        var result0;
        
        result0 = parse_discrete_type();
        if (result0 === null) {
          result0 = parse_composite_type();
        }
        return result0;
      }
      
      function parse_discrete_type() {
        var result0;
        
        if (input.substr(pos, 4).toLowerCase() === "text") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"text\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5).toLowerCase() === "image") {
            result0 = input.substr(pos, 5);
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"image\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 5).toLowerCase() === "audio") {
              result0 = input.substr(pos, 5);
              pos += 5;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"audio\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "video") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"video\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 11).toLowerCase() === "application") {
                  result0 = input.substr(pos, 11);
                  pos += 11;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"application\"");
                  }
                }
                if (result0 === null) {
                  result0 = parse_extension_token();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_composite_type() {
        var result0;
        
        if (input.substr(pos, 7).toLowerCase() === "message") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"message\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "multipart") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"multipart\"");
            }
          }
          if (result0 === null) {
            result0 = parse_extension_token();
          }
        }
        return result0;
      }
      
      function parse_extension_token() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_x_token();
        }
        return result0;
      }
      
      function parse_x_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2).toLowerCase() === "x-") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"x-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_token();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_subtype() {
        var result0;
        
        result0 = parse_extension_token();
        if (result0 === null) {
          result0 = parse_token();
        }
        return result0;
      }
      
      function parse_m_parameter() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_m_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        return result0;
      }
      
      function parse_CSeq() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_CSeq_value();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_Method();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_CSeq_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, cseq_value) {
                          data.value=parseInt(cseq_value.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, expires) {data = expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Event() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, event_type) {
                               data.event = event_type.join('').toLowerCase(); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_event_type() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token_nodot();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_token_nodot();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_token_nodot();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_From() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_from_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_from_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                        var tag = data.tag;
                        try {
                          data = new NameAddrHeader(data.uri, data.display_name, data.params);
                          if (tag) {data.setParam('tag',tag)}
                        } catch(e) {
                          data = -1;
                        }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_from_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_tag_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "tag") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {data.tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Max_Forwards() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, forwards) {
                          data = parseInt(forwards.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Min_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, min_expires) {data = min_expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Name_Addr_Header() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_display_name();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_display_name();
        }
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                result5 = parse_SEMI();
                if (result5 !== null) {
                  result6 = parse_generic_param();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  result5 = parse_SEMI();
                  if (result5 !== null) {
                    result6 = parse_generic_param();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              try {
                                data = new NameAddrHeader(data.uri, data.display_name, data.params);
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "digest") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Digest\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_digest_cln();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_digest_cln();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_digest_cln();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_other_challenge();
        }
        return result0;
      }
      
      function parse_other_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_auth_param();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_auth_param();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_auth_param();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_auth_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 === null) {
              result2 = parse_quoted_string();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digest_cln() {
        var result0;
        
        result0 = parse_realm();
        if (result0 === null) {
          result0 = parse_domain();
          if (result0 === null) {
            result0 = parse_nonce();
            if (result0 === null) {
              result0 = parse_opaque();
              if (result0 === null) {
                result0 = parse_stale();
                if (result0 === null) {
                  result0 = parse_algorithm();
                  if (result0 === null) {
                    result0 = parse_qop_options();
                    if (result0 === null) {
                      result0 = parse_auth_param();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_realm() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "realm") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"realm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_realm_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_realm_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, realm) { data.realm = realm; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domain() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "domain") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"domain\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              result3 = parse_URI();
              if (result3 !== null) {
                result4 = [];
                pos1 = pos;
                result6 = parse_SP();
                if (result6 !== null) {
                  result5 = [];
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_SP();
                  }
                } else {
                  result5 = null;
                }
                if (result5 !== null) {
                  result6 = parse_URI();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                } else {
                  result5 = null;
                  pos = pos1;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos1 = pos;
                  result6 = parse_SP();
                  if (result6 !== null) {
                    result5 = [];
                    while (result6 !== null) {
                      result5.push(result6);
                      result6 = parse_SP();
                    }
                  } else {
                    result5 = null;
                  }
                  if (result5 !== null) {
                    result6 = parse_URI();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos1;
                    }
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                }
                if (result4 !== null) {
                  result5 = parse_RDQUOT();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_URI() {
        var result0;
        
        result0 = parse_absoluteURI();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        return result0;
      }
      
      function parse_nonce() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "nonce") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"nonce\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_nonce_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonce_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, nonce) { data.nonce=nonce; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "opaque") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"opaque\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_quoted_string_clean();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, opaque) { data.opaque=opaque; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stale() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stale") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stale\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            pos1 = pos;
            if (input.substr(pos, 4).toLowerCase() === "true") {
              result2 = input.substr(pos, 4);
              pos += 4;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"true\"");
              }
            }
            if (result2 !== null) {
              result2 = (function(offset) { data.stale=true; })(pos1);
            }
            if (result2 === null) {
              pos = pos1;
            }
            if (result2 === null) {
              pos1 = pos;
              if (input.substr(pos, 5).toLowerCase() === "false") {
                result2 = input.substr(pos, 5);
                pos += 5;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"false\"");
                }
              }
              if (result2 !== null) {
                result2 = (function(offset) { data.stale=false; })(pos1);
              }
              if (result2 === null) {
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_algorithm() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "algorithm") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"algorithm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 3).toLowerCase() === "md5") {
              result2 = input.substr(pos, 3);
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"MD5\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "md5-sess") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MD5-sess\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, algorithm) {
                              data.algorithm=algorithm.toUpperCase(); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_options() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "qop") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"qop\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              pos1 = pos;
              result3 = parse_qop_value();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  result5 = ",";
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result5 !== null) {
                  result6 = parse_qop_value();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    result5 = ",";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_qop_value();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              if (result3 !== null) {
                result4 = parse_RDQUOT();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "auth-int") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"auth-int\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "auth") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"auth\"");
            }
          }
          if (result0 === null) {
            result0 = parse_token();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, qop_value) {
                                data.qop || (data.qop=[]);
                                data.qop.push(qop_value.toLowerCase()); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Record_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rec_route();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_rec_route();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_rec_route();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var idx, length;
                          length = data.multi_header.length;
                          for (idx = 0; idx < length; idx++) {
                            if (data.multi_header[idx].parsed === null) {
                              data = null;
                              break;
                            }
                          }
                          if (data !== null) {
                            data = data.multi_header;
                          } else {
                            data = -1;
                          }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rec_route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var header;
                          if(!data.multi_header) data.multi_header = [];
                          try {
                            header = new NameAddrHeader(data.uri, data.display_name, data.params);
                            delete data.uri;
                            delete data.display_name;
                            delete data.params;
                          } catch(e) {
                            header = null;
                          }
                          data.multi_header.push( { 'possition': pos,
                                                    'offset': offset,
                                                    'parsed': header
                                                  });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_route_param();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_route_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_route_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_route_param() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Subscription_State() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_substate_value();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_subexp_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_subexp_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_substate_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "active") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"active\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "pending") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"pending\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 10).toLowerCase() === "terminated") {
              result0 = input.substr(pos, 10);
              pos += 10;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"terminated\"");
              }
            }
            if (result0 === null) {
              result0 = parse_token();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                data.state = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_subexp_params() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "reason") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"reason\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_event_reason_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, reason) {
                                if (typeof reason !== 'undefined') data.reason = reason; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.substr(pos, 7).toLowerCase() === "expires") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"expires\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_EQUAL();
            if (result1 !== null) {
              result2 = parse_delta_seconds();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expires) {
                                  if (typeof expires !== 'undefined') data.expires = expires; })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.substr(pos, 11).toLowerCase() === "retry_after") {
              result0 = input.substr(pos, 11);
              pos += 11;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"retry_after\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_EQUAL();
              if (result1 !== null) {
                result2 = parse_delta_seconds();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, retry_after) {
                                    if (typeof retry_after !== 'undefined') data.retry_after = retry_after; })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_generic_param();
            }
          }
        }
        return result0;
      }
      
      function parse_event_reason_value() {
        var result0;
        
        if (input.substr(pos, 11).toLowerCase() === "deactivated") {
          result0 = input.substr(pos, 11);
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"deactivated\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "probation") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"probation\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8).toLowerCase() === "rejected") {
              result0 = input.substr(pos, 8);
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"rejected\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7).toLowerCase() === "timeout") {
                result0 = input.substr(pos, 7);
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"timeout\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6).toLowerCase() === "giveup") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"giveup\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 10).toLowerCase() === "noresource") {
                    result0 = input.substr(pos, 10);
                    pos += 10;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"noresource\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 9).toLowerCase() === "invariant") {
                      result0 = input.substr(pos, 9);
                      pos += 9;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"invariant\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_token();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Subject() {
        var result0;
        
        result0 = parse_TEXT_UTF8_TRIM();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_Supported() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_To() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_to_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_to_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      var tag = data.tag;
                      try {
                        data = new NameAddrHeader(data.uri, data.display_name, data.params);
                        if (tag) {data.setParam('tag',tag)}
                      } catch(e) {
                        data = -1;
                      }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_to_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_Via() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_parm();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_via_parm();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_via_parm();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_parm() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_sent_protocol();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_sent_by();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_via_params();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_via_params();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_params() {
        var result0;
        
        result0 = parse_via_ttl();
        if (result0 === null) {
          result0 = parse_via_maddr();
          if (result0 === null) {
            result0 = parse_via_received();
            if (result0 === null) {
              result0 = parse_via_branch();
              if (result0 === null) {
                result0 = parse_response_port();
                if (result0 === null) {
                  result0 = parse_generic_param();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_via_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "ttl") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_ttl();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_ttl_value) {
                              data.ttl = via_ttl_value; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_maddr() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "maddr") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_host();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_maddr) {
                              data.maddr = via_maddr; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_received() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8).toLowerCase() === "received") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"received\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_IPv4address();
            if (result2 === null) {
              result2 = parse_IPv6address();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_received) {
                              data.received = via_received; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_branch() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "branch") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"branch\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_branch) {
                              data.branch = via_branch; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_response_port() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "rport") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"rport\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_DIGIT();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_DIGIT();
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(typeof response_port !== 'undefined')
                                data.rport = response_port.join(''); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_protocol() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_protocol_name();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result3 = parse_SLASH();
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_protocol_name() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 === null) {
          result0 = parse_token();
        }
        if (result0 !== null) {
          result0 = (function(offset, via_protocol) {
                              data.protocol = via_protocol; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_transport() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "udp") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"UDP\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3).toLowerCase() === "tcp") {
            result0 = input.substr(pos, 3);
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"TCP\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tls") {
              result0 = input.substr(pos, 3);
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"TLS\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result0 = input.substr(pos, 4);
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"SCTP\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, via_transport) {
                              data.transport = via_transport; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_by() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_host();
        if (result0 !== null) {
          pos1 = pos;
          result1 = parse_COLON();
          if (result1 !== null) {
            result2 = parse_via_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.host = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_sent_by_port) {
                              data.port = parseInt(via_sent_by_port.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              return parseInt(ttl.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_WWW_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_extension_header() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_HCOLON();
          if (result1 !== null) {
            result2 = parse_header_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header_value() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_TEXT_UTF8char();
        if (result1 === null) {
          result1 = parse_UTF8_CONT();
          if (result1 === null) {
            result1 = parse_LWS();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_TEXT_UTF8char();
          if (result1 === null) {
            result1 = parse_UTF8_CONT();
            if (result1 === null) {
              result1 = parse_LWS();
            }
          }
        }
        return result0;
      }
      
      function parse_message_body() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_OCTET();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_OCTET();
        }
        return result0;
      }
      
      function parse_stun_URI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_stun_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stuns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stuns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "stun") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"stun\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host_port() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_stun_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_reg_name();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, host) {
                              data.host = host; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_stun_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_sub_delims();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_stun_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_sub_delims();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_unreserved() {
        var result0;
        
        result0 = parse_ALPHA();
        if (result0 === null) {
          result0 = parse_DIGIT();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 46) {
                result0 = ".";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 126) {
                    result0 = "~";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_sub_delims() {
        var result0;
        
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 36) {
            result0 = "$";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"$\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 38) {
              result0 = "&";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 39) {
                result0 = "'";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 40) {
                  result0 = "(";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 41) {
                    result0 = ")";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result0 = "*";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 59) {
                            result0 = ";";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\";\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result0 = "=";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_turn_URI() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_turn_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              pos1 = pos;
              if (input.substr(pos, 11) === "?transport=") {
                result3 = "?transport=";
                pos += 11;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?transport=\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "turns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"turns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "turn") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"turn\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_transport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_transport();
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              result1 = [];
              result2 = parse_unreserved();
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_unreserved();
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.transport = transport; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid_URI() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5) === "uuid:") {
          result0 = "uuid:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"uuid:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_uuid();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hex8();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 45) {
                result3 = "-";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_hex4();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 45) {
                    result5 = "-";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_hex4();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 45) {
                        result7 = "-";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_hex12();
                        if (result8 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, uuid) {
                          data = input.substring(pos+5, offset); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex4() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex8() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex12() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var URI = require('./URI');
        var NameAddrHeader = require('./NameAddrHeader');
      
        var data = {};
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
        return -1;
      }
      
      return data;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

},{"./NameAddrHeader":882,"./URI":895}],879:[function(require,module,exports){
module.exports = Logger;

function DateFmt(fstr) {
  this.formatString = fstr;

  var mthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  var dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  var zeroPad = function(number) {
    return ("0"+number).substr(-2,2);
  };

  var dateMarkers = {
    d:['getDate',function(v) { return zeroPad(v);}],
    m:['getMonth',function(v) { return zeroPad(v+1);}],
    n:['getMonth',function(v) { return mthNames[v]; }],
    w:['getDay',function(v) { return dayNames[v]; }],
    y:['getFullYear'],
    H:['getHours',function(v) { return zeroPad(v);}],
    M:['getMinutes',function(v) { return zeroPad(v);}],
    S:['getSeconds',function(v) { return zeroPad(v);}],
    i:['toISOString']
  };

  this.format = function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if ( dateMarker[1] !== null ) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  };

}


function Logger(logger, category, label) {
  this.logger = logger;
  this.category = category;
  this.label = label;
  this.fmt = new DateFmt("%m%d/%H%M%S");
}

Logger.prototype.debug = function(content) {
  this.logger.debug(this.category, this.label, content);
};

Logger.prototype.log = function(content) {
  this.logger.log(this.category, this.label, content);
};

Logger.prototype.warn = function(content) {
  this.logger.warn(this.category, this.label, content);
};

Logger.prototype.error = function(content) {
  this.logger.error(this.category, this.label, content);
};

Logger.prototype.formatMsg = function(msg) {
  return this.getTime()+' : '+msg;
};
Logger.prototype.getTime = function() {
  return this.getTimeFor(new Date());
};
Logger.prototype.getTimeFor = function(date) {
  return this.fmt.format(date);
};
},{}],880:[function(require,module,exports){
module.exports = LoggerFactory;


/**
 * Dependencies.
 */
var Logger = require('./Logger');


function LoggerFactory(configuration) {
  var logger,
    levels = { 'error': 0, 'warn': 1, 'log': 2, 'debug': 3 },
    level = configuration && configuration.trace_sip === true ? 3 : 1,
    builtinEnabled = true,
    connector = null;

    this.loggers = {};

    logger = this.getLogger('ExSIP.loggerfactory');


  Object.defineProperties(this, {
    builtinEnabled: {
      get: function(){ return builtinEnabled; },
      set: function(value){
        if (typeof value === 'boolean') {
          builtinEnabled = value;
        } else {
          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    level: {
      get: function() {return level; },
      set: function(value) {
        if (value >= 0 && value <=3) {
          level = value;
        } else if (value > 3) {
          level = 3;
        } else if (levels.hasOwnProperty(value)) {
          level = levels[value];
        } else {
          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    connector: {
      get: function() {return connector; },
      set: function(value){
        if(value === null || value === "" || value === undefined) {
          connector = null;
        } else if (typeof value === 'function') {
          connector = value;
        } else {
          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
        }
      }
    }
  });
}


LoggerFactory.prototype.print = function(target, category, label, content) {
  var prefix = [];

  prefix.push(new Date());

  prefix.push(category);

  if (label) {
    prefix.push(label);
  }

  prefix.push('');

  if (typeof content === 'string') {
    target.call(console, prefix.join(' | ') + content);
  } else {
    target.call(console, content);
  }
};

LoggerFactory.prototype.debug = function(category, label, content) {
  if (this.level === 3) {
    if (this.builtinEnabled) {
      this.print(console.info, category, label, content);
    }

    if (this.connector) {
      this.connector('debug', category, label, content);
    }
  }
};

LoggerFactory.prototype.log = function(category, label, content) {
  if (this.level >= 2) {
    if (this.builtinEnabled) {
      this.print(console.log, category, label, content);
    }

    if (this.connector) {
      this.connector('log', category, label, content);
    }
  }
};

LoggerFactory.prototype.warn = function(category, label, content) {
  if (this.level >= 1) {
    if (this.builtinEnabled) {
      this.print(console.warn, category, label, content);
    }

    if (this.connector) {
      this.connector('warn', category, label, content);
    }
  }
};

LoggerFactory.prototype.error = function(category, label, content) {
  if (this.builtinEnabled) {
    this.print(console.error,category, label, content);
  }

  if (this.connector) {
    this.connector('error', category, label, content);
  }
};

LoggerFactory.prototype.getLogger = function(category, label) {
  var logger;

  if (label && this.level === 1) {
    return new Logger(this, category, label);
  } else if (this.loggers[category]) {
    return this.loggers[category];
  } else {
    logger = new Logger(this, category);
    this.loggers[category] = logger;
    return logger;
  }
};

},{"./Logger":879}],881:[function(require,module,exports){
module.exports = Message;

function Message(ua) {
  this.ua = ua;
  this.logger = ua.getLogger('ExSIP.message');

  // Custom message empty object for high level use
  this.data = {};
}


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');
var RequestSender = require('./RequestSender');
var Transactions = require('./Transactions');
var Exceptions = require('./Exceptions');


Message.prototype = new EventEmitter();


Message.prototype.isDebug = function() {
  return this.ua.isDebug();
};

Message.prototype.send = function(target, body, options) {
  var request_sender, event, contentType, eventHandlers, extraHeaders,
    events = [
      'succeeded',
      'failed'
    ],
    originalTarget = target;

  if (target === undefined || body === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: '+ originalTarget);
  }

  this.initEvents(events);

  // Get call options
  options = options || {};
  extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [];
  eventHandlers = options.eventHandlers || {};
  contentType = options.contentType || 'text/plain';

  this.content_type = contentType;

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.closed = false;
  this.ua.applicants[this] = this;

  extraHeaders.push('Content-Type: '+ contentType);

  this.request = new SIPMessage.OutgoingRequest(ExSIP_C.MESSAGE, target, this.ua, null, extraHeaders);

  if(body) {
    this.request.body = body;
    this.content = body;
  } else {
    this.content = null;
  }

  request_sender = new RequestSender(this, this.ua);

  this.newMessage('local', this.request);

  request_sender.send();
};

Message.prototype.receiveResponse = function(response) {
  var cause;

  if(this.closed) {
    return;
  }
  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      delete this.ua.applicants[this];
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      delete this.ua.applicants[this];
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};


Message.prototype.onRequestTimeout = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.REQUEST_TIMEOUT
  });
};

Message.prototype.onTransportError = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.CONNECTION_ERROR
  });
};

Message.prototype.close = function() {
  this.closed = true;
  delete this.ua.applicants[this];
};

Message.prototype.init_incoming = function(request) {
  var transaction;

  this.request = request;
  this.content_type = request.getHeader('Content-Type');

  if (request.body) {
    this.content = request.body;
  } else {
    this.content = null;
  }

  this.newMessage('remote', request);

  transaction = this.ua.transactions.nist[request.via_branch];

  if (transaction && (transaction.state === Transactions.C.STATUS_TRYING || transaction.state === Transactions.C.STATUS_PROCEEDING)) {
    request.reply(200);
  }
};

/**
 * Accept the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.accept = function(options) {
  options = options || {};

  var
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"accept" not supported for outgoing Message');
  }

  this.request.reply(200, null, extraHeaders, body);
};

/**
 * Reject the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.reject = function(options) {
  options = options || {};

  var
    status_code = options.status_code || 480,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"reject" not supported for outgoing Message');
  }

  if (status_code < 300 || status_code >= 700) {
    throw new TypeError('Invalid status_code: '+ status_code);
  }

  this.request.reply(status_code, reason_phrase, extraHeaders, body);
};

/**
 * Internal Callbacks
 */

Message.prototype.newMessage = function(originator, request) {
  var message = this,
    event_name = 'newMessage';

  if (originator === 'remote') {
    message.direction = 'incoming';
    message.local_identity = request.to;
    message.remote_identity = request.from;
  } else if (originator === 'local'){
    message.direction = 'outgoing';
    message.local_identity = request.from;
    message.remote_identity = request.to;
  }

  message.ua.emit(event_name, message.ua, {
    originator: originator,
    message: message,
    request: request
  });
};
},{"./Constants":871,"./EventEmitter":875,"./Exceptions":877,"./RequestSender":889,"./SIPMessage":890,"./Transactions":892,"./Utils":896}],882:[function(require,module,exports){
module.exports = NameAddrHeader;


/**
 * Dependencies.
 */
var URI = require('./URI');
var Grammar = require('./Grammar');


function NameAddrHeader(uri, display_name, parameters) {
  var param;

  // Checks
  if(!uri || !(uri instanceof URI)) {
    throw new TypeError('missing or invalid "uri" parameter');
  }

  // Initialize parameters
  this.uri = uri;
  this.parameters = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  Object.defineProperties(this, {
    display_name: {
      get: function() { return display_name; },
      set: function(value) {
        display_name = (value === 0) ? '0' : value;
      }
    }
  });
}

NameAddrHeader.prototype = {
  setParam: function(key, value) {
    if (key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  clone: function() {
    return new NameAddrHeader(
      this.uri.clone(),
      this.display_name,
      JSON.parse(JSON.stringify(this.parameters)));
  },

  toString: function() {
    var body, parameter;

    body  = (this.display_name || this.display_name === 0) ? '"' + this.display_name + '" ' : '';
    body += '<' + this.uri.toString() + '>';

    for (parameter in this.parameters) {
      body += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        body += '='+ this.parameters[parameter];
      }
    }

    return body;
  }
};


/**
  * Parse the given string and returns a NameAddrHeader instance or undefined if
  * it is an invalid NameAddrHeader.
  */
NameAddrHeader.parse = function(name_addr_header) {
  name_addr_header = Grammar.parse(name_addr_header,'Name_Addr_Header');

  if (name_addr_header !== -1) {
    return name_addr_header;
  } else {
    return undefined;
  }
};
},{"./Grammar":878,"./URI":895}],883:[function(require,module,exports){
var Parser = {};

module.exports = Parser;


/**
 * Dependencies.
 */
var sdp_transform = require('sdp-transform');
var Grammar = require('./Grammar');
var SIPMessage = require('./SIPMessage');


/**
 * Extract and parse every header of a SIP message.
 */
function getHeader(data, headerStart) {
  var
    // 'start' position of the header.
    start = headerStart,
    // 'end' position of the header.
    end = 0,
    // 'partial end' position of the header.
    partialEnd = 0;

  //End of message.
  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
    return -2;
  }

  while(end === 0) {
    // Partial End of Header.
    partialEnd = data.indexOf('\r\n', start);

    // 'indexOf' returns -1 if the value to be found never occurs.
    if (partialEnd === -1) {
      return partialEnd;
    }

    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
      // Not the end of the message. Continue from the next position.
      start = partialEnd + 2;
    } else {
      end = partialEnd;
    }
  }

  return end;
}

function parseHeader(message, data, headerStart, headerEnd) {
  var header, idx, length, parsed,
    hcolonIndex = data.indexOf(':', headerStart),
    headerName = data.substring(headerStart, hcolonIndex).trim(),
    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();

  // If header-field is well-known, parse it.
  switch(headerName.toLowerCase()) {
    case 'via':
    case 'v':
      message.addHeader('via', headerValue);
      if(message.getHeaders('via').length === 1) {
        parsed = message.parseHeader('Via');
        if(parsed) {
          message.via = parsed;
          message.via_branch = parsed.branch;
        }
      } else {
        parsed = 0;
      }
      break;
    case 'from':
    case 'f':
      message.setHeader('from', headerValue);
      parsed = message.parseHeader('from');
      if(parsed) {
        message.from = parsed;
        message.from_tag = parsed.getParam('tag');
      }
      break;
    case 'to':
    case 't':
      message.setHeader('to', headerValue);
      parsed = message.parseHeader('to');
      if(parsed) {
        message.to = parsed;
        message.to_tag = parsed.getParam('tag');
      }
      break;
    case 'record-route':
      parsed = Grammar.parse(headerValue, 'Record_Route');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('record-route', headerValue.substring(header.possition, header.offset));
        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
      }
      break;
    case 'call-id':
    case 'i':
      message.setHeader('call-id', headerValue);
      parsed = message.parseHeader('call-id');
      if(parsed) {
        message.call_id = headerValue;
      }
      break;
    case 'contact':
    case 'm':
      parsed = Grammar.parse(headerValue, 'Contact');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('contact', headerValue.substring(header.possition, header.offset));
        message.headers.Contact[message.getHeaders('contact').length - 1].parsed = header.parsed;
      }
      break;
    case 'content-length':
    case 'l':
      message.setHeader('content-length', headerValue);
      parsed = message.parseHeader('content-length');
      break;
    case 'content-type':
    case 'c':
      message.setHeader('content-type', headerValue);
      parsed = message.parseHeader('content-type');
      break;
    case 'cseq':
      message.setHeader('cseq', headerValue);
      parsed = message.parseHeader('cseq');
      if(parsed) {
        message.cseq = parsed.value;
      }
      if(message instanceof SIPMessage.IncomingResponse) {
        message.method = parsed.method;
      }
      break;
    case 'max-forwards':
      message.setHeader('max-forwards', headerValue);
      parsed = message.parseHeader('max-forwards');
      break;
    case 'www-authenticate':
      message.setHeader('www-authenticate', headerValue);
      parsed = message.parseHeader('www-authenticate');
      break;
    case 'proxy-authenticate':
      message.setHeader('proxy-authenticate', headerValue);
      parsed = message.parseHeader('proxy-authenticate');
      break;
    default:
      // Do not parse this header.
      message.setHeader(headerName, headerValue);
      parsed = 0;
  }

  if (parsed === undefined) {
    return {
      error: 'error parsing header "'+ headerName +'"'
    };
  } else {
    return true;
  }
}


/**
 * Parse SIP Message
 */
Parser.parseMessage = function(data, ua) {
  var message, firstLine, contentLength, bodyStart, parsed,
    headerStart = 0,
    headerEnd = data.indexOf('\r\n'),
    logger = ua.getLogger('ExSIP.parser');

  if(headerEnd === -1) {
    logger.warn('no CRLF found, not a SIP message, discarded');
    return;
  }

  // Parse first line. Check if it is a Request or a Reply.
  firstLine = data.substring(0, headerEnd);
  parsed = Grammar.parse(firstLine, 'Request_Response');

  if(parsed === -1) {
    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
    return;
  } else if(!parsed.status_code) {
    message = new SIPMessage.IncomingRequest(ua);
    message.method = parsed.method;
    message.ruri = parsed.uri;
  } else {
    message = new SIPMessage.IncomingResponse(ua);
    message.status_code = parsed.status_code;
    message.reason_phrase = parsed.reason_phrase;
  }

  message.data = data;
  headerStart = headerEnd + 2;

  /* Loop over every line in data. Detect the end of each header and parse
  * it or simply add to the headers collection.
  */
  while(true) {
    headerEnd = getHeader(data, headerStart);

    // The SIP message has normally finished.
    if(headerEnd === -2) {
      bodyStart = headerStart + 2;
      break;
    }
    // data.indexOf returned -1 due to a malformed message.
    else if(headerEnd === -1) {
      parsed.error('malformed message');
      return;
    }

    parsed = parseHeader(message, data, headerStart, headerEnd);

    if(parsed !== true) {
      logger.error(parsed.error);
      return;
    }

    headerStart = headerEnd + 2;
  }

  /* RFC3261 18.3.
   * If there are additional bytes in the transport packet
   * beyond the end of the body, they MUST be discarded.
   */
  if(message.hasHeader('content-length')) {
    contentLength = message.getHeader('content-length');
    message.body = data.substr(bodyStart, contentLength);
  } else {
    message.body = data.substring(bodyStart);
  }

  return message;
};

/**
 * sdp-transform features.
 */
Parser.parseSDP = sdp_transform.parse;
Parser.writeSDP = sdp_transform.write;
Parser.parseFmtpConfig = sdp_transform.parseFmtpConfig;
Parser.parsePayloads = sdp_transform.parsePayloads;
Parser.parseRemoteCandidates = sdp_transform.parseRemoteCandidates;
},{"./Grammar":878,"./SIPMessage":890,"sdp-transform":866}],884:[function(require,module,exports){
module.exports = RTCSession;


var C = {
  // RTCSession states
  STATUS_NULL: 0,
  STATUS_INVITE_SENT: 1,
  STATUS_1XX_RECEIVED: 2,
  STATUS_INVITE_RECEIVED: 3,
  STATUS_WAITING_FOR_ANSWER: 4,
  STATUS_ANSWERED: 5,
  STATUS_WAITING_FOR_ACK: 6,
  STATUS_CANCELED: 7,
  STATUS_TERMINATED: 8,
  STATUS_CONFIRMED: 9,
  STATUS_REFER_SENT: 10,
  STATUS_BYE_SENT: 11
};

/**
 * Expose C object.
 */
RTCSession.C = C;

/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Exceptions = require('./Exceptions');
var Parser = require('./Parser');
var Utils = require('./Utils');
var Timers = require('./Timers');
var UA = require('./UA');
var WebRTC = require('./WebRTC');
var SIPMessage = require('./SIPMessage');
var Dialog = require('./Dialog');
var RequestSender = require('./RequestSender');
var RTCSession_RTCMediaHandler = require('./RTCSession/RTCMediaHandler');
var RTCSession_DTMF = require('./RTCSession/DTMF');


function RTCSession(ua) {
  var events = [
    'connecting',
    'progress',
    'failed',
    'accepted',
    'confirmed',
    'ended',
    'newDTMF',
    'hold',
    'held',
    'resumed',
    'unhold',
    'muted',
    'unmuted',
    'started',
    'onReInvite',
    'dataSent',
    'dataReceived',
    'iceconnected',
    'icecompleted',
    'iceclosed'
  ];

  this.ua = ua;
  this.setStatus(C.STATUS_NULL);
  this.dialog = null;
  this.earlyDialogs = {};
  this.rtcMediaHandler = null;
  this.receiveResponse = this.receiveInviteResponse;

  // RTCSession confirmation flag
  this.is_confirmed = false;

  // is late SDP being negotiated
  this.late_sdp = false;

  // Session Timers
  this.timers = {
    ackTimer: null,
    expiresTimer: null,
    invite2xxTimer: null,
    userNoAnswerTimer: null
  };

  // Custom session empty object for high level use
  this.data = {};
  this.dtmf = new RTCSession_DTMF(this);

  /**
   * User API
   */

  // Mute/Hold state
  this.isOnHold = false;
  this.audioMuted = false;
  this.videoMuted = false;
  this.local_hold = false;
  this.remote_hold = false;
  this.start_time = null;

  this.pending_actions = {
    actions: [],

    length: function() {
      return this.actions.length;
    },

    isPending: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          return true;
        }
      }
      return false;
    },

    shift: function() {
      return this.actions.shift();
    },

    push: function(name) {
      this.actions.push({
        name: name
      });
    },

    pop: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          this.actions.splice(idx, 1);
        }
      }
    }
  };

  // Custom session empty object for high level use
  this.data = {};

  this.initEvents(events);
}

RTCSession.prototype = new EventEmitter();

RTCSession.prototype.hasRemoteAudio = function() {
  return this.rtcMediaHandler && this.rtcMediaHandler.peerConnection && this.rtcMediaHandler.peerConnection.remoteDescription &&
  this.rtcMediaHandler.peerConnection.remoteDescription.hasAudio();
};

RTCSession.prototype.hasRemoteVideo = function() {
  return this.rtcMediaHandler && this.rtcMediaHandler.peerConnection && this.rtcMediaHandler.peerConnection.remoteDescription &&
  this.rtcMediaHandler.peerConnection.remoteDescription.hasVideo();
};

RTCSession.prototype.hasLocalAudio = function() {
  return this.rtcMediaHandler && this.rtcMediaHandler.peerConnection && this.rtcMediaHandler.peerConnection.localDescription &&
  this.rtcMediaHandler.peerConnection.localDescription.hasAudio();
};

RTCSession.prototype.hasLocalVideo = function() {
  return this.rtcMediaHandler && this.rtcMediaHandler.peerConnection && this.rtcMediaHandler.peerConnection.localDescription &&
  this.rtcMediaHandler.peerConnection.localDescription.hasVideo();
};

/**
 * Terminate the call.
 */
RTCSession.prototype.terminate = function(options) {
  options = options || {};

  var cancel_reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  // Check Session Status
  if (this.status === C.STATUS_TERMINATED) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.logger.log('terminate with status : ' + this.status);

  switch (this.status) {
    // - UAC -
    case C.STATUS_NULL:
    case C.STATUS_INVITE_SENT:
    case C.STATUS_1XX_RECEIVED:
      this.logger.debug('canceling RTCSession');

      if (status_code && (status_code < 200 || status_code >= 700)) {
        throw new TypeError('Invalid status_code: ' + status_code);
      } else if (status_code) {
        reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
        cancel_reason = 'SIP ;cause=' + status_code + ' ;text="' + reason_phrase + '"';
      }

      // Check Session Status
      if (this.status === C.STATUS_NULL) {
        this.isCanceled = true;
        this.cancelReason = cancel_reason;
      } else if (this.status === C.STATUS_INVITE_SENT) {
        if (this.received_100) {
          this.logger.debug('canceling after received 100 response');
          if (typeof(this.request.cancel) === 'undefined') {
            this.sendBye(options);
            this.ended('local', null, ExSIP_C.causes.BYE);
          } else {
            this.isCanceled = true;
            this.logger.log('terminate on 100 - setting isCanceled = true', this.ua);
            this.request.cancel(cancel_reason);
          }
        } else {
          this.isCanceled = true;
          this.cancelReason = cancel_reason;
        }
      } else if (this.status === C.STATUS_1XX_RECEIVED) {
        this.isCanceled = true;
        this.logger.log('terminate on 1xx - setting isCanceled = true');
        this.request.cancel(cancel_reason);
      }

      this.setStatus(C.STATUS_CANCELED);

      this.failed('local', null, ExSIP_C.causes.CANCELED);
      break;

      // - UAS -
    case C.STATUS_WAITING_FOR_ANSWER:
      this.logger.log('rejecting RTCSession with 486 Busy Here', this.ua);
      this.request.reply(486);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;
    case C.STATUS_ANSWERED:
      this.logger.debug('rejecting RTCSession');

      status_code = status_code || 480;

      if (status_code < 300 || status_code >= 700) {
        throw new TypeError('Invalid status_code: ' + status_code);
      }

      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;

    case C.STATUS_WAITING_FOR_ACK:
    case C.STATUS_REFER_SENT:
    case C.STATUS_CONFIRMED:
      this.logger.debug('terminating RTCSession');

      // Send Bye
      this.sendBye(options);
      return;
      // reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';

      // if (status_code && (status_code < 200 || status_code >= 700)) {
      //   throw new TypeError('Invalid status_code: '+ status_code);
      // } else if (status_code) {
      //   extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
      // }

      // /* RFC 3261 section 15 (Terminating a session):
      //   *
      //   * "...the callee's UA MUST NOT send a BYE on a confirmed dialog
      //   * until it has received an ACK for its 2xx response or until the server
      //   * transaction times out."
      //   */
      // if (this.status === C.STATUS_WAITING_FOR_ACK &&
      //     this.direction === 'incoming' &&
      //     this.request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {

      //   // Save the dialog for later restoration
      //   dialog = this.dialog;

      //   // Send the BYE as soon as the ACK is received...
      //   this.receiveRequest = function(request) {
      //     if(request.method === ExSIP_C.ACK) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // this.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   };

      //   // .., or when the INVITE transaction times out
      //   this.request.server_transaction.on('stateChanged', function(e){
      //     if (e.sender.state === Transactions.C.STATUS_TERMINATED) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // self.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   });

      //   this.ended('local', null, cause);

      //   // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
      //   this.dialog = dialog;

      //   // Restore the dialog into 'ua' so the ACK can reach 'this' session
      //   this.ua.dialogs[dialog.id.toString()] = dialog;

      // } else {
      //   self.sendBye({
      //     extraHeaders: extraHeaders,
      //     body: body
      //   });
      //   return;
      //   // this.sendRequest(ExSIP_C.BYE, {
      //   //   extraHeaders: extraHeaders,
      //   //   body: body
      //   // });

      //   // this.ended('local', null, cause);
      // }
  }

  this.close();
};

/**
 * Answer the call.
 */
RTCSession.prototype.answer = function(options) {
  options = options || {};

  var idx, length, sdp, remoteDescription,
    hasAudio = false,
    hasVideo = false,
    self = this,
    request = this.request,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    mediaConstraints = options.mediaConstraints || {},
    mediaStream = options.mediaStream || null,

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer succeeded
    sdpCreationSucceeded = function(body) {
      var
      // run for reply success callback
        replySucceeded = function() {
          self.setStatus(C.STATUS_WAITING_FOR_ACK);

          self.setInvite2xxTimer(request, body);
          self.setACKTimer();
          self.accepted('local');
          self.started('local');
        },

        // run for reply failure callback
        replyFailed = function() {
          self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
        };

      request.reply(200, null, extraHeaders,
        body,
        replySucceeded,
        replyFailed
      );
    },

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer failed
    sdpCreationFailed = function() {
      if (self.status === C.STATUS_TERMINATED) {
        return;
      }

      self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

  this.data = options.data || {};

  // Check Session Direction and Status
  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"answer" not supported for outgoing RTCSession');
  } else if (this.status !== C.STATUS_WAITING_FOR_ANSWER) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.setStatus(C.STATUS_ANSWERED);

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS')) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  clearTimeout(this.timers.userNoAnswerTimer);

  extraHeaders.unshift('Contact: ' + self.contact);

  // Determine incoming media from remote session description
  remoteDescription = this.rtcMediaHandler.peerConnection.remoteDescription || {};
  sdp = Parser.parseSDP(remoteDescription.sdp || '');

  // Make sure sdp is an array, not the case if there is only one media
  if (!(sdp.media instanceof Array)) {
    sdp.media = [sdp.media || []];
  }

  // Go through all medias in SDP to find offered capabilities to answer with
  idx = sdp.media.length;
  while (idx--) {
    if (sdp.media[idx].type === 'audio' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasAudio = true;
    }
    if (sdp.media[idx].type === 'video' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasVideo = true;
    }
  }

  // Remove audio from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.audio === false) {
    length = mediaStream.getAudioTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
    }
  }

  // Remove video from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.video === false) {
    length = mediaStream.getVideoTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
    }
  }

  // Set audio constraints based on incoming stream if not supplied
  if (mediaConstraints.audio === undefined) {
    mediaConstraints.audio = hasAudio;
  }

  // Set video constraints based on incoming stream if not supplied
  if (mediaConstraints.video === undefined) {
    mediaConstraints.video = hasVideo;
  }

  this.getUserMedia(mediaConstraints, sdpCreationSucceeded, sdpCreationFailed, {
    isAnswer: true,
    remoteSdp: request.body
  });
};

/**
 * Send a DTMF
 */
RTCSession.prototype.sendDTMF = function(tones, options) {
  var duration, interToneGap;

  options = options || {};
  duration = options.duration || null;
  interToneGap = options.interToneGap || null;

  if (tones === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check Session Status
  if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Convert to string
  if (typeof tones === 'number') {
    tones = tones.toString();
  }

  // Check tones
  if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tones: ' + tones);
  }

  // Check duration
  if (duration && !Utils.isDecimal(duration)) {
    throw new TypeError('Invalid tone duration: ' + duration);
  } else if (!duration) {
    duration = RTCSession_DTMF.C.DEFAULT_DURATION;
  } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {
    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MIN_DURATION;
  } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {
    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to ' + RTCSession_DTMF.C.MAX_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MAX_DURATION;
  } else {
    duration = Math.abs(duration);
  }
  options.duration = duration;

  // Check interToneGap
  if (interToneGap && !Utils.isDecimal(interToneGap)) {
    throw new TypeError('Invalid interToneGap: ' + interToneGap);
  } else if (!interToneGap) {
    interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;
  } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {
    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');
    interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;
  } else {
    interToneGap = Math.abs(interToneGap);
  }

  this.dtmf.send(tones, options);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.rejectReInvite = function(options) {
  options = options || {};

  this.logger.log('rejecting re-INVITE');

  this.request.reply(488);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.acceptReInvite = function(options) {
  options = options || {};

  var self = this,
    extraHeaders = options.extraHeaders || [];

  this.logger.log('accepting re-INVITE');

  var replySucceeded = function() {
    var timeout = Timers.T1;

    self.setStatus(C.STATUS_WAITING_FOR_ACK);

    /**
     * RFC3261 13.3.1.4
     * Response retransmissions cannot be accomplished by transaction layer
     *  since it is destroyed when receiving the first 2xx answer
     */
    self.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
        if (self.status !== C.STATUS_WAITING_FOR_ACK) {
          return;
        }

        self.request.reply(200, null, extraHeaders, self.rtcMediaHandler.peerConnection.localDescription.sdp);

        if (timeout < Timers.T2) {
          timeout = timeout * 2;
          if (timeout > Timers.T2) {
            timeout = Timers.T2;
          }
        }
        self.timers.invite2xxTimer = setTimeout(
          invite2xxRetransmission, timeout
        );
      },
      timeout
    );

    /**
     * RFC3261 14.2
     * If a UAS generates a 2xx response and never receives an ACK,
     *  it SHOULD generate a BYE to terminate the dialog.
     */
    self.timers.ackTimer = setTimeout(function() {
        if (self.status === C.STATUS_WAITING_FOR_ACK) {
          self.logger.log('no ACK received');
          //                window.clearTimeout(self.timers.invite2xxTimer);
          //                self.sendBye();
          //                self.ended('remote', null, ExSIP.C.causes.NO_ACK);
        }
      },
      Timers.TIMER_H
    );

    self.started('local', undefined, true);
  };

  var replyFailed = function() {
    self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
  };

  //    var previousRemoteDescription = self.rtcMediaHandler.peerConnection.remoteDescription;
  var connectSuccess = function() {
    self.logger.debug('onMessage success');
    self.request.reply(200, null, extraHeaders,
      self.rtcMediaHandler.peerConnection.localDescription.getSdp({
        additionalSdp: self.rtcMediaHandler.peerConnection.remoteUnsupportedMedia
      }),
      replySucceeded,
      replyFailed
    );
  };

  var connectFailed = function(e) {
    self.logger.warn('invalid SDP');
    self.logger.warn(e);
    self.request.reply(488);
  };

  this.initialRemoteSdp = this.initialRemoteSdp || self.rtcMediaHandler.peerConnection.remoteDescription.sdp;
  var sdp = this.request.body;
  if (sdp.length === 0) {
    this.logger.debug('empty sdp');
  }
  this.reconnectRtcMediaHandler(connectSuccess, connectFailed, {
    isAnswer: true,
    remoteSdp: sdp,
    isReconnect: true
  });
};

RTCSession.prototype.reconnectRtcMediaHandler = function(connectSuccess, connectFailed, options) {
  var self = this;
  options = options || {};
  var localMedia = options.localMedia || this.rtcMediaHandler.localMedia || self.ua.localMedia;
  options.createOfferConstraints = options.createOfferConstraints || this.rtcMediaHandler.createOfferConstraints;
  this.rtcMediaHandler.close(!!options.localMedia);

  this.initRtcMediaHandler(options);
  this.rtcMediaHandler.localMedia = localMedia;
  this.rtcMediaHandler.createOfferConstraints = options.createOfferConstraints;
  this.connectRtcMediaHandler(localMedia, function() {
    self.started('local', undefined, true);
    connectSuccess();
  }, connectFailed, options);
};

// /**
//  * Send a generic in-dialog Request
//  */
// RTCSession.prototype.sendRequest = function(method, options, callbacks) {
//   var request = new RTCSession_Request(this, callbacks);

//   if(options.status) {
//     this.status = options.status;
//   }
//   request.body = options.sdp;

//   request.send(method, options);
// };

/**
 * Check if RTCSession is ready for a re-INVITE
 */
RTCSession.prototype.isReadyToReinvite = function() {
  // rtcMediaHandler is not ready
  if (!this.rtcMediaHandler.isReady()) {
    return;
  }

  // Another INVITE transaction is in progress
  if (this.dialog.uac_pending_reply === true || this.dialog.uas_pending_reply === true) {
    return false;
  } else {
    return true;
  }
};


/**
 * Mute
 */
RTCSession.prototype.mute = function(options) {
  options = options || {
    audio: true,
    video: false
  };

  var
    audioMuted = false,
    videoMuted = false;

  if (this.audioMuted === false && options.audio) {
    audioMuted = true;
    this.audioMuted = true;
    this.toogleMuteAudio(true);
  }

  if (this.videoMuted === false && options.video) {
    videoMuted = true;
    this.videoMuted = true;
    this.toogleMuteVideo(true);
  }

  if (audioMuted === true || videoMuted === true) {
    this.onmute({
      audio: audioMuted,
      video: videoMuted
    });
  }
};

/**
 * Unmute
 */
RTCSession.prototype.unmute = function(options) {
  options = options || {
    audio: true,
    video: true
  };

  var
    audioUnMuted = false,
    videoUnMuted = false;

  if (this.audioMuted === true && options.audio) {
    audioUnMuted = true;
    this.audioMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteAudio(false);
    }
  }

  if (this.videoMuted === true && options.video) {
    videoUnMuted = true;
    this.videoMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteVideo(false);
    }
  }

  if (audioUnMuted === true || videoUnMuted === true) {
    this.onunmute({
      audio: audioUnMuted,
      video: videoUnMuted
    });
  }
};

/**
 * isMuted
 */
RTCSession.prototype.isMuted = function() {
  return {
    audio: this.audioMuted,
    video: this.videoMuted
  };
};

/**
 * Hold
 */
// RTCSession.prototype.hold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   this.toogleMuteAudio(true);
//   this.toogleMuteVideo(true);

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'unhold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'hold' action, add this one to the queue
//      * Else, if there is already a 'hold' action, skip
//      */
//     if (this.pending_actions.isPending('unhold')) {
//       this.pending_actions.pop('unhold');
//       return;
//     } else if (!this.pending_actions.isPending('hold')) {
//       this.pending_actions.push('hold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === true) {
//       return;
//     }
//   }

//   this.onhold('local');

//   this.sendReinvite({
//     mangle: function(body) {
//       var idx, length;

//       body = Parser.parseSDP(body);

//       length = body.media.length;
//       for (idx = 0; idx < length; idx++) {
//         if (body.media[idx].direction === undefined) {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendrecv') {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendonly') {
//           body.media[idx].direction = 'inactive';
//         }
//       }

//       return Parser.writeSDP(body);
//     }
//   });
// };

// /**
//  * Unhold
//  */
// RTCSession.prototype.unhold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   if (!this.audioMuted) {
//     this.toogleMuteAudio(false);
//   }

//   if (!this.videoMuted) {
//     this.toogleMuteVideo(false);
//   }

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'hold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'unhold' action, add this one to the queue
//      * Else, if there is already an 'unhold' action, skip
//      */
//     if (this.pending_actions.isPending('hold')) {
//       this.pending_actions.pop('hold');
//       return;
//     } else if (!this.pending_actions.isPending('unhold')) {
//       this.pending_actions.push('unhold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === false) {
//       return;
//     }
//   }

//   this.onunhold('local');

//   this.sendReinvite();
// };


/**
 * Session Timers
 */


/**
 * RFC3261 13.3.1.4
 * Response retransmissions cannot be accomplished by transaction layer
 *  since it is destroyed when receiving the first 2xx answer
 */
RTCSession.prototype.setInvite2xxTimer = function(request, body) {
  var
    self = this,
    timeout = Timers.T1;

  this.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
    if (self.status !== C.STATUS_WAITING_FOR_ACK) {
      return;
    }

    request.reply(200, null, ['Contact: ' + self.contact], body);

    if (timeout < Timers.T2) {
      timeout = timeout * 2;
      if (timeout > Timers.T2) {
        timeout = Timers.T2;
      }
    }
    self.timers.invite2xxTimer = setTimeout(
      invite2xxRetransmission, timeout
    );
  }, timeout);
};


/**
 * RFC3261 14.2
 * If a UAS generates a 2xx response and never receives an ACK,
 *  it SHOULD generate a BYE to terminate the dialog.
 */
RTCSession.prototype.setACKTimer = function() {
  var self = this;

  this.timers.ackTimer = setTimeout(function() {
    if (self.status === C.STATUS_WAITING_FOR_ACK) {
      self.logger.debug('no ACK received, terminating the call');
      clearTimeout(self.timers.invite2xxTimer);
      self.sendBye();
      // self.sendRequest(ExSIP_C.BYE);
      self.ended('remote', null, ExSIP_C.causes.NO_ACK);
    }
  }, Timers.TIMER_H);
};


/**
 * RTCPeerconnection handlers
 */
// Modified to support Firefox 22
RTCSession.prototype.getLocalStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.localStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.localStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getLocalStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.getRemoteStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.remoteStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.remoteStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getRemoteStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.initRtcMediaHandler = function(options) {
  options = options || {};
  var constraints = options.RTCConstraints || this.ua.rtcConstraints() || {
    "optional": [{
      'DtlsSrtpKeyAgreement': 'true'
    }]
  };
  this.rtcMediaHandler = new RTCSession_RTCMediaHandler(this, {
    constraints: constraints,
    stun_servers: options.stun_servers,
    turn_servers: options.turn_servers
  });
};
/**
 * Session Management
 */

RTCSession.prototype.init_incoming = function(request) {
  var expires,
    self = this,
    contentType = request.getHeader('Content-Type'),

    waitForAnswer = function() {
      self.setStatus(C.STATUS_WAITING_FOR_ANSWER);

      // Set userNoAnswerTimer
      self.timers.userNoAnswerTimer = setTimeout(function() {
        request.reply(408);
        self.failed('local', null, ExSIP_C.causes.NO_ANSWER);
      }, self.ua.configuration.no_answer_timeout);

      /* Set expiresTimer
       * RFC3261 13.3.1
       */
      if (expires) {
        self.timers.expiresTimer = setTimeout(function() {
          if (self.status === C.STATUS_WAITING_FOR_ANSWER) {
            request.reply(487);
            self.failed('system', null, ExSIP_C.causes.EXPIRES);
          }
        }, expires);
      }

      // Fire 'newRTCSession' event.
      self.newRTCSession('remote', request);

      // Reply 180.
      request.reply(180, null, ['Contact: ' + self.contact]);

      // Fire 'progress' event.
      // TODO: Document that 'response' field in 'progress' event is null for
      // incoming calls.
      self.progress('local', null);
    };

  // Check body and content type
  if (request.body && (contentType !== 'application/sdp')) {
    request.reply(415);
    return;
  }

  // Session parameter initialization
  this.setStatus(C.STATUS_INVITE_RECEIVED);
  this.from_tag = request.from_tag;
  this.id = request.call_id + this.from_tag;
  this.request = request;
  this.contact = this.ua.contact.toString();

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  //Get the Expires header value if exists
  if (request.hasHeader('expires')) {
    expires = request.getHeader('expires') * 1000;
  }

  /* Set the to_tag before
   * replying a response code that will create a dialog.
   */
  request.to_tag = Utils.newTag();

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS', true)) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  //Initialize Media Session
  this.initRtcMediaHandler();

  if (request.body) {
    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid. Fire UA newRTCSession
       */
      waitForAnswer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.warn('invalid SDP');
        self.logger.warn(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    waitForAnswer();
  }
};

RTCSession.prototype.connect = function(target, options) {
  var self = this;
  options = options || {};

  this.data = options.data || {};

  this.initRtcMediaHandler(options);

  this.connectLocalMedia(target, options, function() {
    self.sendInviteRequest(target, options);
  }, function() {

  });
};

RTCSession.prototype.close = function() {
  var idx;

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  this.logger.debug('closing INVITE session ' + this.id);

  // 1st Step. Terminate media.
  if (this.rtcMediaHandler) {
    this.rtcMediaHandler.close();
  }

  // 2nd Step. Terminate signaling.

  // Clear session timers
  for (idx in this.timers) {
    clearTimeout(this.timers[idx]);
  }

  // Terminate dialogs

  // Terminate confirmed dialog
  if (this.dialog) {
    this.dialog.terminate();
    delete this.dialog;
  }

  // Terminate early dialogs
  for (idx in this.earlyDialogs) {
    this.earlyDialogs[idx].terminate();
    delete this.earlyDialogs[idx];
  }

  this.setStatus(C.STATUS_TERMINATED);

  delete this.ua.sessions[this.id];
};

/**
 * Dialog Management
 * @private
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.id) {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
      // Dialog not created due to an error.
      else {
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.id) {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
    // Dialog not created due to an error
    else {
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    }
  }
};

RTCSession.prototype.connectRtcMediaHandler = function(stream, creationSucceeded, creationFailed, options) {
  this.rtcMediaHandler.connect(stream, creationSucceeded, creationFailed, options);
  this.dtmf.enableDtmfSender(stream, this.rtcMediaHandler.peerConnection);
};

RTCSession.prototype.sendData = function(data) {
  this.rtcMediaHandler.sendData(data);
};

/**
 * Get User Media
 * @private
 */
RTCSession.prototype.getUserMedia = function(constraints, creationSucceeded, creationFailed, options) {
  var self = this;

  var userMediaSucceeded = function(stream) {
    self.ua.localMedia = stream;
    self.connectRtcMediaHandler(stream, creationSucceeded, creationFailed, options);
    //      self.reconnectRtcMediaHandler(creationSucceeded, creationFailed, {localMedia: stream});
  };

  var userMediaFailed = function() {
    if (self.status === C.STATUS_TERMINATED) {
      return;
    }
    self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  };


  if (this.ua.reuseLocalMedia() && this.ua.localMedia) {
    this.rtcMediaHandler.localMedia = this.ua.localMedia;
    userMediaSucceeded(this.ua.localMedia);
  } else {
    this.rtcMediaHandler.getUserMedia(
      userMediaSucceeded,
      userMediaFailed,
      constraints
    );
  }
};

RTCSession.prototype.sendInviteRequest = function(target, options, inviteSuccessCallback, inviteFailureCallback) {
  options = options || {};
  options.status = C.STATUS_INVITE_SENT;
  options.sdp = this.rtcMediaHandler.peerConnection.localDescription.sdp;
  options.target = target;
  this.sendRequest(ExSIP_C.INVITE, options, {
    success: inviteSuccessCallback,
    failure: inviteFailureCallback
  });
};
/**
 * Initial Request Sender
 * @private
 */
RTCSession.prototype.createOutgoingRequestSender = function(target, method, options) {
  options = options || {};

  var event, requestParams, iceServers,
    originalTarget = target,
    eventHandlers = options.eventHandlers || {},
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    stun_servers = options.stun_servers || null,
    turn_servers = options.turn_servers || null;


  if (stun_servers) {
    iceServers = UA.configuration_check.optional.stun_servers(stun_servers);
    if (!iceServers) {
      throw new TypeError('Invalid stun_servers: ' + stun_servers);
    } else {
      stun_servers = iceServers;
    }
  }

  if (turn_servers) {
    iceServers = UA.configuration_check.optional.turn_servers(turn_servers);
    if (!iceServers) {
      throw new TypeError('Invalid turn_servers: ' + turn_servers);
    } else {
      turn_servers = iceServers;
    }
  }

  if (target === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check WebRTC support
  if (!WebRTC.isSupported) {
    throw new Exceptions.NotSupportedError('WebRTC not supported');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: ' + originalTarget);
  }

  // Check Session Status
  if (this.status !== C.STATUS_NULL) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  // Session parameter initialization
  this.from_tag = Utils.newTag();

  // Set anonymous property
  this.anonymous = options.anonymous || false;

  // OutgoingSession specific parameters
  this.isCanceled = false;

  requestParams = {
    from_tag: this.from_tag
  };

  this.contact = this.ua.contact.toString({
    anonymous: this.anonymous,
    outbound: true
  });

  if (this.anonymous) {
    requestParams.from_display_name = 'Anonymous';
    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';

    extraHeaders.push('P-Preferred-Identity: ' + this.ua.configuration.uri.toString());
    extraHeaders.push('Privacy: id');
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Allow: ' + Utils.getAllowedMethods(this.ua));

  this.request = new SIPMessage.OutgoingRequest(method, target, this.ua, requestParams, extraHeaders);

  this.id = this.request.call_id + this.from_tag;

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  this.newRTCSession('local', this.request);

  return new RequestSender(this, this.ua);

};

RTCSession.prototype.sendReferRequest = function(sessionToTransfer, options) {
  this.sessionToTransfer = sessionToTransfer;
  options = options || {};
  options.status = C.STATUS_REFER_SENT;
  options.target = sessionToTransfer.dialog.remote_target;
  this.sendRequest(ExSIP_C.REFER, options);
};

RTCSession.prototype.sendNotifyRequest = function(options, successCallback, failureCallback) {
  options = options || {};
  var extraHeaders = ['Content-Type: message/sipfrag',
    'Subscription-State: ' + (options.subscriptionState || "active;expires=60"),
    'Event: refer'
  ];
  options = Utils.merge_options({
    extraHeaders: extraHeaders
  }, options);
  this.sendRequest(ExSIP_C.NOTIFY, options, {
    success: successCallback,
    failure: failureCallback
  });
};

RTCSession.prototype.isStarted = function() {
  return this.start_time !== null;
};

RTCSession.prototype.isHeld = function() {
  return this.isOnHold;
};

RTCSession.prototype.iceConnected = function(originator, message) {
  var session = this,
    event_name = 'iceconnected';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.iceCompleted = function(originator, message) {
  var session = this,
    event_name = 'icecompleted';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.iceClosed = function(originator, message) {
  var session = this,
    event_name = 'iceclosed';

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.held = function() {
  this.isOnHold = true;
  this.emit('held', this);
};

RTCSession.prototype.resumed = function() {
  this.isOnHold = false;
  this.emit('resumed', this);
};

RTCSession.prototype.hold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({
      audioMode: ExSIP_C.INACTIVE,
      audioPort: "0",
      videoMode: ExSIP_C.INACTIVE,
      videoPort: "0"
    }, function() {
      self.held();
      if (inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.unhold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({
      audioMode: ExSIP_C.SENDRECV,
      videoMode: ExSIP_C.SENDRECV
    }, function() {
      self.resumed();
      if (inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.changeSession = function(sdpOptions, inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.logger.debug('changeSession : ' + JSON.stringify(sdpOptions));
  this.reconnectRtcMediaHandler(function() {
    self.logger.debug('changeSession : reconnectRtcMediaHandler : success');
    self.receiveResponse = self.receiveReinviteResponse;
    self.reinviteSucceeded = inviteSuccessCallback;
    self.reinviteFailed = inviteFailureCallback;
    self.sendInviteRequest(undefined, undefined);
  }, function() {
    self.logger.error("Could not change local mode");
  }, sdpOptions);
};

/**
 * Reception of Response for Initial INVITE
 */
RTCSession.prototype.receiveInviteResponse = function(response) {
  var cause, dialog,
    session = this;

  // Handle 2XX retransmissions and responses from forked requests
  if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {

    /*
     * If it is a retransmission from the endpoint that established
     * the dialog, send an ACK
     */
    if (this.dialog.id.call_id === response.call_id &&
      this.dialog.id.local_tag === response.from_tag &&
      this.dialog.id.remote_tag === response.to_tag) {
      this.sendRequest(ExSIP_C.ACK);
      return;
    }

    // If not, send an ACK  and terminate
    else {
      dialog = new Dialog(this, response, 'UAC');

      if (dialog.error !== undefined) {
        this.logger.error(dialog.error);
        return;
      }

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.ACK);

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.BYE);
      return;
    }

  }

  // Proceed to cancellation if the user requested.
  if (this.isCanceled) {
    // Remove the flag. We are done.
    this.isCanceled = false;

    if (response.status_code >= 100 && response.status_code < 200) {
      this.request.cancel(this.cancelReason);
    } else if (response.status_code >= 200 && response.status_code < 299) {
      this.acceptAndTerminate(response);
    }
    return;
  }

  if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
    return;
  }

  switch (true) {
    case /^100$/.test(response.status_code):
      this.received_100 = true;
      break;
    case /^1[0-9]{2}$/.test(response.status_code):
      this.received_100 = true;
      if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
        break;
      }

      // Do nothing with 1xx responses without To tag.
      if (!response.to_tag) {
        this.logger.warn('1xx response received without to tag');
        break;
      }

      // Create Early Dialog if 1XX comes with contact
      if (response.hasHeader('contact')) {
        // An error on dialog creation will fire 'failed' event
        if (!this.createDialog(response, 'UAC', true)) {
          break;
        }
      }

      this.setStatus(C.STATUS_1XX_RECEIVED);
      this.progress('remote', response);

      if (!response.body) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'pranswer',
        response.body,
        /*
         * OnSuccess.
         * SDP Answer fits with Offer.
         */
        function() {},
        /*
         * OnFailure.
         * SDP Answer does not fit with Offer.
         */
        function(e) {
          session.logger.warn(e);
          session.earlyDialogs[response.call_id + response.from_tag + response.to_tag].terminate();
        }
      );
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      this.setStatus(C.STATUS_CONFIRMED);

      if (!response.body) {
        this.acceptAndTerminate(response, 400, ExSIP_C.causes.MISSING_SDP);
        this.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        break;
      }

      // An error on dialog creation will fire 'failed' event
      if (!this.createDialog(response, 'UAC')) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'answer',
        response.body,
        /*
         * onSuccess
         * SDP Answer fits with Offer. Media will start
         */
        function() {
          session.accepted('remote', response);
          session.started('remote', response);
          session.sendRequest(ExSIP_C.ACK);
          session.confirmed('local', null);
        },
        /*
         * onFailure
         * SDP Answer does not fit the Offer. Accept the call and Terminate.
         */
        function(e) {
          session.logger.warn(e);
          session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
          session.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        }
      );
      break;
    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.failed('remote', response, cause);
  }
};

/**
 * Dialog Management
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.error) {
        this.logger.error(dialog.error);
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      } else {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.error) {
      this.logger.error(dialog.error);
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    } else {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
  }
};

/**
 * In dialog INVITE Reception
 */

RTCSession.prototype.receiveReinvite = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = false,

    createSdp = function(onSuccess, onFailure) {
      if (self.late_sdp) {
        self.rtcMediaHandler.createOffer(onSuccess, onFailure);
      } else {
        self.rtcMediaHandler.createAnswer(onSuccess, onFailure);
      }
    },

    answer = function() {
      createSdp(
        // onSuccess
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              self.setStatus(C.STATUS_WAITING_FOR_ACK);
              self.setInvite2xxTimer(request, body);
              self.setACKTimer();

              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        // onFailure
        function() {
          request.reply(500);
        }
      );
    };


  if (request.body) {
    if (contentType !== 'application/sdp') {
      this.logger.warn('invalid Content-Type');
      request.reply(415);
      return;
    }

    sdp = Parser.parseSDP(request.body);

    for (idx = 0; idx < sdp.media.length; idx++) {
      direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

      if (direction === 'sendonly' || direction === 'inactive') {
        hold = true;
      }
    }

    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid
       */
      answer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.error(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    answer();
  }
};

/**
 * In dialog UPDATE Reception
 */

RTCSession.prototype.receiveUpdate = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = true;

  if (!request.body) {
    request.reply(200);
    return;
  }

  if (contentType !== 'application/sdp') {
    this.logger.warn('invalid Content-Type');
    request.reply(415);
    return;
  }

  sdp = Parser.parseSDP(request.body);

  for (idx = 0; idx < sdp.media.length; idx++) {
    direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

    if (direction !== 'sendonly' && direction !== 'inactive') {
      hold = false;
    }
  }

  this.rtcMediaHandler.onMessage(
    'offer',
    request.body,
    /*
     * onSuccess
     * SDP Offer is valid
     */
    function() {
      self.rtcMediaHandler.createAnswer(
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        function() {
          request.reply(500);
        }
      );
    },
    /*
     * onFailure
     * Bad media description
     */
    function(e) {
      self.logger.error(e);
      request.reply(488);
    }
  );
};

/**
 * In dialog Request Reception
 */
RTCSession.prototype.receiveRequest = function(request) {
  var contentType,
    self = this;

  if (request.method === ExSIP_C.CANCEL) {
    /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
     * was in progress and that the UAC MAY continue with the session established by
     * any 2xx response, or MAY terminate with BYE. ExSIP does continue with the
     * established session. So the CANCEL is processed only if the session is not yet
     * established.
     */

    /*
     * Terminate the whole session in case the user didn't accept (or yet send the answer)
     * nor reject the request opening the session.
     */
    if (this.status === C.STATUS_WAITING_FOR_ANSWER || this.status === C.STATUS_ANSWERED) {
      this.setStatus(C.STATUS_CANCELED);
      this.request.reply(487);
      this.failed('remote', request, ExSIP_C.causes.CANCELED);
    }
  } else {
    // Requests arriving here are in-dialog requests.
    switch (request.method) {
      case ExSIP_C.ACK:
        if (this.status === C.STATUS_WAITING_FOR_ACK) {
          clearTimeout(this.timers.ackTimer);
          clearTimeout(this.timers.invite2xxTimer);
          this.setStatus(C.STATUS_CONFIRMED);
          if (request.body.length > 0) {
            this.logger.log('set remoteDescription for late offer ACK');
            this.rtcMediaHandler.onMessage(self.rtcMediaHandler.getSetRemoteLocationType(), request.body, function() {
              self.logger.log('late offer remoteDescription success');
              self.started('local', undefined, true);
            }, function() {
              self.logger.log('late offer remoteDescription failure');
            });
          }
        }
        break;
      case ExSIP_C.BYE:
        if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_REFER_SENT) {
          request.reply(200);
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else if (this.status === C.STATUS_INVITE_RECEIVED) {
          request.reply(200);
          this.request.reply(487, 'BYE Received');
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INVITE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('re-INVITE received');
          this.request = request;
          // accept empty reinvites
          if (!request.body || request.body.length === 0) {
            this.acceptReInvite();
            return;
          }

          var description = new WebRTC.RTCSessionDescription({
            type: "offer",
            sdp: request.body
          });
          var oldDescription = this.rtcMediaHandler.peerConnection.remoteDescription;
          var audioAdd = description.hasActiveAudio() && (!oldDescription || !oldDescription.hasActiveAudio());
          var videoAdd = description.hasActiveVideo() && (!oldDescription || !oldDescription.hasActiveVideo());
          if (audioAdd || videoAdd) {
            this.ua.emit("onReInvite", this.ua, {
              session: this,
              request: request,
              audioAdd: audioAdd,
              videoAdd: videoAdd
            });
          } else {
            this.acceptReInvite();
          }
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INFO:
        if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_INVITE_RECEIVED || this.status === C.STATUS_ANSWERED) {
          contentType = request.getHeader('content-type');
          if (contentType && (contentType.match(/^application\/dtmf-relay/i))) {
            new RTCSession_DTMF(this).init_incoming(request);
          } else if (contentType && (contentType.match(/^application\/media_control\+xml/i))) {
            request.reply(200);
            this.started('local', undefined, true);
          } else {
            request.reply(415);
          }
        } else {
          this.logger.debug('Wrong Status : ' + this.status);
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.UPDATE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('UPDATE received');
          this.receiveUpdate(request);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.REFER:
        if (this.status === C.STATUS_CONFIRMED) {
          this.ua.processRefer(this, request);
        }
        break;
      case ExSIP_C.NOTIFY:
        if (this.status === C.STATUS_REFER_SENT) {
          request.reply(200);
          this.logger.log('received NOTIFY with body : ' + request.body);
          var status = parseInt(request.body.match(/SIP\/2.0\s(.*)\s/)[1], 10);
          this.logger.log('NOTIFY status : ' + status);

          if (!this.sessionToTransfer) {
            this.logger.warn('no transferred session for REFER session : ' + this.id);
            return;
          }

          if (status >= 200 && status <= 299) {
            this.logger.log('terminate transferred session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.terminate();
          } else if (status >= 400 && status <= 699) {
            this.logger.warn('resuming session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.unhold(function() {
              self.logger.log('resumed session : ' + self.sessionToTransfer.id);
            });
          }
        }
        break;
      default:
        request.reply(501);
    }
  }
};


RTCSession.prototype.setStatus = function(status) {
  if (this.logger) {
    this.logger.debug('setStatus : ' + Object.keys(C)[status]);
  }
  this.status = status;
};

RTCSession.prototype.supports = function(name) {
  var supported = this.request.getHeader("Supported");
  return supported !== undefined && supported.indexOf(name) !== -1;
};

/**
 * @private
 */
RTCSession.prototype.sendACK = function() {
  this.sendRequest(ExSIP_C.ACK);
};

/**
 * @private
 */
RTCSession.prototype.sendBye = function(options) {
  var self = this;
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];

  var reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '',
    body = options.body;

  if (status_code && (status_code < 200 || status_code >= 700)) {
    throw new TypeError('Invalid status_code: ' + status_code);
  } else if (status_code) {
    reason = 'SIP ;cause=' + status_code + '; text="' + reason_phrase + '"';
    options.extraHeaders.push('Reason: ' + reason);
  }

  options.sdp = body;
  options.status = C.STATUS_BYE_SENT;
  var callbacks = {
    success: function() {
      self.sendACK();
      self.ended('local', null, ExSIP_C.causes.BYE);
    }
  };
  this.logger.log('sendBye : ' + callbacks);
  this.sendRequest(ExSIP_C.BYE, options, callbacks);
};


/**
 * @private
 */
RTCSession.prototype.sendRequest = function(method, options, requestCallbacks) {
  var request_sender;
  options = options || {};
  if (this.dialog) {
    this.logger.debug('sendRequest : dialog : ' + method);
    request_sender = this.dialog.createRequestSender(this, method, options);
  } else {
    this.logger.debug('sendRequest : createOutgoingRequestSender : ' + method + ', ' + JSON.stringify(options));
    request_sender = this.createOutgoingRequestSender(options.target, method, options);
  }

  if (!request_sender) {
    return;
  }

  if (options.status) {
    this.setStatus(options.status);
  }
  request_sender.request.body = options.sdp;

  var hasSdp = request_sender.request.body && request_sender.request.body.length > 0;
  if (!Utils.containsHeader(request_sender.request.extraHeaders, "Content-Type") && hasSdp) {
    request_sender.request.extraHeaders.push('Content-Type: application/sdp');
  }
  this.logger.debug('request_sender.request.extraHeaders : ' + Utils.toString(request_sender.request.extraHeaders));

  request_sender.send(requestCallbacks);
};

/**
 * Session 1009s
 */

/**
 * Callback to be called from UA instance when TransportError occurs
 * @private
 */
RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Initial Request Sender
 */
RTCSession.prototype.connectLocalMedia = function(target, options, success, failure) {
  var
    self = this;

  // // User media succeeded
  // userMediaSucceeded = function(stream) {
  //   self.rtcMediaHandler.addStream(
  //     stream,
  //     streamAdditionSucceeded,
  //     streamAdditionFailed
  //   );
  // },

  // // User media failed
  // userMediaFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  // },

  // // rtcMediaHandler.addStream successfully added
  // streamAdditionSucceeded = function() {
  //   self.connecting(self.request);

  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.rtcMediaHandler.createOffer(
  //     offerCreationSucceeded,
  //     offerCreationFailed,
  //     RTCOfferConstraints
  //   );
  // },

  // // rtcMediaHandler.addStream failed
  // streamAdditionFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // },

  // // rtcMediaHandler.createOffer succeeded
  // offerCreationSucceeded = function(offer) {
  //   if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.request.body = offer;
  //   self.status = C.STATUS_INVITE_SENT;
  //   request_sender.send();
  // },

  // // rtcMediaHandler.createOffer failed
  // offerCreationFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // };

  this.receiveResponse = this.receiveInviteResponse;
  var mediaConstraints = options.mediaConstraints || {
    audio: true,
    video: true
  };

  this.getUserMedia(mediaConstraints, function() {
    self.logger.log('getUserMedia succeeded');
    success();
  }, function() {
    self.logger.log('getUserMedia failed');
    self.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    failure();
  }, options);

  // if (mediaStream) {
  //   userMediaSucceeded(mediaStream);
  // } else {
  //   this.getUserMedia(
  //     mediaConstraints,
  //     userMediaSucceeded,
  //     userMediaFailed
  //   );
  // }
};

/**
 * Send Re-INVITE
 */
RTCSession.prototype.sendReinvite = function(options) {
  options = options || {};

  var
    self = this,
    extraHeaders = options.extraHeaders || [],
    eventHandlers = options.eventHandlers || {},
    mangle = options.mangle || null;

  if (eventHandlers.succeeded) {
    this.reinviteSucceeded = eventHandlers.succeeded;
  } else {
    this.reinviteSucceeded = function() {};
  }
  if (eventHandlers.failed) {
    this.reinviteFailed = eventHandlers.failed;
  } else {
    this.reinviteFailed = function() {};
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Content-Type: application/sdp');

  this.receiveResponse = this.receiveReinviteResponse;

  this.rtcMediaHandler.createOffer(
    function(body) {
      if (mangle) {
        body = mangle(body);
      }

      self.dialog.sendRequest(self, ExSIP_C.INVITE, {
        extraHeaders: extraHeaders,
        body: body
      });
    },
    function() {
      if (self.isReadyToReinvite()) {
        self.onReadyToReinvite();
      }
      self.reinviteFailed();
    }
  );
};


/**
 * Reception of Response for in-dialog INVITE
 */
RTCSession.prototype.receiveReinviteResponse = function(response) {
  var
    self = this,
    contentType = response.getHeader('Content-Type');

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  switch (true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      if(this.status !== C.STATUS_CONFIRMED) {
        this.setStatus(C.STATUS_CONFIRMED);
        this.sendRequest(ExSIP_C.ACK);

        if (!response.body) {
          this.reinviteFailed();
          break;
        } else if (contentType !== 'application/sdp') {
          this.reinviteFailed();
          break;
        }

        this.rtcMediaHandler.onMessage(
          'answer',
          response.body,
          /*
           * onSuccess
           * SDP Answer fits with Offer.
           */
          function() {
            if (self.reinviteSucceeded) {
              self.reinviteSucceeded();
            }
          },
          /*
           * onFailure
           * SDP Answer does not fit the Offer.
           */
          function() {
            if (self.reinviteFailed) {
              self.reinviteFailed();
            }
          }
        );

      }
      break;
    default:
      if (this.reinviteFailed) {
        this.reinviteFailed();
      }
  }
};



RTCSession.prototype.acceptAndTerminate = function(response, status_code, reason_phrase) {
  var extraHeaders = [];

  if (status_code) {
    reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
    extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
  }

  // An error on dialog creation will fire 'failed' event
  if (this.dialog || this.createDialog(response, 'UAC')) {
    this.sendRequest(ExSIP_C.ACK);
    this.sendBye();
    // this.sendRequest(ExSIP_C.BYE, {
    //   extraHeaders: extraHeaders
    // });
  }

  // Update session status.
  this.setStatus(C.STATUS_TERMINATED);
};


RTCSession.prototype.toogleMuteAudio = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getAudioTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

RTCSession.prototype.toogleMuteVideo = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getVideoTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

/**
 * Session Callbacks
 */

RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Callback to be called from UA instance when RequestTimeout occurs
 * @private
 */
RTCSession.prototype.onRequestTimeout = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.REQUEST_TIMEOUT);
    } else {
      this.ua.reconnect();
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

RTCSession.prototype.onDialogError = function(response) {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    } else {
      this.failed('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    }
  }
};

/**
 * Internal Callbacks
 */

RTCSession.prototype.newRTCSession = function(originator, request) {
  var session = this,
    event_name = 'newRTCSession';

  if (originator === 'remote') {
    session.direction = 'incoming';
    session.local_identity = request.to;
    session.remote_identity = request.from;
  } else if (originator === 'local') {
    session.direction = 'outgoing';
    session.local_identity = request.from;
    session.remote_identity = request.to;
  }

  session.ua.emit(event_name, session.ua, {
    originator: originator,
    session: session,
    request: request
  });
};

RTCSession.prototype.connecting = function(request) {
  var session = this,
    event_name = 'connecting';

  session.emit(event_name, session, {
    request: request
  });
};

RTCSession.prototype.progress = function(originator, response) {
  var session = this,
    event_name = 'progress';

  session.emit(event_name, session, {
    originator: originator,
    response: response || null
  });
};

RTCSession.prototype.accepted = function(originator, message) {
  var session = this,
    event_name = 'accepted';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.started = function(originator, message, isReconnect) {
  var session = this,
    event_name = 'started';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null,
    isReconnect: isReconnect
  });
};

RTCSession.prototype.confirmed = function(originator, ack) {
  var session = this,
    event_name = 'confirmed';

  this.is_confirmed = true;

  session.emit(event_name, session, {
    originator: originator,
    ack: ack || null
  });
};

RTCSession.prototype.ended = function(originator, message, cause) {
  var session = this,
    event_name = 'ended';

  session.end_time = new Date();

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.failed = function(originator, message, cause) {
  var session = this,
    event_name = 'failed';

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.onhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = true;
  } else {
    this.remote_hold = true;
  }

  this.emit('hold', this, {
    originator: originator
  });
};

RTCSession.prototype.onunhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = false;
  } else {
    this.remote_hold = false;
  }

  this.emit('unhold', this, {
    originator: originator
  });
};

RTCSession.prototype.onmute = function(options) {
  this.emit('muted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onunmute = function(options) {
  this.emit('unmuted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onReadyToReinvite = function() {
  var action = (this.pending_actions.length() > 0) ? this.pending_actions.shift() : null;

  if (!action) {
    return;
  }

  if (action.name === 'hold') {
    this.hold();
  } else if (action.name === 'unhold') {
    this.unhold();
  }
};
},{"./Constants":871,"./Dialog":872,"./EventEmitter":875,"./Exceptions":877,"./Parser":883,"./RTCSession/DTMF":885,"./RTCSession/RTCMediaHandler":887,"./RequestSender":889,"./SIPMessage":890,"./Timers":891,"./UA":894,"./Utils":896,"./WebRTC":897}],885:[function(require,module,exports){
module.exports = DTMF;


var C = {
  MIN_DURATION:            70,
  MAX_DURATION:            6000,
  DEFAULT_DURATION:        100,
  MIN_INTER_TONE_GAP:      50,
  DEFAULT_INTER_TONE_GAP:  500
};

/**
 * Expose C object.
 */
DTMF.C = C;


/**
 * Dependencies.
 */
var EventEmitter = require('../EventEmitter');
var Exceptions = require('../Exceptions');
var RTCSession = require('../RTCSession');
var Utils = require('../Utils');


function DTMF(session) {
  var events = [
  'succeeded',
  'failed'
  ];

  this.sendTimeoutId = null;
  this.queuedDTMFs = [];
  this.session = session;
  this.direction = null;
  this.tone = null;
  this.duration = null;
  this.interToneGap = null;
  this.dtmfSender = null;

  this.logger = this.session.ua.getLogger('rtcsession.dtmf', session.id);

  this.initEvents(events);
}

DTMF.prototype = new EventEmitter();

DTMF.prototype.send = function(tone, options) {
  var event, eventHandlers, extraHeaders;

  if (tone === undefined) {
    throw new TypeError('Not enough arguments');
  }

  this.direction = 'outgoing';

  // Check RTCSession Status
  if (this.session.status !== RTCSession.C.STATUS_CONFIRMED && this.session.status !== RTCSession.C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.session.status);
  }

  // Get DTMF options
  options = options || {};
  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
  eventHandlers = options.eventHandlers || {};

  // Check tone type
  if (typeof tone === 'string' ) {
    tone = tone.toUpperCase();
  } else if (typeof tone === 'number') {
    tone = tone.toString();
  } else {
    throw new TypeError('Invalid tone: '+ tone);
  }

  // Check tone value
  if (!tone.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tone: '+ tone);
  } else {
    this.tone = tone;
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.queueTone(this.tone, options.duration, options.interToneGap);
};

DTMF.prototype.processQueuedDTMFs = function() {
  var self = this;
  if(this.queuedDTMFs.length === 0) {
    return;
  }
  if(!this.dtmfSender.canInsertDTMF) {
    this.logger.log("DTMF Sender cannot insert DTMF - trying again after timeout", this.session.ua);
    this.sendTimeoutId = setTimeout(function(){
      self.processQueuedDTMFs();
    }, 1000);
    return;
  }
  var tones = "";
  var durationSum = 0;
  var interToneGapSum = 0;
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    tones += dtmf.tone;
    durationSum += dtmf.duration;
    interToneGapSum += dtmf.interToneGap;
  }
  var duration = durationSum / this.queuedDTMFs.length;
  var interToneGap = interToneGapSum / this.queuedDTMFs.length;

  this.logger.log("sending DTMF with tones "+tones+", duration "+duration+", gap "+interToneGap);
  this.dtmfSender.insertDTMF(tones, duration, interToneGap);
};

DTMF.prototype.queueTone = function(tone, duration, interToneGap) {
  this.logger.log("Queue tone : "+tone);
  clearTimeout(this.sendTimeoutId);
  this.queuedDTMFs.push({tone: tone, duration: duration, interToneGap: interToneGap});
  var self = this;
  this.sendTimeoutId = setTimeout(function(){
    self.processQueuedDTMFs();
  }, 2 * duration);
};

DTMF.prototype.onDTMFSent = function(tone) {
  if (!tone) {
    return;
  }

  this.logger.log("Sent Dtmf tone: " + tone.tone);
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    if(tone.tone === dtmf.tone) {
      this.queuedDTMFs.splice(i, 1);
      this.logger.log("removing from queued tones - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    } else if(dtmf.tone.indexOf(tone.tone) !== -1) {
      dtmf.tone = dtmf.tone.replace(tone.tone, '');
      this.queuedDTMFs[i] = dtmf;
      this.logger.log("removing from queued tones as contained - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    }
  }
  this.session.emit('newDTMF', this.session, {
    originator: 'local',
    dtmf: this,
    tone: tone.tone
  });
};

DTMF.prototype.enableDtmfSender = function(localstream, peerConnection) {
  var self = this;
  this.logger.debug('enableDtmfSender : '+localstream);
  if (localstream !== null) {
    var local_audio_track = localstream.getAudioTracks()[0];
    this.dtmfSender = peerConnection.createDTMFSender(local_audio_track);
    this.logger.log("Created DTMF Sender with canInsertDTMF : "+this.dtmfSender.canInsertDTMF);

    this.dtmfSender.ontonechange = function(tone) {
      self.onDTMFSent(tone);
    };

    this.processQueuedDTMFs();
  }
  else {
    this.logger.error("No Local Stream to create DTMF Sender");
  }
};

/**
* @private
*/
DTMF.prototype.receiveResponse = function(response) {
  var cause;

  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};

/**
 * @private
 */
DTMF.prototype.onRequestTimeout = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.REQUEST_TIMEOUT
  });
};

/**
 * @private
 */
DTMF.prototype.onTransportError = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.CONNECTION_ERROR
  });
};

/**
 * @private
 */
DTMF.prototype.init_incoming = function(request) {
  var body,
    reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
    reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;

  this.direction = 'incoming';
  this.request = request;

  request.reply(200);

  if (request.body) {
    body = request.body.split('\r\n');
    if (body.length === 2) {
      if (reg_tone.test(body[0])) {
        this.tone = body[0].replace(reg_tone,"$2");
      }
      if (reg_duration.test(body[1])) {
        this.duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
      }
    }
  }

  if (!this.tone || !this.duration) {
    this.logger.warn('invalid INFO DTMF received, discarded');
  } else {
    this.session.emit('newDTMF', this.session, {
      originator: 'remote',
      dtmf: this,
      request: request
    });
  }
};
},{"../EventEmitter":875,"../Exceptions":877,"../RTCSession":884,"../Utils":896}],886:[function(require,module,exports){
module.exports = DataChannel;

var EventEmitter = require('../EventEmitter');
/**
 * Dependencies.
 */
function DataChannel(session, peerConnection) {

  this.session = session;
  this.peerConnection = peerConnection;
  this.sendChannel = null;
  this.receiveChannel = null;
  this.chunkLength = 60000;
  this.dataReceived = [];

  this.logger = session.ua.getLogger('ExSIP.rtcsession.datachannel', session.id);

  this.initSendChannel();
}

DataChannel.prototype = new EventEmitter();

DataChannel.prototype.isDebug = function() {
  return this.session.ua.isDebug();
};

DataChannel.prototype.close = function() {
  if(this.sendChannel) {
    this.sendChannel.close();
  }
  if(this.receiveChannel) {
    this.receiveChannel.close();
  }
};

DataChannel.prototype.send = function(data) {
  this.sendInChunks(data);
  this.logger.log('Sent Data: ' + data, this.session.ua);
  this.session.emit('dataSent', this, { data: data });
};

DataChannel.prototype.sendInChunks = function(data) {
  var text = null, last = false, self = this;
  if (data.length > this.chunkLength) {
    text = data.slice(0, this.chunkLength); // getting chunk using predefined chunk length
  } else {
    text = data;
    last = true;
  }

  this.sendChannel.send(text + (last ? "\n" : "")); // use JSON.stringify for chrome!

  if (!last) {
    var remainingDataURL = data.slice(text.length);
    window.setTimeout(function () {
      self.sendInChunks(remainingDataURL); // continue transmitting
    }, 50);
  }
};

DataChannel.prototype.initSendChannel = function() {
  var self = this;
  try {
    // Data Channel api supported from Chrome M25.
    // You might need to start chrome with  --enable-data-channels flag.
    this.sendChannel = this.peerConnection.createDataChannel("sendDataChannel", null);
    this.logger.log('Created send data channel', this.session.ua);

    var onSendChannelStateChange = function() {
      var readyState = self.sendChannel.readyState;
      self.logger.log('Send channel state is: ' + readyState, self.session.ua);
    };

    this.sendChannel.onopen = onSendChannelStateChange;
    this.sendChannel.onclose = onSendChannelStateChange;

    var receiveChannelCallback = function(event) {
      self.logger.log('Receive Channel Callback', self.session.ua);
      self.receiveChannel = event.channel;

      var onReceiveChannelStateChange = function() {
        var readyState = self.receiveChannel.readyState;
        self.logger.log('Receive channel state is: ' + readyState, self.session.ua);
      };

      var onReceiveMessageCallback = function(event) {
        self.logger.log('Received Message : '+event.data, self.session.ua);

        if(event.data.indexOf('\n') !== -1) {
          self.dataReceived.push(event.data.replace('\n', ''));
          var data = self.dataReceived.join('');
          self.dataReceived = [];
          self.session.emit('dataReceived', self, { data: data });
        } else {
          self.dataReceived.push(event.data);
        }
      };

      self.receiveChannel.onmessage = onReceiveMessageCallback;
      self.receiveChannel.onopen = onReceiveChannelStateChange;
      self.receiveChannel.onclose = onReceiveChannelStateChange;
    };

    this.peerConnection.ondatachannel = receiveChannelCallback;
  } catch (e) {
    this.emit('failed', this, {
      cause: 'Failed to create data channel'
    });
    self.logger.error('Create Data channel failed with exception: ' + e.message);
  }
};
},{"../EventEmitter":875}],887:[function(require,module,exports){
module.exports = RTCMediaHandler;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var WebRTC = require('../WebRTC');
var Utils = require('../Utils');
var DataChannel = require('./DataChannel');


/* RTCMediaHandler
 * -class PeerConnection helper Class.
 * -param {RTCSession} session
 * -param {Object} [contraints]
 */
function RTCMediaHandler(session, constraints) {
  constraints = constraints || {};
  this.logger = session.ua.getLogger('ExSIP.rtcsession.rtcmediahandler', session.id);

  this.logger.log('constraints : '+Utils.toString(constraints), session.ua);
  this.session = session;
  this.localMedia = null;
  this.peerConnection = null;
  this.createOfferConstraints = null;
  this.dataChannel = null;
  this.ready = true;

  this.init(constraints);
}


RTCMediaHandler.prototype = {
  isReady: function() {
    return this.ready;
  },

  copy: function(rtcMediaHandler) {
    var self = this;

    var streamAdditionSucceeded = function() {
    };
    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

    var description = new WebRTC.RTCSessionDescription({type: this.getSetLocalDescriptionType(), sdp: rtcMediaHandler.peerConnection.localDescription.sdp});
    this.setLocalDescription(description);

    this.addStream(rtcMediaHandler.localMedia, streamAdditionSucceeded, streamAdditionFailed);
  },

  connect: function(stream, connectSucceeded, connectFailed, options) {
    var self = this;
    options = options || {};
    this.logger.log('connect with isAnswer : '+options.isAnswer+" and remoteSdp : "+options.remoteSdp, self.session.ua);

    var setLocalDescription = function(callback) {
      self.setLocalDescription(options.localDescription, callback || connectSucceeded, connectFailed);
    };

    var setRemoteDescription = function(successCallback) {
      self.onMessage(
        self.getSetRemoteLocationType(),
        options.remoteSdp,
        successCallback || connectSucceeded, function(e){
          self.logger.error("setRemoteDescription failed");
          self.logger.error(Utils.toString(e));
          connectFailed();
        }
      );
    };

    var createAnswer = function(){
      self.createAnswer(connectSucceeded, connectFailed, options.mediaConstraints);
    };

    var createOffer = function(){
      self.createOffer(function(sdp){
        if(options.remoteSdp && options.remoteSdp !== "") {
          setRemoteDescription(connectSucceeded);
        } else {
          connectSucceeded(sdp);
        }
      }, connectFailed, options.createOfferConstraints, options);
    };

    var streamAdditionSucceeded = function() {
      var hasRemoteSdp = options.remoteSdp && options.remoteSdp.length > 0;
      var isRemote = options.isAnswer && hasRemoteSdp;
      self.logger.log("isRemote : "+isRemote+", isAnswer : "+options.isAnswer+", hasRemoteSdp :"+hasRemoteSdp, self.session.ua);
      if(isRemote) {
        if(options.localDescription) {
          setRemoteDescription(setLocalDescription);
        } else {
          setRemoteDescription(createAnswer);
        }
      } else {
        if(options.remoteSdp) {
          setLocalDescription(setRemoteDescription);
        } else {
          createOffer();
        }
      }
    };

    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
      connectFailed();
    };

    this.addStream(
      stream,
      streamAdditionSucceeded,
      streamAdditionFailed
    );
  },

  createOffer: function(onSuccess, onFailure, constraints, options) {
    var self = this;
    options = options || {};

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed') ||
          !self.peerConnection.localDescription.isActive()) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    this.createOfferConstraints = constraints;
    this.logger.log("createOffer with createOfferConstraints : "+Utils.toString(this.createOfferConstraints), this.session.ua);
    this.peerConnection.createOffer(
      function(sessionDescription){
        if(options.videoMode) {
          sessionDescription.setVideoMode(options.videoMode);
        }
        if(options.videoPort) {
          sessionDescription.setVideoPort(options.videoPort);
        }
        if(options.audioMode) {
          sessionDescription.setAudioMode(options.audioMode);
        }
        if(options.audioPort) {
          sessionDescription.setAudioPort(options.audioPort);
        }
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create offer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  getRemoteDescriptionSdp: function() {
    return this.peerConnection.remoteDescription ? this.peerConnection.remoteDescription.sdp : undefined;
  },

  createAnswer: function(onSuccess, onFailure, constraints) {
    var self = this;

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed') ||
          !self.peerConnection.localDescription.isActive()) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    constraints = constraints ||  this.createOfferConstraints;
    this.logger.log("createAnswer with constraints : "+constraints, this.session.ua);
    this.peerConnection.createAnswer(
      function(sessionDescription){
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create answer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  setLocalDescription: function(sessionDescription, onSuccess, onFailure) {
    var self = this;

    this.logger.log('peerConnection.setLocalDescription : '+Utils.toString(sessionDescription));
    this.peerConnection.setLocalDescription(
      sessionDescription,
      onSuccess,
      function(e) {
        self.logger.error('unable to set local description');
        self.logger.error(e);
        onFailure(e);
      }
    );
  },

  addStream: function(stream, onSuccess, onFailure, constraints) {
    try {
      this.logger.log("add stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.addStream(stream, constraints);
    } catch(e) {
      this.logger.error('error adding stream');
      this.logger.error(e);
      onFailure();
      return;
    }

    onSuccess();
  },

  clearStreams: function() {
    if(!this.localMedia) {
      return;
    }
    if(this.removeStream(this.localMedia)) {
      this.localMedia = null;
    }
    return;
  },

  removeStream: function(stream) {
    try {
      this.logger.log("remove stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.removeStream(stream);
    } catch(e) {
      this.logger.error('error removing stream');
      this.logger.error(e);
      return false;
    }

    return true;
  },

  getSetLocalDescriptionType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-local-offer') {
      return "offer";
    } else if(state === 'have-remote-offer' || state === 'have-local-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  getSetRemoteLocationType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-remote-offer') {
      return "offer";
    } else if(state === 'have-local-offer' || state === 'have-remote-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  sendData: function(data) {
    if(this.dataChannel) {
      this.dataChannel.send(data);
    } else {
      this.logger.error('datachannel is not enabled - see UA.configuration.enable_datachannel');
    }
  },

  /**
  * peerConnection creation.
  */
  init: function(options) {
    options = options || {};

    var idx, length, server,
      self = this,
      servers = [],
      constraints = options.constraints || {},
      stun_servers = options.stun_servers  || null,
      turn_servers = options.turn_servers || null,
      config = this.session.ua.configuration;

    if (!stun_servers) {
      stun_servers = config.stun_servers;
    }

    if (!turn_servers) {
      turn_servers = config.turn_servers;
    }

    /* Change 'url' to 'urls' whenever this issue is solved:
     * https://code.google.com/p/webrtc/issues/detail?id=2096
     */

    if (stun_servers.length > 0) {
      servers.push({'url': stun_servers});
    }

    length = turn_servers.length;
    for (idx = 0; idx < length; idx++) {
      server = turn_servers[idx];
      servers.push({
        'url': server.urls,
        'username': server.username,
        'credential': server.credential
      });
    }

    this.peerConnection = new WebRTC.RTCPeerConnection({'iceServers': servers}, constraints);

    this.peerConnection.onaddstream = function(e) {
      self.logger.debug('pc.onaddstream : '+ e.stream.id);
    };

    this.peerConnection.onpeeridentity = function(e) { 
      self.logger.debug('pc.onpeeridentity : '+Utils.toString(e));
    };

    this.peerConnection.onidpassertionerror = function(e) { 
      self.logger.debug('pc.onidpassertionerror : '+Utils.toString(e));
    };

    this.peerConnection.onidpvalidationerror = function(e) { 
      self.logger.debug('pc.onidpvalidationerror : '+Utils.toString(e));
    };
    
    this.peerConnection.onremovestream = function(e) {
      self.logger.debug('pc.onremovestream : '+ e.stream.id);
    };

    this.peerConnection.onnegotiationneeded = function(e) {
      self.logger.debug('pc.onnegotiationneeded : '+ Utils.toString(e));
    };

    this.peerConnection.onsignalingstatechange = function(e) {
      self.logger.debug('pc.onsignalingstatechange : '+ Utils.toString(e));
    };

    this.peerConnection.onicecandidate = function(e) {
      self.logger.debug('pc.onicecandidate : '+ Utils.toString(e));
      if (e.candidate && self.session.ua.rtcMediaHandlerOptions.enableICE) {
        self.logger.debug('ICE candidate received: '+ e.candidate.candidate);
      } else if (self.onIceCompleted !== undefined) {
        self.logger.log('onIceCompleted with ready : '+ self.ready+" and candidate : "+Utils.toString(e.candidate), self.session.ua);
        if(!self.ready && e.candidate) {
          self.onIceCompleted();
        }      
      }
    };

    this.peerConnection.oniceconnectionstatechange = function() {
      self.logger.debug('pc.oniceconnectionstatechange : '+ this.iceConnectionState);

      if (this.iceConnectionState === 'connected') {
        self.session.iceConnected();
      } else if (this.iceConnectionState === 'completed') {
        self.session.iceCompleted();
      } else if (this.iceConnectionState === 'closed') {
        self.session.iceClosed();
      } else if (this.iceConnectionState === 'failed') {
        self.session.terminate({
          cause: ExSIP_C.causes.RTP_TIMEOUT,
          status_code: 200,
          reason_phrase: ExSIP_C.causes.RTP_TIMEOUT
        });
      }
    };


    this.peerConnection.onstatechange = function() {
      self.logger.debug('pc.onstatechange : '+ this.readyState);
    };

    if(self.session.ua.configuration.enable_datachannel) {
      this.dataChannel = new DataChannel(this.session, this.peerConnection);
    }
  },

  close: function(stopLocalMedia) {
    this.logger.debug('closing PeerConnection');
    if(this.peerConnection) {
      if(this.peerConnection.signalingState !== 'closed') {
        this.logger.log('closing PeerConnection', this.session.ua);
        this.peerConnection.close();
      }

      if(stopLocalMedia) {
        if(this.localMedia) {
          this.logger.log('stopping local media '+Utils.toString(this.localMedia), this.session.ua);
          this.localMedia.stop();
        }
      }
    }
  },

  /**
  * -param {Object} mediaConstraints
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  getUserMedia: function(onSuccess, onFailure, constraints) {
    var self = this;

    this.logger.debug('requesting access to local media : '+JSON.stringify(constraints));

    WebRTC.getUserMedia(constraints,
      function(stream) {
        self.logger.debug('got local media stream');
        self.localMedia = stream;
        onSuccess(stream);
      },
      function(e) {
        self.logger.error('unable to get user media');
        self.logger.error(e);
        onFailure();
      }
    );
  },

  /**
  * Message reception.
  * -param {String} type
  * -param {String} sdp
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  onMessage: function(type, body, onSuccess, onFailure) {
    var self = this;
    var description = new WebRTC.RTCSessionDescription({type: type, sdp:body});
    if(this.session.ua.rtcMediaHandlerOptions.videoBandwidth) {
      description.setVideoBandwidth(this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
      this.logger.log("Modifying SDP with videoBandwidth : "+this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
    }

    if(this.peerConnection) {
      if(!description.sdp) {
        this.logger.log('empty sdp on setRemoteDescription - calling success');
        onSuccess();
        return;
      }

      var unsupportedMedia = description.removeUnsupportedMedia();
      if(unsupportedMedia) {
        this.logger.log('removed unsupported media : '+unsupportedMedia);
        this.peerConnection.remoteUnsupportedMedia = unsupportedMedia;
      }

      this.logger.log('peerConnection.setRemoteDescription : description : '+Utils.toString(description));
      this.logger.log('peerConnection.setRemoteDescription for type '+description.type+' : '+description.sdp);
      this.peerConnection.setRemoteDescription(
        description,
        onSuccess,
        function(e){
          self.logger.log("----------setRemoteDescription with error : "+JSON.stringify(e));
          onFailure(e);
        }
      );
    }
  }
};
},{"../Constants":871,"../Utils":896,"../WebRTC":897,"./DataChannel":886}],888:[function(require,module,exports){
module.exports = Registrator;


/**
 * Dependecies
 */
var Utils = require('./Utils');
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var RequestSender = require('./RequestSender');

function Registrator(ua, transport) {
  var reg_id=1; //Force reg_id to 1.

  this.logger = ua.getLogger('ExSIP.registrator');

  this.ua = ua;
  this.transport = transport;

  this.registrar = ua.configuration.registrar_server;
  this.expires = ua.configuration.register_expires;

  // Call-ID and CSeq values RFC3261 10.2
  this.call_id = Utils.createRandomToken(22);
  this.cseq = 0;

  // this.to_uri
  this.to_uri = ua.configuration.uri;

  this.registrationTimer = null;

  // Set status
  this.registered = false;

  // Contact header
  this.contact = this.ua.contact.toString();

  // sip.ice media feature tag (RFC 5768)
  this.contact += ';+sip.ice';

  // Custom headers for REGISTER and un-REGISTER.
  this.extraHeaders = [];

  // Custom Contact header params for REGISTER and un-REGISTER.
  this.extraContactParams = "";

  if(reg_id) {
    this.contact += ';reg-id='+ reg_id;
    this.contact += ';+sip.instance="<urn:uuid:'+ this.ua.configuration.instance_id+'>"';
  }
}


Registrator.prototype = {
  setExtraHeaders: function(extraHeaders) {
    if (! extraHeaders instanceof Array) {
      extraHeaders = [];
    }

    this.extraHeaders = extraHeaders.slice();
  },

  setExtraContactParams: function(extraContactParams) {
    if (! extraContactParams instanceof Object) {
      extraContactParams = {};
    }

    // Reset it.
    this.extraContactParams = "";

    for(var param_key in extraContactParams) {
      var param_value = extraContactParams[param_key];
      this.extraContactParams += (";" + param_key);
      if (param_value) {
        this.extraContactParams += ("=" + param_value);
      }
    }
  },

  register: function() {
    var request_sender, cause, extraHeaders,
      self = this;

    extraHeaders = this.extraHeaders.slice();
    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires + this.extraContactParams);
    extraHeaders.push('Expires: '+ this.expires);

    this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
        'to_uri': this.to_uri,
        'call_id': this.call_id,
        'cseq': (this.cseq += 1)
      }, extraHeaders);

    request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var contact, expires,
        contacts = response.getHeaders('contact').length;

      // Discard responses to older REGISTER/un-REGISTER requests.
      if(response.cseq !== this.cseq) {
        return;
      }

      // Clear registration timer
      if (this.registrationTimer !== null) {
        clearTimeout(this.registrationTimer);
        this.registrationTimer = null;
      }

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          if(response.hasHeader('expires')) {
            expires = response.getHeader('expires');
          }

          // Search the Contact pointing to us and update the expires value accordingly.
          if (!contacts) {
            this.logger.warn('no Contact header in response to REGISTER, response ignored');
            break;
          }

          while(contacts--) {
            contact = response.parseHeader('contact', contacts);
            if(contact.uri.user === this.ua.contact.uri.user) {
              expires = contact.getParam('expires');
              break;
            } else {
              contact = null;
            }
          }

          if (!contact) {
            this.logger.warn('no Contact header pointing to us, response ignored');
            break;
          }

          if(!expires) {
            expires = this.expires;
          }

          // Re-Register before the expiration interval has elapsed.
          // For that, decrease the expires value. ie: 3 seconds
          this.registrationTimer = setTimeout(function() {
            self.registrationTimer = null;
            self.register();
          }, (expires * 1000) - 3000);

          //Save gruu values
          if (contact.hasParam('temp-gruu')) {
            this.ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/"/g,'');
          }
          if (contact.hasParam('pub-gruu')) {
            this.ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/"/g,'');
          }

          if (! this.registered) {
            this.registered = true;
            this.ua.emit('registered', this.ua, {
              response: response
            });
          }
          break;
        // Interval too brief RFC3261 10.2.8
        case /^423$/.test(response.status_code):
          if(response.hasHeader('min-expires')) {
            // Increase our registration interval to the suggested minimum
            this.expires = response.getHeader('min-expires');
            // Attempt the registration again immediately
            this.register();
          } else { //This response MUST contain a Min-Expires header field
            this.logger.warn('423 response received for REGISTER without Min-Expires');
            this.registrationFailure(response, ExSIP_C.causes.SIP_FAILURE_CODE);
          }
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.registrationFailure(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.registrationFailure(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.registrationFailure(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  unregister: function(options) {
    var extraHeaders;

    // if(!this.registered) {
    //   this.logger.debug('already unregistered');
    //   return;
    // }

    options = options || {};

    this.registered = false;

    // Clear the registration timer.
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    extraHeaders = this.extraHeaders.slice();

    if(options.all) {
      extraHeaders.push('Contact: *' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    } else {
      extraHeaders.push('Contact: '+ this.contact + ';expires=0' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    }

    var request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var cause;

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          this.unregistered(response);
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.unregistered(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.unregistered(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.unregistered(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  registrationFailure: function(response, cause) {
    this.ua.emit('registrationFailed', this.ua, {
      response: response || null,
      cause: cause
    });

    if (this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua, {
        response: response || null,
        cause: cause
      });
    }
  },

  unregistered: function(response, cause) {
    this.registered = false;
    this.ua.emit('unregistered', this.ua, {
      response: response || null,
      cause: cause || null
    });
  },

  onTransportConnected: function() {
    this.register();
  },

  onTransportClosed: function() {
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    if(this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua);
    }
  },

  close: function() {
    if (this.registered) {
      this.unregister();
    }
  }
};
},{"./Constants":871,"./RequestSender":889,"./SIPMessage":890,"./Utils":896}],889:[function(require,module,exports){
module.exports = RequestSender;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var UA = require('./UA');
var DigestAuthentication = require('./DigestAuthentication');
var Transactions = require('./Transactions');

function RequestSender(applicant, ua) {
  this.logger = ua.getLogger('ExSIP.requestsender');
  this.ua = ua;
  this.applicant = applicant;
  this.method = applicant.request.method;
  this.request = applicant.request;
  this.credentials = null;
  this.challenged = false;
  this.staled = false;

  // If ua is in closing process or even closed just allow sending Bye and ACK
  if (ua.status === UA.C.STATUS_USER_CLOSED && (this.method !== ExSIP_C.BYE || this.method !== ExSIP_C.ACK)) {
    this.onTransportError();
  }
}


/**
 * Create the client transaction and send the message.
 */
RequestSender.prototype = {
  send: function(callbacks) {
    this.callbacks = callbacks || {};
    this.logger.log('callbacks : ' + this.callbacks);

    switch (this.method) {
      case "INVITE":
        this.clientTransaction = new Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
        break;
      case "ACK":
        this.clientTransaction = new Transactions.AckClientTransaction(this, this.request, this.ua.transport);
        break;
      default:
        this.clientTransaction = new Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
    }
    this.clientTransaction.send();
  },

  /**
   * Callback fired when receiving a request timeout error from the client transaction.
   * To be re-defined by the applicant.
   */
  onRequestTimeout: function() {
    this.logger.log('******************** onRequestTimeout : '+this.applicant);
    this.applicant.onRequestTimeout();
  },

  /**
   * Callback fired when receiving a transport error from the client transaction.
   * To be re-defined by the applicant.
   */
  onTransportError: function() {
    this.applicant.onTransportError();
  },

  /**
   * Called from client transaction when receiving a correct response to the request.
   * Authenticate request if needed or pass the response back to the applicant.
   */
  receiveResponse: function(response) {
    var cseq, challenge, authorization_header_name,
      status_code = response.status_code;
    this.logger.log('receiveResponse: callbacks : ' + this.callbacks);


    /*
     * Authentication
     * Authenticate once. _challenged_ flag used to avoid infinite authentications.
     */
    if ((status_code === 401 || status_code === 407)) {

      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
      if (response.status_code === 401) {
        challenge = response.parseHeader('www-authenticate');
        authorization_header_name = 'authorization';
      } else {
        challenge = response.parseHeader('proxy-authenticate');
        authorization_header_name = 'proxy-authorization';
      }

      // Verify it seems a valid challenge.
      if (!challenge) {
        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
        this.applicant.receiveResponse(response);
        return;
      }

      if (!this.challenged || (!this.staled && challenge.stale === true)) {
        if (!this.credentials) {
          this.credentials = new DigestAuthentication(this.ua);
        }

        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.request, challenge)) {
          this.applicant.receiveResponse(response);
          return;
        }
        this.challenged = true;

        if (challenge.stale) {
          this.staled = true;
        }

        if (response.method === ExSIP_C.REGISTER) {
          cseq = this.applicant.cseq += 1;
        } else if (this.request.dialog) {
          cseq = this.request.dialog.local_seqnum += 1;
        } else {
          cseq = this.request.cseq + 1;
          this.request.cseq = cseq;
        }
        this.request.setHeader('cseq', cseq + ' ' + this.method);

        this.request.setHeader(authorization_header_name, this.credentials.toString());
        this.send();
      } else {
        this.applicant.receiveResponse(response);
      }
    } else {
      this.applicant.receiveResponse(response);
    }

    switch (true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        break;
      case /^2[0-9]{2}$/.test(response.status_code):
        if (this.callbacks.success) {
          this.callbacks.success();
        }
        break;
      default:
        if (this.callbacks.failure) {
          this.callbacks.failure(response);
        }
        break;
    }

  }
};
},{"./Constants":871,"./DigestAuthentication":874,"./Transactions":892,"./UA":894}],890:[function(require,module,exports){
module.exports = {
  OutgoingRequest: OutgoingRequest,
  IncomingRequest: IncomingRequest,
  IncomingResponse: IncomingResponse
};


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var NameAddrHeader = require('./NameAddrHeader');
var Grammar = require('./Grammar');


/**
 * -param {String} method request method
 * -param {String} ruri request uri
 * -param {UA} ua
 * -param {Object} params parameters that will have priority over ua.configuration parameters:
 * <br>
 *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set
 * -param {Object} [headers] extra headers
 * -param {String} [body]
 */
function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {
  var
    to,
    from,
    call_id,
    cseq;

  params = params || {};

  this.logger = ua.getLogger('ExSIP.sipmessage');

  this.logger.debug('OutgoingRequest.extraHeaders : '+method+', '+ruri+', '+extraHeaders);
  // Mandatory parameters check
  if(!method || !ruri || !ua) {
    return null;
  }

  this.ua = ua;
  this.headers = {};
  this.method = method;
  this.ruri = ruri;
  this.body = body;
  this.extraHeaders = extraHeaders && extraHeaders.slice() || [];
this.logger.debug('OutgoingRequest.extraHeaders 2 : '+this.extraHeaders);
  // Fill the Common SIP Request Headers

  // Route
  if (params.route_set) {
    this.setHeader('route', params.route_set);
  } else if (ua.configuration.use_preloaded_route){
    this.setHeader('route', ua.transport.server.sip_uri);
  }

  // Via
  // Empty Via header. Will be filled by the client transaction.
  this.setHeader('via', '');

  // Max-Forwards
  this.setHeader('max-forwards', ExSIP_C.MAX_FORWARDS);

  // To
  to = (params.to_display_name || params.to_display_name === 0) ? '"' + params.to_display_name + '" ' : '';
  var toUri = (params.to_uri || ruri);
  to += '<' + (ua.configuration.enable_ims && toUri.isPhoneNumber() && toUri.toString().indexOf(';user=phone') === -1 ? toUri +";user=phone" : toUri) + '>';
  to += params.to_tag ? ';tag=' + params.to_tag : '';
  this.to = new NameAddrHeader.parse(to);
  this.setHeader('to', to);


  // From
  var fromName;
  if (params.from_display_name || params.from_display_name === 0) {
    fromName = '"' + params.from_display_name + '" ';
  } else if (ua.configuration.display_name) {
    fromName = '"' + ua.configuration.display_name + '" ';
  } else {
    fromName = '';
  }
  var fromUri = (params.from_uri || ua.configuration.uri);
  fromName += '<' + (ua.configuration.enable_ims && fromUri.isPhoneNumber() && fromUri.toString().indexOf(';user=phone') === -1 ? fromUri +";user=phone" : fromUri) + '>';
  var fromTag = ';tag=' + (params.from_tag || Utils.newTag());
  from = fromName + fromTag;
  this.from = new NameAddrHeader.parse(from);
  this.setHeader('from', from);

  // Call-ID
  call_id = params.call_id || (ua.configuration.exsip_id + Utils.createRandomToken(15));
  this.call_id = call_id;
  this.setHeader('call-id', call_id);

  // CSeq
  cseq = params.cseq || Math.floor(Math.random() * 10000);
  this.cseq = cseq;
  this.setHeader('cseq', cseq + ' ' + method);

  // P-Asserted-Identity
  if(ua.configuration.enable_ims) {
    this.setHeader('P-Asserted-Identity', fromName);
  } else if(ua.configuration.p_asserted_identity) {
    this.setHeader('P-Asserted-Identity', ua.configuration.p_asserted_identity);
  }
}

OutgoingRequest.prototype = {
  /**
   * Replace the the given header by the given value.
   * -param {String} name header name
   * -param {String | Array} value header value
   */
  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  /**
   * Get the value of the given header name at the given position.
   * -param {String} name header name
   * -returns {String|undefined} Returns the specified header, null if header doesn't exist.
   */
  getHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length,
      header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0];
      }
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          return header.substring(header.indexOf(':')+1).trim();
        }
      }
    }

    return;
  },

  /**
   * Get the header/s of the given name.
   * -param {String} name header name
   * -returns {Array} Array with all the headers of the specified name.
   */
  getHeaders: function(name) {
    var idx, length, regexp,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if (header) {
      length = header.length;
      for (idx = 0; idx < length; idx++) {
        result.push(header[idx]);
      }
      return result;
    } else {
      length = this.extraHeaders.length;
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          result.push(header.substring(header.indexOf(':')+1).trim());
        }
      }
      return result;
    }
  },

  /**
   * Verify the existence of the given header.
   * -param {String} name header name
   * -returns {boolean} true if header with given name exists, false otherwise
   */
  hasHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length;

    if (this.headers[Utils.headerize(name)]) {
      return true;
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        if (regexp.test(this.extraHeaders[idx])) {
          return true;
        }
      }
    }

    return false;
  },

  toString: function() {
    var msg = '', header, length, idx,
      supported = [];

    msg += this.method + ' ' + (this.ua.configuration.enable_ims && this.ruri.isPhoneNumber() ? this.ruri + ";user=phone" : this.ruri) + ' SIP/2.0\r\n';

    for (header in this.headers) {
      length = this.headers[header].length;
      for (idx = 0; idx < length; idx++) {
        msg += header + ': ' + this.headers[header][idx] + '\r\n';
      }
    }

    length = this.extraHeaders.length;
    for (idx = 0; idx < length; idx++) {
      msg += this.extraHeaders[idx].trim() +'\r\n';
    }

    // Supported
    switch (this.method) {
      case ExSIP_C.REGISTER:
        supported.push('path', 'gruu');
        break;
      case ExSIP_C.INVITE:
        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
          supported.push('gruu');
        }
        break;
    }

    supported.push('outbound');

    // Allow
    if(!this.hasHeader('Allow')) {
      msg += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';      
    }

    if(!this.hasHeader('Supported')) {
      msg += 'Supported: ' +  supported +'\r\n';
    }
    
    msg += 'User-Agent: ' + ExSIP_C.USER_AGENT +'\r\n';

    if(this.body) {
      length = Utils.str_utf8_length(this.body);
      msg += 'Content-Length: ' + length + '\r\n\r\n';
      msg += this.body;
    } else {
      msg += 'Content-Length: 0\r\n\r\n';
    }

    return msg;
  }
};


function IncomingMessage(){
  this.data = null;
  this.headers = null;
  this.method =  null;
  this.via = null;
  this.via_branch = null;
  this.call_id = null;
  this.cseq = null;
  this.from = null;
  this.from_tag = null;
  this.to = null;
  this.to_tag = null;
  this.body = null;
}

IncomingMessage.prototype = {
  /**
  * Insert a header of the given name and value into the last position of the
  * header array.
  */
  addHeader: function(name, value) {
    var header = { raw: value };

    name = Utils.headerize(name);

    if(this.headers[name]) {
      this.headers[name].push(header);
    } else {
      this.headers[name] = [header];
    }
  },

  getHeader: function(name) {
    var header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0].raw;
      }
    } else {
      return;
    }
  },

  /**
   * Get the header/s of the given name.
   */
  getHeaders: function(name) {
    var idx, length,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if(!header) {
      return [];
    }

    length = header.length;
    for (idx = 0; idx < length; idx++) {
      result.push(header[idx].raw);
    }

    return result;
  },

  /**
   * Verify the existence of the given header.
   */
  hasHeader: function(name) {
    return(this.headers[Utils.headerize(name)]) ? true : false;
  },

  /**
  * Parse the given header on the given index.
  * -param {String} name header name
  * -param {Number} [idx=0] header index
  * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
  */
  parseHeader: function(name, idx) {
    var header, value, parsed;

    name = Utils.headerize(name);

    idx = idx || 0;

    if(!this.headers[name]) {
      this.logger.log('header "' + name + '" not present');
      return;
    } else if(idx >= this.headers[name].length) {
      this.logger.log('not so many "' + name + '" headers present');
      return;
    }

    header = this.headers[name][idx];
    value = header.raw;

    if(header.parsed) {
      return header.parsed;
    }

    //substitute '-' by '_' for grammar rule matching.
    parsed = Grammar.parse(value, name.replace(/-/g, '_'));

    if(parsed === -1) {
      this.headers[name].splice(idx, 1); //delete from headers
      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  },

  /**
   * Message Header attribute selector. Alias of parseHeader.
   * -param {String} name header name
   * -param {Number} [idx=0] header index
   * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
   *
   * -example
   * message.s('via',3).port
   */
  s: function(name, idx) {
    return this.parseHeader(name, idx);
  },

  /**
  * Replace the value of the given header by the value.
  * -param {String} name header name
  * -param {String} value header value
  */
  setHeader: function(name, value) {
    var header = { raw: value };
    this.headers[Utils.headerize(name)] = [header];
  }
};

function IncomingRequest(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.ua = ua;
  this.headers = {};
  this.ruri = null;
  this.transport = null;
  this.server_transaction = null;
}

IncomingRequest.prototype = new IncomingMessage();

/**
* Stateful reply.
* -param {Number} code status code
* -param {String} reason reason phrase
* -param {Object} headers extra headers
* -param {String} body body
* -param {Function} [onSuccess] onSuccess callback
* -param {Function} [onFailure] onFailure callback
*/
IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
  var rr, vias, length, idx, response,
    supported = [],
    to = this.getHeader('To'),
    r = 0,
    v = 0;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';
  extraHeaders = extraHeaders && extraHeaders.slice() || [];

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  if(this.method === ExSIP_C.INVITE && code > 100 && code <= 200) {
    rr = this.getHeaders('record-route');
    length = rr.length;

    for(r; r < length; r++) {
      response += 'Record-Route: ' + rr[r] + '\r\n';
    }
  }

  vias = this.getHeaders('via');
  length = vias.length;

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';

  length = extraHeaders.length;
  for (idx = 0; idx < length; idx++) {
    response += extraHeaders[idx].trim() +'\r\n';
  }

  // Supported
  switch (this.method) {
    case ExSIP_C.INVITE:
      if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
        supported.push('gruu');
      }
      break;
  }

  supported.push('outbound');

  // Allow and Accept
  if (this.method === ExSIP_C.OPTIONS) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  } else if (code === 405) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
  } else if (code === 415 ) {
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  }

  response += 'Supported: ' +  supported +'\r\n';

  if(body) {
    length = Utils.str_utf8_length(body);
    if(response.indexOf('Content-Type:') === -1) {
      response += 'Content-Type: application/sdp\r\n';      
    }
    response += 'Content-Length: ' + length + '\r\n\r\n';
    response += body;
  } else {
    response += 'Content-Length: ' + 0 + '\r\n\r\n';
  }

  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);
};

/**
* Stateless reply.
* -param {Number} code status code
* -param {String} reason reason phrase
*/
IncomingRequest.prototype.reply_sl = function(code, reason) {
  var to, response,
    v = 0,
    vias = this.getHeaders('via'),
    length = vias.length;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  to = this.getHeader('To');

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
  response += 'Content-Length: ' + 0 + '\r\n\r\n';

  this.transport.send(response);
};

function IncomingResponse(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.headers = {};
  this.status_code = null;
  this.reason_phrase = null;
}

IncomingResponse.prototype = new IncomingMessage();

},{"./Constants":871,"./Grammar":878,"./NameAddrHeader":882,"./Utils":896}],891:[function(require,module,exports){
var T1 = 500,
  T2 = 4000,
  T4 = 5000;


var Timers = {
  T1: T1,
  T2: T2,
  T4: T4,
  TIMER_B: 64 * T1,
  TIMER_D: 0  * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0  * T1,
  TIMER_J: 0  * T1,
  TIMER_K: 0  * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1,
  PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
};

module.exports = Timers;

},{}],892:[function(require,module,exports){
module.exports = {
  C: null,
  NonInviteClientTransaction: NonInviteClientTransaction,
  InviteClientTransaction: InviteClientTransaction,
  AckClientTransaction: AckClientTransaction,
  NonInviteServerTransaction: NonInviteServerTransaction,
  InviteServerTransaction: InviteServerTransaction,
  checkTransaction: checkTransaction
};


var C = {
  // Transaction states
  STATUS_TRYING:     1,
  STATUS_PROCEEDING: 2,
  STATUS_CALLING:    3,
  STATUS_ACCEPTED:   4,
  STATUS_COMPLETED:  5,
  STATUS_TERMINATED: 6,
  STATUS_CONFIRMED:  7,

  // Transaction types
  NON_INVITE_CLIENT: 'nict',
  NON_INVITE_SERVER: 'nist',
  INVITE_CLIENT: 'ict',
  INVITE_SERVER: 'ist'
};

/**
 * Expose C object.
 */
module.exports.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Timers = require('./Timers');


function NonInviteClientTransaction(request_sender, request, transport) {
  var via,
    via_transport,
    events = ['stateChanged'];

  this.type = C.NON_INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  this.initEvents(events);
}


NonInviteClientTransaction.prototype = new EventEmitter();

NonInviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteClientTransaction.prototype.send = function() {
  var tr = this;

  this.stateChanged(C.STATUS_TRYING);
  this.F = setTimeout(function() {tr.timer_F();}, Timers.TIMER_F);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

NonInviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting non-INVITE client transaction ' + this.id);
  clearTimeout(this.F);
  clearTimeout(this.K);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onTransportError();
};

NonInviteClientTransaction.prototype.timer_F = function() {
  this.logger.debug('Timer F expired for non-INVITE client transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onRequestTimeout();
};

NonInviteClientTransaction.prototype.timer_K = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

NonInviteClientTransaction.prototype.receiveResponse = function(response) {
  var
    tr = this,
    status_code = response.status_code;
  if(status_code < 200) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
    }
  } else {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        clearTimeout(this.F);

        if(status_code === 408) {
          this.request_sender.onRequestTimeout();
        } else {
          this.request_sender.receiveResponse(response);
        }

        this.K = setTimeout(function() {tr.timer_K();}, Timers.TIMER_K);
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteClientTransaction(request_sender, request, transport) {
  var via,
    tr = this,
    via_transport,
    events = ['stateChanged'];

  this.type = C.INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.ict', this.id);

  this.logger.log('******************** request_sender : ' + request_sender);
  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  // TODO: Adding here the cancel() method is a hack that must be fixed.
  // Add the cancel property to the request.
  //Will be called from the request instance, not the transaction itself.
  this.request.cancel = function(reason) {
    tr.cancel_request(tr, reason);
  };

  this.initEvents(events);
}

InviteClientTransaction.prototype = new EventEmitter();

InviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteClientTransaction.prototype.send = function() {
  var tr = this;
  this.stateChanged(C.STATUS_CALLING);
  this.B = setTimeout(function() {
    tr.timer_B();
  }, Timers.TIMER_B);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

InviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  clearTimeout(this.D);
  clearTimeout(this.M);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);

  if (this.state !== C.STATUS_ACCEPTED) {
    this.request_sender.onTransportError();
  }
};

// RFC 6026 7.2
InviteClientTransaction.prototype.timer_M = function() {
  this.logger.debug('Timer M expired for INVITE client transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    clearTimeout(this.B);
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
  }
};

// RFC 3261 17.1.1
InviteClientTransaction.prototype.timer_B = function() {
  this.logger.debug('Timer B expired for INVITE client transaction ' + this.id);
  if(this.state === C.STATUS_CALLING) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
    this.logger.debug('InviteClientTransaction.timer_B : ' + this.request_sender);
    this.request_sender.onRequestTimeout();
  }
};

InviteClientTransaction.prototype.timer_D = function() {
  this.logger.debug('Timer D expired for INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

InviteClientTransaction.prototype.sendACK = function(response) {
  var tr = this;

  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
  this.ack += 'Via: ' + this.request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.ack += 'Route: ' + this.request.headers.Route.toString() + '\r\n';
  }

  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
  this.ack += 'From: ' + this.request.headers.From.toString() + '\r\n';
  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
  this.ack += 'CSeq: ' + this.request.headers.CSeq.toString().split(' ')[0];
  this.ack += ' ACK\r\n';
  this.ack += 'Content-Length: 0\r\n\r\n';

  this.D = setTimeout(function() {tr.timer_D();}, Timers.TIMER_D);

  this.transport.send(this.ack);
};

InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
  var request = tr.request;

  this.cancel = ExSIP_C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
  this.cancel += 'Via: ' + request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.cancel += 'Route: ' + request.headers.Route.toString() + '\r\n';
  }

  this.cancel += 'To: ' + request.headers.To.toString() + '\r\n';
  this.cancel += 'From: ' + request.headers.From.toString() + '\r\n';
  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
  this.cancel += 'CSeq: ' + request.headers.CSeq.toString().split(' ')[0] +
  ' CANCEL\r\n';

  if(reason) {
    this.cancel += 'Reason: ' + reason + '\r\n';
  }

  this.cancel += 'Content-Length: 0\r\n\r\n';

  // Send only if a provisional response (>100) has been received.
  if(this.state === C.STATUS_PROCEEDING) {
    this.transport.send(this.cancel);
  }
};

InviteClientTransaction.prototype.receiveResponse = function(response) {
  var
  tr = this,
  status_code = response.status_code;

  if(status_code >= 100 && status_code <= 199) {
    this.logger.debug('received 1xx : '+this.state);
    switch(this.state) {
      case C.STATUS_CALLING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_PROCEEDING:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_CALLING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.M = setTimeout(function() {
          tr.timer_M();
        }, Timers.TIMER_M);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_ACCEPTED:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_CALLING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          this.sendACK(response);
          if(status_code === 503) {
            var options = {code: 503, reason: 'Service Unavailable', retryCallback: function(transport){
              transport.ua.once("connected", function(e){
                if(transport === e.data.transport) {
                  tr.send();
                }
              });
            }};
            this.request_sender.ua.onTransportError(this.request_sender.ua.transport, options);
          } else {
            this.request_sender.receiveResponse(response);
          }
          break;
        case C.STATUS_COMPLETED:
          this.sendACK(response);
          break;
      }
    }
};


function AckClientTransaction(request_sender, request, transport) {
  var via,
    via_transport;

  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);
}

AckClientTransaction.prototype = new EventEmitter();

AckClientTransaction.prototype.send = function() {
  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

AckClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, for an ACK client transaction ' + this.id);
  this.request_sender.onTransportError();
};


function NonInviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.NON_INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.nist', this.id);

  this.state = C.STATUS_TRYING;

  ua.newTransaction(this);

  this.initEvents(events);
}

NonInviteServerTransaction.prototype = new EventEmitter();

NonInviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteServerTransaction.prototype.timer_J = function() {
  this.logger.debug('Timer J expired for non-INVITE server transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

NonInviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting non-INVITE server transaction ' + this.id);

    clearTimeout(this.J);
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code === 100) {
    /* RFC 4320 4.1
     * 'A SIP element MUST NOT
     * send any provisional response with a
     * Status-Code other than 100 to a non-INVITE request.'
     */
    switch(this.state) {
      case C.STATUS_TRYING:
        this.stateChanged(C.STATUS_PROCEEDING);
        if(!this.transport.send(response))  {
          this.onTransportError();
        }
        break;
      case C.STATUS_PROCEEDING:
        this.last_response = response;
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
    }
  } else if(status_code >= 200 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        this.last_response = response;
        if(Timers.TIMER_J === 0) {
            tr.timer_J();
        } else {
          this.J = setTimeout(function() {
            tr.timer_J();
          }, Timers.TIMER_J);
        }
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.ist', this.id);

  this.state = C.STATUS_PROCEEDING;

  ua.newTransaction(this);

  this.resendProvisionalTimer = null;

  request.reply(100);

  this.initEvents(events);
}

InviteServerTransaction.prototype = new EventEmitter();

InviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteServerTransaction.prototype.timer_H = function() {
  this.logger.debug('Timer H expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_COMPLETED) {
    this.logger.log('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
  }

  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

InviteServerTransaction.prototype.timer_I = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

// RFC 6026 7.1
InviteServerTransaction.prototype.timer_L = function() {
  this.logger.debug('Timer L expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting INVITE server transaction ' + this.id);

    if (this.resendProvisionalTimer !== null) {
      clearInterval(this.resendProvisionalTimer);
      this.resendProvisionalTimer = null;
    }

    clearTimeout(this.L);
    clearTimeout(this.H);
    clearTimeout(this.I);

    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.resend_provisional = function() {
  if(!this.transport.send(this.last_response)) {
    this.onTransportError();
  }
};

// INVITE Server Transaction RFC 3261 17.2.1
InviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code >= 100 && status_code <= 199) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if(!this.transport.send(response)) {
          this.onTransportError();
        }
        this.last_response = response;
        break;
    }
  }

  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
    if(this.resendProvisionalTimer === null) {
      this.resendProvisionalTimer = setInterval(function() {
        tr.resend_provisional();}, Timers.PROVISIONAL_RESPONSE_INTERVAL);
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.last_response = response;
        this.L = setTimeout(function() {
          tr.timer_L();
        }, Timers.TIMER_L);

        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }
        /* falls through */
        case C.STATUS_ACCEPTED:
          // Note that this point will be reached for proceeding tr.state also.
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }

        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else {
          this.stateChanged(C.STATUS_COMPLETED);
          this.H = setTimeout(function() {
            tr.timer_H();
          }, Timers.TIMER_H);
          if (onSuccess) {
            onSuccess();
          }
        }
        break;
    }
  }
};

/**
 * INVITE:
 *  _true_ if retransmission
 *  _false_ new request
 *
 * ACK:
 *  _true_  ACK to non2xx response
 *  _false_ ACK must be passed to TU (accepted state)
 *          ACK to 2xx response
 *
 * CANCEL:
 *  _true_  no matching invite transaction
 *  _false_ matching invite transaction and no final response sent
 *
 * OTHER:
 *  _true_  retransmission
 *  _false_ new request
 */
function checkTransaction(ua, request) {
  var tr;

  switch(request.method) {
    case ExSIP_C.INVITE:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_PROCEEDING:
            tr.transport.send(tr.last_response);
            break;

            // RFC 6026 7.1 Invite retransmission
            //received while in C.STATUS_ACCEPTED state. Absorb it.
          case C.STATUS_ACCEPTED:
            break;
        }
        console.log("checkTransaction failed for INVITE request and server transaction in state : "+tr.state);
        return true;
      }
      break;
    case ExSIP_C.ACK:
      tr = ua.transactions.ist[request.via_branch];

      // RFC 6026 7.1
      if(tr) {
        if(tr.state === C.STATUS_ACCEPTED) {
          return false;
        } else if(tr.state === C.STATUS_COMPLETED) {
          tr.state = C.STATUS_CONFIRMED;
          tr.I = setTimeout(function() {tr.timer_I();}, Timers.TIMER_I);
          return true;
        }
      }
      // ACK to 2XX Response.
      else {
        return false;
      }
      break;
    case ExSIP_C.CANCEL:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        request.reply_sl(200);
        if(tr.state === C.STATUS_PROCEEDING) {
          return false;
        } else {
          console.log("checkTransaction failed for CANCEL request and server transaction in state : "+tr.state);
          return true;
        }
      } else {
        request.reply_sl(481);
        console.log("checkTransaction failed for CANCEL request and no server transaction");
        return true;
      }
      break;
    default:

      // Non-INVITE Server Transaction RFC 3261 17.2.2
      console.log('***************** nist : ', Object.keys(ua.transactions.nist));
      tr = ua.transactions.nist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_TRYING:
            break;
          case C.STATUS_PROCEEDING:
          case C.STATUS_COMPLETED:
            tr.transport.send(tr.last_response);
            break;
        }
        console.log("checkTransaction failed for non invite server transaction in state : "+tr.state);
        return true;
      }
      break;
  }
}

},{"./Constants":871,"./EventEmitter":875,"./Timers":891}],893:[function(require,module,exports){
(function (global){
module.exports = Transport;


var C = {
  // Transport status codes
  STATUS_READY:        0,
  STATUS_DISCONNECTED: 1,
  STATUS_ERROR:        2
};


/**
 * Expose C object.
 */
Transport.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Parser = require('./Parser');
var UA = require('./UA');
var SIPMessage = require('./SIPMessage');
var sanityCheck = require('./sanityCheck');
// Conditional module loading.
var WebSocket;  // jshint ignore:line
var isNode = false;
if (global.WebSocket) {
  WebSocket = global.WebSocket;  // jshint ignore:line
}
else {
  WebSocket = require('ws');  // jshint ignore:line
  isNode = true;
}


function Transport(ua, server) {
  this.logger = ua.getLogger('ExSIP.transport');
  this.ua = ua;
  this.ws = null;
  this.server = server;
  this.reconnection_attempts = 0;
  this.closed = false;
  this.connected = false;
  this.reconnectTimer = null;
  this.lastTransportError = {};

  if (isNode) {
    this.ws_options = this.ua.configuration.node_ws_options;
    this.ws_options.protocol = 'sip';
    this.ws_options.headers = {
      'User-Agent': ExSIP_C.USER_AGENT
    };
  }
}

Transport.prototype = {
  /**
   * Send a message.
   */
  send: function(msg) {
    var message = msg.toString();

    if(this.ws && this.readyState() === WebSocket.OPEN) {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('sending WebSocket message:\n\n' + message + '\n');
      }
      this.ws.send(message);
      return true;
    } else {
      this.logger.warn('unable to send message, WebSocket is not open');
      return false;
    }
  },

  readyState: function() {
    return this.ws.readyState;
  },

  /**
  * Disconnect socket.
  */
  disconnect: function() {
    if(this.ws) {
      // Clear reconnectTimer
      clearTimeout(this.reconnectTimer);
      // TODO: should make this.reconnectTimer = null here?

      this.closed = true;
      this.logger.debug('closing WebSocket ' + this.server.ws_uri);
      this.ws.close();
    }

    // TODO: Why this??
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
      this.ua.emit('disconnected', this.ua, {
        transport: this,
        code: this.lastTransportError.code,
        reason: this.lastTransportError.reason
      });
    }
  },

  /**
  * Connect socket.
  */
  connect: function() {
    var transport = this;

    if(this.ws && (this.readyState() === WebSocket.OPEN || this.readyState() === WebSocket.CONNECTING)) {
      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
      return false;
    }

    if(this.ws) {
      this.ws.close();
    }

    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
    this.ua.onTransportConnecting(this,
      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);

    try {
      if (! isNode) {
        this.ws = new WebSocket(this.server.ws_uri, 'sip');
        this.ws.binaryType = 'arraybuffer';
      }
      else {
        this.ws = new WebSocket(this.server.ws_uri, this.ws_options);
      }
      this.ua.usedServers.push(this.server);

      this.ws.onopen = function() {
        transport.onOpen();
      };

      this.ws.onclose = function(e) {
        transport.onClose(e);
      };

      this.ws.onmessage = function(e) {
        transport.onMessage(e);
      };

      this.ws.onerror = function(e) {
        transport.onError(e);
      };
    } catch(e) {
      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
      this.lastTransportError.code = null;
      this.lastTransportError.reason = e.message;
      this.ua.onTransportError(this);
    }
  },

  // Transport Event Handlers

  onOpen: function() {
    this.connected = true;

    this.logger.debug('WebSocket ' + this.server.ws_uri + ' connected');
    // Clear reconnectTimer since we are not disconnected
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    // Reset reconnection_attempts
    this.reconnection_attempts = 0;
    // Disable closed
    this.closed = false;
    // Trigger onTransportConnected callback
    this.ua.onTransportConnected(this);
  },

  onClose: function(e) {
    var connected_before = this.connected;

    this.connected = false;
    this.lastTransportError.code = e.code;
    this.lastTransportError.reason = e.reason;
    this.logger.debug('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');

    if(e.wasClean === false) {
      this.logger.warn('WebSocket abrupt disconnection');
    }
    // Transport was connected
    if(connected_before === true) {
      this.ua.onTransportClosed(this);
      // Check whether the user requested to close.
      if(!this.closed) {
        this.reConnect();
      } else {
        this.ua.emit('disconnected', this.ua, {
          transport: this,
          code: this.lastTransportError.code,
          reason: this.lastTransportError.reason
        });
      }
    } else {
      // This is the first connection attempt
      // May be a network error (or may be UA.stop() was called)
      this.ua.onTransportError(this);
    }
  },

  onMessage: function(e) {
    var message, transaction,
      data = e.data;

    // CRLF Keep Alive response from server. Ignore it.
    if(data === '\r\n') {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket message with CRLF Keep Alive response');
      }
      return;
    }

    // WebSocket binary message.
    else if (typeof data !== 'string') {
      try {
        data = String.fromCharCode.apply(null, new Uint8Array(data));
      } catch(evt) {
        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
        return;
      }

      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket binary message:\n\n' + data + '\n');
      }
    }

    // WebSocket text message.
    else {
      this.logger.log('onMessage : '+this.ua.configuration.trace_sip);
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket text message:\n\n' + data + '\n');
      }
    }

    message = Parser.parseMessage(data, this.ua);

    if (! message) {
      return;
    }

    if(this.ua.status === UA.C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {
      return;
    }

    // Do some sanity check
    if(! sanityCheck(message, this.ua, this)) {
      return;
    }

    if(message instanceof SIPMessage.IncomingRequest) {
      message.transport = this;
      this.ua.receiveRequest(message);
    } else if(message instanceof SIPMessage.IncomingResponse) {
      /* Unike stated in 18.1.2, if a response does not match
      * any transaction, it is discarded here and no passed to the core
      * in order to be discarded there.
      */
      switch(message.method) {
        case ExSIP_C.INVITE:
          transaction = this.ua.transactions.ict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
        case ExSIP_C.ACK:
          // Just in case ;-)
          break;
        default:
          transaction = this.ua.transactions.nict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
      }
    }
  },

  onError: function(e) {
    this.logger.warn('WebSocket connection error: ' + e);
  },

  /**
  * Reconnection attempt logic.
  */
  reConnect: function() {
    var transport = this;

    this.reconnection_attempts += 1;

    if(this.reconnection_attempts > this.ua.configuration.ws_server_max_reconnection) {
      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
      this.ua.onTransportError(this);
    } else {
      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')'+ ' (reconnection timeout '+this.ua.configuration.ws_server_reconnection_timeout+')');

      if(this.ua.configuration.ws_server_reconnection_timeout === 0) {
        transport.connect();
      } else {
        this.reconnectTimer = setTimeout(function() {
          transport.connect();
          transport.reconnectTimer = null;
        }, this.ua.configuration.ws_server_reconnection_timeout * 1000);
      }
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Constants":871,"./Parser":883,"./SIPMessage":890,"./UA":894,"./sanityCheck":898,"ws":869}],894:[function(require,module,exports){
module.exports = UA;


var C = {
  // UA status codes
  STATUS_INIT: 0,
  STATUS_READY: 1,
  STATUS_USER_CLOSED: 2,
  STATUS_NOT_READY: 3,

  // UA error codes
  CONFIGURATION_ERROR: 1,
  NETWORK_ERROR: 2
};

/**
 * Expose C object.
 */
UA.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var LoggerFactory = require('./LoggerFactory');
var EventEmitter = require('./EventEmitter');
var Registrator = require('./Registrator');
var RTCSession = require('./RTCSession');
var Message = require('./Message');
var Transport = require('./Transport');
var Transactions = require('./Transactions');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var WebRTC = require('./WebRTC');
var Exceptions = require('./Exceptions');
var URI = require('./URI');
var Grammar = require('./Grammar');
var Utils = require('./Utils');



/**
 * The User-Agent class.
 * @class UA
 * @param {Object} configuration Configuration parameters.
 * @throws {Exceptions.ConfigurationError} If a configuration parameter is invalid.
 * @throws {TypeError} If no configuration is given.
 */
function UA(configuration) {
  var events = [
    'connecting',
    'connected',
    'disconnected',
    'newTransaction',
    'transactionDestroyed',
    'registered',
    'unregistered',
    'registrationFailed',
    'newRTCSession',
    'newMessage',
    'onReInvite'
  ];

  this.log = new LoggerFactory(configuration);
  this.logger = this.getLogger('ua');
  this.usedServers = [];
  this.rtcMediaHandlerOptions = {};

  this.cache = {
    credentials: {}
  };

  this.configuration = {};
  this.dynConfiguration = {};
  this.dialogs = {};

  //User actions outside any session/dialog (MESSAGE)
  this.applicants = {};

  this.sessions = {};
  this.transport = null;
  this.contact = null;
  this.status = C.STATUS_INIT;
  this.error = null;
  this.transactions = {
    nist: {},
    nict: {},
    ist: {},
    ict: {}
  };

  // Custom UA empty object for high level use
  this.data = {};

  this.transportRecoverAttempts = 0;
  this.transportRecoveryTimer = null;

  Object.defineProperties(this, {
    transactionsCount: {
      get: function() {
        var type,
          transactions = ['nist', 'nict', 'ist', 'ict'],
          count = 0;

        for (type in transactions) {
          count += Object.keys(this.transactions[transactions[type]]).length;
        }

        return count;
      }
    },

    nictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nict).length;
      }
    },

    nistTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nist).length;
      }
    },

    ictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ict).length;
      }
    },

    istTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ist).length;
      }
    }
  });

  /**
   * Load configuration
   */

  if (configuration === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Apply log configuration if present
  if (configuration.log) {
    if (configuration.log.hasOwnProperty('builtinEnabled')) {
      this.log.builtinEnabled = configuration.log.builtinEnabled;
    }

    if (configuration.log.hasOwnProperty('level')) {
      this.log.level = configuration.log.level;
    }

    if (configuration.log.hasOwnProperty('connector')) {
      this.log.connector = configuration.log.connector;
    }
  }

  try {
    this.loadConfig(configuration);
    this.initEvents(events);
  } catch (e) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.CONFIGURATION_ERROR;
    throw e;
  }
}


UA.prototype = new EventEmitter();

//=================
//  High Level API
//=================
UA.prototype.isDebug = function() {
  return this.configuration.trace_sip === true;
};

/**
 * Registration state.
 * @param {Boolean}
 */
UA.prototype.isRegistered = function() {
  if (this._registrator && this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 * @param {Boolean}
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

UA.prototype.transfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    this.logger.warn("invalid transfer target");
    return;
  }

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending refer to transferee");
    self.sendReferBasic(sessionToTransfer, transferTarget, options);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.attendedTransfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('attended transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    this.logger.warn('invalid transfer target');
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    return;
  }


  var targetSession = self.newSession(options);
  targetSession.rtcMediaHandler.copy(sessionToTransfer.rtcMediaHandler);

  var holdTargetSuccess = function() {
    self.logger.log("transfer : hold target success - sending attended refer");
    self.sendReferAttended(sessionToTransfer, targetSession, transferTarget, options);
  };

  var holdTargetFailed = function() {
    self.logger.log("transfer : hold target failed");
  };

  var sendTargetInviteSuccess = function() {
    self.logger.log("transfer : send invite to target success - putting target on hold");
    targetSession.hold(holdTargetSuccess, holdTargetFailed);
  };

  var sendTargetInviteFailed = function(response) {
    self.logger.log("transfer : send invite to target failed - sending basic refer");
    if (response.status_code === 420) {
      self.sendReferBasic(sessionToTransfer, transferTarget, options);
    }
  };

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending invite to target");
    targetSession.sendInviteRequest(transferTarget, {
        extraHeaders: ["Require: replaces"]
      },
      sendTargetInviteSuccess, sendTargetInviteFailed);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.sendReferAttended = function(sessionToTransfer, targetSession, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, targetSession, options);
  var referTo = "<" + (transferTarget).toString() +
    "?Replaces=" + targetSession.dialog.id.call_id +
    "%3Bto-tag%3D" + targetSession.dialog.id.remote_tag +
    "%3Bfrom-tag%3D" + targetSession.dialog.id.local_tag + ">";
  options.extraHeaders.push('Refer-To: ' + referTo);
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.processRefer = function(sessionToTransfer, referRequest) {
  var self = this;
  referRequest.reply(202);
  var notifySuccess = function() {
    self.logger.log("Notify successful");
  };
  var notifyFailure = function() {
    self.logger.log("Notify failed");
  };
  sessionToTransfer.sendNotifyRequest({
    sdp: "SIP/2.0 100 Trying"
  }, notifySuccess, notifyFailure);
};

UA.prototype.sendReferBasic = function(sessionToTransfer, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, sessionToTransfer, options);
  options.extraHeaders.push('Refer-To: <' + transferTarget + '>');
  this.logger.debug('refer options : ' + JSON.stringify(options));
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.getReferOptions = function(sessionToTransfer, targetDialogSession, options) {
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];
  if (sessionToTransfer.supports("tdialog")) {
    options.extraHeaders.push('Require: tdialog');
    var localTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.remote_tag : targetDialogSession.dialog.id.local_tag;
    var remoteTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.local_tag : targetDialogSession.dialog.id.remote_tag;
    var targetDialog = targetDialogSession.dialog.id.call_id + ";local-tag=" + localTag + ";remote-tag=" + remoteTag;
    options.extraHeaders.push('Target-Dialog: ' + targetDialog);
  }
  return options;
};

UA.prototype.getReferSession = function(sessionToTransfer, options) {
  if (sessionToTransfer.supports("tdialog")) {
    return this.newSession(options);
  } else {
    this.logger.warn('tdialog not supported - sending refer in same session : ' + sessionToTransfer.id, this);
    return sessionToTransfer;
  }
};

UA.prototype.newSession = function(options) {
  var session = new RTCSession(this);
  session.initRtcMediaHandler(options);
  return session;
};

UA.prototype.getUserMedia = function(options, success, failure, force) {
  if (!force && this.localMedia) {
    return this.localMedia;
  }

  if (this.localMedia) {
    this.logger.log("stopping existing local media stream", this);
    this.localMedia.stop();
  }

  this.logger.log('options : ' + Utils.toString(options), this);
  var self = this;
  var constraints = options.mediaConstraints || {
    audio: true,
    video: true
  };
  WebRTC.getUserMedia(constraints,
    function(stream) {
      self.logger.log('got local media stream', self);
      self.localMedia = stream;
      success(stream);
    },
    function(e) {
      self.logger.error('unable to get user media');
      self.logger.error(e);
      failure(e);
    }
  );
};

/**
 * Gracefully close.
 *
 */
UA.prototype.stop = function() {
  var session, applicant,
    ua = this;

  this.logger.log('user requested closure...');

  // Remove dynamic settings.
  this.dynConfiguration = {};

  if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.warn('UA already closed');
    return;
  }

  // Clear transportRecoveryTimer
  clearTimeout(this.transportRecoveryTimer);

  // Close registrator
  if (this._registrator) {
    this.logger.debug('closing registrator');
    this._registrator.close();
  }

  // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.
  var num_sessions = Object.keys(this.sessions).length;

  // Run  _terminate_ on every Session
  for (session in this.sessions) {
    this.logger.log('closing session ' + session, this);
    this.sessions[session].terminate();
  }

  // Run  _close_ on every applicant
  for (applicant in this.applicants) {
    this.applicants[applicant].close();
  }

  this.status = C.STATUS_USER_CLOSED;
  // If there are no pending non-INVITE client or server transactions and no
  // sessions, then disconnect now. Otherwise wait for 2 seconds.
  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0 && num_sessions === 0) {
    ua.transport.disconnect();
  } else {
    setTimeout(function() {
      ua.transport.disconnect();
    }, 2000);
  }
};

UA.prototype.reconnect = function() {
  this.logger.debug('************** reconnect');
  this.stop();
  this.status = C.STATUS_INIT;
  this.start();
};

/**
 * Connect to the WS server if status = STATUS_INIT.
 * Resume UA after being closed.
 */
UA.prototype.start = function() {
  var server;

  this.logger.debug('user requested startup... : ', this.status);

  if (this.status === C.STATUS_INIT) {
    server = this.getNextWsServer({
      force: true
    });
    this.transport = new Transport(this, server);
    this.transport.connect();
  } else if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.log('resuming');
    this.status = C.STATUS_READY;
    this.transport.connect();
  } else if (this.status === C.STATUS_READY) {
    this.logger.log('UA is in READY status, not resuming');
  } else {
    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
  }

  // Set dynamic configuration.
  this.dynConfiguration.register = this.configuration.register;
};

/**
 * Register.
 */
UA.prototype.register = function() {
  this.dynConfiguration.register = true;
  this._registrator.register();
};

/**
 * Unregister.
 */
UA.prototype.unregister = function(options) {
  this.dynConfiguration.register = false;
  this._registrator.unregister(options);
};

/**
 * Get the Registrator instance.
 */
UA.prototype.registrator = function() {
  return this._registrator;
};

/**
 * Registration state.
 */
UA.prototype.isRegistered = function() {
  if (this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

/**
 * Make an outgoing call.
 *
 * -param {String} target
 * -param {Object} views
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.call = function(target, options) {
  var session;

  session = new RTCSession(this);
  session.connect(target, options);
  return session;
};

/**
 * Send a message.
 *
 * -param {String} target
 * -param {String} body
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.sendMessage = function(target, body, options) {
  var message;

  message = new Message(this);
  message.send(target, body, options);
};

/**
 * Normalice a string into a valid SIP request URI
 * -param {String} target
 * -returns {URI|undefined}
 */
UA.prototype.normalizeTarget = function(target) {
  return Utils.normalizeTarget(target, this.configuration.hostport_params);
};

UA.prototype.setRtcMediaHandlerOptions = function(rtcMediaHandlerOptions) {
  this.rtcMediaHandlerOptions = rtcMediaHandlerOptions;
};

UA.prototype.rtcConstraints = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.RTCConstraints : false;
};

UA.prototype.reuseLocalMedia = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.reuseLocalMedia : false;
};

//===============================
//  Private (For internal use)
//===============================

UA.prototype.saveCredentials = function(credentials) {
  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
};

UA.prototype.getCredentials = function(request) {
  var realm, credentials;

  realm = request.ruri.host;

  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
    credentials = this.cache.credentials[realm][request.ruri];
    credentials.method = request.method;
  }

  return credentials;
};

UA.prototype.getLogger = function(category, label) {
  return this.log.getLogger(category, label);
};


//==========================
// Event Handlers
//==========================

/**
 * Transport Close event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportClosed = function(transport) {
  // Run _onTransportError_ callback on every client transaction using _transport_
  var type, idx, length,
    client_transactions = ['nict', 'ict', 'nist', 'ist'];

  transport.server.status = Transport.C.STATUS_DISCONNECTED;
  this.logger.log('connection state set to ' + Transport.C.STATUS_DISCONNECTED, this);

  length = client_transactions.length;
  for (type = 0; type < length; type++) {
    for (idx in this.transactions[client_transactions[type]]) {
      this.transactions[client_transactions[type]][idx].onTransportError();
    }
  }

  // Close sessions if GRUU is not being used
  if (!this.contact.pub_gruu) {
    this.closeSessionsOnTransportError();
  }
};

/**
 * Unrecoverable transport event.
 * Connection reattempt logic has been done and didn't success.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportError = function(transport, options) {
  options = options || {};
  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to ' + Transport.C.STATUS_ERROR, this);

  // Close sessions.
  //Mark this transport as 'down' and try the next one
  transport.server.status = Transport.C.STATUS_ERROR;

  this.closeSessionsOnTransportError();
  if (!this.error || this.error !== C.NETWORK_ERROR) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.NETWORK_ERROR;
  }
  // Transport Recovery process
  this.recoverTransport(options);

  var data = Utils.merge_options({
    transport: transport,
    code: transport.lastTransportError.code,
    reason: transport.lastTransportError.reason
  }, options);
  this.emit('disconnected', this, data);
};

/**
 * Transport connection event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportConnected = function(transport) {
  this.transport = transport;

  // Reset transport recovery counter
  this.transportRecoverAttempts = 0;

  transport.server.status = Transport.C.STATUS_READY;
  this.logger.log('connection state set to ' + Transport.C.STATUS_READY, this);

  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.status = C.STATUS_READY;
  this.error = null;
  this.emit('connected', this, {
    transport: transport
  });

  if (this.dynConfiguration.register) {
    if (this._registrator) {
      this._registrator.onTransportConnected();
    } else {
      this._registrator = new Registrator(this, transport);
      this.register();
    }
  } else if (!this._registrator) {
    this._registrator = new Registrator(this, transport);
  }
};

/**
 * Transport connecting event
 */
UA.prototype.onTransportConnecting = function(transport, attempts) {
  this.emit('connecting', this, {
    transport: transport,
    attempts: attempts
  });
};


/**
 * new Transaction
 */
UA.prototype.newTransaction = function(transaction) {
  this.transactions[transaction.type][transaction.id] = transaction;
  this.emit('newTransaction', this, {
    transaction: transaction
  });
};


/**
 * Transaction destroyed.
 */
UA.prototype.destroyTransaction = function(transaction) {
  delete this.transactions[transaction.type][transaction.id];
  this.emit('transactionDestroyed', this, {
    transaction: transaction
  });
};


//=========================
// receiveRequest
//=========================

/**
 * Request reception
 * @private
 * @param {IncomingRequest} request.
 */
UA.prototype.receiveRequest = function(request) {
  var dialog, session, message,
    method = request.method;

  // Check that Ruri points to us
  if (request.ruri.user !== this.configuration.uri.user && request.ruri.user !== this.contact.uri.user) {
    this.logger.warn('Request-URI (' + request.ruri.user + ') does not point to us (' + this.configuration.uri.user + ')', this);
    if (request.method !== ExSIP_C.ACK) {
      request.reply_sl(404);
    }
    return;
  }

  // Check request URI scheme
  if (request.ruri.scheme === ExSIP_C.SIPS) {
    request.reply_sl(416);
    return;
  }

  // Check transaction
  if (Transactions.checkTransaction(this, request)) {
    this.logger.warn('Check Transaction failed', this);
    return;
  }

  // Create the server transaction
  if (method === ExSIP_C.INVITE) {
    new Transactions.InviteServerTransaction(request, this);
  } else if (method !== ExSIP_C.ACK && method !== ExSIP_C.CANCEL) {
    new Transactions.NonInviteServerTransaction(request, this);
  }

  /* RFC3261 12.2.2
   * Requests that do not change in any way the state of a dialog may be
   * received within a dialog (for example, an OPTIONS request).
   * They are processed as if they had been received outside the dialog.
   */
  if (method === ExSIP_C.OPTIONS) {
    request.reply(200);
  } else if (method === ExSIP_C.MESSAGE) {
    if (!this.checkEvent('newMessage') || this.listeners('newMessage').length === 0) {
      request.reply(405);
      return;
    }
    message = new Message(this);
    message.init_incoming(request);
  } else if (method === ExSIP_C.INVITE) {
    if (!this.checkEvent('newRTCSession') || this.listeners('newRTCSession').length === 0) {
      request.reply(405);
      return;
    }
  }

  // Initial Request
  if (!request.to_tag) {
    switch (method) {
      case ExSIP_C.INVITE:
        if (WebRTC.isSupported) {
          this.logger.debug('INVITE received', this);
          session = new RTCSession(this);
          session.init_incoming(request);
        } else {
          this.logger.warn('INVITE received but WebRTC is not supported', this);
          request.reply(488);
        }
        break;
      case ExSIP_C.BYE:
        // Out of dialog BYE received
        request.reply(481);
        break;
      case ExSIP_C.CANCEL:
        session = this.findSession(request);
        if (session) {
          session.receiveRequest(request);
        } else {
          this.logger.warn('received CANCEL request for a non existent session', this);
        }
        break;
      case ExSIP_C.ACK:
        /* Absorb it.
         * ACK request without a corresponding Invite Transaction
         * and without To tag.
         */
        break;
      default:
        request.reply(405);
        break;
    }
  }
  // In-dialog request
  else {
    dialog = this.findDialog(request);

    if (dialog) {
      dialog.receiveRequest(request);
    } else if (method === ExSIP_C.NOTIFY) {
      session = this.findSession(request);
      if (session) {
        this.logger.log('received NOTIFY request for session : ' + session.id, this);
        session.receiveRequest(request);
      } else {
        this.logger.warn('received NOTIFY request for a non existent session', this);
        this.logger.log('request : ' + (request.call_id + "-" + request.from_tag + "-" + request.to_tag), this);
        this.logger.log('sessions : ' + Object.keys(this.sessions), this);
        request.reply(481, 'Subscription does not exist');
      }
    }
    /* RFC3261 12.2.2
     * Request with to tag, but no matching dialog found.
     * Exception: ACK for an Invite request for which a dialog has not
     * been created.
     */
    else {
      if (method !== ExSIP_C.ACK) {
        request.reply(481);
      }
    }
  }
};

//=================
// Utils
//=================

/**
 * Get the session to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest} request.
 * @returns {OutgoingSession|IncomingSession|null}
 */
UA.prototype.findSession = function(request) {
  var
    sessionIDa = request.call_id + request.from_tag,
    sessionA = this.sessions[sessionIDa],
    sessionIDb = request.call_id + request.to_tag,
    sessionB = this.sessions[sessionIDb];

  if (sessionA) {
    return sessionA;
  } else if (sessionB) {
    return sessionB;
  } else {
    return null;
  }
};

/**
 * Get the dialog to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest}
 * @returns {Dialog|null}
 */
UA.prototype.findDialog = function(request) {
  var
    id = request.call_id + request.from_tag + request.to_tag,
    dialog = this.dialogs[id];

  if (dialog) {
    return dialog;
  } else {
    id = request.call_id + request.to_tag + request.from_tag;
    dialog = this.dialogs[id];
    if (dialog) {
      return dialog;
    } else {
      return null;
    }
  }
};

/**
 * Retrieve the next server to which connect.
 * @private
 * @returns {Object} ws_server
 */
UA.prototype.getNextWsServer = function(options) {
  options = options || {};

  // reset if all servers have been used
  if (options.force && this.usedServers.length >= this.configuration.ws_servers.length) {
    this.usedServers = [];
  }

  var candidates = [];
  var totalWeight = 0;
  // Add only server with status ready and not already used
  for (var i = 0; i < this.configuration.ws_servers.length; i++) {
    var server = this.configuration.ws_servers[i];
    if (server.status === Transport.C.STATUS_READY && this.usedServers.indexOf(server) === -1) {
      candidates.push(server);
      totalWeight += (server.weight || 1);
    }
  }

  var weightedServers = []; //new array to hold "weighted" servers
  for (var j = 0; j < candidates.length; j++) {
    var candidate = candidates[j];
    for (var k = 0; k < (candidate.weight || 1); k++) {
      weightedServers.push(candidate);
    }
  }

  var randomNumber = Math.floor(Math.random() * totalWeight);
  var index = Math.min(randomNumber, weightedServers.length - 1);
  return weightedServers[index];
};

/**
 * Close all sessions on transport error.
 */
UA.prototype.closeSessionsOnTransportError = function() {
  var idx;

  // Run _transportError_ for every Session
  for (idx in this.sessions) {
    this.sessions[idx].onTransportError();
  }
  // Call registrator _onTransportClosed_
  this._registrator.onTransportClosed();
};

UA.prototype.loadConfig = function(configuration) {
  // Settings and default values
  var parameter, value, checked_value, hostport_params, registrar_server,
    settings = {
      /* Host address
       * Value to be set in Via sent_by and host part of Contact FQDN
       */
      via_host: this.configuration.via_host || (Utils.createRandomToken(12) + '.invalid'),

      // Password
      password: null,

      // Registration parameters
      register_expires: 600,
      register: true,
      registrar_server: null,

      // Transport related parameters
      ws_server_max_reconnection: 3,
      ws_server_reconnection_timeout: 4,

      connection_recovery_min_interval: 2,
      connection_recovery_max_interval: 30,

      use_preloaded_route: false,

      // Session parameters
      no_answer_timeout: 60,
      stun_servers: ['stun:stun.l.google.com:19302'],
      turn_servers: [],

      // Logging parameters
      trace_sip: false,

      // Hacks
      hack_via_tcp: false,
      hack_via_ws: false,
      hack_ip_in_contact: false,
      enable_datachannel: false,
      enable_ims: false,
      p_asserted_identity: null,

      // Options for Node.
      node_ws_options: {}
    };

  // Pre-Configuration

  // Check Mandatory parameters
  for (parameter in UA.configuration_check.mandatory) {
    if (!configuration.hasOwnProperty(parameter)) {
      throw new Exceptions.ConfigurationError(parameter);
    } else {
      value = configuration[parameter];
      checked_value = UA.configuration_check.mandatory[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Check Optional parameters
  for (parameter in UA.configuration_check.optional) {
    if (configuration.hasOwnProperty(parameter)) {
      value = configuration[parameter];

      /* If the parameter value is null, empty string, undefined, empty array
       * or it's a number with NaN value, then apply its default value.
       */
      if (Utils.isEmpty(value)) {
        continue;
      }

      checked_value = UA.configuration_check.optional[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Sanity Checks

  // Connection recovery intervals
  if (settings.connection_recovery_max_interval < settings.connection_recovery_min_interval) {
    throw new Exceptions.ConfigurationError('connection_recovery_max_interval', settings.connection_recovery_max_interval);
  }

  // Post Configuration Process

  // Allow passing 0 number as display_name.
  if (settings.display_name === 0) {
    settings.display_name = '0';
  }

  // Instance-id for GRUU
  if (!settings.instance_id) {
    settings.instance_id = this.configuration.instance_id || Utils.newUUID();
  }

  // ExSIP_id instance parameter. Static random tag of length 5
  settings.exsip_id = this.configuration.exsip_id || Utils.createRandomToken(5);

  // String containing settings.uri without scheme and user.
  hostport_params = settings.uri.clone();
  hostport_params.user = null;
  settings.hostport_params = hostport_params.toString().replace(/^sip:/i, '');

  /* Check whether authorization_user is explicitly defined.
   * Take 'settings.uri.user' value if not.
   */
  if (!settings.authorization_user) {
    settings.authorization_user = settings.uri.user;
  }

  /* If no 'registrar_server' is set use the 'uri' value without user portion. */
  if (!settings.registrar_server) {
    registrar_server = settings.uri.clone();
    registrar_server.user = null;
    settings.registrar_server = registrar_server;
  }

  // User no_answer_timeout
  settings.no_answer_timeout = settings.no_answer_timeout * 1000;

  // Via Host
  if (settings.hack_ip_in_contact) {
    settings.via_host = Utils.getRandomTestNetIP();
  }

  // Set empty Stun Server Set if explicitly passed an empty Array
  value = configuration.stun_servers;
  if (value instanceof Array && value.length === 0) {
    settings.stun_servers = [];
  }

  this.contact = this.contact || {
    pub_gruu: null,
    temp_gruu: null,
    uri: new URI('sip', Utils.createRandomToken(8), settings.via_host, null, {
      transport: 'ws'
    }),
    toString: function(options) {
      options = options || {};

      var
        anonymous = options.anonymous || null,
        outbound = options.outbound || null,
        contact = '<';

      if (anonymous) {
        contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';
      } else {
        contact += this.pub_gruu || this.uri.toString();
      }

      if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {
        contact += ';ob';
      }

      contact += '>';

      return contact;
    }
  };

  // Fill the value of the configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = settings[parameter];
  }

  Object.defineProperties(this.configuration, UA.configuration_skeleton);

  // Clean UA.configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = '';
  }

  this.logger.debug('configuration parameters after validation:');
  for (parameter in settings) {
    switch (parameter) {
      case 'uri':
      case 'registrar_server':
        this.logger.debug('· ' + parameter + ': ' + settings[parameter]);
        break;
      case 'password':
        this.logger.debug('· ' + parameter + ': ' + 'NOT SHOWN');
        break;
      default:
        this.logger.debug('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
    }
  }

  // Initialize registrator
  this._registrator = new Registrator(this);

  return;
};

UA.prototype.retry = function(nextRetry, server, callback) {
  var self = this;
  var retryCallback = function() {
    var transport = new Transport(self, server);
    if (callback) {
      callback(transport);
    }
  };

  if (nextRetry === 0) {
    retryCallback();
  } else {
    setTimeout(retryCallback, nextRetry * 1000);
  }
};

UA.prototype.recoverTransport = function(options) {
  var idx, length, k, nextRetry, count, server;

  options = options || {};
  count = this.transportRecoverAttempts;

  length = this.configuration.ws_servers.length;
  for (idx = 0; idx < length; idx++) {
    this.configuration.ws_servers[idx].status = Transport.C.STATUS_READY;
  }

  server = this.getNextWsServer();
  if (options.code === 503 && !server) {
    delete options.retryAfter;
    this.logger.log('non-failover on 503 error - skipping recoverTransport', this);
    return;
  }

  var maxTransportRecoveryAttempts = this.configuration.max_transport_recovery_attempts;
  if (typeof(maxTransportRecoveryAttempts) !== "undefined" && count >= parseInt(maxTransportRecoveryAttempts, 10)) {
    delete options.retryAfter;
    this.logger.log('recover attempts ' + count + " exceed max transport recovery attempts " + maxTransportRecoveryAttempts + " - skipping recoverTransport");
    return;
  }

  if (server) {
    this.logger.log('failover - new connection attempt with ' + server.ws_uri);
    this.retry(0, server, options.retryCallback);
    return;
  }

  if (options.retryAfter) {
    nextRetry = options.retryAfter;
  } else {
    k = Math.floor((Math.random() * Math.pow(2, count)) + 1);
    nextRetry = k * this.configuration.connection_recovery_min_interval;

    if (nextRetry > this.configuration.connection_recovery_max_interval) {
      this.logger.log('time for next connection attempt exceeds connection_recovery_max_interval, resetting counter', this);
      nextRetry = this.configuration.connection_recovery_min_interval;
      count = 0;
    }
  }

  server = this.getNextWsServer({
    force: true
  });
  this.transportRecoverAttempts = count + 1;
  this.logger.log('resetting ws server list - next connection attempt in ' + nextRetry + ' seconds to ' + server.ws_uri + ' : ' + this.transportRecoverAttempts);
  this.retry(nextRetry, server, options.retryCallback);
};

/**
 * Configuration Object skeleton.
 */
/**
 * Configuration Object skeleton.
 */
UA.configuration_skeleton = (function() {
  var idx, parameter,
    skeleton = {},
    parameters = [
      // Internal parameters
      "exsip_id",
      "ws_server_max_reconnection",
      "ws_server_reconnection_timeout",
      "hostport_params",

      // Mandatory user configurable parameters
      "uri",
      "ws_servers",

      // Optional user configurable parameters
      "authorization_user",
      "connection_recovery_max_interval",
      "connection_recovery_min_interval",
      "max_transport_recovery_attempts",
      "display_name",
      "hack_via_tcp", // false
      "hack_via_ws", // false
      "hack_ip_in_contact", //false
      "instance_id",
      "no_answer_timeout", // 30 seconds
      "node_ws_options",
      "password",
      "register_expires", // 600 seconds
      "registrar_server",
      "stun_servers",
      "trace_sip",
      "turn_servers",
      "use_preloaded_route",
      "enable_datachannel",
      "enable_ims",
      "p_asserted_identity",

      // Post-configuration generated parameters
      "via_core_value",
      "via_host"
    ];

  for (idx in parameters) {
    parameter = parameters[idx];
    skeleton[parameter] = {
      value: '',
      writable: false,
      configurable: true
    };
  }

  skeleton.register = {
    value: '',
    writable: true,
    configurable: true
  };

  return skeleton;
}());

/**
 * Configuration checker.
 */
UA.configuration_check = {
  mandatory: {

    uri: function(uri) {
      var parsed;

      if (!/^sip:/i.test(uri)) {
        uri = ExSIP_C.SIP + ':' + uri;
      }
      parsed = URI.parse(uri);

      if (!parsed) {
        return;
      } else if (!parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    ws_servers: function(ws_servers) {
      var idx, length, url;

      /* Allow defining ws_servers parameter as:
       *  String: "host"
       *  Array of Strings: ["host1", "host2"]
       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
       */
      if (typeof ws_servers === 'string') {
        ws_servers = [{
          ws_uri: ws_servers
        }];
      } else if (ws_servers instanceof Array) {
        length = ws_servers.length;
        for (idx = 0; idx < length; idx++) {
          if (typeof ws_servers[idx] === 'string') {
            ws_servers[idx] = {
              ws_uri: ws_servers[idx]
            };
          }
        }
      } else {
        return;
      }

      if (ws_servers.length === 0) {
        return false;
      }

      length = ws_servers.length;
      for (idx = 0; idx < length; idx++) {
        if (!ws_servers[idx].ws_uri) {
          this.logger.error('missing "ws_uri" attribute in ws_servers parameter');
          return;
        }
        if (ws_servers[idx].weight && !Number(ws_servers[idx].weight)) {
          this.logger.error('"weight" attribute in ws_servers parameter must be a Number');
          return;
        }

        url = Grammar.parse(ws_servers[idx].ws_uri, 'absoluteURI');

        if (url === -1) {
          this.logger.error('invalid "ws_uri" attribute in ws_servers parameter: ' + ws_servers[idx].ws_uri);
          return;
        } else if (url.scheme !== 'wss' && url.scheme !== 'ws') {
          this.logger.error('invalid URI scheme in ws_servers parameter: ' + url.scheme);
          return;
        } else {
          ws_servers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';

          if (!ws_servers[idx].weight) {
            ws_servers[idx].weight = 0;
          }

          ws_servers[idx].status = 0;
          ws_servers[idx].scheme = url.scheme.toUpperCase();
        }
      }
      return ws_servers;
    }
  },

  optional: {

    authorization_user: function(authorization_user) {
      if (Grammar.parse('"' + authorization_user + '"', 'quoted_string') === -1) {
        return;
      } else {
        return authorization_user;
      }
    },

    connection_recovery_max_interval: function(connection_recovery_max_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_max_interval)) {
        value = Number(connection_recovery_max_interval);
        if (value > 0) {
          return value;
        }
      }
    },

    connection_recovery_min_interval: function(connection_recovery_min_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_min_interval)) {
        value = Number(connection_recovery_min_interval);
        if (value >= 0) {
          return value;
        }
      }
    },

    display_name: function(display_name) {
      if (Grammar.parse('"' + display_name + '"', 'display_name') === -1) {
        return;
      } else {
        return display_name;
      }
    },

    hack_via_tcp: function(hack_via_tcp) {
      if (typeof hack_via_tcp === 'boolean') {
        return hack_via_tcp;
      }
    },

    hack_via_ws: function(hack_via_ws) {
      if (typeof hack_via_ws === 'boolean') {
        return hack_via_ws;
      }
    },

    hack_ip_in_contact: function(hack_ip_in_contact) {
      if (typeof hack_ip_in_contact === 'boolean') {
        return hack_ip_in_contact;
      }
    },

    enable_ims: function(enable_ims) {
      if (typeof enable_ims === 'boolean') {
        return enable_ims;
      }
    },

    ws_server_reconnection_timeout: function(ws_server_reconnection_timeout) {
      var value;
      if (Utils.isDecimal(ws_server_reconnection_timeout)) {
        value = Number(ws_server_reconnection_timeout);
        if (value >= 0) {
          return value;
        }
      }
    },

    max_transport_recovery_attempts: function(max_transport_recovery_attempts) {
      var value;
      if (Utils.isDecimal(max_transport_recovery_attempts)) {
        value = Number(max_transport_recovery_attempts);
        if (value >= 0) {
          return value;
        }
      }
    },

    p_asserted_identity: function(p_asserted_identity) {
      return String(p_asserted_identity);
    },

    enable_datachannel: function(enable_datachannel) {
      if (typeof enable_datachannel === 'boolean') {
        return enable_datachannel;
      }
    },

    instance_id: function(instance_id) {
      if ((/^uuid:/i.test(instance_id))) {
        instance_id = instance_id.substr(5);
      }

      if (Grammar.parse(instance_id, 'uuid') === -1) {
        return;
      } else {
        return instance_id;
      }
    },

    no_answer_timeout: function(no_answer_timeout) {
      var value;
      if (Utils.isDecimal(no_answer_timeout)) {
        value = Number(no_answer_timeout);
        if (value > 0) {
          return value;
        }
      }
    },

    node_ws_options: function(node_ws_options) {
      return (typeof node_ws_options === 'object') ? node_ws_options : {};
    },

    password: function(password) {
      return String(password);
    },

    register: function(register) {
      if (typeof register === 'boolean') {
        return register;
      }
    },

    register_expires: function(register_expires) {
      var value;
      if (Utils.isDecimal(register_expires)) {
        value = Number(register_expires);
        if (value > 0) {
          return value;
        }
      }
    },

    registrar_server: function(registrar_server) {
      var parsed;

      if (!/^sip:/i.test(registrar_server)) {
        registrar_server = ExSIP_C.SIP + ':' + registrar_server;
      }
      parsed = URI.parse(registrar_server);

      if (!parsed) {
        return;
      } else if (parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    stun_servers: function(stun_servers) {
      var idx, length, stun_server;

      if (typeof stun_servers === 'string') {
        stun_servers = [stun_servers];
      } else if (!(stun_servers instanceof Array)) {
        return;
      }

      length = stun_servers.length;
      for (idx = 0; idx < length; idx++) {
        stun_server = stun_servers[idx];
        if (!(/^stuns?:/.test(stun_server))) {
          stun_server = 'stun:' + stun_server;
        }

        if (Grammar.parse(stun_server, 'stun_URI') === -1) {
          return;
        } else {
          stun_servers[idx] = stun_server;
        }
      }
      return stun_servers;
    },

    trace_sip: function(trace_sip) {
      if (typeof trace_sip === 'boolean') {
        return trace_sip;
      }
    },

    turn_servers: function(turn_servers) {
      var idx, idx2, length, length2, turn_server, url;

      if (!turn_servers instanceof Array) {
        turn_servers = [turn_servers];
      }

      length = turn_servers.length;
      for (idx = 0; idx < length; idx++) {
        turn_server = turn_servers[idx];

        // Backward compatibility:
        //Allow defining the turn_server 'urls' with the 'server' property.
        if (turn_server.server) {
          turn_server.urls = [turn_server.server];
        }

        // Backward compatibility:
        //Allow defining the turn_server 'credential' with the 'password' property.
        if (turn_server.password) {
          turn_server.credential = [turn_server.password];
        }

        if (!turn_server.urls || !turn_server.username || !turn_server.credential) {
          return;
        }

        if (!(turn_server.urls instanceof Array)) {
          turn_server.urls = [turn_server.urls];
        }

        length2 = turn_server.urls.length;
        for (idx2 = 0; idx2 < length2; idx2++) {
          url = turn_server.urls[idx2];

          if (!(/^turns?:/.test(url))) {
            url = 'turn:' + url;
          }

          if (Grammar.parse(url, 'turn_URI') === -1) {
            return;
          }
        }
      }
      return turn_servers;
    },

    use_preloaded_route: function(use_preloaded_route) {
      if (typeof use_preloaded_route === 'boolean') {
        return use_preloaded_route;
      }
    }
  }
};
},{"./Constants":871,"./EventEmitter":875,"./Exceptions":877,"./Grammar":878,"./LoggerFactory":880,"./Message":881,"./RTCSession":884,"./Registrator":888,"./Transactions":892,"./Transport":893,"./URI":895,"./Utils":896,"./WebRTC":897}],895:[function(require,module,exports){
module.exports = URI;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var Grammar = require('./Grammar');


/**
 * -param {String} [scheme]
 * -param {String} [user]
 * -param {String} host
 * -param {String} [port]
 * -param {Object} [parameters]
 * -param {Object} [headers]
 *
 */
function URI(scheme, user, host, port, parameters, headers) {
  var param, header;

  // Checks
  if(!host) {
    throw new TypeError('missing or invalid "host" parameter');
  }

  // Initialize parameters
  scheme = scheme || ExSIP_C.SIP;
  this.parameters = {};
  this.headers = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  for (header in headers) {
    this.setHeader(header, headers[header]);
  }

  Object.defineProperties(this, {
    scheme: {
      get: function(){ return scheme; },
      set: function(value){
        scheme = value.toLowerCase();
      }
    },

    user: {
      get: function(){ return user; },
      set: function(value){
        user = value;
      }
    },

    host: {
      get: function(){ return host; },
      set: function(value){
        host = value.toLowerCase();
      }
    },

    port: {
      get: function(){ return port; },
      set: function(value){
        port = value === 0 ? value : (parseInt(value,10) || null);
      }
    }
  });
}


URI.prototype = {
  setParam: function(key, value) {
    if(key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  getHeader: function(name) {
    if(name) {
      return this.headers[Utils.headerize(name)];
    }
  },

  hasHeader: function(name) {
    if(name) {
      return (this.headers.hasOwnProperty(Utils.headerize(name)) && true) || false;
    }
  },

  deleteHeader: function(header) {
    var value;
    header = Utils.headerize(header);
    if(this.headers.hasOwnProperty(header)) {
      value = this.headers[header];
      delete this.headers[header];
      return value;
    }
  },

  clearHeaders: function() {
    this.headers = {};
  },

  isPhoneNumber: function() {
    return this.user && this.user.match(/^\+?\d+$/) !== null;
  },

  clone: function() {
    return new URI(
      this.scheme,
      this.user,
      this.host,
      this.port,
      JSON.parse(JSON.stringify(this.parameters)),
      JSON.parse(JSON.stringify(this.headers)));
  },

  toString: function(){
    var header, parameter, idx, uri,
      headers = [];

    uri  = this.scheme + ':';
    if (this.user) {
      uri += Utils.escapeUser(this.user) + '@';
    }
    uri += this.host;
    if (this.port || this.port === 0) {
      uri += ':' + this.port;
    }

    for (parameter in this.parameters) {
      uri += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        uri += '='+ this.parameters[parameter];
      }
    }

    for(header in this.headers) {
      for(idx in this.headers[header]) {
        headers.push(header + '=' + this.headers[header][idx]);
      }
    }

    if (headers.length > 0) {
      uri += '?' + headers.join('&');
    }

    return uri;
  },

  toAor: function(show_port){
      var aor;

      aor  = this.scheme + ':';
      if (this.user) {
        aor += Utils.escapeUser(this.user) + '@';
      }
      aor += this.host;
      if (show_port && (this.port || this.port === 0)) {
        aor += ':' + this.port;
      }

      return aor;
  }
};


/**
  * Parse the given string and returns a ExSIP.URI instance or undefined if
  * it is an invalid URI.
  */
URI.parse = function(uri) {
  uri = Grammar.parse(uri,'SIP_URI');

  if (uri !== -1) {
    return uri;
  } else {
    return undefined;
  }
};
},{"./Constants":871,"./Grammar":878,"./Utils":896}],896:[function(require,module,exports){
var Utils = {};

module.exports = Utils;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var URI = require('./URI');
var Grammar = require('./Grammar');

Utils.inArray = function(array, el) {
  for (var i = array.length; i--;) {
    if (array[i] === el) {
      return true;
    }
  }
  return false;
};

Utils.isEqArrays = function(arr1, arr2) {
  if (arr1 === null && arr2 !== null) {
    return false;
  }
  if (arr1 !== null && arr2 === null) {
    return false;
  }
  if (arr1 === null && arr2 === null) {
    return true;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (var i = arr1.length; i--;) {
    if (!this.inArray(arr2, arr1[i])) {
      return false;
    }
  }
  return true;
};

/**
 * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
 * @param obj1
 * @param obj2
 * @returns obj3 a new object based on obj1 and obj2
 */
Utils.merge_options = function(obj1, obj2) {
  var obj3 = {};
  for (var attrname1 in obj1) {
    obj3[attrname1] = obj1[attrname1];
  }
  for (var attrname2 in obj2) {
    obj3[attrname2] = obj2[attrname2];
  }
  return obj3;
};

Utils.containsHeader = function(headers, name) {
  for (var i = 0; i < headers.length; i++) {
    if (headers[i].indexOf(name) !== -1) {
      return true;
    }
  }
  return false;
};

Utils.str_utf8_length = function(string) {
  return unescape(encodeURIComponent(string)).length;
};

Utils.toString = function(object) {
  var seen = [];

  return JSON.stringify(object, function(key, val) {
    if (typeof val === "object") {
      if (seen.indexOf(val) >= 0) {
        return;
      }
      seen.push(val);
    }
    return val;
  });
};

Utils.isFunction = function(fn) {
  if (fn !== undefined) {
    return (Object.prototype.toString.call(fn) === '[object Function]') ? true : false;
  } else {
    return false;
  }
};

Utils.isDecimal = function(num) {
  return !isNaN(num) && (parseFloat(num) === parseInt(num, 10));
};

Utils.getHeadersFromQuery = function(query) {
  var headers = [];
  var queryParts = query.split("&");
  for (var i = 0; i < queryParts.length; i++) {
    var parameters = queryParts[i].split("=");
    headers.push(parameters[0] + ": " + decodeURIComponent(parameters[1]));
  }
  return headers;
};

Utils.stripSip = function(address) {
  var match = address.match(/<sip\:(.*)\>/);
  return match ? match[1] : address;
};

Utils.isEmpty = function(value) {
  if (value === null || value === "" || value === undefined || (value instanceof Array && value.length === 0) || (typeof(value) === 'number' && isNaN(value))) {
    return true;
  }
};

Utils.getAllowedMethods = function(ua) {
  var event,
    allowed = ExSIP_C.ALLOWED_METHODS.toString();

  for (event in ExSIP_C.EVENT_METHODS) {
    if (ua.checkEvent(event) && ua.listeners(event).length > 0) {
      allowed += ',' + ExSIP_C.EVENT_METHODS[event];
    }
  }

  return allowed;
};

Utils.createRandomToken = function(size, base) {
  var i, r,
    token = '';

  base = base || 32;

  for (i = 0; i < size; i++) {
    r = Math.random() * base | 0;
    token += r.toString(base);
  }
  return token;
};

Utils.newTag = function() {
  return Utils.createRandomToken(10);
};

// http://stackoverflow.com/users/109538/broofa
Utils.newUUID = function() {
  var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0,
      v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });

  return UUID;
};

Utils.hostType = function(host) {
  if (!host) {
    return;
  } else {
    host = Grammar.parse(host, 'host');
    if (host !== -1) {
      return host.host_type;
    }
  }
};

/**
 * Normalize SIP URI.
 * NOTE: It does not allow a SIP URI without username.
 * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
 * Detects the domain part (if given) and properly hex-escapes the user portion.
 * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
 */
Utils.normalizeTarget = function(target, domain) {
  var uri, target_array, target_user, target_domain;

  // If no target is given then raise an error.
  if (!target) {
    return;
    // If a URI instance is given then return it.
  } else if (target instanceof URI) {
    return target;

    // If a string is given split it by '@':
    // - Last fragment is the desired domain.
    // - Otherwise append the given domain argument.
  } else if (typeof target === 'string') {
    target_array = target.split('@');

    switch (target_array.length) {
      case 1:
        if (!domain) {
          return;
        }
        target_user = target;
        target_domain = domain;
        break;
      case 2:
        target_user = target_array[0];
        target_domain = target_array[1];
        break;
      default:
        target_user = target_array.slice(0, target_array.length - 1).join('@');
        target_domain = target_array[target_array.length - 1];
    }

    // Remove the URI scheme (if present).
    target_user = target_user.replace(/^(sips?|tel):/i, '');

    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
    if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
      target_user = target_user.replace(/[\-\.\(\)]/g, '');
    }

    // Build the complete SIP URI.
    target = ExSIP_C.SIP + ':' + Utils.escapeUser(target_user) + '@' + target_domain;

    // Finally parse the resulting URI.
    if ((uri = URI.parse(target))) {
      return uri;
    } else {
      return;
    }
  } else {
    return;
  }
};

/**
 * Hex-escape a SIP URI user.
 */
Utils.escapeUser = function(user) {
  // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
  return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
};

Utils.headerize = function(string) {
  var exceptions = {
      'Call-Id': 'Call-ID',
      'Cseq': 'CSeq',
      'Www-Authenticate': 'WWW-Authenticate'
    },
    name = string.toLowerCase().replace(/_/g, '-').split('-'),
    hname = '',
    parts = name.length,
    part;

  for (part = 0; part < parts; part++) {
    if (part !== 0) {
      hname += '-';
    }
    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
  }
  if (exceptions[hname]) {
    hname = exceptions[hname];
  }
  return hname;
};

Utils.sipErrorCause = function(status_code) {
  var cause;

  for (cause in ExSIP_C.SIP_ERROR_CAUSES) {
    if (ExSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
      return ExSIP_C.causes[cause];
    }
  }

  return ExSIP_C.causes.SIP_FAILURE_CODE;
};

/**
 * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
 */
Utils.getRandomTestNetIP = function() {
  function getOctet(from, to) {
    return Math.floor(Math.random() * (to - from + 1) + from);
  }
  return '192.0.2.' + getOctet(1, 254);
};

// MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
Utils.calculateMD5 = function(string) {
  function rotateLeft(lValue, iShiftBits) {
    return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
  }

  function addUnsigned(lX, lY) {
    var lX4, lY4, lX8, lY8, lResult;
    lX8 = (lX & 0x80000000);
    lY8 = (lY & 0x80000000);
    lX4 = (lX & 0x40000000);
    lY4 = (lY & 0x40000000);
    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
    if (lX4 & lY4) {
      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
    }
    if (lX4 | lY4) {
      if (lResult & 0x40000000) {
        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
      } else {
        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
      }
    } else {
      return (lResult ^ lX8 ^ lY8);
    }
  }

  function doF(x, y, z) {
    return (x & y) | ((~x) & z);
  }

  function doG(x, y, z) {
    return (x & z) | (y & (~z));
  }

  function doH(x, y, z) {
    return (x ^ y ^ z);
  }

  function doI(x, y, z) {
    return (y ^ (x | (~z)));
  }

  function doFF(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doGG(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doHH(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doII(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function convertToWordArray(string) {
    var lWordCount;
    var lMessageLength = string.length;
    var lNumberOfWords_temp1 = lMessageLength + 8;
    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
    var lWordArray = new Array(lNumberOfWords - 1);
    var lBytePosition = 0;
    var lByteCount = 0;
    while (lByteCount < lMessageLength) {
      lWordCount = (lByteCount - (lByteCount % 4)) / 4;
      lBytePosition = (lByteCount % 4) * 8;
      lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
      lByteCount++;
    }
    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
    lBytePosition = (lByteCount % 4) * 8;
    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
    return lWordArray;
  }

  function wordToHex(lValue) {
    var wordToHexValue = "",
      wordToHexValue_temp = "",
      lByte, lCount;
    for (lCount = 0; lCount <= 3; lCount++) {
      lByte = (lValue >>> (lCount * 8)) & 255;
      wordToHexValue_temp = "0" + lByte.toString(16);
      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
    }
    return wordToHexValue;
  }

  function utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";

    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
    }
    return utftext;
  }

  var x = [];
  var k, AA, BB, CC, DD, a, b, c, d;
  var S11 = 7,
    S12 = 12,
    S13 = 17,
    S14 = 22;
  var S21 = 5,
    S22 = 9,
    S23 = 14,
    S24 = 20;
  var S31 = 4,
    S32 = 11,
    S33 = 16,
    S34 = 23;
  var S41 = 6,
    S42 = 10,
    S43 = 15,
    S44 = 21;

  string = utf8Encode(string);

  x = convertToWordArray(string);

  a = 0x67452301;
  b = 0xEFCDAB89;
  c = 0x98BADCFE;
  d = 0x10325476;

  for (k = 0; k < x.length; k += 16) {
    AA = a;
    BB = b;
    CC = c;
    DD = d;
    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);
    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);
    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);
    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);
    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);
    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);
    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);
    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);
    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);
    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);
    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);
    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);
    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);
    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);
    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);
    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);
    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);
    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);
    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);
    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);
    a = addUnsigned(a, AA);
    b = addUnsigned(b, BB);
    c = addUnsigned(c, CC);
    d = addUnsigned(d, DD);
  }

  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

  return temp.toLowerCase();
};
},{"./Constants":871,"./Grammar":878,"./URI":895}],897:[function(require,module,exports){
var WebRTC = {};

module.exports = WebRTC;

var ExSIP_C = require('./Constants');
var Utils = require('./Utils');

// getUserMedia
if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  WebRTC.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  WebRTC.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.getUserMedia) {
  WebRTC.getUserMedia = navigator.getUserMedia.bind(navigator);
}

// RTCPeerConnection
if (typeof webkitRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = webkitRTCPeerConnection;
}
else if (typeof mozRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = mozRTCPeerConnection;
}
else if (typeof RTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = RTCPeerConnection;
}
else {
  console.log("WebRTC.RTCPeerConnection undefined");
  WebRTC.RTCPeerConnection = function(options, constraints){
    this.options = options;
    this.constraints = constraints;
  };
}

// RTCIceCandidate
if (typeof RTCIceCandidate !== 'undefined') {
  WebRTC.RTCIceCandidate = RTCIceCandidate;
}
else {
  console.log("WebRTC.RTCIceCandidate undefined");
  WebRTC.RTCIceCandidate = function(){};
}

// RTCSessionDescription
if (typeof webkitRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = webkitRTCSessionDescription;
}
else if (typeof mozRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = mozRTCSessionDescription;
}
else if (typeof RTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = RTCSessionDescription;
}
else {
  console.log("WebRTC.RTCSessionDescription undefined");
  WebRTC.RTCSessionDescription = function(options){
    options = options || {};
    this.sdp = options.sdp;
    this.type = options.type;
  };
}

WebRTC.RTCSessionDescription.prototype.getSdp = function(options){
  options = options || {};
  var sdp = this.sdp;
  if(options.additionalSdp) {
    sdp += options.additionalSdp;
  }
  return sdp;
};
WebRTC.RTCSessionDescription.prototype.getUnsupportedMedias = function(){
  var slideMedias = this.getSlidesMedias();
  var inactiveApplicationMedias = this.getApplicationMedias('0 RTP/SAVPF');
  var unsupportedMedias = slideMedias.concat(inactiveApplicationMedias);
  return unsupportedMedias;
};
WebRTC.RTCSessionDescription.prototype.removeUnsupportedMedia = function(){
  var unsupportedMedias = this.getUnsupportedMedias();
  for(var i = 0; i < unsupportedMedias.length; i++) {
    this.sdp = this.sdp.replace(unsupportedMedias[i], '');
    console.warn('removing unsupported media from sdp : '+unsupportedMedias[i]);
  }
  return unsupportedMedias.join('');
};
WebRTC.RTCSessionDescription.prototype.getSlidesMedias = function(){
  var slideMedia = this.getVideoMedias('a=content:slides');
  return slideMedia;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedias = function(filter){
  return this.getMedias('video', filter);
};
WebRTC.RTCSessionDescription.prototype.getApplicationMedias = function(filter){
  return this.getMedias('application', filter);
};
WebRTC.RTCSessionDescription.prototype.getMedias = function(type, filter){
  var regex = new RegExp("(m="+type+"(?:(?!m=)[\\s\\S])*)", "mig");
  var match;
  var results = [];
  while((match = regex.exec(this.sdp)) !== null) {
    var media = match.pop();
    if(!filter || media.indexOf(filter) !== -1) {
      results.push(media);
    }
  }
  return results;
};
WebRTC.RTCSessionDescription.prototype.getAudioIcePwd = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIcePwd = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioIceUfrag = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIceUfrag = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getCandidates = function(media){
  var regex = new RegExp("a=candidate:(.*)", "ig");
  var matches;
  var result = [];
  while ((matches = regex.exec(media)) !== null)
  {
    result.push(matches[matches.length-1]);
  }
  return result;
};
WebRTC.RTCSessionDescription.prototype.getAudioCandidates = function(){
  var audio = this.getAudio();
  return audio ? this.getCandidates(audio) : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCandidates = function(){
  var video = this.getVideo();
  return video ? this.getCandidates(video) : null;
};
WebRTC.RTCSessionDescription.prototype.getConnection = function(){
  var match = this.sdp.match(/v=(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudio = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideo = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioConnection = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.getVideoConnection = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.hasVideo = function(){
  return this.sdp.match(/m=video/) !== null;
};
WebRTC.RTCSessionDescription.prototype.hasAudio = function(){
  return this.sdp.match(/m=audio/) !== null;
};
WebRTC.RTCSessionDescription.prototype.videoPort = function(){
  var match = this.sdp.match(/m=video\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.audioPort = function(){
  var match = this.sdp.match(/m=audio\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioMedia = function(){
  var match = this.sdp.match(/m=audio\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedia = function(){
  var match = this.sdp.match(/m=video\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecs = function(){
  var audioMedia = this.getAudioMedia();
  return this.getCodecs(audioMedia);
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecs = function(){
  var videoMedia = this.getVideoMedia();
  return this.getCodecs(videoMedia);
};
WebRTC.RTCSessionDescription.prototype.getCodecs = function(media){
  if(!media) {
    return null;
  }
  var mediaParts = media.split(" ");
  return mediaParts.splice(2);
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecRtpmap = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecRtpmap = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecFmtp = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecFmtp = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioFingerprint = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoFingerprint = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioRtcp = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoRtcp = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.removeVideoFingerprint = function(){
  if(this.getVideoFingerprint()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.removeAudioFingerprint = function(){
  if(this.getAudioFingerprint()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.hasActiveVideo = function(){
  var videoPort = this.videoPort() || 0;
  var videoConnection = this.getVideoConnection() || "";
  return this.hasVideo() && videoPort > 0 && videoConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.hasActiveAudio = function(){
  var audioPort = this.audioPort() || 0;
  var audioConnection = this.getAudioConnection() || "";
  return this.hasAudio() && audioPort > 0 && audioConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.getVideoBandwidth = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*b=.*:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setVideoBandwidth = function(videoBandwidth){
  if(this.getVideoBandwidth()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(b=.*)/mi, "$1b=AS:" + videoBandwidth);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nb=AS:" + videoBandwidth);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoMode = function(mode){
  if(this.getVideoMode()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoPort = function(port){
  this.sdp = this.sdp.replace(/(m=video\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.getVideoMode = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setAudioMode = function(mode){
  if(this.getAudioMode()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*(:?(?!m=)[\s\S])*(c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioPort = function(port){
  this.sdp = this.sdp.replace(/(m=audio\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.setAudioConnection = function(audioConnection){
  if(this.getAudioConnection()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + audioConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + audioConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoConnection = function(videoConnection){
  if(this.getVideoConnection()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + videoConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + videoConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioRtcp = function(audioRtcp){
  if(this.getAudioRtcp()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + audioRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + audioRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoRtcp = function(videoRtcp){
  if(this.getVideoRtcp()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + videoRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + videoRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.getAudioMode = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.isActive = function(){
  if(this.hasAudio() && this.audioPort() !== "0" && this.getAudioMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  if(this.hasVideo() && this.videoPort() !== "0" && this.getVideoMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  return false;
};
WebRTC.RTCSessionDescription.prototype.mediaChanges = function(otherSdp){
  var mediaChanges = [];
  if(this.hasAudio() !== otherSdp.hasAudio()) {
    mediaChanges.push("audio has changed");
  }
  if(this.hasVideo() !== otherSdp.hasVideo()) {
    mediaChanges.push("video has changed");
  }
  if(this.audioPort() !== otherSdp.audioPort()) {
    mediaChanges.push("audio port has changed : "+this.audioPort()+" - " + otherSdp.audioPort());
  }
  if(this.videoPort() !== otherSdp.videoPort()) {
    mediaChanges.push("video port has changed : "+this.videoPort()+" - " + otherSdp.videoPort());
  }
  if(this.getAudioConnection() !== otherSdp.getAudioConnection()) {
    mediaChanges.push("audio connection has changed : "+this.getAudioConnection()+" - " + otherSdp.getAudioConnection());
  }
  if(this.getVideoConnection() !== otherSdp.getVideoConnection()) {
    mediaChanges.push("video connection has changed : "+this.getVideoConnection()+" - " + otherSdp.getVideoConnection());
  }
  var audioCodecs = this.getAudioCodecs();
  if(!Utils.isEqArrays(audioCodecs, otherSdp.getAudioCodecs())) {
    mediaChanges.push("audio codecs has changed : "+audioCodecs+" - " + otherSdp.getAudioCodecs());
  }
  var videoCodecs = this.getVideoCodecs();
  if(!Utils.isEqArrays(videoCodecs, otherSdp.getVideoCodecs())) {
    mediaChanges.push("video codecs has changed : "+videoCodecs+" - " + otherSdp.getVideoCodecs());
  }

  if(audioCodecs) {
    for(var i = 0; i < audioCodecs.length; i++) {
      if(this.getAudioCodecRtpmap(audioCodecs[i]) !== otherSdp.getAudioCodecRtpmap(audioCodecs[i])) {
        mediaChanges.push("audio codec rtpmap for "+audioCodecs[i]+" has changed : "+this.getAudioCodecRtpmap(audioCodecs[i])+" - " + otherSdp.getAudioCodecRtpmap(audioCodecs[i]));
      }
//      if(this.getAudioCodecFmtp(audioCodecs[i]) !== otherSdp.getAudioCodecFmtp(audioCodecs[i])) {
//        mediaChanges.push("audio codec fmtp for "+audioCodecs[i]+" has changed : "+this.getAudioCodecFmtp(audioCodecs[i])+" - " + otherSdp.getAudioCodecFmtp(audioCodecs[i]));
//      }
    }
  }
  if(videoCodecs) {
    for(var j = 0; j < videoCodecs.length; j++) {
      if(this.getVideoCodecRtpmap(videoCodecs[j]) !== otherSdp.getVideoCodecRtpmap(videoCodecs[j])) {
        mediaChanges.push("video codec rtpmap for "+videoCodecs[j]+" has changed : "+this.getVideoCodecRtpmap(videoCodecs[j])+" - " + otherSdp.getVideoCodecRtpmap(videoCodecs[j]));
      }
//      if(this.getVideoCodecFmtp(videoCodecs[j]) !== otherSdp.getVideoCodecFmtp(videoCodecs[j])) {
//        mediaChanges.push("video codec fmtp for "+videoCodecs[j]+" has changed : "+this.getVideoCodecFmtp(videoCodecs[j])+" - " + otherSdp.getVideoCodecFmtp(videoCodecs[j]));
//      }
    }
  }

  return mediaChanges;
};

// New syntax for getting streams in Chrome M26.
if (WebRTC.RTCPeerConnection && WebRTC.RTCPeerConnection.prototype) {
  if (! WebRTC.RTCPeerConnection.prototype.getLocalStreams) {
    WebRTC.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };
    WebRTC.RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };
  }
  WebRTC.RTCPeerConnection.prototype.isIceCandidateReady = function(candidate) {
    // if(mozRTCPeerConnection && !candidate) {
    //   return true;
    // }
    // if(!mozRTCPeerConnection && candidate) {
    //   return true;
    // }
    return candidate;
  };
}

// isSupported attribute.
if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
  WebRTC.isSupported = true;
}
else {
  WebRTC.isSupported = false;
}

},{"./Constants":871,"./Utils":896}],898:[function(require,module,exports){
module.exports = sanityCheck;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');


var logger,
  message, ua, transport,
  requests = [],
  responses = [],
  all = [];


requests.push(rfc3261_8_2_2_1);
requests.push(rfc3261_16_3_4);
requests.push(rfc3261_18_3_request);
requests.push(rfc3261_8_2_2_2);

responses.push(rfc3261_8_1_3_3);
responses.push(rfc3261_18_3_response);

all.push(minimumHeaders);


function sanityCheck(m, u, t) {
  var len, pass;

  message = m;
  ua = u;
  transport = t;

  logger = ua.getLogger('ExSIP.sanitycheck');

  len = all.length;
  while(len--) {
    pass = all[len](message);
    if(pass === false) {
      return false;
    }
  }

  if(message instanceof SIPMessage.IncomingRequest) {
    len = requests.length;
    while(len--) {
      pass = requests[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  else if(message instanceof SIPMessage.IncomingResponse) {
    len = responses.length;
    while(len--) {
      pass = responses[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  //Everything is OK
  return true;
}


/*
 * Sanity Check for incoming Messages
 *
 * Requests:
 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
 *   Does not look at via sent-by but at exsip_id, which is inserted as
 *   a prefix in all initial requests generated by the ua
 *  - _rfc3261_18_3_request_ Body Content-Length
 *  - _rfc3261_8_2_2_2_ Merged Requests
 *
 * Responses:
 *  - _rfc3261_8_1_3_3_ Multiple Via headers
 *  - _rfc3261_18_3_response_ Body Content-Length
 *
 * All:
 *  - Minimum headers in a SIP message
 */

// Sanity Check functions for requests
function rfc3261_8_2_2_1() {
  if(message.s('to').uri.scheme !== 'sip') {
    logger.warn('Scheme ('+message.s('to').uri.scheme+') is not sip. Dropping the request', ua);
    reply(416);
    return false;
  }
}

function rfc3261_16_3_4() {
  if(!message.to_tag) {
    if(message.call_id.substr(0, 5) === ua.configuration.exsip_id) {
      logger.warn('Call_id ('+message.call_id+') is same as exsip ('+ua.configuration.exsip_id+'). Dropping the request', ua);
      reply(482);
      return false;
    }
  }
}

function rfc3261_18_3_request() {
  var len = Utils.str_utf8_length(message.body),
  contentLength = message.getHeader('content-length');

  if(len < contentLength) {
    logger.warn('Message body length ('+len+') is lower than the value in Content-Length header field ('+contentLength+'). Dropping the request', ua);
    reply(400);
    return false;
  }
}

function rfc3261_8_2_2_2() {
  var tr, idx,
    fromTag = message.from_tag,
    call_id = message.call_id,
    cseq = message.cseq;

  // Accept any in-dialog request.
  if(message.to_tag) {
    return;
  }

  // INVITE request.
  if (message.method === ExSIP_C.INVITE) {
    // If the branch matches the key of any IST then assume it is a retransmission
    // and ignore the INVITE.
    // TODO: we should reply the last response.
    if (ua.transactions.ist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.ist) {
        tr = ua.transactions.ist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
  // Non INVITE request.
  else {
    // If the branch matches the key of any NIST then assume it is a retransmission
    // and ignore the request.
    // TODO: we should reply the last response.
    if (ua.transactions.nist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.nist) {
        tr = ua.transactions.nist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
}

// Sanity Check functions for responses
function rfc3261_8_1_3_3() {
  if(message.getHeaders('via').length > 1) {
    logger.warn('More than one Via header field present in the response. Dropping the response');
    return false;
  }
}

function rfc3261_18_3_response() {
  var
    len = Utils.str_utf8_length(message.body),
    contentLength = message.getHeader('content-length');

    if(len < contentLength) {
      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
      return false;
    }
}

// Sanity Check functions for requests and responses
function minimumHeaders() {
  var
    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
    idx = mandatoryHeaders.length;

  while(idx--) {
    if(!message.hasHeader(mandatoryHeaders[idx])) {
      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
      return false;
    }
  }
}

// Reply
function reply(status_code) {
  var to,
    response = "SIP/2.0 " + status_code + " " + ExSIP_C.REASON_PHRASE[status_code] + "\r\n",
    vias = message.getHeaders('via'),
    length = vias.length,
    idx = 0;

  for(idx; idx < length; idx++) {
    response += "Via: " + vias[idx] + "\r\n";
  }

  to = message.getHeader('To');

  if(!message.to_tag) {
    to += ';tag=' + Utils.newTag();
  }

  response += "To: " + to + "\r\n";
  response += "From: " + message.getHeader('From') + "\r\n";
  response += "Call-ID: " + message.call_id + "\r\n";
  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
  response += "\r\n";

  transport.send(response);
}
},{"./Constants":871,"./SIPMessage":890,"./Utils":896}],899:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],900:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],901:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],902:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":901,"./bdsft":903,"./constants":906,"./cookieconfig":907,"./cookieprop":908,"./dateformat":911,"./debug":912,"./element":913,"./eventbus":914,"./factory":915,"./icon":916,"./loader":917,"./popup":918,"./prop":919,"./urlconfig":921,"./utils":922,"./visibleprop":923,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],903:[function(require,module,exports){
module.exports=require(54)
},{"./app":902,"./binding":904,"./classesbinding":905,"./databinder":910,"./stylesmanager":920,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":947}],904:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":903,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],905:[function(require,module,exports){
module.exports=require(56)
},{"./binding":904,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],906:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],907:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":903,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":947,"jquery.cookie":946}],908:[function(require,module,exports){
module.exports=require(59)
},{"./constants":906,"./prop":919,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":947,"jquery.cookie":946}],909:[function(require,module,exports){
module.exports=require(60)
},{"./constants":906,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":928}],910:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":931}],911:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],912:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":899,"./bdsft":903,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":924,"stacktrace-js":949}],913:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],914:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":903,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":931}],915:[function(require,module,exports){
module.exports=require(66)
},{"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":947}],916:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],917:[function(require,module,exports){
module.exports=require(68)
},{"../":902,"./constants":906,"./factory":915,"./stylesmanager":920,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":927}],918:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":947}],919:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":948}],920:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":900,"./constants":906,"./css":909,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],921:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":899,"./bdsft":903,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],922:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":901,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":947}],923:[function(require,module,exports){
module.exports=require(74)
},{"./constants":906,"./prop":919,"./utils":922,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],924:[function(require,module,exports){
module.exports=require(75)
},{"./debug":925,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],925:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":926}],926:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],927:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],928:[function(require,module,exports){
module.exports=require(79)
},{"./filters":929,"./utils":930,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],929:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],930:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],931:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":932,"es5-ext/object/valid-callable":941}],932:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":933,"es5-ext/object/is-callable":936,"es5-ext/object/normalize-options":940,"es5-ext/string/#/contains":943}],933:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":934,"./shim":935,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],934:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],935:[function(require,module,exports){
module.exports=require(86)
},{"../keys":937,"../valid-value":942,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],936:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],937:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":938,"./shim":939,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],938:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],939:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],940:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],941:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],942:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],943:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":944,"./shim":945,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],944:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],945:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],946:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":947}],947:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],948:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],949:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],950:[function(require,module,exports){
module.exports = {model: require('./lib/models/sound')};
},{"./lib/models/sound":953}],951:[function(require,module,exports){
module.exports = {
    volumeClick: 1,
    volumeDTMF: 1,
    volumeRingtone: 1
}

},{}],952:[function(require,module,exports){
module.exports = {"click":"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","dtmf-0":"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","dtmf-1":"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","dtmf-2":"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","dtmf-3":"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","dtmf-4":"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","dtmf-5":"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","dtmf-6":"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","dtmf-7":"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","dtmf-8":"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","dtmf-9":"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","dtmf-busy":"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","dtmf-pound":"T2dnUwACAAAAAAAAAAA+i+leAAAAAGQDX38BHgF2b3JiaXMAAAAAAYC7AAAAAAAAgDgBAAAAAAC4AU9nZ1MAAAAAAAAAAAAAPovpXgEAAAB7V/YBDvH///////////////+BA3ZvcmJpcx0AAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDA5MDcwOQYAAAAgAAAAVElUTEU9V2ViUlRDIENsaWVudCAtIGR0bWYgcG91bmQWAAAAQVJUSVNUPU5hdGhhbiBTdHJhdHRvbgkAAABEQVRFPTIwMTMeAAAAQ09QWVJJR0hUPTIwMTMgRXhhcmlvIE5ldHdvcmtzHwAAAExJQ0VOU0U9aHR0cDovL3d3dy5yb2JvdGljcy5uZXQwAAAARU5DT0RFRC1CWT1OYXRoYW4gU3RyYXR0b24gPG5hdGhhbkByb2JvdGljcy5uZXQ+AQV2b3JiaXMiQkNWAQBAAAAkcxgqRqVzFoQQGkJQGeMcQs5r7BlCTBGCHDJMW8slc5AhpKBCiFsogdCQVQAAQAAAh0F4FISKQQghhCU9WJKDJz0IIYSIOXgUhGlBCCGEEEIIIYQQQgghhEU5aJKDJ0EIHYTjMDgMg+U4+ByERTlYEIMnQegghA9CuJqDrDkIIYQkNUhQgwY56ByEwiwoioLEMLgWhAQ1KIyC5DDI1IMLQoiag0k1+BqEZ0F4FoRpQQghhCRBSJCDBkHIGIRGQViSgwY5uBSEy0GoGoQqOQgfhCA0ZBUAkAAAoKIoiqIoChAasgoAyAAAEEBRFMdxHMmRHMmxHAsIDVkFAAABAAgAAKBIiqRIjuRIkiRZkiVZkiVZkuaJqizLsizLsizLMhAasgoASAAAUFEMRXEUBwgNWQUAZAAACKA4iqVYiqVoiueIjgiEhqwCAIAAAAQAABA0Q1M8R5REz1RV17Zt27Zt27Zt27Zt27ZtW5ZlGQgNWQUAQAAAENJpZqkGiDADGQZCQ1YBAAgAAIARijDEgNCQVQAAQAAAgBhKDqIJrTnfnOOgWQ6aSrE5HZxItXmSm4q5Oeecc87J5pwxzjnnnKKcWQyaCa0555zEoFkKmgmtOeecJ7F50JoqrTnnnHHO6WCcEcY555wmrXmQmo21OeecBa1pjppLsTnnnEi5eVKbS7U555xzzjnnnHPOOeec6sXpHJwTzjnnnKi9uZab0MU555xPxunenBDOOeecc84555xzzjnnnCA0ZBUAAAQAQBCGjWHcKQjS52ggRhFiGjLpQffoMAkag5xC6tHoaKSUOggllXFSSicIDVkFAAACAEAIIYUUUkghhRRSSCGFFGKIIYYYcsopp6CCSiqpqKKMMssss8wyyyyzzDrsrLMOOwwxxBBDK63EUlNtNdZYa+4555qDtFZaa621UkoppZRSCkJDVgEAIAAABEIGGWSQUUghhRRiiCmnnHIKKqiA0JBVAAAgAIAAAAAAT/Ic0REd0REd0REd0REd0fEczxElURIlURIt0zI101NFVXVl15Z1Wbd9W9iFXfd93fd93fh1YViWZVmWZVmWZVmWZVmWZVmWIDRkFQAAAgAAIIQQQkghhRRSSCnGGHPMOegklBAIDVkFAAACAAgAAABwFEdxHMmRHEmyJEvSJM3SLE/zNE8TPVEURdM0VdEVXVE3bVE2ZdM1XVM2XVVWbVeWbVu2dduXZdv3fd/3fd/3fd/3fd/3fV0HQkNWAQASAAA6kiMpkiIpkuM4jiRJQGjIKgBABgBAAACK4iiO4ziSJEmSJWmSZ3mWqJma6ZmeKqpAaMgqAAAQAEAAAAAAAACKpniKqXiKqHiO6IiSaJmWqKmaK8qm7Lqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67quC4SGrAIAJAAAdCRHciRHUiRFUiRHcoDQkFUAgAwAgAAAHMMxJEVyLMvSNE/zNE8TPdETPdNTRVd0gdCQVQAAIACAAAAAAAAADMmwFMvRHE0SJdVSLVVTLdVSRdVTVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVTdM0TRMIDVkJAAABANBac8ytl45B6KyXyCikoNdOOeak18wogpznEDFjmMdSMUMMxpZBhJQFQkNWBABRAACAMcgxxBxyzknqJEXOOSodpcY5R6mj1FFKsaZaO0qltlRr45yj1FHKKKVaS6sdpVRrqrEAAIAABwCAAAuh0JAVAUAUAACBDFIKKYWUYs4p55BSyjnmHGKKOaecY845KJ2UyjknnZMSKaWcY84p55yUzknmnJPSSSgAACDAAQAgwEIoNGRFABAnAOBwHE2TNE0UJU0TRU8UXdcTRdWVNM00NVFUVU0UTdVUVVkWTVWWJU0zTU0UVVMTRVUVVVOWTVW1Zc80bdlUVd0WVdW2ZVv2fVeWdd0zTdkWVdW2TVW1dVeWdV22bd2XNM00NVFUVU0UVddUVds2VdW2NVF0XVFVZVlUVVl2XVnXVVfWfU0UVdVTTdkVVVWWVdnVZVWWdV90Vd1WXdnXVVnWfdvWhV/WfcKoqrpuyq6uq7Ks+7Iu+7rt65RJ00xTE0VV1URRVU1XtW1TdW1bE0XXFVXVlkVTdWVVln1fdWXZ10TRdUVVlWVRVWVZlWVdd2VXt0VV1W1Vdn3fdF1dl3VdWGZb94XTdXVdlWXfV2VZ92Vdx9Z13/dM07ZN19V101V139Z15Zlt2/hFVdV1VZaFX5Vl39eF4Xlu3ReeUVV13ZRdX1dlWRduXzfavm48r21j2z6yryMMR76wLF3bNrq+TZh13egbQ+E3hjTTtG3TVXXddF1fl3XdaOu6UFRVXVdl2fdVV/Z9W/eF4fZ93xhV1/dVWRaG1ZadYfd9pe4LlVW2hd/WdeeYbV1YfuPo/L4ydHVbaOu6scy+rjy7cXSGPgIAAAYcAAACTCgDhYasCADiBAAYhJxDTEGIFIMQQkgphJBSxBiEzDkpGXNSQimphVJSixiDkDkmJXNOSiihpVBKS6GE1kIpsYVSWmyt1ZpaizWE0loopbVQSouppRpbazVGjEHInJOSOSellNJaKKW1zDkqnYOUOggppZRaLCnFWDknJYOOSgchpZJKTCWlGEMqsZWUYiwpxdhabLnFmHMopcWSSmwlpVhbTDm2GHOOGIOQOSclc05KKKW1UlJrlXNSOggpZQ5KKinFWEpKMXNOSgchpQ5CSiWlGFNKsYVSYisp1VhKarHFmHNLMdZQUoslpRhLSjG2GHNuseXWQWgtpBJjKCXGFmOurbUaQymxlZRiLCnVFmOtvcWYcyglxpJKjSWlWFuNucYYc06x5ZparLnF2GttufWac9CptVpTTLm2GHOOuQVZc+69g9BaKKXFUEqMrbVaW4w5h1JiKynVWEqKtcWYc2ux9lBKjCWlWEtKNbYYa4419ppaq7XFmGtqseaac+8x5thTazW3GGtOseVac+695tZjAQAAAw4AAAEmlIFCQ1YCAFEAAAQhSjEGoUGIMeekNAgx5pyUijHnIKRSMeYchFIy5yCUklLmHIRSUgqlpJJSa6GUUlJqrQAAgAIHAIAAGzQlFgcoNGQlAJAKAGBwHMvyPFE0Vdl2LMnzRNE0VdW2HcvyPFE0TVW1bcvzRNE0VdV1dd3yPFE0VVV1XV33RFE1VdV1ZVn3PVE0VVV1XVn2fdNUVdV1ZVm2hV80VVd1XVmWZd9YXdV1ZVm2dVsYVtV1XVmWbVs3hlvXdd33hWE5Ordu67rv+8LxO8cAAPAEBwCgAhtWRzgpGgssNGQlAJABAEAYg5BBSCGDEFJIIaUQUkoJAAAYcAAACDChDBQashIAiAIAAAiRUkopjZRSSimlkVJKKaWUEkIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIBQD4TzgA+D/YoCmxOEChISsBgHAAAMAYpZhyDDoJKTWMOQahlJRSaq1hjDEIpaTUWkuVcxBKSam12GKsnINQUkqtxRpjByGl1lqssdaaOwgppRZrrDnYHEppLcZYc86995BSazHWWnPvvZfWYqw159yDEMK0FGOuufbge+8ptlprzT34IIRQsdVac/BBCCGEizH33IPwPQghXIw55x6E8MEHYQAAd4MDAESCjTOsJJ0VjgYXGrISAAgJACAQYoox55yDEEIIkVKMOecchBBCKCVSijHnnIMOQgglZIw55xyEEEIopZSMMeecgxBCCaWUkjnnHIQQQiillFIy56CDEEIJpZRSSucchBBCCKWUUkrpoIMQQgmllFJKKSGEEEIJpZRSSiklhBBCCaWUUkoppYQQSiillFJKKaWUEEIppZRSSimllBJCKKWUUkoppZSSQimllFJKKaWUUlIopZRSSimllFJKCaWUUkoppZSUUkkFAAAcOAAABBhBJxlVFmGjCRcegEJDVgIAQAAAFMRWU4mdQcwxZ6khCDGoqUJKKYYxQ8ogpilTCiGFIXOKIQKhxVZLxQAAABAEAAgICQAwQFAwAwAMDhA+B0EnQHC0AQAIQmSGSDQsBIcHlQARMRUAJCYo5AJAhcVF2sUFdBnggi7uOhBCEIIQxOIACkjAwQk3PPGGJ9zgBJ2iUgcBAAAAAGAAAA8AAMcFEBHRHEaGxgZHh8cHSEgAAAAAALgAwAcAwCECREQ0h5GhscHR4fEBEhIAAAAAAAAAAAAEBAQAAAAAAAIAAAAEBE9nZ1MABIAlAAAAAAAAPovpXgIAAACnPCsWCyNCNzU3NTY2NzhF/G4o17jgBt97os+PAAL4vWaOWv5phsP5N998M3zzzeiwPgHaudblt+A31PefsDqecjmpKR7Q4/bt25NjoH+aHgDeIAUAAAAAAAAAQHvfJ+ccwqLfEXea8rfWACqEmADTe++9dwA+yo7PH8F3kO9cv+G9Hw/+1BRBIQAAKQAAAAAAAACA+dEHoAvA4aezbPjR1m8CADR+KhYAAAAAPsqOzx/Bb5DvPH7HezUKrCY1RVAIAAAqAAAAAAAAAMD7CYAjAIefjtpw3y7kBgBQeNkxAAA+yo7PH8FvkO+8fsP7yXjqT00RFAIAkAIAAAAAAAAAcNUA3AbgcrWrLMPm8JsuAEDDdScAAAAAPsqOzx/Bd5DvXL/jvRoFVpOaIigEAAAVAAAAAAAAAGAaALwCIIaDlqKgssYgAEDhQwECAAA+yo7PH8FvkO+sv+O9jQJLk5oiKAQAABUAAAAAAAAAYJsSwG0AwrUELUVdu4cBAMCOWhIAAAA+yo7PH8F3kO88fsd7PwqcIjVFUAgAACoAAAAAAAAAwFMD8AqA8eQnmzSXJ+/rBQAoXDBAAAA+yo7PH8F3kO/1AryfjAJLJTVFUAgAACoAAAAAAAAAwFcXgNsADN/PiGBfsAeSAAA7avwAAAAAPsqOz1+C7yA/fP6O9zq+Z2qKoA4AAFQAAAAAAAAAwP4aAO4BAJL12LpPxfb9QBksAITM7gECAAAeWdbtl+A3XNu7fwPn5zvl4klN8cDcOcfYaHr/x5saoG9IJwAAAAAAAAAAAKBk9433Q0X/Pk5NwrXNtbm2+r2hRSyJCAA=","dtmf-ringback":"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","dtmf-star":"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","ringtone":"T2dnUwACAAAAAAAAAADZXVE7AAAAABUrGWoBHgF2b3JiaXMAAAAAAUSsAAAAAAAAAHcBAAAAAAC4AU9nZ1MAAAAAAAAAAAAA2V1ROwEAAAAa4KePEC3//////////////////8kDdm9yYmlzHQAAAFhpcGguT3JnIGxpYlZvcmJpcyBJIDIwMDkwNzA5AAAAAAEFdm9yYmlzKUJDVgEACAAAADFMIMWA0JBVAAAQAABgJCkOk2ZJKaWUoSh5mJRISSmllMUwiZiUicUYY4wxxhhjjDHGGGOMIDRkFQAABACAKAmOo+ZJas45ZxgnjnKgOWlOOKcgB4pR4DkJwvUmY26mtKZrbs4pJQgNWQUAAAIAQEghhRRSSCGFFGKIIYYYYoghhxxyyCGnnHIKKqigggoyyCCDTDLppJNOOumoo4466ii00EILLbTSSkwx1VZjrr0GXXxzzjnnnHPOOeecc84JQkNWAQAgAAAEQgYZZBBCCCGFFFKIKaaYcgoyyIDQkFUAACAAgAAAAABHkRRJsRTLsRzN0SRP8ixREzXRM0VTVE1VVVVVdV1XdmXXdnXXdn1ZmIVbuH1ZuIVb2IVd94VhGIZhGIZhGIZh+H3f933f930gNGQVACABAKAjOZbjKaIiGqLiOaIDhIasAgBkAAAEACAJkiIpkqNJpmZqrmmbtmirtm3LsizLsgyEhqwCAAABAAQAAAAAAKBpmqZpmqZpmqZpmqZpmqZpmqZpmmZZlmVZlmVZlmVZlmVZlmVZlmVZlmVZlmVZlmVZlmVZlmVZlmVZQGjIKgBAAgBAx3Ecx3EkRVIkx3IsBwgNWQUAyAAACABAUizFcjRHczTHczzHczxHdETJlEzN9EwPCA1ZBQAAAgAIAAAAAABAMRzFcRzJ0SRPUi3TcjVXcz3Xc03XdV1XVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVYHQkFUAAAQAACGdZpZqgAgzkGEgNGQVAIAAAAAYoQhDDAgNWQUAAAQAAIih5CCa0JrzzTkOmuWgqRSb08GJVJsnuamYm3POOeecbM4Z45xzzinKmcWgmdCac85JDJqloJnQmnPOeRKbB62p0ppzzhnnnA7GGWGcc85p0poHqdlYm3POWdCa5qi5FJtzzomUmye1uVSbc84555xzzjnnnHPOqV6czsE54Zxzzonam2u5CV2cc875ZJzuzQnhnHPOOeecc84555xzzglCQ1YBAEAAAARh2BjGnYIgfY4GYhQhpiGTHnSPDpOgMcgppB6NjkZKqYNQUhknpXSC0JBVAAAgAACEEFJIIYUUUkghhRRSSCGGGGKIIaeccgoqqKSSiirKKLPMMssss8wyy6zDzjrrsMMQQwwxtNJKLDXVVmONteaec645SGultdZaK6WUUkoppSA0ZBUAAAIAQCBkkEEGGYUUUkghhphyyimnoIIKCA1ZBQAAAgAIAAAA8CTPER3RER3RER3RER3RER3P8RxREiVREiXRMi1TMz1VVFVXdm1Zl3Xbt4Vd2HXf133f141fF4ZlWZZlWZZlWZZlWZZlWZZlCUJDVgEAIAAAAEIIIYQUUkghhZRijDHHnINOQgmB0JBVAAAgAIAAAAAAR3EUx5EcyZEkS7IkTdIszfI0T/M00RNFUTRNUxVd0RV10xZlUzZd0zVl01Vl1XZl2bZlW7d9WbZ93/d93/d93/d93/d939d1IDRkFQAgAQCgIzmSIimSIjmO40iSBISGrAIAZAAABACgKI7iOI4jSZIkWZImeZZniZqpmZ7pqaIKhIasAgAAAQAEAAAAAACgaIqnmIqniIrniI4oiZZpiZqquaJsyq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7rukBoyCoAQAIAQEdyJEdyJEVSJEVyJAcIDVkFAMgAAAgAwDEcQ1Ikx7IsTfM0T/M00RM90TM9VXRFFwgNWQUAAAIACAAAAAAAwJAMS7EczdEkUVIt1VI11VItVVQ9VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV1TRN0zSB0JCVAAAZAAAjQQYZhBCKcpBCbj1YCDHmJAWhOQahxBiEpxAzDDkNInSQQSc9uJI5wwzz4FIoFURMg40lN44gDcKmXEnlOAhCQ1YEAFEAAIAxyDHEGHLOScmgRM4xCZ2UyDknpZPSSSktlhgzKSWmEmPjnKPSScmklBhLip2kEmOJrQAAgAAHAIAAC6HQkBUBQBQAAGIMUgophZRSzinmkFLKMeUcUko5p5xTzjkIHYTKMQadgxAppRxTzinHHITMQeWcg9BBKAAAIMABACDAQig0ZEUAECcA4HAkz5M0SxQlSxNFzxRl1xNN15U0zTQ1UVRVyxNV1VRV2xZNVbYlTRNNTfRUVRNFVRVV05ZNVbVtzzRl2VRV3RZV1bZl2xZ+V5Z13zNNWRZV1dZNVbV115Z9X9ZtXZg0zTQ1UVRVTRRV1VRV2zZV17Y1UXRVUVVlWVRVWXZlWfdVV9Z9SxRV1VNN2RVVVbZV2fVtVZZ94XRVXVdl2fdVWRZ+W9eF4fZ94RhV1dZN19V1VZZ9YdZlYbd13yhpmmlqoqiqmiiqqqmqtm2qrq1bouiqoqrKsmeqrqzKsq+rrmzrmiiqrqiqsiyqqiyrsqz7qizrtqiquq3KsrCbrqvrtu8LwyzrunCqrq6rsuz7qizruq3rxnHrujB8pinLpqvquqm6um7runHMtm0co6rqvirLwrDKsu/rui+0dSFRVXXdlF3jV2VZ921fd55b94WybTu/rfvKceu60vg5z28cubZtHLNuG7+t+8bzKz9hOI6lZ5q2baqqrZuqq+uybivDrOtCUVV9XZVl3zddWRdu3zeOW9eNoqrquirLvrDKsjHcxm8cuzAcXds2jlvXnbKtC31jyPcJz2vbxnH7OuP2daOvDAnHjwAAgAEHAIAAE8pAoSErAoA4AQAGIecUUxAqxSB0EFLqIKRUMQYhc05KxRyUUEpqIZTUKsYgVI5JyJyTEkpoKZTSUgehpVBKa6GU1lJrsabUYu0gpBZKaS2U0lpqqcbUWowRYxAy56RkzkkJpbQWSmktc05K56CkDkJKpaQUS0otVsxJyaCj0kFIqaQSU0mptVBKa6WkFktKMbYUW24x1hxKaS2kEltJKcYUU20txpojxiBkzknJnJMSSmktlNJa5ZiUDkJKmYOSSkqtlZJSzJyT0kFIqYOOSkkptpJKTKGU1kpKsYVSWmwx1pxSbDWU0lpJKcaSSmwtxlpbTLV1EFoLpbQWSmmttVZraq3GUEprJaUYS0qxtRZrbjHmGkppraQSW0mpxRZbji3GmlNrNabWam4x5hpbbT3WmnNKrdbUUo0txppjbb3VmnvvIKQWSmktlNJiai3G1mKtoZTWSiqxlZJabDHm2lqMOZTSYkmpxZJSjC3GmltsuaaWamwx5ppSi7Xm2nNsNfbUWqwtxppTS7XWWnOPufVWAADAgAMAQIAJZaDQkJUAQBQAAEGIUs5JaRByzDkqCULMOSepckxCKSlVzEEIJbXOOSkpxdY5CCWlFksqLcVWaykptRZrLQAAoMABACDABk2JxQEKDVkJAEQBACDGIMQYhAYZpRiD0BikFGMQIqUYc05KpRRjzknJGHMOQioZY85BKCmEUEoqKYUQSkklpQIAAAocAAACbNCUWByg0JAVAUAUAABgDGIMMYYgdFQyKhGETEonqYEQWgutddZSa6XFzFpqrbTYQAithdYySyXG1FpmrcSYWisAAOzAAQDswEIoNGQlAJAHAEAYoxRjzjlnEGLMOegcNAgx5hyEDirGnIMOQggVY85BCCGEzDkIIYQQQuYchBBCCKGDEEIIpZTSQQghhFJK6SCEEEIppXQQQgihlFIKAAAqcAAACLBRZHOCkaBCQ1YCAHkAAIAxSjkHoZRGKcYglJJSoxRjEEpJqXIMQikpxVY5B6GUlFrsIJTSWmw1dhBKaS3GWkNKrcVYa64hpdZirDXX1FqMteaaa0otxlprzbkAANwFBwCwAxtFNicYCSo0ZCUAkAcAgCCkFGOMMYYUYoox55xDCCnFmHPOKaYYc84555RijDnnnHOMMeecc845xphzzjnnHHPOOeecc44555xzzjnnnHPOOeecc84555xzzgkAACpwAAAIsFFkc4KRoEJDVgIAqQAAABFWYowxxhgbCDHGGGOMMUYSYowxxhhjbDHGGGOMMcaYYowxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGFtrrbXWWmuttdZaa6211lprrQBAvwoHAP8HG1ZHOCkaCyw0ZCUAEA4AABjDmHOOOQYdhIYp6KSEDkIIoUNKOSglhFBKKSlzTkpKpaSUWkqZc1JSKiWlllLqIKTUWkottdZaByWl1lJqrbXWOgiltNRaa6212EFIKaXWWostxlBKSq212GKMNYZSUmqtxdhirDGk0lJsLcYYY6yhlNZaazHGGGstKbXWYoy1xlprSam11mKLNdZaCwDgbnAAgEiwcYaVpLPC0eBCQ1YCACEBAARCjDnnnHMQQgghUoox56CDEEIIIURKMeYcdBBCCCGEjDHnoIMQQgghhJAx5hx0EEIIIYQQOucchBBCCKGEUkrnHHQQQgghlFBC6SCEEEIIoYRSSikdhBBCKKGEUkopJYQQQgmllFJKKaWEEEIIoYQSSimllBBCCKWUUkoppZQSQgghlFJKKaWUUkIIoZRQSimllFJKCCGEUkoppZRSSgkhhFBKKaWUUkopIYQSSimllFJKKaUAAIADBwCAACPoJKPKImw04cIDUGjISgCADAAAcdhq6ynWyCDFnISWS4SQchBiLhFSijlHsWVIGcUY1ZQxpRRTUmvonGKMUU+dY0oxw6yUVkookYLScqy1dswBAAAgCAAwECEzgUABFBjIAIADhAQpAKCwwNAxXAQE5BIyCgwKx4Rz0mkDABCEyAyRiFgMEhOqgaJiOgBYXGDIB4AMjY20iwvoMsAFXdx1IIQgBCGIxQEUkICDE2544g1PuMEJOkWlDgIAAAAAAAEAHgAAkg0gIiKaOY4Ojw+QEJERkhKTE5QAAAAAAOABgA8AgCQFiIiIZo6jw+MDJERkhKTE5AQlAAAAAAAAAAAACAgIAAAAAAAEAAAACAhPZ2dTAADAOQAAAAAAANldUTsCAAAA7BLhHzIo0tgnJiYoMTfr5O0rKysoKicoMzU39CktKSs2NjHvKyk1NCk2NDU0OPYqKjM2NDfn6uwM/TNPnXjcMDUb0jAa/Nr2tlu8hwxXr96lyKFVFjm2sUWJiArZlwDaRdQyXUwH3GaS0ttU/U7d1HfigAmMlZ0BaJyfsCCZsRiRL58fUaR9alK/vlkg7+af53tZVzeHO4cOVUh0goPQe/1rCuj0PCSdBg26ijTLLWJihx3yHADYNcbRCYqopIpJcr9taXQ0B2s1Np9Ex0F5I1uo/fp7jG5KiQQ86r6C0t+JQ4DJWiodtscP5rtiK8Uq04QAiMttxJpUdQKWMpDk4gDBCVIlxGZbcUOyoQ1qCP6nL97MTv0we2wQiSVkvSnabO2qHLsa5QzfN7yoJwAU2ADWRcTMrVQFGJCYXn0rVtaZsXFIQ5mgxgqX9ZVmwxTXo/utLb814vU+9Mw8bFUSB32VZ1d3VIy93CTFa9T9iwjf9szOkNTsje+Lj1imO6P7svnGKDg4iYRYQmdOZ/H4ybok4zxrb7cictG+u5f2JOe00TUiPaA120irZbvGDaG4UMm4bP88sCg4voXfM188CbcCortim6ziXcMoujbYMtNDGdO4zGzW9KV+fsZgEe17lKyDhgqkTvWVLLuCeslSzFbmEEfPv9Sw5DkY2cWc22KgWf/qZgUQGgCEAfVVQehiAuVlZxQBIgJaZnfjXShm90LJl1uhpQqN92/W/sgJ5gPE/bAD1aCZOWkmB5AS1jbbTXAam/yTMGomppsCeaPQ4+D28mCjbMz9uAVF1gztoyligZE8U/mWOuvsLO9bbRHTfH6Zum87sgnGGxQAzP2QoFKZ3OXRo79pICIYY54XU+kka8xEFPE2KJUjSfo776OmL+YgAKwBaZQUe2dT2HtFAUQa4Hi7l+XWJ3XFQ1389/rpdGKbfhag/fdIxnFq7fX93wskOgW8/XycaTu/J0fXKI28a1IABqsNiJJnxzOskVMn1nVdKHlsICKghm8oX7845E5RKuOViqeyjZsFWlZUkImY4XQPn5/VSdsUOXG/ytGsr/GLudWuVwDgiUyCy5IGq7/tgyQACSOhiUpWFMcXUxcnXx9bLZHzYjjNFP3MLI+MSe8aK9vZ7NuJRSt6JUcAfehejFHjweT7wzY2vHt9kwBQbX7+vwtbnq3CtA757bgTLPL3lAQL8vvrxt/ep8yp7JO1cSVet8xRq9D0ICdXtVoNQcNUQ8BVv3y6ylB8e9aLcMsJAMceW/cg09L3m9YmAFmVCSDuzSulVoYwbtH56VjERfkY8IwheIaUPKLpMgmGuCeii826RlvcKxTyr0hg7vllbuYZAN5HNCACfADwHtmBRThKQJsF2CyRHgBXgjRQTY3WmhRaK2TXm+ZMV5z2YeCobgi0d/cPTsjl1vttEjRszQhjMoqrGGpOfDTEAWgSoih7+ivIk5Jo0XPqu7xNKemJysa9ZZL7VBIcRWp0Of75Dj2hutUnueTMV53juHIXoDH4FOfBurF35/2sBz3EwKNt5g2lVcOOZvtULwmrFxS34d0Il4+BlRLCEwpnVOfYlTAQJtXb4moneWgeu3QllHzlZ7VS9lopNvRfZW0pLLGr+k5hYVf1FmILu6qtNG6TPlVbYTdiqdKlAvZGRKAA9YGuR1L8vUn+QtfJSHeHvQ/AAExtBkASgFzOOq21wgmd/vmK1PbGFxt507K2+PbQO9vDHzQcHgPBGPhydnDBZFSJ4S3TrHLHNUlIznm1l7u4lMNwFw9H+1RT+yjK7tQhYiOzDcjnozj6Eqi+C9qQIAOXsQDwKBmUJdzmokWEwF2tbzFJkY9m1l/MakS1c7vyjR4docfN+ASOhDK6/isqfFEiRVGKAWMQN/cPnKR+iMelffRoL9/CpqYLlRxKGbY97D4OjifXh8AWRSFjdEjTllJUXwUfw3yLYz05/AeRry9F09Mt6zubDbzxCpKEkFsnB8AOkJJ7BLjmEtM1ZdHEEM2cI9JwA/nEge3qLqoy0ijuKwDU9XTJo1vvqLJT6L7KBgis8VcvjGGdWMyZ4VwP4CwKWkdz8DVk1S13NY4CLPqgFeE8UeV79O2HkSL9qWd7Uowu9c5ufcpcWFe3/mqulVRmy2xFLLHUAOzx9A1IYSHbf34Al9hf1marRK4maXdcjs3V7KBscBX6ohcd7Y/AMRLs8XQVGNdOpcyh+XQTNDqSxxGGppLUu7dB4EmdOk1nJDOShnCCt5CwVwkE9tAArDM4BF8fQsEl9+LLNB6qmRxO7TWTb4mj6DwyCLbTbmN3NRK0+QqzAeP/UOLUdkcCI/iXkj4n0rQog8a3jCfAZ27/lw//SV2XY2cSFPLQoBI6FLHgE0cJOhgRNaFocuGh4faDiNnp5q+Qd/TDbh0xxx9UI71/xHuStDySvBcA1Pko7SIDawddofH66j22wUL4fbUf0DB/uVS6r45dOXnwNPp8JO0nqdvOaQTNtnOjooMXuTX0EQu4rbWGkd8N7gG3XhrAYvc0qPGFo09rHHlO1UTQevsKbr8X8T2C6FhzDw3FxJ4XZy7tStYL0kckgEHpv221XNH5qKjMif+75zaknu9spHXcAICvkQmwVtID2PnNZAiGAlkTJohKaMb7gSlrHDMUezu/cX3fONP0bM7yXF4+BbfIwdENN90ddfeocXrrzSrTOlRTwdvCxWjQSR0OIE6mp/8/OD0enK3z2AkvnL+3OIYnhFD+SBimjVevxebSiUlKU5iB+J/LBgANdBGAi6ZcGqhh+uLvP2uUegXLlOxJBgKMat3KEndfuv9CmZVFSbWFV33PL7dB9iSsMf1QfvDrxhWVFIeCtdwvzfg8hrz6Wq3SjbEsikUE6spQIfEze2RpCHIecwz+7EaZACQK9Q1IX3Np8zSTF4gYXr6WDawko+E7278jG28mT2X7KjE/+pKBeWQBDPI8HQgzWVwaCKStfAGCaRRbyBoVsUYxwUXUPXfuIOC/HyfiZWu+VwaKwd0BJO6EBoy1z3KJmFdxAOguuWG2m5DUYFStFI9GphbDgp1Vw9qGXJy0dpEE+rSgMPjtq8wIn1fMCYIk3woFm1L6cYO+guZ/IY/FAnuSYdrrYl8IgYoJ9PnQ5jGb8yQKYjtla6h0mN0k+eTutRQxBlWMIQ2sPyjJLeXr3T6/FwLDJhOgdtYv4cBMeJYdDPIEB9RdUERA4KosEkADLvj9cFGUFW5qYeKrsmtd5sC5HP9vbUrHnqmdL0aps1E+j7nvWGsAJPaQZAB3yxzkYPsqJemK+2ltVkuzvjiuWAS462OUX9KOypoXRtTtFlgf39SJSqRMABI4hKIAfTcQOyQQ3xN/Gg3HHPUSrrNkDQzAFGdgIlnCN9ppISw9XtvdonF1NXk5eeIdvvOm8m95nL64ii+nndFsNTiJuiglRjgjMm5oMrb1ItmcpRsiMZJyfI2AUmhtVyepWdSsUuX6xt0zrtziJcxz6kyONVrbedoa4U+QAFgAyf/8WrHqo/dzW82stjRrVSvK46UB6t02GgpRUDCmYMf63AkchJqYbvva0/rYpa+Wrmo1w9PMSm7I6GRXkFq77YUxfWYEYDH3DWeGINkwN2pjoty23bCWAEevjra2PzpI9ipvJNtlL+MPHVuUW4ENFPZQp1HMBpbAfXkkaHQE9x1axmEz1GJfKuqsB0Y+oq9mNfMzjbllyV4zAQz29Fnr0r257DBTUSeISIamTJGIMPwk6vwpWfYdyCF6lCOEH5mlQyoA9PUEZ4fyAi7Wq4TFzJSr9wtcz4aiuezqXJNZ45fWaq9HrP8gsD09Zr3NJ11r8Wuma//0DQAE9ugIFGbKd4FZ9QUas1x97a6Y8BPd7J69LfV4DMnRKMb0N9+HdQeH1XedCvsveuGfBVYALAqFBozLuAeK+V8xACHJIKqpgDpqIKLNsatCeVIhgrolRZCvKpjcbAnc8XzZs6oEipeY+hCCGLi49uDWPV0mL77XvhIVr2ARxzZ/5ZWrMncpruYbeXIa7p/6/z9jrQQc8tBkI7g0sj48fJxAukiPTLrxWvzaR5AqFosQe1Rdm+5ctkadONfGaTi+fO/rIQ/+qWoC7PVQa0dWzMIX3Na2ALpJoXbmNU3ZxKDvLstkLemjmjYuYWrkOzsTNLT1CDQyiX6kzDGHCgAc9sQiwEcOFLf0Z4FKzSy3mkTZZ36foB8Eh9+Jo5vy80tnxGPiqz56SAzTFRwJPN0RmQoAHAZ1Xttmqf35HLTtXRMv4MkUf2xrtS8yyfBgOIDEfPTt7S1//0JzI9RVO6M5RNns7k+zj+HpcAMSOCQYrilD4/UhzGK2EqftXXP2qd4hcoe19QfIjQJmABlQmKkCQcIkjrVWdLg6Po13ilPvb9XhpisXwwOX7h6dHvXSyGqTxSahjj99MDXpGp3Sag0AWgsHP6d6VI8qDYbxdzmRVdyUJOIyST8Jyn2iJLEhXcfq2gyAPbyX5vZPFCYfbH3Bqr2hEeBLNndfNTwzFIDwy/XZer0++1BY0onWRIXG1664FDFcJAkOIJtj7M9ujY0BcvErZVE1/Ix/aDeXH/UJ5+RRDkIJw11TqcVdUci6Jb4DWK7soxQNI2+RJK5tbi/TQ0YUvc3CGPRvVAtF0fuUNAAU8jyO3EAKYZbSnwYgDoogWzNXoVMsyyoo31m61xs0VREZPn3BR71vkwHU8Yq4B1aVi5diLw4gIsnLDGvFkLp8pzdHSJsybjaO0mlnom6p7pCW7AAU+iinbUpGheq5rhmARjFdHC05PWnJrumZaRfqXEJ7mVWWlAUfu6HsACr1cyavFe2xEg0k9lAljcGGpBBu5RSABowJcShrRbZuvJNzbRsYkzRpxb+Hx81mo/TqEJVuP5n7VlfsmYqeHAAM8jCX9lJC4GK9zAB6uciu86dXwM7sYdxWl+Npf4OsJnrbqXFDEx2/1ExUizcE75f//48DFPKIte3RSuKxW+M5gU6D7qq+B94+VOxK7pvtKonffe1LWAeHuwt5eklt1GZa/Hph76Wep6ZiADpoBCLFKmFVAicS/l/Fm1E8wxzMe8hhg5kgA3QDKEhlwCRIaa2VVowrehqbCbvfI2Yx54FkmoctpqTYTce8jWLNF3q+kjLVPTq85Q1RFNWI8jPvUanaZMRqGtqyZ1eClgy6V0qs8VpkmlkZjOjX8YR28V1iNApQqdv9YzGcKWaSs0ks/mtqH5qoUmnPNK399XlOap1pG2R6l6JHrM5+e5FZyCw/WF4J9ZZXxvdH7qQGm71uIOowo3ka5xndMJBLg7D13GgKq0jDwbnSx3xA5yE6Y65CaDYbnia5LNPFTkeoPmYfTLk3ADZIBDChHr9hBfjfUZ36GOZZzRYxDDAAxQoQHgCkQUuMMtppobCY9udtN56d3fJfTnquuZ3t13b5nuZ9kYsejeyGmTjQnYqLN4Hv5zmTxli9uWnWyIfGjgja9of6c29CVGIrxnDr9hc2Z3mLRony5mhHSRV9S2BcKf3ESj0I1++4FRFJkXZIM7RvvzcSLQEAlEzED+4uVva6xUqQGIatYfu8pVgcTSgeYZ6HyrjOlJBKPe/tV9gZoXKPNHkLd6EW6hN3rhYoUwkbA0u3InysyCVgk7KtYu5rprw9jopGlWLRZFBZXViuC+EOAE9nZ1MAAMB5AAAAAAAA2V1ROwMAAAA5ap13LSkyOPIpLSk0MuPiKCkwNzfp1+UrJyYqLCgyNDXr4N0pKCgpJiUmMTo4/wDt4ez5dEzarG76TG+j8z4pQCd41HAxTgg6ptEjtxnR7jy9eehuebJob7wINPpEWt8np/2gCOPPAZTTnMvu62G9/nkug0C0E0+LIE+n884oeYrf5ZClff8z07ER9THkBb26BsDuLKVtZsOrtVV4mg+j4sf3zxO3dmH1OIx7Upubvj+e9Zo6CtPtf39SboB5XZMmtwhXAXJHVCkoxpQNnyC1YlRJD5y2d+buc3p7zccTyfJjYLIBhA9AAyQBsB8dy1ph7sS8cXue7e7kHl70XteDS2kGf/XlvppDYowfl0jh1crC4en7M2nnqQZAy7bWVi/+hJBMM0+BVlhagbS2mn9x5b/57AvaKlsA+2c0WlVIlHM8GdROg5uJ6gQAsFZuX8TXSgYpZt7EXcEwoBJbwjPaYiQxQm9BR+0njvn3xCm34qi0zc406vMlppbunw0+sr74vSwcuFzyueBme0vmIozHvdm76sSsnGc1S83JFoMoFjKFdXPQYQAonkSC3k+DxuzkC7IX1hJ0VBbRCKCaeTe1nRqIgym4nm1YqUkiE8zG+2hHdEaWnM2a9e05ZvnfLAD8+TTJPLKBbEFD6+8EEBemwAqFpg9tQpUxzER9zKBvsXCkJC/L0T4sL29oQQMU8gTJ7otqOi1s57RARMWzKc5k7FB++tzFCvXlIDOa8LMunf+FBIt3AjQCiZGSFdIhqn93gXKZuWvZJynNtA9xOAWLKcOoGV7bqTtv76MDI/5xM5GaLCDz////DAA0CplhdsFKySi/WwNptBMu9bOOm04//xsENR32nmZ2Vh2bIfnoxb9KB68mU1PPXooGGrpX5GmJCQYFhL4Xx3SfOefsZLMeKKHMAA4QoKOLMO1MKe0U8rWDj+efOOFXTciTJ99beDz00Ca5ybl2S+4ASZe4khgMIVFzgokXlLvEwvaTPRVRLad0/W/KcOVT5vPB8GWygZA4euNQIZEZUevKrpoksoGQ/nxFDVk/6LhiYVAbnVkZp7sN5lGTjMWaiKUUKpgya/fRRWp8endotNvyEmrhKusLkPAzkA2E+SnSFDHMtx8ztN42GePOXWwr6BzGFZwlcXW+qNTsba2wcF8vu3d1iMDQbDSdYqyDlTNoi9Y7PGwAdlfkacroCCK2tF9dlrvnOZIjkscMgLWkgbS6YOgdl+i8YmbwZjj9JxmN2HsnbM3jmGfVwYPRPYpibWmt98Mab163NptI6bop0KjqtVr70bzn3YyHZcNvAkIvU6Hhsz8bOMP6ibTjooQB5SNqhRZhiM5aEDrGbSw7GS+DafuAywvdH38dvoRvZzPquOcLwOJ+bJI3718SE2Q29UFF3b4SImxGC8CK3U7dnE9E/C0NxiJDaDZf6a/T3XiMIhzrzatOU5KwmFM/EAnf/Lj5K830lbGq8kJ7Mbmvr+jojeaauQoPAATyfBEtywhI6FQ5gHDJ8U23IZWll+/d3z3THWcrpe8Nlbna6j9IMQXU9fxS25yUzo39qUYBNBXfh3U5TS1NcuP1wYx3lh1tOus+I1HYL1Z2AxQKgSyBAA7D3x+QFru+m6yIITeJtp7u7cKuykH7ymZubS8G/OC4Ql3uTIfSqGdxAAQCPZSE1cfXQHdWawyIYRUIGp16uKefD+vimL28oXXx/5Qunf7saYTQf9LtWlz2a2NWL4FQbDbEJa9IT+OtlDt64DI42gHQA9CdZYAoG4nO6v0VJ9Yy/e+IB/clEmmtvSHpZ766iFQV3i8w21MCGmccTqTiyhHTeUSVrGvf247n2eI4QiatkRgmoM2ADxLyPEBYCUUKBe724lZw078Ras8y0X8D30n/KhFjPPhaZjbb5EzbMVM9uivIuoeoNdFJnD48s8s78u+W1kyPH9NFinIFyN1S+ulOtkxXF6zT/Rr4vbVedifjaMdWbiaXZNR0WA48NECn0FNZsn3oIpY/2X4ZdXwk2TIIHiAV+/EGwSpBCb2DnPheqh25bhdnW64ww/0Dy6pdXjtd8nNOU43T7rQQAbVJg2/HUOFTuavZ0boX6Z/yQoBRf7S5vOslT60LXzTh6KZF2h7eSEQgBQkBFdpb+GVoiQRphavk6JiVVnh7/ZTv3sbkQdP8evqBxL3z+PXlw6/g7dIkDdPyxuDPMhn4HlZS2x8jkXIpcrUuFn+J8Wr4gypc8RzVe46bUk2wZasfn5epsTGx+yb1+tzs3jBwW2bxFZuoQN2Cj3ZgPWHGLdzZCkh0oMDIdKldCdkMsh8fTTKtPh4a+GYrXEj+WiwXdekZWch5+0MbZKRlVAlFD0Q6/9lV9iqzDV40b5p/sT6vBLOo8roil/whxWdxYH+tkJGLQNwo0RqZYoM3AbZHtJGvGAQTaN/1UkbU02TOXPVmdNqk/BgrTXKkFQr1nqXpS4OpybHmgGc8MDa8fP/72P6xXG7POkzK5Esw5MpNrZmEkSfoc6lacFmsL9l1MHdEcWq6n10dD9twrppyK7n8g8uMZcT/+gDjgEdJ/weGCR9agtXyu1UDRUs1lBdMAcoUzSDDakE109hjoBlyszzUY+bhOqynEDHKEDqHWhqtEnYKYK0688ldo+iRCwVlPMwYjEpQ/U0PqPbg3D3f3n6N//um1XiN19H9g3lcme3sLI8wLVxwGfx3kFEC2g1lOhOAMggc7jwKSCodfyTzEgtcxZ7p1QmxTj3nx/XaCNzWo25eXt1pSUvajShMKuMBDPL8SiEUHMZmVHAlbuR7uT+tLWyJH6f4ra8iW1wvNJYftXW3s2kA7PHKjEYHDt7vscBofJu+FZ0Hw5cgRctg9PcXuoxLMBct0W+2lgAc8kSiAIEGIi14M80EURVFnazFGatGYx3hKBf42jLT4zrOrJL03g3msADMAQugoThtkxzZPQCXrLVAy5A3Fa8JjtpUjqTO4zjYOmPkpoUQ2T2axiNQBSTyUGmHa4Ap/ffFIHHw73+p8ztxQ4nLNsp8wCPWJkBlccMWXHywVisk+gSjDMrJwajLVw+gAcv9SWhUF6eSUeyxaRuLYrfY/ofDzZ47sLHwfMzk3pJG3bD6AOz1ClF7gtwtuhJH94VFhZgyM795icM0rXsgGj7/30NKcRrBIdHsfX6N65kKSOfwT75oYCv8KcvxN0sP88rTwnprMgAXS0YhLkR9r7EyRpPY8WSDJz1Tir5qA562FvO4RqTALzYXL4l7AHp3HKC1HIwi+IlRde5/X8bwUR9bz4bGoEXiBTAApFkA2HiZA3IyTxUEaaWEYmwZZXIJ77abE+c+6N94K9bE5gEj2gWn9KAR8v6StCah6PRhqyyxiXUSbu04Yz5lylp2U8s8m506A+7V8bX9LrQanQNczrEviQORgheyJxXaDnzG0E19uiKGWdO0AT6FbQlx6R1l6WXKVqhi/o4FMG/2jG729LMMNneCk+Z2QjHRgQTz88E7jHO9r+vqtSEAWoBIxZR3AwMGU2WXtrM/2XzacrlRZ/vrYxokIFXidsZ2zVsVUIKy6U1p1/vTBAE+WCSADygAfJcKy7KNgoJZAjIAGTBpdb4Ua6JjfPxlWf2MyWPPh3/+/jp08No923/v22zJHHNqjRqzzW6bGarUK3hVk9C0EDyqvh+14g5KW198I5F6wEYtJZsIVYhDNgH2JISGaoJQ94WtoFWBqCFZFCH5vjI9XNTsau2CFC7npafbj7FEd7QbpcrlwQcRCZhNY+qroa19ZcGbnQ+YwdhGLCzP4AE1vxesOafjwqr2FdWYTTxWlmxDwW8wSRqKUOI5WlBZ3jIVukMtTmEdLM0z5Qja5plAg0OlfrftJWUCAFZXzJAtCAED+N+n2+tmMRy7a7Bxx0CEu7T8GPA0a8X09bL7mRdp2Xnq5a4VrfH8k3/nJ+3QppyRt5ZMTcy8IBWeq6ddgg9P3cCakIMbx4UWtwy7E2rmLmYqlPv7Sy0wa1y3i8nwMQytuHxy+wWhhUYJfOcL4skBzaYP4KRPq7cqnkIOoGUfhHOvH/4qmyIj1iAr/OiqGa3O7nlqd0gVtywyJYIBjFlZCTVaWYaCax4Kgd2ueY//alXwo1Ug/cpkltydwguDFJbQiodhJWWrloqdpS3dw9TL+pzjBYAG5PGKLFtcTRnC+q2+wCWXH1ejuE1V49q1VYSk77ANCTR2tNWUCK3dJAAM8jQFrGoyMXJ/H2Akmnd3mHKzSA4rRcO+SmerlnQvHO5lyowS0NEA9Pn01oZrVPCnYgAcx9HXrSGIg7mcNPK3TPZvoet2OVBFUd5eCtWwAfzx9NKAQjsxNn0hgRWcM2h71rZpsjKVlljhFMwgFtWs2KIa3sfld9EADPI0ZwAQYF8u4ILrixqOmaVSK0s3xmFbgdnhTDLcNq14HlxQPQQs9rQGMqSEdD+vDbgE8NOKuJTSfLvQHvveLuPYJSzMqyy7ZoQx1PG8yn4AVDC/OoELNh0M+BENrDJnpyPFntgXTEVCp/lSr6bHbgrM+TzOsAEynP03AcoVc0PzyGrEzOSx4hQKfR16j5Id05HtwoOLtFySuCrpRrcKGloA1BHLC54xyXKhFTPqSq9zDQApWxegWDj6YooRacTwixXmyvzsvHCdAgk+w60h3aCngC5nP6J24pYsAOwVSwRbWcbSy3Sz7fKsykgCXkxQZIuO44bLYLj73eS9i/8to6Qbuarntd3spWH5jVcWj/phQI4B2qfMwlTtaXMdvrVqt5gvnNC+O+Nrt/ulYyO2oScDYIMdMhYAag4ekwNs4zYCJKFDSJ4DE8sUwcZUTn/kutZoPBiJN32vZrWat5vBjKpzkGQ0tL0up6vr8fuW1kD9yeE70zE5nVQnRm80adVWIoM3NZ+OCB6JwGp+kpOvt5qf/7uy6dJ8a00AJwKuF3OXWmutCRTg4Hw84qKsSY2ojZym3Y51jsriPKijD2dlVS9HR6vFnmByMMKMoJc9fpTflmEvjrOQAJBNDciBYPc39vIJ03g7LPId9tIG5m0ZY16qUGAqcMNsNVgrTm3J5hiChkMuprkvoy0b46mg5QyUK9YBHplkroYI0EDx7pcWC3EBADAgIHMBpCscmok0AJc3minWCuYGWmlOn28ccH1GNaGgCoDsFK48NQNkHRj+nJ3e6NCkaL4sShmr3uxeZoQxqkDB2Sv/iSIhUGa1xxH30K2uMSZm7BmE7EX9Mw8bOgPt96FknCKCyPLkUCybdbFU4MCY//DHBnkB6UWxSbyhZP8dV2vzANg2CekHy1ckA1ckcv9oL3sdwvF+tSwIPM4WCtsWQLdc67akKtr7YGUIz/nd8GTPENq0eNEdiegTwQj2+kX1NAcpfMsj37Fv/YoXG1+TQytt7tKK+hxESj4BtnYMiJSNUBAyG+H3/Z3l37L+ujvbMxp7nwRgBpARQCCRZwDaWWGYojB6Mj989naVL4d6TP+Y0SzTUvwpSFw8FJciOi5Wg/614LRKUv3/yhkSKVFZJ6rmihkj4N5M0Yo6wWe6uls8J0BJ/RmBIkfIRExWI3wLglqBKvamlbtgvVDbn70MwBxt68GPIraq850JcKyxF2SZ5JBAlNCZ2T76e7dYyNB/wIGPc/kYGQRxpZqu88JZn2hUizt1/5Fas+jrx6Wyq7mKJJQIrWNWhUui8spDUhjJqpfrFr+N63s2Gg0AT2dnUwAAwLgAAAAAAADZXVE7BAAAALe2Ln4yLCsoKiorMjc4/wLo6S8sKyosKDQ2NvLb5igpKSgnJykxODnu3+ooKCkpKygyNjg27ei8/Uq4Z1LI5ixLnfwOgFQQUMcGuGQPQdWu8WmPEb20VGLT1l0/eDZa+VWtdBwGvcnIi1bRoZRifRwBAg6C0w+JIn5MdXtCHRX4KtDNdI24uiDrfOw10RT0BX3ODtdbRYc6vcgEegmLxQONBdFzvMA0/Y3WCJf8VpIUrd3+yRER7AELnCevlLlyFn+dBAAXHDybDSt1BddBrtqjQvWKpFe6GyYP/sGMLIkGHAI90Y6lRKe4fyJBwEHyYfOeEZXS8MtLiYLfP1kW0xNi9xPDD6tg2rwAFPq8zq673DuEbGt4Q9CA4IOH09TiPcvKNjCF24eSs3KeBmmJHDNKhTt3G7wNi6qn4tRW2slX5XNhgTtPuoeIM+vWfD9fYyv739+vVxV3v3Fl83jZHGWYLq3+S9QBDBK9ohFX2uH20X4aC5CynQeIAQ0Twviq2Gio5XAJtfQtM5Yq2OKvSpKim/pxJ8DV0LI7rn87ALQZd1GKnUy60I3t4KzqmSSSFqyD4mV9xll7le39oLaTyu56+YbRaC1rFE+SJpGDvoxrpw+H5wAA2qYcQjrZaq7h5KQP3PykBPsDAGC/FADG4QNwCzA8rQQ44H4bA5CEBlrPg4lhiuvrQlFGGonEy5kZOnxQiWP1drW3cjWmf3046TEqeNJbJCoxTpv3Pn3xQNJpTy7ks59JetQI4EKjgMhqePj5xqHU/f9fuXRpPtuaAE6JtHZh085NRVWRTkmgw8fBAfSz4UW3dm3bVDhvnV/crjlAV5eNrVHVP7cIGwBiQcmXArunV+FTBljb1tQdu+qoQqo8v14aRciZDFVqYQryEigZDTrKRB6WyGaWqByqRYXNd+jCMfJLieuAUyVshP5j0I5iLQG7yBo9KbON1g99ckxrtu8YmQDeqHTYBcJEwob3FViAgab/LwAOGpCQpXgBAJW9AswAZBNymilemut32/7ucaKJNnEDQ9mx2E3+qsm9d7JEWs8xanpiDGEvcy0ltTQQ6iGjaQPvOpX09KFSFhawErSKxHRaRAGAaznYU6RoUojO6eB4NEr2dqWYVMMktqrnMaNQuKCAGxqb014/Vr/ornYAkZlomXChAN9ZalLcDSDBnNj/h/b9ObKZr8F9Nhg8HvIgIBAaDEc5fZg6b6+SNigww3yywfv//dq2xFT3jokwd1f0Roz/eK2e4ALfsvA/fRf4maKcIStdnfMAtqcE2PethiHJ2PC+efQS5Smn9bHyWXj+1QAcNCBgWAP0Cg1uooXVWlH8qm8/Q85yo4fucguG+63p32sh/70nR6xExEeJZBWDIV53d8ME7lIS3VP+79WggpTth6eJhBbuLniyHNMs1/ZhftsFr1gTFRvFF/bErBlf68ce9RWhQ1j+9V1JV5iExziHmS1HSKFw12aLM1UPQMbDGOn5v/tp+6uHNea0cgYw2R0E2sUA2wS49/D9uOP68FSosaHeOj7Z/o+fHiK2+iws/FlsBZmLNFTHZC1rQcHxx1CKz+VrDz4bwPXYXWJTaAAkCnXRkA8jaurPYS2CnxALAh6SJ533AynboeRmS9SOYRWjkR6feWAYvENpTYoLAOQJy6KnmII1wV9nsgEEHFTkPPe0RZIS9n4qnbBc8hFVORLJmB+quFXSo8wA7AELjCfvBHOlt5CuCblA4pKCGWEpGaotLF2ar1zEXF/wT4hc2rJKka9jA+QFS7pnd2aobLp+ujUIJpm5nU9Jubd5/DBM4MXT68NWTiRWrmxorbriAswJy1KCN6hXqfHXrRMIghnOlT8z1FahSloWDbKydkyD43g284lFTlmSmegJDP4Kkm25PBfJfiRAwEGA9qe/CB9n+ZuK6Ely+l1oW34VHiRIRYSj2PQFtcnzC6L4aZ98FTGgSco5c/nXh6TUDMfBLkHz4qEXysz3769mjda6Cv8o8gH9fmHrvQPcBf2050baifzQAnYz2YKKB1j/zY6NB3THs/9H0cqpvM3b0G5fK1rJoLPjmyoGUxYZiOgqaQH8Ia8EI3/bkFcelkW2TyBZvcPJje6fY9A1Cq9mE7KkLiSVn1h1QtzoK5DlJrM+jjrzmkN3TgAaZwyRaS6SG6k6pfdpOX5/AAD0G7AFZNAg+AEr8OZgjaABHCEprUimuO4cG2bkNoCi81FYumo8ZTKcryu1ai07f+meoQDNIL7NJBzItkvZ/RlXBWhNWnNjdcRSoDE5fX8m2iXbn03lqhOlwD0+TYc6snkEtRFv31bz0JuX53364roV3SMH8mPSztD//I3cM2ZhqQxGd5wtw+cdz4Xl+ZEA8NvDMHRzcwDA2jShBPx5blHECgBGScleezrmvrqDLKNSa5jnhjTaYBd4BlCPp/wIa5lzwYrMOOak+9LQT46b5n579ZoW7S8ffLaMrZiDBj/rAJ5YZCAFCAD+3bAGIMcAOBIgILMCaOchk0BABxyzpnglfPqVGb9Ky5VDs299uRGQdLYao2mZc5g6IsIvRXxNu6o6KqwsWuVxZq4hkahS/H/Ktq7ArbCv3l1QRXJXXtmSXAuCrhKyJH+YNYCdfV+ffLSCtx5iQntoybWwkCIZWq3KI1FSiwDrGXMWK4YOnUqPZ9+5SRL0vIIOBd6FU+yWBSTBFDkzIVGTi+ImufeTOrKuEoKGwWkdtmdS2Gd2QPcra+GkqzDdKfMVxoaN6kQhLoimwDVM0oemqvl+6rZXJFEpc9gWpMgh5vS9+5/RfRwxF8QmKmCGhNkaEFcAOe85TQrLdKUz8C54Pfu6eAmecmsfBwf+reHZdGI/iPZsMGWDXtrmZAYAd+G/hzyIgEy6G+BOF0J2tb1FTZT4kXkjLy+01IMgrHN7+y64WiaGQyAePbdOlqzOg2So37BErUWIg7XxOa9poN8SUZQ6NfwAkJC4krH+AZ/+uiyN96SkmE5YNXOJwZzQdgqvvU42URfmV+XvosWAqy4G/pqCj/JUmcvtyk342IO+nSF+5u/6bhIu8NaKOMdU0LqC1teaNc4wPYAJ/PEg84wEBLh9NcFVvNn8904lY6Prx6kNg2v1JYIZEXb3rDxQTGIQABTyBGcjazgt2qnoABGB/XMj6COSluN1/GjZA6R+ka1+rISVIdoYb9AA7PFKGqiMCmnmTjkncCXshDwW69b6Pf1n9V4dWNBjbRKdlHdCL0uw+QHE9YqdjRB0YmznTxYYyYAdyG1DpB/i8vn9M0OjlOZawnF7MqQsg7MAvPHKVTsqUHy2L0ziKj7+vaHrRERqejdUDRdB3Q2oA91k3VAU4ocO3PUKojF14ODPmQSM4d7kaFiSun/mbxfib5kKc/xRdZDxF71YRcg63AU145lIKn6YdgAjoY4Gl8/dqYgUG8kbTF807jKg4lnOjfj1C0uHiQH8BfXNiAOHY/xeQKX61NPbtCsdf87Ih//uZusbxAgnqB7Fi2xTHQBzNHYWrYnKK6cB5AV3SZvMiozLpta2JtaQ0FoBxAPyzCdxkUwWKq7z5H93fVWylVzE2m0GrUHJHraLvQIk+l72NgHUJa82+3SMW8z5UJJtrf2bnBZY0wBn38k73Jgidsu2elIy/pPV8JREN/W/pIKevp9pa8phjxKFsgG6ZyShKa5yxSXkzldvMfh77x7jjHgRe2V+A44MQDA45gExD5ekksAHUkoowRTiX8OztnF7tn3/c9Xiusz1FPPSQ1FbdvXHdiYZNYkSJ7fSxuiOa0xuNqAgxtv/ftkdxwvwknH6s+1VA48xTk/PxJl7R3PZVUNJxlg1XyJXs01KHridV4nyfdTM88HHgSwehPLcCnB7CcYGSPi48DR+DB3a/4KWjClJXgV5sTI2qVHGp6FGZwMqwM6W/QraU+/BZ0U1E6Y5s+9V/xSjIAgMfkz8cVHm7IXv+kHKqc2oS94il87dWex2Jcp0DI6Zo4MBXliEoAQhYAPf+9SN1FDTNLZJlsBdAOFmHiSyr4M8FopxHvkQg5ipplGZU6x1TGXcP9cPZg4z9e3jppGRwhad3WiSsABdJY6ypmH/nZGszIoPNU8yBHLSk2ruUgkJXyNLqykTqZ3zrdDlMAm4c6hf+N9XIqKCQdS6/gagvRyJZIFrYfpTxRhRwiqWYvTQRima7v6qhios0JSe8y7RUrK1JBw3/aPR51WBTIQKpg8Rwgwaaxd7NpznNvF+sbii1kPM+9x2hZYNg+LguRtdNZEU8rY2xRdBPQbcerOEkzv8A3ZX5EBJAlE17PG/N8qjKHI+1EwoNAUcAGowHKDtq4RlTwiSojW376l+39JwdWtQ5sP+mMnZxXj/5+5sL9fIjGpkpWc/xAbuzWOTYYyRof3SVYEe4/M8RVRpq2yudXAuthp5UrQYAQBQW7u351V8uISijQQ1RhfczGDIOuM9iMTub3vs3dtXPDV3bBjRvPvMsONtiLhTMdFA5bYS76EDVpP+8jUbJfa+S+Mz4n8rUtf2Kf9Zd3fj5Mw0jAiRoDSWP1QRhAKU82xzq7jFKsIRTPqOM1dRptUi6ZeOhHDluRsiKAPmwfYQOW5WNxTyfM1IlxvgNhsOvWQ2/+b8FYbWpMQtxZo63V6EriBE2/7N0aEfFwDM9co3W5/AN7z4KrtBxJCYHmfjss3WM75WrcIdrbqtM1qMkcQURwg8HPZ8HUxCujRy420IUsVHS5r1wi6xb4KeMfLTqLxhcn34UE+sEFj7xgEE8oo67RdpHEvE5u4BGMkPObBkUI9Ca/zAr64QgSOODEm0nhE5soprHgTyfJUlCONsNHM+J4hKfmuapBIPoaBOezJVkjeoNv4qDyJ/x+mP2oIpXQHs9QomG0IApLspasBI1g7u2QYQNsmmXcXuVNvNRJReZR4+Kih4afUn/Pk8Q2MCAfO+raGk5c3dtEue/kjXrXcOFSv52d+C/tTTtf9wOG9ScfsWnryLsSMrqgDcEUuggcHastdYddYkNwBUPGwoj+Qg7SnZb+sy5lpcXg+IjBw8JHFRyOJDyN3tpTKjfqEaswr8MYuUtlnv85Oqr6HyrOcCgXVj0jEchnOwmAP/klqWM9rpNRi3VJs6YxQ87NKfQ3WY7VEVPzA0ABwiddJubL6HT6+pHd06tUWjVwfeNcaUJKHHxmrYmqyudGmtKjG3kD8k/6PZnGe2yL09dwMhARpntBTf1bUW8Fqz61VeXuBE//R951etDWJ7BtQywJNM6AD0OEFykJaGAixZaWYk0THRRue85f/L7z11tuFQu7bFh89ea63J6tLXqUlHCYdAo+5/eS2rlFLZ3N5tthbTrqYaAjQW7cdcRaEi4TjWSU9nf+ozSUbQtl9C7JRuQHgfgYYobKr+Cs8ErFwGQEhkRSNRL0krzTmLqWxmLXQwvG1nCXduoQouinG+FIp5XoimXmsU5lLhvA/ZdlPm8IRP4zYa2NMszPqItyBkA+oAtPC5OE3SpGBtKlA43dAaWORensrDxmqlq5qmwt8mAF5YhKAGFxCA720CwFBJwJw1krU0A7tIM/iJ86OTrRaM7Z17E72xNXyaqg3Ijc/G90eTG/+W3JoooeL+gQ8ouZ5pVKk8SdEhqNMrcXZ06+xNC8Toa4LsmJqVcisurVDT42akmUwTm9grYME8QL5foyR09SeELm4QqeI9MgBwJuu7/GlWo0yPDL/3zA3sn27Ygh9NI+1XaLWRFrPTIZrFdnqvBOiVjbjxB+MIXv5q51awSo8iTO/KE3QI27Cd1zB9wl83dXPZZX2AEzNgffnCW1khDcB/6Q1bNVawo2ZNN3VzfrQKave6QAJPZ2dTAADA9gAAAAAAANldUTsFAAAA//vnEi/rKCoqKioqLjU3++jpKiknKigmMDf38esrLSwmKicqMTY37OzkKywqLSgvKjM4+nZH5PhUQ1m5LoD37gzzXkfWR3QcuTVAphA0lYGJGbgQMMIYZTXT2RfTzXzx7X1wqrZ47cXCu9k6/rUR824Rh4EH1088BG9XTc113d+UCGjRVczxodd/ai7XOhAapLbNl/P2udUvJbR5OIldR6EkA9KtKwFMO6yTOpZahBmhe6Vex8IOTprtyyLqyNRQ/3HH1CYbAn56ZrOHbd4LqAtR83pc2aowrrUOgdC+9x4639MpPgL/6rrmnbSx4ce3O03UlF/7xk5PpHoK1hHtMmBwngtCbVqffadXGhwLiw11YbUhZlw4gljdiSIBCgA08sQOUkOAGwhOs5WBXjIjd35yhqtduu5Z1x0apdAiElQwxeq/6eAOLAbFjpVcY8hXynTX9AHANegM9SqlbJ+qJ0oXO6mzeRdd4JR2A90jW1oHDO4KGhBeI7BQI/LpAhFJnZeToUmpyMn2ukQlniqJbJ5ix8ni7bPMylUC7PGKqv2LbhWC0zc8CcLz/+NXkhJWq6wUHPKX8USgfOroVUqthWTAkFvzBPa81YCq1pGRYm0zVBKS/PxsVmxOcjc/u1fQdILUTofLaES410o7sboADPL8zeCdDyJnHpkZZ4Jwybw1IxXQRL/79YKTnBmVOSq7H0zf++YqaA8FFPZoaACwYPyZTlibfDwT1KewesXBQpyUQ21pQ7U2HQI15dEYpCf67DmsgBtCS/QZi4kNo4/ZxbRdYwmS3h0DzCW521FVhsajbLxdaH5z2Hn8XU0apYB0/HsPvfCa9OgRBSABJDI1Zj8O/s/r/DM2xLYqWTT2XSc5eYneJiXDjWFtUbmZU9Cat1sfuuVeWz/NgOvIKuda8QGNCZp35EhXyDKte/n4JA6/ToPv3TFPn2OH3MjIlwFQO4AAU2UJQN+GRBKA70nDCEIZgBArRufw+LLO624+D+YyYWfl4fbGdGjJs1+JyhqrP7/HpEJA2rIgIr8yU5USLDFGJlr/bCJWUmUD1z4vo6Pv+7NAdI0H0x7qw0rf5YdaUftbs5vIipTIisxLWxqvfNsAlHQpgBgCseVyT+7/Qdl1cXbQDiIxvyjV7ThVYIczZmER3Cspgb2RMZ6IC3FFZTJhRybN21NCNh+QLxPSQUBseenAbvUGGB/A219LFQT5q7dD0CoqOlu2im7rb+YHO/CIsADtpm4R0XqJgpAAfljEoARnAET/A4nVYatMQAZYlZ8FAMMTkIFbjm9MyZo14yfvSd/sm4rtuTo8nu3ptt7KyGf5Tg6t9J6iQ5k9I5DsqUF7b+HihoNKKxJl6Dns5xisLsIIwqO/PPT33lAmsV/VD0mpoSr8IfQs/dT+nuve6Eq4J7EWTaYqcTY2gWhEe4R1HH7UORzBtuZpAx8uyvlkmfNRRR9ZWXlW927Kj+lxbydAr44uxVZGFaCurrCce+U6SyzB6Nno4ZlZhUEyqpRxYn1klri4bxYqVh3Sde9Irff2Xd85yHDiBKFZS4r2QVQL0QIBAPZXJEAZhAIg+t69hXqckdStr7cvwAB0bTC8MIAVpLSETpxQjO/FG9dZaLpYav9i2xMNNj4Pyj93XLfJJLF14kN/sYZzLsBFczUNVPXueZPl/NAmm62EIgRxaKtzu5d/0sXMK8t79ocjqEUTEmRpxzMNehbzIVjzfMSwCiv/YFNXudkDR6pE1KWvJQzK3UdNdXivwoiByMEhXA22ixRe0lcrC7tS4E8nMKBQVRvPzgmaoZ+Eg4Oy4ugyngrj04KHuYRoGyNFhtfrnvnIp0Szt0bug8p7oGLjmJ/MCKuQbuab15fPSVnfDlsC1PFKupEwBzU45l1VOwG4itG/K6RCUhf33ppnaKex4tXxM0Q781mUmGAmxPlKJwPCHAVHZb6IBFYFJnfEnIIyciLtuL1DobE02t4NFiDUo98N7R3E8YqzgnHtAsyKfwbASOhb7KLu6ZV7qwqeVnz8xDwkuN6hZ4MfiAAE+vTNRvOzeEChQTPtAC55/dOaYa0PbZr5FWG+ETgYCdFXQsZ/ks5qNgAM9jyVRcpJ8ca4vnqBC5oH8o+ypjXGGnrqE/3UBJ+z0Fs0GLfrZy4E3PV8zh6r4uDNSQAjOdy8LTJOruLqvnk7kH2MmJ002gdu4Ye41h/c+XTAE4AbhjPKQCjLqL/5oGiF9X/7bX9ynzrc0E4j+JRaU9cuf+dyJt5IL0z6kgcMHgt9wIbmh/ppLsa8FT8A6JjFi5mSPtpKjXNiXGVqUizxosf5bbGxFanJNcq/94uvAxoiE58A+oa0bTL0xcMSq7Qph3T7OIrphhDSc/n7kQBwJACmDT4YQGMAkASrXyUYCImKIcEU/dEX95PRH8/Y9PI7PpXXo2sMJtdBlpg6iKwTRSZxMjVvKQB0vX4KOnoVslpZBhSc6GaMb1MvL2VbteA0P2gWT95l+qoR4zQoZcz+8vPRVBVdtbYKbf+1Lb9mm00iBYC0oq5moa01GBOvdj9ua+0Lj04L3KYOAADUGvs8d9vp2DSz2t5cTMPw9QmRMCH2TcKMBYNSTw1TMgAWCQBqK6UuFRC5b7VQZBQU9cHRwuLyujXfGi+U08752kSrpFB2CXPtsDl+s8eRG96YlMbFNkcFGQDvFwAAAGBHDQCAkj0ArgBmABnQCOaqAyElhMeOKQCwiDKrRgCAamxfdiRS1asqjhIeHQVakn2OcwEhoiIuie14KkoKx3u5L+rXzcFCENlUNCbJe1/f/jgJGk2t8OvC82NbZ0CQHWusqJNcd7tM9Y67poy582dSk2uamdBG1SfLT1ezDNtSOtrpAI3R+E3hNeIbWKAM9WuqdnezB6K6RlC7NUZGhgQACcDKf4KxKM3AQcC0wo0Z9lmYVw8NtKUutN4B742V1zzcm4QScyyKbNu2Bw63ca+GDQ5hdyp7/cdNd8RWwZKCNAG2ZySR71ljXmQMhL9np/d/8gRz6LwaMAOaFRIZUCMDFo4M+oQVTjOHKHJyGm8/bU7+P2tXbuO9f+GC6sVXa+FslTQruNmoqL1U9ZR/l2IJAajSlNl3Rh8CEw2uPtE+d7WIrIJnS4rx/u1Br27YGmJEwdrk98XX7LMNjWSzvY9Nm5k3I6TsoYOn/0DVG/KvUtppA0vsMGV6NFZhLPpvgOqqvchFluSWhUDRlr24iOg51YKQaJOFlNe9e2GHgJy6y4UvISWuxcqByzNLttN+rMT4VzsDSl9pq73NsRJT5gBDU3ebklINTS+cvsJ35A29zI4t2y9XIzX9v6IrQUTC6Ats29lxqg3uHDtfOkYuf4m2zMwzs1TqGRT6KODBzl/cJGpU1jgTQBx0jc2ZR2odVnygVfdgTVBTyi7VqAzLbcNJFTv1AtQBi4in3PzyiyW7U9EFiAskuT8vkmMZ1kOtYH/bUV5+/7AwSDcDadZuCDUADAp11p7kshfYuS7ACP58XkCnmOL8a+jfZhuH+YD9CdrylrishgAE8gToidEvrRrZNItJRPL+7VeSJzd2p30Muz5sv5Br1coJo7DkmUX5Kh20AcupAM3PL/DmpAbBSzA5PZcJsb5msp5NDfsKdpErczPn8JjJJgDM/XwkEM0r36c3U26A4IKg8cZJRodY095U4jhoy1UVp2TPMghlDwwyKgUM9gRujzU54M+rBA1mYhnuD3J0/WZ14okOxa72Ur3No1tpjJ0Ebc2pZyYPuPeYhGkB1CELizzXcsclFOWtqpvgUcVut0CIgWww9Xky9szkmi70APTf952YXzyws7Gi9cUDrVsSvNYA3B39Hu3Z3p8bsT1219sFJhqMOnDovlDzQWlk4mbt1cG20sEXqrCtrEi9T4XnVOEBa7UaaLBqA7qX5CnR5d3S1VtKIeWUbt/gzWtcduVAnuz9AABHAcA0D8uTqWRJANKA5HO0JFN85eYer82aYDdvTGL2Ji/u4LA3IioOZ0mRohhhn/b+s3WMPrpoDCPg0qLSWtsSowKRtto9PpScVkWgWnj8c+XZlU0XLs0LACCFhGPTMRkgBIdhRDI+ziiGhW1H6Rb4mBt9bPUkeWZLpI1ZZaseaTPB2H/xlTmy4uGCIt2uyFMId+kuLV04SFG4BiXU05TALgZKazy7mppO0ELuShZoiSIs9xachK8EH4dtXhX2sdWxDaz3oeppfmlsTcEkQCEAvogU1BW00NYMCri7uSlVWevJAOAAgA3sCTCXQAZggGtkUIZBikmntab432bwg1/tp035Z73t67SZr76SnqSCDjDmOU3Rlhx6Goqc5gREtXVkklNpY+VKotfuUZOQllppj/7dCiCVpKsAomd2SKxxqCcwWSxP705PK1EsK8K93MG0szYViN60gDJ/2u2ASZsk9qAVyTjXy0iStrj29Qh0FgcATXRrrPSU1iRQgtrfMfCdlZzfuLnEmoywK8lADAiR20uoOW92zJB23Dzy32DFTXpULKMHoP2ANyJlofyUSZM55gADgzobEhIVeAC2dySp70M35ZWsGPG+Yzgf3UZFXepG4ToAwAwYadsBDCAYvwIllBNKUWoiR9tl32KYlzROmUTnmFfGh83HxSIXhyKhslhKRJJCSe/cHJUE8xta6jXf0n756rQq5WGSMpwe/HKbBwCWJ5UKzWll5DYAlNJbC454Ck0LgKODJZ1eSzXeS+dshdFOEV4Tnlehw4uXOR+q8Gr0p7t+hSzBGNCvbHSgXf7cmlOFkhZSEqHNssoMpIqgvbY0g0hubqGfkHNxE1SpzWY2BwkIfNW5q/peBsbuM7qdlebYX7ANtu2CN9dvgA789VDdGzh/K386WtZ9cieI4ChOGlNPaGVfrOVaw07oEaYTvFNJE5EEwZINHP4oxH6Osd6Q968uQBxMScP0tpa0iRgk4fDOBiolSs7Fl6NChluDCievbgAkDkVsh02aPxbK9j5ZgCAJ13kHpJRUkWrOibxlnkqS8VXofB3by5TD4AHkFT3MnkfS3EEMPeJbAEawjgStNPcqW8Yvu4pU5zrM/VeISwnvJ/EkpNuvNwAsEmllJPnygZj+FZsguCDhsCFP0jjaRZ+hvs3kbPrNipaTnPNxK/IA/A113B5jyZeS2R0gDhqOZStAL5nX9jbe9maabm8Qyn2Q5sCeyDBZeoajJ90V0wAUBgVlozkxw6Yn4yfHggYEB9dXNbkSjtGj8p2Zao7Jjg2Q9Fqt2PzdUgfUCQV/UNtTfTe+/VkJSo9e1qL0QJyssGIRBEEep/Nm1Oxn6tYdrWt88P4hqGRrb6OBGwH8Lf0F9m3omVLsXOS3XrfBREeJMn/1GB1mrJanj1HOWpapPqjaj/OYgDw/TmASS+udRz5c6cZMABrHVDm1mzMKH6tOrLRCBkzvPwCA29kCAB48AQAwMg+XjAOAJBSQMipbGwaG7LWeunPlgngo0HJZThUUGeLUKEKpRfbmX3SUsU60TmZBEDebms1I6xFBy6DOV59mpmNEia3RVv+shpp69K7JZHr64Mzvrx88qm2V9Xj8pfu+qVx++rBxiiM02l91uyZif8B1ti+R/RSGzDZvuaGIhdXcPkrQ/uU0gIaz3mJ/j+dhT2Uz1P3sBgCAzK+IwbPmjodSxr0ifPpndO7X830CANkuryIg3d3dfXnvfhgQwtSUf3nay/18garwvV2R8S+UZWFMO9ydEGiN0hvhlwBPZ2dTAABAPwEAAAAAANldUTsGAAAAKtyumRrq7yorKykqKSoyNvXe2eji4tnh2NPX1NjW0l64xMCFloAASfsFCTQ8/vUzANgBAMAW7AnwJFAZ+E4wdEjkSSc0U9QXdguumd6QszKrMVwZx9VZre+tmHINWa+VICxm6bv8zR0PNJAlDRAHcd7KWwMHEokkUAcMz2SOWpJEWUFrY+6h+8dX2RAdojn9+8rrD/ZqWeBU2FN43I7NS+rcsfqsmgLh7vQwyR2VlWTU8e9pzidoxpJuhnV6a2MAIjtb/ysNIA1GKn/J4I561mGZJs9+2hGrWV/7JLIviHctngNzIdJdnsbtcHWmKq2TM0WAMXkTF602odCiY2Bdzjnt1b21beQhANanpNgUQ4WpWjAQevvvLdsp4rB27QQAgBmwtRWGiHEGJGk48ISEUkZR2L8INzh5XksOuFtiuc11rAMAFlZBJQQpaesPgGpHXR6sdZNYGOtGC+LTN4fPTjN9I+J+oR4tw5//L4vn9MpfryV1ldTTVldKZUo4fKD4rG8rnIQltWzr88TVzb6QTEx5oFFTb2EzmGm9fzNLnnRNdgyNwIIFc/MnzTNhSpA0paihA2symlubWWq7hBqLfmKTQq1unxtGFcBk85G6VNBoK1VdaaO+tej+kFedpluvEMcEUvQDqj/yAUh23M3LKtqlQruDjQUABAoF4hmbNQ+0Hl91G8TBNODmi74Lx0pCksqSYb2sHSGFkO1xIZcxJkIA7P18xI4t5i4gb99bgHhokoMFnkwRV6nKAOwfSGUmTakB12/MV8uqMXo9AAwGNegZyY8LqNtvVrkRB03Cw4/3e2yJSUW6cMvmmTsV3g/Z1Xzbe9aGHwD8DUXiOcVPrsDBnzOSICWrxVzde8qu9sDLGBsbJErFOMK/skntpMLWAez5Cow9NioXxEgzVIU4IDk3/GsZY1t5aynwls0Q83xPfXmD0eUyDBtSAgQKaZygj35mQvZf1AEiEhpn5zNKynYq0ITxMTXriL+pyJ0Jn1dweiMoDA4F7nk0L/cEdyqHBHFQlCDq44sUPQk7q6HwfSbxrbW6VQ9nvAf87NIatBH9QrC03HwbvZm+XZVyWu7kk3Ez2+yTp0WQp26625g6eRdkO1rLm7dBZ5/syZT+CgD8JQsKPMbyjajFWrcqNsChQzHWiHFFldKLryRHXbIJ8+DQxvXH3Iop0XOeU7b4LzdlpkQ3YQNap1R4LqyjXS+vEiuXeVII6fu9U289xFXWdWJrWQUAHAGAYh52mA5QIAkNJAGpbChkFBDdEx25faJ/Mf/kK043814e5zgFHFKpsH1IFIi0dmH2UTOijupER/Fiv6TUkxezrQlS0lrWmORrtCIrC06c/H0w7aTNr4xaXbp0adOnK+H210dn+rwAAArIsSTtWUPRoMIer7UP8Fi+dZszXhPl48c0fA65jDWsQRIzSLxhs3Bj8rVKKfg6r/PcAwXwQAVcEqDNTjOm7gLohR92Fl5Y+aJz7nHTDERY/DuWYVarNXF1Voj7owcMCOp8g4yEoS6rtJouAb6Y1MCEFqDHLHE/UiJAT/3qDQA4EgBjK6ygZnCTYFQLpFg4JpmxkV9wFZXsfgrrvCp1C2H5HunTZZB2pBt5V4Yj7G7d9iWaEa1YhnsU1cVdjIv/IdLUVSVOf08pjsQovaNiefkkY+LMo7SpBwZsN59mT0JR2C3JbJ5sJrezhKRFL+skXZBhg3yEcR4zkpI1TVm2vY4zXw31lM2+ea6qsEoC4ME+ATZfLHWtMGBac5FLkaUfegAP42uWt2padWnWCQdhht8591rXWZ8Mq7i3HauUh10UCuJ36ZufCAEFAJ541MAFFADuRzQCGCoNZwcN2FEAACiZhy0wweCQht0eWpOWNVMsEHry6yOtV70RDcrqz7zSGNvStfFXxplBazgYqn7asNNeZZJrhJWuivuKwitJqBhR72KQtJhxoVrp0FXop2dTv+0eGYOK3B/HmfNPcxei0nVtJBphVEDQVH/s3XVFd8NQWNp1bVkPRVx9QT0xB/56QcyxvpjbLlVRwwbhG1DkJR3enx1XSViMTT5nlYIbnGBYhnrZegErbWBbc1j8eukzWxNe+0lsV9nEwigLF3bL5pC9tQIeiIScCT1AL5lJ3N2m/oSF8UwAADNg0QYTlQEjpKGMoD3ttFYU4d2duWf3EtZ083TWK63JanZ7VyrpUpFpZxjG5qilJJRgTG6OxU5TwOsfwzbPy7ujdCqbmvngoAFTTTSozK+P/vv7wCQH3lHDMzDPGe6ak0U0Akie4Oi+nHryVeXv+Gl1wUahuOXnDbd0poEVLgTyhJ2e1hP0BUIRAEaq6VbFvnYe4Bml/L4uW67mnG3ATHTIgg9zOR3gRirb7hBJ5G0pHFARDa6/KhQzR2nQD7TReIVGrPv6R7iKlyAUh6uy8rkoEbEB3ncEXAq4BJRwv0qLlUCxX+8BADNgZA4mvAw4JGE78BzR6ZCi9MDU3jXEdtt/nz3c7JqcrAzP9rRtNR9KqWhWL1uVJys7RKR9mA5rVB1avbuWSomIDHGIw7N8Uy9P5JqjNRmU733pY9h3p1O3p9qCgh7uzKR1xm9bte0q8WlP7EiNOV5TQ8C3ZL6/3j5wtZhdsb/Os6owNKauukdZ3WxKYZOEPXgoIvham/fd+OR6qjNCBo0ZKoo08x271yOwTEHSjhgBzDXqDAezgiVOcayZjYEmxl3M6cs57BJZ0GW7eZB0AJ5oZLSEEgB4u7IZsWxPNQ0AM6DboKA6aejgtPOMUJTe15/b78pt//fQ/z//fXkznds2ejMXc1PLifQqxiydKhBPdLP7RmjuVCmjjgcmwXQQ2qYL8vr33bmmz0TZDvjnTbdkuGmmNSsbHb7LbmlW7LKWf6PmdUDBu4y1Aymu9EXp2ruBxcBJ0K6f8DtXW1CKVpbAjDSDRjK6JgKr4V0YdC8PCfDTHlJQq7EfrDrVtioYVTi/3nHbDbMnIepq+y1jfUEdzh/ZeWS0b+7cbbE5XL9+kZldWt5qgDLHKu0vVgokOgAeWZS6hgUBoN01CRu4PQBgAIp5GIQflrLaaBZW4daz3/NzDun0/Z/JB+pU/7TsRJE+EdLAAcuGXVuu0ogugfp+JlGqQtH14tYEMaoH5Tp7tzNDKo18jd74r+/Q+JlO8UKn3eS+raZ+HR2t1qkL1hyySmeFMTLXuPvfj/synDi1MyBj6uIVJxELMgfaoBsNGM32FZV7RA5LQDQORO6GkuvWv13a4L14gJw50ds1VT7dMHoWOxB6PazdsdQOxS/Vtfrkl8UG+ZurTsasKpN1GigthlkuhYRIVgIA3ljUrIaCoILg38W2IQyIPgsAzICprZ406PAS7TTJDAv/Hcs/sHdcM1/fs8jRt8j0ViQXSTUdBkdsvbhfwNKVLqo1sSlHwKj5Kwev2ogpFNlQEs8dTexg1xa1Iv96HKvOKjZLkPcrFPU2gsLuatbSICtuBDd7hHrCRkk7Oo9rSv3FptoM5S7nUqTRsqkT4qXa0+sblzaoHCwWRZ7yfdO0K+6REOpo09jeRxoSJIH+/p6iY21W8tg8qjOUzpVhAhrocgQ/EI8dZVQ/DBOvOjBArWakv7VY9c5nn2Sbexgb2DABXliksIaAJgDtrvnDVvSOAUAGmFZoaEvWnnKWlcLjttPZn0/bL164+aiJ93ufXlf5+MkdqC1LlBJFWTRppiLNWM7naK+h4QrLTbD6UloDiAsd+AonylC3JN1OwEwaeaq/b3EtDZgjOLk0jeJ/JnyX9Gv+l0BCg67iDiyekBXfSZTvjN65LivBIUrJbrmwOBKA9scIWbij0yw0s8Ncd33eCa+stBFseM3hH11hGhhUl7hmBea/NVIgESYXB5z/CgsXt0YpqLieWFwslj73yo4SolJ5IyIigAoAXlhkuAQQAP5dVsHYPAIA03z5QVr7mkmlsOXOf69evnhw9qc9ix+Lz9mfXpb07vutMdPmLqEy8C9kQbVQQrIbk2GuhHdG8nhALamA9V+MEpZpkkpNz4wmqaEuNvfteNFQ92LHFqoQdTRnONoflDOXVJeetBZso/gPTK5ps+H+R+EElF34vuvBO3VhGZey490hC9kqhPWV1DA6elYSvU5SRGiXwgjD9GBWD73RxRpUUaomayl7K81Sm/nzHd8EX6dwuW3Ab6oJRc0Z1qpza213BYugAX5YlKAGIAD8u1xoCrYLADADuraqtAsZzYpxI3/+0fx5s//bC7rW/9rmG5f3GE6zCdflgHo0Qm/TeIvLGKxGP/KUu75OAsRIrUtDNR+/3Q0ePd1YRBS+NcPaQjynhWSfUKSfpq+jrY6zOSxIahVVMksNGvFsIcTxwSgmCF8TBal5k3QQSkSmanb6IVoul/1mXQz6N6eVCfMaE4Ione1dglRc858LzuQIg1/mTSswdI1To2/wR1k93Bkzo68qv1kFJOErHKaV+M5wwwpQe2arDth+6fecisQDflhkoIaCANDeMJBuC1ArQJUve1FmqymOHviQuDWcGTQm0/lK7t+dt8R3P7N9CXoJH81UvFcF/EPeIl1RPvfzY/yaWkMDrZO6e39y7WDdCDf3m3vrFxEaV09ng8YYwp9vW+wcIv4rRa7xzrWGACqQlaVPyYYrscPlnuB6KyZddRTwlqloX9YIoMBgOFahD5V6WJP5aMTfRt1Uu2ikPKeGJLftBBWkljArkuDZk5yHSLgFkTXxpmXb/a5QGLkVHbSvymbirE3BLiu7DQDrays3ksLxHA+eWGSshSAA+HYFcYZTAoC29aNcupQmFSPv9vr9luL263b3/19bn12L3fzAx7re1ccs3FFazMYPzGF06cCza9q2jA3xaR1e4D1sSIFgLJ2jepL/ORSkg3oy1UKeHu7bep0VtJVMojusrOSx4Xk2dFeRSYqNf0dzlp1jpfS40FYzCWF5WHcVu8HxlIClJnUdQc5w7CWF8ZpY63h6AKv7yPVTSaJbUOvvACfVE2Ik02hAuZp9FntqWXxs5W99C7aq6Bqo2Bh2Xmac2uMSZIO2I5tRt23L3bUFEwB+aBS0hkAA+F/FSmCT9gWYVDLKMtHXSggGt9v9Mq5pxL7vq/vqKDlLbnv90qlSyphKrdEz2zV3OeKFUWyAjcwISS2lSApho40qe4Qj4u7T+2mdSYqSa4jwg4x/iaQXfNf23ISw6ySUwtB2JcKsYrv9QaexjwCUXriCvokbogwUai4FazrvBSM09VUJPk8KJ/NWikMEIz2RoXLznrt1H02tRrjTwreJUXbAoCSbbrOgiMFfilYExuba9i7b/PsWP2WyFzWerbCqf7SZEUbekwCEMvVUawEAXlikoIZgkID/MtqjCSBN/VErHbXRmkLyzWWqnc9s3WTOts/3bsvlLdZ/bLM6TN3TTaKZpzLe1gDRfF0k353aLPFD0HMj+gsVHGFXHs9SPA7KrjzuWdqRUtH/0XQx0dJD+ipYMGD5tXOsFZT0NOyrzicrubYwRElMXHxvCAMzarJBiVf3S4zez1Z6MOO/mVTwYZi4CjmSqgLmZgF1/fqV2SHjjHzdBoGQ6qFmD8RLLJAVepHlxV3G7OKqdgaRieLM4LfNFYKnsr59wMIaCZVybkzfT2dnUwAAgIYBAAAAAADZXVE7BwAAAFCslp0i39bTJikmJicmMTIx4djd0+HX1dbZ3NYxMTIwMzDjKCYmMb5IlKyHQBCA72wxNQsIYEzbKl+OiayZsf9260g8nt/mLDF9+F17xebCkTZvrOPEzmi9YlsmjjOT1fCWPhuEzlkHEU1HTn3pJIw5917ZSlIBnidkvwxXz5pcF7w3QB3veuJ0MxbWpjxOI6GYd6Hbs5bOjtUlHUO907IyuVjWr07OaDQ9GNhzext1GXFBuk+p4NQyY0+hZRMpCOkNuU8jFqO4EPyl0GGv0InVJehdMv9OplU/OKNhxV88i7fPpDLmxYYPE4l9aNYRRHqvTngZodoxZvt9eL+Sqe1R7HwbJgB+WNSgBhAA/jemTgC0BKaxUr+M0Y4VQ5Nf/H9+2GCr4Mr0nNT63/pr56kPvji49Xy4X82Jl3folxOzYDC0ccD6pTszMGd5VpPdO4D9xVJ8TcfFJ33b1oKrSzsD9RDBDylKBYHtaeaUpnuTsW76gmCqFuKqpsykuHc3UhIBjoEsZHB7Ee4CZ8FxhLv5c8+lhZ6i46YlmINDi6dOMMMkVgA8l5//TrmEfMJVrz+sWGTa0q1HigR07SEjEkgQPfyEofQvHO/9zFSNsi0Rlh10Ycbjqh2tYFIANlckiZoBBID/Gc39e3CrLbUYJzCNVZUYY7VgisbxbfLxOWvupqN2ZrZw5Vk+y8fbzzdepoeUuOTk3A7zY0HltDfZ+HlQ0uNOADNioHEowYv93GC6zjI/JZFyDEU2X81MH6CbUvStBWiMdMYbbzwhD6WEPldwkEOpfXDC46ZaTHeeW6PvpqtflHWWDNNUsZvPLb72mdZW7UHjxOOhLtub+SsJ3u1Ko+DEdbQ6qImDFnY/o2mHBhqp2UDtPNqwgigGODCiWzo2+8vDIGpma3k4beRJANzx9EEKBHLzeZ8egEt4IkUT3UrWtI1M+Xbvar4gspZgRm8HH70D9O1oY0AisogIUxyASz7fDGhXnKhuvTKK1y1xHS7Xl26l3g28hcSKVQAU9ugMnHCleXMnE0QkjM1EEE0q62LjUB+6niWlvN/KkrQ2btTKAez19A0o1wReM8TESB78sGcaLUvhgNPC6VfV1SXTKEg+EbGl8iUbzPEKgq0bGYFj524AQYb/xbNYlLo/MOLyNW0ROOWn8yW3/pv4XCwSNPagAw4CwnZOB2AEl1sXNIKKXkEzdQen4aPQ6nn/fujY9aLNQQAsCkkHUypQuo7rlAnAXcG3RllS44R77/op1/a9rs7FYevH882Rfcu3afQV1yTboxIAHApBBBkkED5xA+ViITiOy56ijE/bTOffFEo5HcpAyJneCHbWv4qj+5I2SsrNtn9O/QwM/oADznuWMJm/J4F08Xgx3eYGHLK4ke5X7xZKXmzfy94fcUoWrDkRE/h2fjpXktYAmgl1PiGIHwC+96847XnZNjvDEVcDxupLyisthI4WU2I3/2wh8rm1de6ikuXI9pWHTwO5mafzZ0f9w6/9+ArFWYunc0p4guQmmZyZCHo/2ztJl/Tb1iFODakUIsjFRm/X3aixEeeUU45l21gHdzrTe/uBoxH+6RdouixVXAPd5qcPZJSLNqMWCIw6Ej0HWJ50ruSz/uskHUVCYwWs/mmeUgc7o83IqTQqAg/rcF1GXTtilO3bWXeKRwhlybkvAquyN38wITpM2EqjUExB1x5K2XxyQmY0YMJmGLYPwxWBFQB0Hgqdaw84AMy3MNCUeQWMSVKVyBW1ZuDWd9qV3ZYX8uDkVj4bBj9Peyn91/+nQ9Z8CZujl/zgytks6xI4Uz3tkvnPUeymLg6FuHmesgSCIF1LBVMlh6H93HhpsMX9Yk+dCFswaXI1Jvkc7Kb8CxZexu4FBpBhMABR4SfssAUWEjUx43LAmSFcNTefYRhnn9m80YcP1/2gj4xi+Z8le2RBSdyW4+NRpDR1Dy1WX+EezCKkkE/898hZpr6rLpNfs4Rs9Yyt5fpCE0G9kgqYrfdn4jZ8n2u+ZismnmjUoIZgAPhuwIqiADCONXq6EmdJZrrlf1v7/S2/D5nHX6mNt1dWv+fMpK6rYr5Er1E2kvK5MXpKgJdvaJDQ7bw6gL/MUHxA85nlC7azySwBoUQjJdz7J2LWBpNP106Z+/ldteeG49VutG9pxmyu2jPvdEVp4giKnrIv/21j+llMeIC3k+gQTgpfPvYqK9vWR7KhYrMNsmwXEnAxkIQyF5GZoFbQqWUqpXRyeZGCJz3iAn0PhIBzl75JuTy2HOZuq1ViSZcXKyd8WAvMI3cLl99sLqvr57StzM0G0AEeWfSyBwhQ4b+6NnVlAsaSE1PWKqG1og9fzPkXl84eun92e/OlB36fPWQzYNk726iU6U2HrZIKCqYIS7bWLIBrJRGu5Ka78k13LQEPsJaWLWikfasnrPeyAsOKQVmKmjxVUkY8NF3V52qWO0c6wY56rkMRZ02C8u17eZtHXXPX3QYhOoA2fHD/RTyKGbDWYLza2mTlUK/PyIcMkMPNGFauV7N60fobHjz1NB2mmJmDFcpeHCpMi2x5MUI1hgM964RvCAqXNde24s40JGn/BiisDkAHHll0poVC0IDvKq2h1wpgkmaXn8aStVCU/n/pw4d7T27SjtkLdrMPPxv0Mn2ceux7t88PTw5frrH3UlOMwzbYTtTGk1znV3Sb/Xok3lagTfc0USqy2gk4qMqWGoQ6Ms8ko3r1aot6s2+m95P1qSxGV0okLbgywdF8F8ad2mKgFOYZHVlZIRqZ0BPYQhewqS1xuqd8UinbGaREq+vTW3281SXOjNpd1R90MNI6Qhmg9W8dtfO4YaAfyLZDZ8TtDgXytVQ4iAN53drazOws/XnLKAg9Zha7UEVa6LOXlTJn6dAB3ljUuoZiAPjfC4INMDRAX5qW7Gk/KsNMH1S/cagHT7ozFBuH0o/Vxcsis1MTdzP0omi2wxcUZrSZUhfasH2bxb1SKkrjjELbuaupXXDYSrGoIviWjgQKcNbfn5ly8E1rcEwIK2HptGlM0iBVC/eMz5hKLefp7InkCj4+pkYcXIife35gCi2sc0Xp/WE7ew5670yXG3Hpca9WzqnLLrGqOvRLwSdiMxubeH2tT9XGspHxH3W1/tfAGjC7uzkFEEJ89X6u3fEWcpqwW1VlB+6zMpqHdHQAOgCeWGSyhyLQgP/yUERrwFhthQLaRacspauU3L9H0yS/3G38frrO/M536+DNtN2ntaXMtpiePArmuOZ6JoiKfZkMudeCz/J+V2i75+bxBocjerqDvnh+l2awY1hGpNdZK3QoSB011CxmnvDLv6DKS8KGcjKuSQITjkQ7MIdlw5ssRdyXVFmHwr01L/nuNH2HIrqVobzLxS8Q1Cg2ON6du25dK9gZgFjt8o8ZBaju9isxrRjpTyhlyfcQ/Aewui5CO8yF2hV4s6C7aEsS1cISwRyhfD1CRwE+WKSwhUYA8F2ZmqQZgbSqlWUTNZOW6S+bdb7pC5ZXDx3KGPNSbbOfa/zwdeqTtNZhTqXtTcUXcZSV3dXwSbmsFyjJVV/ktH1SrGRZfXpnbawAX6/C5X/d3YSFrHZdU4fIgzxVRre3UjpkDcv2J2h1lbZ8LxKa3CaMrnfbqG1CtDA27ZAZ4iVZlo0n8j6JtkzKNTIhe0uGWxm80LK1e7vh4iDzk4PsVmd9r8OMUdDKZyud4Ksxx+rYqzBeSe5z4NivezIzjojJlq5n+6YW1jW/KNP0AAUAnkiUogUIAN7V86dgrSWMo2t9X7aJM8z0y+GcVd4Xb3OOXZ579/DsNJ+NbZPrq/VA2HzSsow/XX5G9IoVkNiIZu4Qg3UXpZ3RkJp3KMsDskI7Eh9GSEBhNjctqsm5BloaQpcxc+/j8osKa62rvzO7z+6WRBzFX99ffo8Xw1ZnK/0KiAC+ce0mwdrrfaTYW9T8K2PcmdIoisfbZnoinGCEOtE0FXwps2g3iTzLQffbiSTNqqsg5uM6Xe20y0iQTqMKwRS5QlWzh8MTaKRDsKayvf4VNF9S7wWACR5ZjLoFJwAE3xW0l9sQMLbh1neuolCK0nH94K9B+S6GW5lndz3x95SRlIsHDJvZe9M74i4Ob6PpvpujDWJvDAXin9gwn5ZZMhc1HdDJ4+LtoA91m0+Lv0nU779Yr9fnQdhJ/sNEDt+seweIOV/lISCYwxCPPixomSS5drBuW20DHyfpHt0ye7PGndIOefyg4zKrtNp9k0RCKapY2U1QVIkbhciwPV1YgR1nKRgfn3ZkKtLO1y4NIdpmB233nShmCWNcC4HMYLL71JxUvmkeu7NkU262LXoehgoVMAHWRwS4FnlBAPjfqRhFOnZwHXBZQFtViTJaMzPTb6MvTc3EHNtU+1l/Hj9/P1kP7P3HpkfrlO77xMw+6fPLbSlWUUP0mwyh0O8olJXPKE0O00i6yL11l7+urVF31S4aGU92IeXC2Uqkxt99RlC1JFSdSVtNzyjei5t3dYusYMqoa583IuPJW3KCUng4bz3Ryib1rB6SXkzRkZWMtsHcTcJ6F9xeKiAnuRm6IK9EVUn62Xopl2nRrW5Z+irnypFqZTKNnc1CmdMRDqdbzxJKLv2cs//mAUwA/PXQACAjy4udMwmkxa4XFzqlpp58yQ3r92csjvdocAqcbkqWXq7/YaEZco1E1CiVACwSgQOhWkEv/OwCpBG8aK+nrpPZ290J4whjdtHTdJq/HZu6RWU/s7f/23Vrxmx7GgDM+cTgUQRt4mzY/VogXQsNxSgu3kU1lp0s/1hTQB1dnId95Y7a978tPJyYd+xOMVAbBfT1kKAlQckIcj+ugXJ0zhq1M0EP+tc0P6EFeeeuspECwn1PudHvJ46jiGIuyrI2CDz2mAIVAPipDuBuVg4Dm0wafdgUily0sX4l7eefwE3/ooq4vk187Zri2O44LPoUceubAOz1gLMHoGBmEg2UFZfuLLNiO52wh3T+kHwpR4b/UNwmciij6MkbTgo0l5uxVvlpBBJIFDKB4adfAb73JqfBXIsd5BoDenJMfN9PrNaK6fx55jd/Zv7vsawVcKa0Lb+21NYBy3OjRb9gf7asjkOUgZhtheuXvED0TzMHvoMNwqG2+H+XVQoj9r68zyngi1JkTjWSqFJBr0Ub75KfaUdtpgicb/Fga5iWa+gtJ6PVYuEv01UGLD3hU/1eJvgCyIb6k9uQzw9KFZcZ3fixdsSv1cLO0qPFzfYfbZxYuBVm3XIpHKujvjkgDVuxWzqykhT2Vd8EXYMa1v5uzMQJMaJatZ3G9Ehe+Rkcxu9pdG0rb1QAAiMArO0Kg43gSgBCpKknIcN/LIODmaW9maZFfxNJ5p5/ro5SYoy3jKbgDBTuEEmUEFTARAE4Hs460cWghvKTR/g+RUJSWt3NrM6RhKU4MxQB/PG0CLpkhZdm7k3AJfzPrfpG6fy6Tbb+Gnt6tM+Lu2h613JW9AYc8phUhEJ10KS/SFAuoo4HkhBN4lie6yFLufUCtG5M25OHJQ6/7D7JuwxEy5634nIHT2dnUwAAALcBAAAAAADZXVE7CAAAADc4vBxMNODeKiooJykyMN0nJyYnKDIwMzQ1LSo2PTYrKjY1NDMzKikoKywxMjIqLDQyKSssKysyMjU4Ny4uOTY1Ki0pKTQ0MjUwLCs2MzEmKyT6CJcHYSmcOf9iBtIN3ZWZEaudPKd5ideOWeZXvkSlseREuN156L2uopIVgdFdLM40vwf6WJQlQVY7ALyX19uj2HYMorWt0MFYVa60r4XWCukTc/lwX7Wc1pa5GkF97Uh7d+jr15NdZ2WZLKblY2tVcngAaIxGHVCTlQrx87fWrpnGt3SfmjU1Xdk4sxVxNyZu+QAD1Kc8m2Aj5CPIDhUjB/HIdJYGk1PCpKCy525uMSUc9fgcpARVoBYqN+t6LChfU+QLA2irXcqq1kUpw3L0jLtbm5n7Dw6dO0YeUBI00XlaGADLagnJMl7l2YZKqmtxsbTsGLxe2pBdcJ9pkGWjLqiagtksiGy+sFDGtUNuWKTvABYoBCACsQDge+UvuW4vT/Rc97JooGqs1nNaaPYUfcbZPr1pHKnG2ZTHmsqvn77g07bBKTeF6KasxcaWDmV2zpz4WFNvBWyXzqHTpEvP83Ekj8ktSMAMav0ONzYvdbK5VQkN/UBjlj49327GAPPnH88hsbGk7XV8MfRlTQrlXSQEQfz+EMp0RrYxVcNXcudcqXpljEu7oHf90IBuX+9xcy/FGJ4gI0HR9vNVVnD/XDEL70UMQRk5TlnhOkGlGKpUq70tYbs7Jkaqgwv64eOFMuOKV1FFC3+k7VBCv6NBAfTtPA4Yt0G+F2bLBBGBZY76qhKVchjj5hbgu2FnvpRuaiVxqbW7fbVOAiz6oJW6VStATP/UAVyi22+xZuoIFZK0Pd1uOoquuGIlT81fDlX48tv2ATQWkQqUWxFCxGbSEOCS0xo/DC1NCmzXCh2o2rJX4R7mZExik4jCHQBEHnFkCRBgZtIFkFVceTyZ8BCIFuVMj7/88x0VAe5j4SonJfh5eAAcEukAhLyyLHozaQBxQLJwsDF6bJMSw04rhPbgyCn1Vc90R7Bl3NNeByT2sFLIbAYHfwmgXJxEjg1efO92bRnYA2uj9WSdzk84dQI0qTOWgLb/u+1Fr3r16lUBdCpD4gA0CGbODEC5gv2U821Ro+HSQNUoz/sGLK8HKt7imM7gb/iRrZ6+YPygTz0KUphkoAD8APC96S8PZaqHBCmR6CVJpVVGaxaMbDp7ex35lYM3/Jzly9nCP4vN3Ev+5OyBfeEmxook8s+nVkqSTaKB9Sev0dC1eWiNK7dFhmi1Glh9vJDIvld0gampmYs6JO8y++YSKxaiRTeOJV2XVWLzNERlsk2EbeXgWTVZXYnBGZHXdkLIaxJBIRQzR28ERVBknW/e7doUkhZZGlo85Ftf/FOEydVuvepdiKF1rasr4cfN3frbUIJ681ggv3OuUEmrZcTO3/Zwq7udue3kqE8ovGmmiUU4jrA6CwBE+tAIggLi8BMgonHx9ynUlJRrVwsQkhlx4xvV6mlRXttyYKpM7gBMCrECCBRXmFsNOCLW+F83s0yVDPyUKbCwxu4M9IovfrDJbHTHQwMk9oDUACpZYd4IYCQ3jsOJSBRx7zMUCgrX2gThiP8/aMMl3+JubhzyaAscAJiKAXAhqr5x5LC01r1wfJDHcywQhvqhyafMoLLQQ3KbADQesQXWipA02x3ASBgKqF/HodqkNHK4ayntzLT1R2StLjbZx1zc4gY8HmUgLUAfzHoHAOliUbDZWA/acj3ovFpCc3XqvE3B5Ze/U2BP3WfRL6fuOofvhf/oAFT+pAJKkYCXmaBcG3/xVs2WdcreU8kxvXaXoZLjipLxzam+OZBTr6RhpQiroWLpDfT1hAScA1Jxyu8MQKY4NB+wnHS9xKrKHHO3en6rIUj+mOPQuC+qFNRAc/jdsVlsH8zQAQz+aNHYHsChjvykucC2sAf0LntbL0rttKhQu3wp9g2E1s/bidP7D9orvd07tlGeQ2FzlQbsEX3Qs6dn1hj0i3W+oKGbxMPqOJiqrbD0Ts/ndpHb15VoWKNpFReqNr/KCqIKJX2A9EoEAFQiNaMk4+zy0Q3aSvWKWUNK2OSKqegsV5GPMJD9irFpZdofRFGOghbu54UfAkwiUSc9nlQqtdCoNZ3BoruEoXU8cIi9wa+Jq77OPCZcM0ozXFI0+zLSUiT+RKU8BrPkrQu09QQgzcbjGPe3OB1YKkgfN3WJPU3sk6/h4uHdryx3d7/vmlxnf699PTP8B6z5SmLwYxCQIichCVCrbXLoLQe4Ofj/hbeejNNjvcVYckt1eZrrkX2Z2KtOzzZdLkUrKCi/pPxwU8mUHwAsBtFon5rT8hbJwa3qTXIIKoVemgY8Snds6ipBpl+Cgz4Kk4rQtU98JYKQ1mRUIefJz5ZTDAIcIr1dG6yaKqFO3AGMimUNFNxNtUldhq5s2bjjK/wv6Ei6x47KIypkOTYdBA712bBPcgsC5d2+yrlGG5T6rHikw70apJPGX3Nlounp2+2NifgW/ewb7Pm8yRNSHxMQYx2XBrDGTPYZjzrbnK20ncxlbuRfupbR/sSY8C9Sdy/Nzex5q5S2X8W67gIA/PW0bMCIohMCYQfIFGUCdLpuldEtiR27XMSkfEW3wrzyOy3WWfBDyY1+A8v5660AG5bbXwO8/TTj6cmiKP7wv44NuDA7NMA/UXCgQubVm5GbkpXRjToWWQV8ok2njyl4p849U9W06fodVP6gURAcZIv1dgFowMUmosYs6xebTq3NzrtYu4EeNmLu3Os7FlQ+Q5yAyh1917bdur4E7P30wTObXNZPDt/WhgOsC/89vzLNsC0ZbdrYd796z0azrlyhZWC3FWTS473hzRHnKzEFDOY0ZxiKDh/Q2hZgWoH+sb2ySqrfFe+xmtsUBCLcb9KbCfDK6/MpA14CBPp0xpiaj9gY52WBiOTz0CUMLKbHqZLzTdDX1cAvHzGt3RIgib85WwIM5vTSiOpyLR1mggSuYUaffWHcwzyzZ3yl7EII1FfNER0ZPhUi8YEOBObEYLPJKvwSgW1VIkFJtqimuoagHx1RRHzDVUGGJXrSzYmtNoWo1ribAPz1KOVZaUIKnjbnnSBV6H8Vc8ix9H045+zShB9yM/LCKRlZrLOxCL06WzABNPpAMJCdMUD4qYEOjt3vcieM10TJovZJT6zt3xymWKrwGprr2QUJuo8fnd2bxP9wCUQKmQNWxoCyxhcA6ZrteaNiWO+VswxfptWIxvzTTIq4wDRWoa1xLGBaDOj7KgbTFFgA/PVoa0+SyUSvtTCAdGzulnz7m5LTj9m4rbk0a5e+jmLozDw510Vqzu1g0RplC6Vz2jAc9uhotFJFl978yQCuoTt5Bg0TQCvRI2p8o9/q1lC2j1nqhTi3lMhLOwX08fTJvqAKc2LM+bMBwgTamphqNJZwnZfW8Ixln0ji78acRrn3mBBVrfKODjwCsdGSywYgeJ3JAJAutBex5nFCGpaWmeyTcXsy9actorVXy9KefYmDU83iM1P+ur+eOwD8/bCy2eaM+iHUPl6gEmOZ/E4c3ZUpaG0L7y+dsI+Cjn+JhN0yaT6as2u6iXLD7VTOCjQG6QBw0pTGwkyYgUgQk6LeLipaP3lh+3ii5w9jzcYnKJZEtIE32WsKFPK0bkSJJCAmmYo5QaMj6cKCeJFKTVUNogyjX/W+fwW3o5K/9Eq/+zBUARTydNWItYSV62JOa5RgNiCZzSaCqfG2uCY1ModOWq21sxIVyq7ipw2drE8A9PG8TsO4t45J2QB0hnsa+HTmWGMI/Qnsu1NacHMdBfHOaWyEyX0tNts6ACT6dEGroZLLHjXE4i1DSPLdsfR82mt+HF4QUUwtTptd1jZ9aQibBZPMNhNU9iwndgAAfTVz1s2lt+RpesjKlX0fTFPY/b2jUxWdXmd6aMqDExJtL5+62fcZb/5DAAzyqGgrkmMhgPuyoFw8/Kr9ylobr7aamziGGmEi0nKFSIgWXtymg9Cl2YABfeuZp7IBFPoQvW2wmmYD81URASBb2B4wyrM9GVe0yafXveKBhAqBqf04CCikWp4uqxxeN2xx5sC11gAMEnWkSrDXhzjnRo01ecEKuk4bYMzhF/ZGo0GDrh52kffnViTFEL+lrALsmsklKki3f/LPmAG7eQwi9cr4fPPu+qNDvrpYEwEwY1B8FmPnoyA3rP5aAg4esEhEY6UN8e0kLD5nhGn0sdpjxVyw1AkMFr3Gbnu4bP5ycuTgVxEW0MvA51ssDaBuxDfcY6XDmrKKW2xpiaucItrPX5IiBAY9yqPsTRNfOojp1sMCZgOGjUeLfdSSWYPDWug/0DJQ0uAjdYqj6JfQvOluG+zxdDZ42DnF/GpM0FrY9MI1HhfXn2ccsGrNyrG5Ym61oiYPO6v6H/9rfSDdWvsH75+1f+r/90xOAEwCjVSGZ35Nt56Y1rjWaHwagcb0mijSYO6vJ7T+FeFY6eXYHup8vEOOUDj6T76u7otn98WzEQQKPdlu5+ZQH6pyTRuArhNFNURzwzBKmKL5dUnmPjtnVq0pa5Asju2NTBaZl72eMUdMc74C7Pn0xt4WisCrrb1CsNCYSEa/mSoqsVHkp4n8QkjTINpZF+/ayI7ttbQGHPqAk54bspjAhfBdmwU0pt6wlWM8Cggdsey5LtgRnyjWfXMzWSzohPLoDyYA9O2KsrGoQD6k2FRuAL1gQW6kqogMiaNX467oleMOzcy8Vx1JuVlXViT08bTowdAQQvoRzv4sENLYLhZIVtoxIwQJO5fbiVJpRe+2mkQTjjIVBQz60KBtRS351NBdZxY0lCv1Z01ufF08iiTOta8fTvy22o1Gz+BLzegu1Pitko1KBUk05Af0CQVlbEWHA9oBIF1UF5AYz2PoYUDnb9ZBpYwNLn//mvLM5g8YOMEAWe6ui6iZ0XLPR0YJDPpQ55kdrNKfaF5dgnLs+KhltQjxi1vk1JTWV8l7QLRFQ0KH1ybjLWp75tT7UEkcTgEU+hj2jCKQOOgDuXTzPmXuwWTOmNjua35rqeXedxMy2u88LW6FL7bVhU4/pAUHyLyC6Y85ADQGQdfAGhxC79NIEABOTa6Z1pVr/q5kq91JoqVb0Nmaa3VyhpWyxp9yw9WK2Mj5ByzyFDPqZsmYWEyzelJwQRm3zpm72BQvWn03asm+7lw3z3YKWs0cBjEh+NIA3Pl0Rtsk9UomB7IBGMnyIzA4k/LVlWF/O8q8/pwy7R2XzhrBLm8T22y+NBTyQLAbJFefvZjpTwfoOqntlqayX1FDtE5th7OholSNPMkKeFDl4ipgAVLe9QXr0WlYSuwOAhz2MLMjcSSgLxA04ObTpe16WMK8ZTf9l2iuQ48Wh1tUTTNzfSpySVlxsXis+MfsLPvIAez1EOlB0UtnzW8boIHEDqmhpJraanbk+IxycLt+Jos441/xKoxeUkAcjlFdPK/y5QEU8kSrYSybycJUzAFSgtgrPKCJ9JJfDF1p7FG2ZHlgJnQtYLwy1CT2gDWQzKSDF07mZQOkpKZ3caKI2Jawzz2WE7SCDV2mNHeTXEgOKJlibSpPZ2dTAACA7AEAAAAAANldUTsJAAAAHB+uvjoqMzQ3LSgrKzI0NT036uTuMzM0KjgxNTcxLiwsKy00NTUpKSwrNDM0KjYv6ygnKDM5OO45N/LaKispNOq0CoJiSMTcbCNSQ48O828kem2gUiQGbMl9gSOFj8n9KfSQ0ELJmKUADAZB8MToahUZ6+CrRIJyVPvf4nukeBR2UDxVzrLm5zfHnLuynSSb2EGMr6beyr2FiCUJRPokU5CyGw5i9KHSNWDk2ysSMipxXsvkZ1QjyZdoscIVMVxVOG7Bm+1s3vR/PJn/ikYrAPT1tGAzUkQ/LjksrVHGhAZS6RXbG0/Xei0bFpLmx9C8jrv0jULRWOWFavZ5utCheqo+ovfpAg3c+QqcjcEns+wcU1/xAYQkGuZENDwq1tipmaGv0RstN0/asK2/95yHWSwvkQDM7UqTEeNuGS+hH12AcsnzmwswSlxxeHrQVvKTlLE7HER430ttAnMHDPL0VVMjlBkxpa+DxkRwU1rrMGuIteN2qlGKOniLFcpe9ML7W6KObvzEA/ztdNVmBj3MlybkkE2WAVzjJC8bHxHM6JS6JoDu4roUN0aqWOIFMaG18Q7M9UTn2SPp1icxrC8zoK1j2NFmdQ3D8N5HmTj6lbn7+xkQofozJymDu3qAoCoektdL5PwNSz2God90cAtUZDN0UMVD21KHw6l2+TH/ifFnfKdmvT3yxJRGJ3ozsYnD1Z8ReJuIWwAUJj0e+6e2+4POxTprAUcjjIqH3V7OtEvL6cw601BxWu1jX33YJ3OX/qStAE3rdGbdbjKrAQQOCzTPdgM9P9RmC1BIO0BDgzeiKoAmeNkYvLRVihFr01fPz3ITy1KWlQEp8wT/0nzuiv/Fvdb/Hpe/rAAUFlE0aD8q8wQFS9qvSTpAoGO66KEr1OCK+EC7FZM9Weu4LB5HCc84r90zXfHJPea9rDV2N6MBekdEBC62G+F6BE7WpvP+N7yUb/c09xyIua0+GhsNTCoDkEFILCultczIBgUDdi153vjtzzSevzRlV3v/pM1FzyFzops1Qdoh27OEKSpoyF1O/JAy8FUbCbSqyrY6u5i98vlI/nnXFdzDKPKQAE8l2dxv8rHIs0poApeRUTWxr7gfGEcIsJKjBHk3pD/6E10MQxrmfsX1lctMLc1ElgQhGZ9H1sGY217DHKdt4djak9rCZBhDjYOxHftomjGANlQX3V+9S0hgMi9uhr4WURGtCZx1xAjNMjUqCTOLAeNeE00LutbjbMuZO6sFXkjEIAH8APi+r0bTwmKKABRwjAHQLQEqlQY1qMQpLSxDNV9dvJraM/M5XaccQ1vDNsXGKabHWFCiGJJNiycn+bwMFO/SPUJlpfDGEw0NdM9uj4BAQVUMHrupqZ8ezJ/fBmeOCUmF+nbepfkYoIPhYHFjOPRuJuylXOyzUQxh2zrgwqvWzOp/vxcNyG41oIzwoXatRygwXq0OAfArdYfaXL4/4rczQSLu7WtBaX8y/WaiyJ7LO0s+IYfW92z5PyriJ9znYbzGlXPgs5hkydC2ljBCFLPty453e0vVUsK5hTbqDYcAVkgUIqKJT+seAO172bk+j5PeTtsHeDJAdwAANYBAGuwXgjBJSBvBODCqs65Rku8B05jl487jz1/abXOPNUx5+7TWxQnEGpZ4onO3niMub69nvbwHbaB+HgRZHD9ov1WVNjoKoy+DSjvNyZkxHLDJnPPOYmtKpxm/dnr/u8jqfERivsAmaC2/Umin9R+wp0tq9CIy0mfZ5tMb+CIrb1M+k4lqFlDbLpzVvgsT5l1zojX5P4kNIlLQE6m405vNIMY0Tyd35+/LVZw1dOewEcQBQ786kVmyqLyTiOCVrbTXsIxpeTFa0NxfOwG9mRPsACz+iJECYFIKKfLKA2gwHTt8iAid2Fl1z1y3jk14bd+0AuFp+xXkiK/SRlIzDnT3////D1QWrSJ3icsgCL87AOkimBdWY8ocxh2fbTjT+fzqDOs/So6s+w/h0gOi8a/nOJ5FCxP/AvTxaGV4NDEFUM5uPgEaiau9SWPrbd111s2ujX255Kj7X77MXqR0D7bTd8BBAlnBGh8dyxM89igOEHVxqRSaDTmikjaJKz8WRZf3UkaJQCPO7IlpLXLN7b5Cu6IoJQA89izX9pasNu8T/NMA9Gu4ln1lZnpkOaU/33ddVs7f9WpGEdjiuli4yK1zHMLSp955KnH3rP2pA0QiDTdQLCqk2CduoCw29Wsu5Dr2uiYOD1O56FY8ay16eya6qd2XopGjd1aVcAv92VikEcsXejzESTxSAej3foCOUsTsSOxx7UBTTGPIP9k5GOqmpVpJjAdII2rlx6xUh3sWU1haJfQZdf56Bs924SjS4heuuxZAg3HSrV+LERcG71N8dpBpje/zjDY+JmkKpvuZ3RDTWFmRvdHV+QYcFvWax/65ev5ihXaZHSAOSFZXAp9Qpiffb37r2vcqjXzHOAM6zbHJ/hWVOsrFfq8CVBoBarcb2flqt8xk3RUgEA8kZ456fVekSItPE8eqmNXycQAq6W/KExb+xgprCiwGRdp+98y5PtmjJezfsSB4yafMc3zkRLkU9LtQ7qxktx8xA2vJBSnyyGkADPo8tOdYrBsKEGlVZoKGiORfjnauDYVb+AEtXG9KI4SnTNXFR5vJt62U0AE0GmnE8Bjkc9OoNK82gYiK3Y+sadHCCqWF5DPHSVX8shjv5Q+IgzND62QCFApF5rElUyeBUssnEgFxQOO6ptlUQx3RGuTRF9vZ8cZGJdJZmcPQyuVhkR8ATB4jse32mAKnp+KnDTToBpuZMR1lidKTyxgsJGb/iW1RsQl03cPfbNng2vf/rejVq1evNjT+EG4YJTn74sif0EAjcFFwkQ5WdfWZ9fxhrOkLwZBvmqdk7T8eR9gPtO9X1UOUUjIwm94B/A0RxOPJEnlh+XEHKFefBDhT6eiZaRZGdSuxPFTQOtz3Vu9VSaRu27OZZw/+K91zyv6FwQgkGhEm7aycFlDNz/0XiEp27sTYkScJ8dAoR+dRzvZSkWLow6sjx4GJE+TxRMr+qSAmL5upIoEOkexvQ2YpyeiT015d3lVx9n92KSJsPHiawj4BFAI1ou3QxQTa1bdNBsTBlDT6fC4WHSMavY/IxO7dLduFwtNQsnXbOoygAwDc5QqNcQfB/MiInxEgDgi0b/g826Eyq3iDZVBLKISwrWpCOI9/IsNg6wQA5PFEaUci6dxs/zYFNBBM7bZg+lwUDftxymDSft4E0n+jxpT42QFmvCiDyI5yZRlR4nJ0BiT+CJZ2iXVCIPIJs4TEi6hVcMa0ob0U7cYcHXlTijmPvlFxRKuIRjd7v16hI4+5b8v6ABz2IFP2qpyVAoi59+oBlIvRIT8vrUjjokQfoVdsO3Q/bXt0iBlGzyRViLUid28K9ynJMxok8mimYJhZZYXapg8Rekn7D3Ofn1FLaxzJg/hANPfELJGfE12Gbd9s2AAE9iDW9gO8zgLLz95Auun58oNxkeldhCOqdad8Hl07tfAa6Dg8SbzX+x/GNZ+acbXi2/7/AAAkAqFSDEBD4HxcCkjHDg10vizb0cpDUFBcIp7Nwsv76Zfa10d/LaCSUkrBr+dnNxJYlNQkywirFQPtf9WL7SjnI7LpPTwmY0+UNFjFQvDIilFrptPnCyx/Kn4VHTvMKb7l7WRu3viU6re7Dw8+Y0ER6ZWpW3+evbPbG5a34vwRmE7XsyartGKx80erq2MG2HMcdlFw7TdO1IyTnCpUucziypLaf1e+O3I9UB9AGej0TzO5oo8vN6+oy3mJ2OyZt/t76KS+pvTmvtYXhVO0dATGVXpih99xbw/PXhITI8bd3cFeJKcDVUppleg4pzgqmzTsRDeaOZlfI+AaBxvu9wGdQU2+h76jy8gIBX284c3R82jYF5f3VTgE0AD08bxW2TBN4LifNmBwnNM0xieW+r0Z+ZU817/79hnNsubi4aLZrPwE3PX8XBut7FXEsu3LoBN8KG3cNAaVG5Fo5TQgojIuhXnzJWf0MZce3PE82DAAHPLTLACX6JbZ5/ZWI4YT5mr9iJb++MKaVkNWls1KRTUUAEQGpTKkaagdKrMZEg0UdnT+QIrNcmHDh8e9wuTAdcflxke8GWs7q40J6okiKDmnNRElORQGS1GVKW830AR3/QgA+xiakVfFE5VMGpPzMSUmdPmqBwLt4em+muOlcLVbi6SwP73Xn97r03stAOQtr1Hv7CbQV5ZLYawJAKxbuKRZtlzfNwSjvqS15HSiloGodbZEP2VPiHMpjSJI1Lwea4rNUYsC8qfMs1S3JIY36td/vvfUP/ZkXrXzlKCKWQcMAFkA2JjfBCTkOQApJStSUeR/dnpnNNc7cX6Rexm8lRv50g9GMx4eZJmaz7YmPxfJZkVaE1DBaFnoEJMxx698UlJS58jB2dDpV/9EOqdw9uXRmekkMSqgGTfVzZvMRLZsSc83OWesOqvrc1e/ODgIpMJ1h4JTgjjgdKy3/bzRAmrQ8zNDeazTlT/nIqsUHRATP8caqCzi5+W3g4ZB4VxU/ImZujl8LDOjKXKwpmJBopUUp7KxBBa5K3tHaztKm4uCm45d3demFrcPFISZmzcbsVTBBAzyfM5GledER08RwHrbEHRi4CJTnDJCURjk0rnqYZ1/4sGDmNspfawpuii3s1wVe5IILHtdKJfLNvQB/c4Tn5aQgMS1A0DhRRUwye6PVrJfrDp72rVo1FGMdqzJbh+rlUmQCOXn4Qkt3TIga5M7hgPaWFTcCLLf4ER6/lvq3Xfn3q8y5WCHCZIDZgAZUMiAHuRUk9pooy0N/7zf3JANUgneOKF280qwe5bf6vxz6cArrZVu39REZIV46x6bG029vFz9e8lhriVqjEPiJPfncv6GwVTv2PWmGwrMpnTpp4Zi65+LoGK8Nx44TLxtPsT9+JOUuN6sNa2fa0EBz7BlmOeXkGXl8s3vLXPdX2sAyS38m+bgEoJhTq9P7P/3sGrtm10ogg7I0+GAaQ0hcZCrt41/1h09AmuLnEoNX82FR8K16aaXcCqeMJcaRyF1JfefpgPcqO0ADytlKh3oUtsMmKDRAVZHDMgSlMBOyPb/sssyBtHitUU+ApkaoJMGEj+gjDGsFNPM9svx6sqkftKU3eGuTRuddrPvnR1qNt/TOmiywx+eaER6L3VjlYTFgee63sizk+nBLoWOfCBbxpFCSi3axwXB1DeWjIL7VX9dX++w29Ii1LW03PKZflK2UviEAHHRPvguJYXugJLFLiXK1vvw79DXrmDMOnUyISWySNxyzFPoGAWY4Ut+kKxH9Bgfk9Tq0cODKRtAsKJyrS4OXf+5wBCgayK7euCkTmHKjb55b5/ly27d2nZGb4AOxPlKnYa7UjaolpMF4AJV5315OlhR/D35k2nhmLPVBTqm6pQkijbgi90B/O38VsE5mY7WKK9MQKrQqf6WohksPUCxxqQiK1hPE6/H56ScZVo3qhUaANz19MbQnEkCJ+Q/XcAlAlE543wulUw1NuH2JZQP2jAUb2xjU60+UJkAT2dnUwAAgB4CAAAAAADZXVE7CgAAALoQjWw8KSowNjgvLzg6OfboMjMzJicsMzYyMTs5Ojz/BOX0LTg0NTM4Pv8ENjc1KyssLSs3NTQtODs4Ljk3OS0uDPJEp9DZAoky7e8CXHJ24DQe0KIoib9lzt9bd8XYmgXf5ix+JZUibgAE8kQFBCO7oITlrwGkEk8HC7NdScm0uahEX6awkl86LIQre+qmnvpivCfU/TRsGwELrr4DpLPawHo9Q8wsu6qiD9ml6a99kanFp3WS+cGOWWIspX7ThNiqrwHkGa8iZLq2kL6k1np3AazEMOhYQf8Mm+lwsosxGWxw62eaBEoLV1EpI3v+cDElJQ6MKFGUywEkMsu4wfw9+S8u68rCXdMUgH0MpTi/mEiynFWndW1OMDl0ZRHFX72QDvw3sASBePHWpQyKWFMLAAwedwebvjbu9BEdXT22huroLgCU+Jjv7QxP7eLYN6nL792JTCCn2l5ybosNS08ANBpLom19RnPHBWFhcm3ZAfiABmVwrhk1ozRQD3FGMOa8byhrDeY2J098uldZZxz0GctCh9yAXunjQonm6242wDpWmM6FoUkDfe0N26peKDHz0WzuMmUXAvcO/1HB4QA7Tm449y2iAzQGC7OBl9UeZZWwV5YNYg0uw/ao7kZa95Zj2MIaraQHg34/jvP2orKbff3557/Y+Wzpq/3tJ/MkIgDsDQuNZ+bY9zsdyqeSxFVGJwE9hmmxv4Y9RxEn42wuWniW9oBXD2Sb2uokDnmJcU5z+E0yGC9+ZyqaV8yzKZkztjtx0qW7781M34+yn87r3eaiqOII0AHhLAC0R8CPCWHOGGUVHc1xvmYNMcHqvve4xxL+5Pf07u8wTu7mN4dJE6PRPRm6xhDVleT2y9nWWlNx0dWGICFFkqbJ+clLbXYu8Gy+EoaT50hyE8VAFV3jNbbSscFFgJvlpbmpzKmdZ1IHadC18M6+22VsQtoIu9WvT8N1BmFd/29MHQskt2X+7c2pE2dcNVEHwMU/Kde/9T07GE2wGEZLQbVTJ1axO6gSumq/adZZXyYV8RyLneF7jCEWl1quacxlQDH2sfpPRIFoaly4u21JHVKwqNIGmACWV7RBDyB4B2SvfXlMvt36Cr3zGIE6DqAGCAcDSFVeyrHwhMIJr7n8V/+IXWAb35aH3LR7Fy7emhOy9yxzH82aClXLuF3Le6k6YthexZXqDfcxrzcwG+tsj9sT40WhO62txagTY43Z2CyJNB4H5s9qxTlzWzsjq2iPyG4ZTcqtXq67MjJrivUBUZDwSSEBiMOSZ1Tyvzo32MANdoGMqzdI1Q39BjB+SmchYZQtdh00k3uGZtQPPJdBHNe7lxFX36/rsVwtXOPmncHgoKpDleaLXA8c29LO5HlTYRgcaHcwxhfU977+TNABHO50mS2XIgGifxtAufp6z6nvEOPsYgQ/2HU/vys4wo47rQ60pgUnv9n9zV6WPjU+41QkAmkHlGcB0pqQCyDd5JEt0ljXi3tmWydWYi/ilJr8vvzrOX1w8atji+BrKymFauPPGgAsBtFEtJ+9CIi9j2sgBoUZHxBOpxSNMiYuZRFbmjqs670pxClLZQqN8qYaMFHCX6xL5MUs8mgLsmrgTPRnUkAEpfZdy7WlRhww3zwvASzpY8rTlOGzUKE8ExwGBaOhjEv6WPq9DbjkJz1vEB0JNDhGw8d6oiBZT7+F77rzvvM1HhzyaA6cySrNUQ/30QIp0NeTtdpgSKwHdOJyZaqRCxMTRrPT/wCZoy927uwAFCKFJLXXxh2M1O4A1rI8AH1nVee+rxtT1zkvLVdCvNV/IieHqRz+qs5WYNuvOs815XoI9Pk8gdmCwZAJWqcaQLdu2IYClSVmbZ4ZshOtvJK/6H/QOlIbJKXr7a91dMlqJauWKCsuJ3cADAJ1jR26YgMomuzVFEClgrQ5sXvFiZ+b7uIF345G57qZ6IIQVb0QaWQZ3qendEezRBQMHimjbIADwx3AlqIcMM3fftxos8n866JlaOHv9irGM6g4HMM0+pEuGqGuOHGBi4kCDCp9OnJzhk9xLaFe3PXOAtCCXidWwJh1FZF5tsHX/6uGp4Mk+LfZVe6O7wyt0idZw5s4nOxiW/Vx3wEEJn2C3UO12RXHBNrzrEk1UJS4AXxOUNCzPSHtKOTW2ZMI03stxGUOXvRtANI6rknjwq+VupeewwEEGksR++Hi9VUgzS3MmtgCNS2G6dh0rylNW1O9jDvzjMPzbL5KYkiaovzsYr38jLvb+bLgtyW9tX8dBB4LmafhSPWP1qzO1My7JqtJ1JXYmnEAqD8buNKZhKnGT67+NtdyDUVfTGRbI9IcLfc+qDSrA2daZSkA2tfM0Va3M1lvu3D1q6a7fN9rV/ZIjWFcAP0KgJKmCgS7EUhXCjggFIA0jCESc1pTaJr/m7hm08O5vtpxfv+bSrO9XH8WuNI5GxXUqvbafw/OTk7HadOn1UWZ5L7f8s7O543BRKNWycW88Ho5WmOMCuKFTBruqedpp9NaL0zPD50KICjuQEzq3qxJkmSnSMa8BqbnsFLuM2KGSyrG+0oER+k/WusD1F13Lg55Zk24Y0OTUfNXgCAzaaLd/HeALnyFxv9OCfDZchjc+sMc2kYh9Yz+gla6+/n3Pfv80LosBUz0bDo4//7lqaCmLadLJF7cIDHvKDcpxiF7RjwWiNZtXJkrE764JFiPCAczMqUEt18WAj0SAGCauQDCcnNAFIDUaOuY4v2VB3dfZF+ZTF2Zs/yef8gCHwNg+uVjcDWh0/tCozyWN0XX/yzhT/o/82ZUja2yDhKJCfvJ4xWpLXa2rerbMnBGsp/M92TLWfDWzDVcs6xcRrOOJfIOJemJAdR9OT8yPpjaV38uhHb+a5IAaFQlqbqDszZ7pespw/gUEIiA3NHJ10rCCBOjEhNaZgFfpr6bXgc4Asq2yrgBiroX0Vt0nyEDtJJEvWA7IiAlymH0sWkq91hMQTN5rpu8mDr72yKzmGgkHgD2p7Tl2C9L6Z92oU0dve925zmiSGueEAL6DQAqS88MADIAsndgxReAhBaeURRP3wVRGcPG+u7By8nzzbElyuii9T2sh2HIMVCF8iWH8uEtLFFWguqkp0lc01qXgmIKNJdxJSHx+qd/bt26NqmcqVW9I73wt3X7e4lHw5s5HinePe0OcUx68kIP11+B0ke/JETaXEFMunF4H2rPMNtp6/Sp+8zMrXcx5roLmMuMKRPywu3tuLQxoJUvJ8im78VDjtdI6NPUqjPV+4tROjMNVqhGzyqQ4uKxLSJaVwOm18UGbsAct3qftimjZm4eHKOOd9Qkz64L3Ak93HOyIS90g1DqswMETCCyXANmObD2odomFWYmRdtunDgOeE+hF+ukToIG5B11LlAyxJnoBm1VbAcQxHZwrNwC8yFphJCdvvA5LtRGsjepbhRJp9jGtozCsJ6Is0hx9Bmb0QEkBoVgRzc4gNYqFw5lTP/9NoahtSeW72xkc2wvPJR1S//2GXBRKP9UeunPH0nsC/Tk+QAAHB6pEMgOvyY67Kd1NgskZbH7hkigrCE3MbEZqnzQTVAnojrlt4iaGbKmu87UZK0c28ueagwcIoUUIGSd5NWaVANVrVIR6k1KPPTT8vSPhnqbyuBKKvJ60LXpbMapFUXEgZuI19lZHADULUu0wGYlPRxNuquKBICU3XsCMQDjloaYYkjY9uo7Gw2n62/VhoZa4MNCDEEUXtcyvWkjzfT1E8Q1dwmGp8tQj+I1Qc2wcfsAKNDiBpIrgeU+AMJMGEmFia/KB1ovdmBQB668g/a6MyOFCor9rTMXyjcBaW0C8ufMaleztlzJe3Cubf8y3vtfjju3sMewhgoAACyhQ9oBCA3zmzkASG0EOCDWVYAkjEHIc2CNYID5HoihTbec4IP01lYvc9DlCYBpVJloPX9qtOwQ4uP1f+azrbVWUivBVVNcVrWWM1UTXGDdfu4s3+a5SaJGoBykGV2YPDiJ9uy99lq8uz8DIRkjEfAYJ377/UGrUCiIgMjShKkL00lVK/fm6X9XqNoORyCdp6xbyKJWSRLO+2qklDeZyq4mKRYnFvDUwGulALSshrUgI6txYk1sfJ73b10bnSSzqK6ONQPg9niT4xNrRDxc7KjssouVOV4oYt4iLyPUqJxpm3rOUybQHiwy6ehBl+alWIygVXGdkQSS2IdiGW+I5UghU8xG0RZWVn/YDMg6pQO3VUlolmjXj9UNaTqrCVQisfVEKFWBUu4aC6DQggtcXBumuemBTxLfL6PX1KRabhlA2+TUFZlklpY5n3fQfz/yfMSTNwDkLQtyYrmScQy0YrZqVTRiD8dyh16b4jyXyC379LrYxpUM0W+7E/KbcozkQdf3sf9QfjstAuwti1MCFhsH3Wxq8P7JFgQcEIE9NQlllrp+x5DSQuRDI1pw5JouzvhtvBj8LX0xiEr6RAtmfrjOZANwPGwavSSlSmSvOQHf0G3QN+9q2ay7bhAuYyIL3CkLTRCLWR9atJgaEJd4AAQcBExVkZF9o0r8l6BTG/LYKNxM6FYVm4eMMBz8KQtDAnkxcaElA/qthRQkiUi7KZtJrbSrWpLCZKqRtasGHTC1dabx+aNS6QHsJQtjAoJYXZEBaq96NQ5gJQ1RvMCmErXdGHloHksuQ7eaADA11bHp2BUNHDbpnJBqv04Q3TCaXLYWUkEQAHqFW/5OL5VvKKu5wbk3uZCz9RDe85Q4pRYtY125md04yWCUACwmRecZkHUK8sKqVgJBOTbX1MgRK7GmB04haF52iN/zppvgBU91lcXhaO45d2aeds5kxNsBHDIFG0yX+o02Zm7eqgZQzqO5kzUx1fKN47+4XDA79y/qRdOuUg0CnY2Yb564+R9xb1Z6ATQy9dlzOjM7OszLNdkAJAEPydu8Hw1JwYrOisWM85ZQUSTxK0eGWbzMrS3UACwuaRtcMnufj9aMRM24P2MmiQkcezHne5E34uqhtD4UjHD/uSat1cvUfoam9RKn3zrHwZZkLxcHFCZFmYBOdYaKxQxKSzuAICZIMa0B4W8mwzONr+fczaV9d8xvKvfaTa8B69/ayIxSXAVUXm11Ga/zqgEELnXOs3FK4iDJDB3SDhDwgSv2scD3LdsQqsScPFkWWRVFeFuPMcK2NjdfaIvnWI8gsiyFdu1lAQwq9SqIya4LrRiVQrvW0AWwki/aA/vcIqx8UCnDveaAE0O/VkHNgFtd+A4vlAQsJjFO6EqIiRYNEyWS9WqBJAAc29VNa3KfxK19Voxy3uthO5UQhp+4ScVjOzVZvd3/+9326aVXDwFUJoH1jEl6RytmLmnXxGoAAb3h2Ffsr07GuqGtPi212lktlz+2orUHLx/MhnRPtxrsvrewW1MCDCo153lMZk50s7mqr0ICAVK2G2AVj2vzjLrm2kzJZkp4qqSlC+s0dGL9Y3Dj4Ae9s5GUdPEuoYEBBCL1LohOyAstm3xqVxEBNNR8SHgqK76VHFHHHcIh5IB0iJrUl3jwUMYmtwMD5CmLYkKEWi81UEwfN7QqlEAvebb/KyFrCZIyLGiIeq8VWWQ5gcyjvn0FP8TqAE9nZ1MAAMBVAgAAAAAA2V1ROwsAAABSn8ziOiwtNDk38PDvKysoKi0pNTk39/D1KismJyYoLDY56y0pLysoMTI2KikrKzMvMikrKzQ2NCspNTY4Nu8cKnUhSGHWFeB05kcxA6QCIsfWmCU16eS9WZR3+/0TW16s/5F8zivNlQgjACwqPbNnLOEVrZlNPXF8cjYISd7kcOMkLlWmOoDt1XJEbvXJFHWoQcbMGZoQE9wxPXSgqWJreoSChVyvvoHAndFmTBLKWbVofqaMjbhSayb77ze8Sgd7xd1cxrt0TnNVLRoMKncinkk06emcn/rbhy5m7+gmfJu+kFtjubafHs3Jemm6ZAxwvtbdPJhXk1De3oEGY3tks2TOAQAMOq9V9uYypthZKMXbF3q5cQsgBvD+2v3yKHa7rZroup11q21ZaW35Mqd4FymOiPWNAjyGR8cM2ufMQdOvmOTFV++3F/tVVFa8kXV2PRzOBF9hRwYFZj2hWYGdFW6h8SWBgyXnc4ZSMCbMxdG0sZXvC43lw0WQuWz6ajhtxjiZ7puyrcUYJ8npp9ZGCQXZtINxp7Lt0ouvRlUAkDJUE0vafAqQjJOY/uTp/1/PTFwbgpDVmPydjBoXvy6yu8X7CpxXCjPHyUgSlez0ceHFRakPh49SQapJc/U000FbwVMfDDcB9UV4roYutgk4b+1r1r0tUElh2+SqQ7CKGS1BEggGq7V+xib8KEMVTwzgJG/xtxvQOVZSaSUOuTnsoRPKeHChzNHeBUwAnqhEIAYcbNWK8PteSABfD+hv0ENiRwCgBHAA60BhA40NJqQ6K1m2minSO+6ci11bKcwvV/W8gW4u48tPjkgCUhITDi2WZCa2Ni+tEtkPOIi29H8CFgCFlSA9rfQY6KiawpyjzcKiVc+iahYBnDKX5Nv5VGZwQHrz08ODW+YQbb49x3/C0M0paAw+K3QtQe5OR8Z2ysQVlE45wbdoEuhATf119DdhO1YmGZOjUSVPJAMB7GzBHDw0OArxvCuGr1mW2AUDWzhSO+rsDfVTAZD9iAK1YRoG8s3KqhyEVCyqkXyQnjthvWLQt007n8Y9B+kAlqfkSF+3mSJppfMU3jfs3bi5uk/56l8D7F0AHAlQgyw9AEC7Quuk8wCKqIxQFL9RF91OzsfX/qCg4PBlhsbSZqH+mKNBBiHV40HE4s8QXaxdsNoIQTwRjgwy0SqIxf68gIhSAqt66qWEuKD8SLGbbX8gSSUEx6twDz8lYu/X1aAmo3ZjYN3k6fwMZ/in42CThMglXCmF4NskjHsEjWamfShfaHgEwsbHp49WDGFlOWERKF9pve/e6MM65+MMFV+FbZJvaw9Lv4USR87nzsAEctQvE3DbtMG/cq9qKm8O9Spus9Yf+2/z6HqsFmfjEAAUDouzJxXUYytTX7BGVOPc0+eWMG8094CxKpOtwpTph/7EA5krVmvbnmcA9AnLV08sgwhSwL/ap0FUo9H1IgnR5RgUcQaF8Tw8CU+F3xUY5SAwYltKADwGvc1GJpOA2M64F0QkqdEqZUCj/Jpz5XxoPBF+uy8079hea8Ch2QCsCXfnBGQSgafgnwkay3Hc3/M4SrZtKLaTFKskQbhI8wug3icVhtSsMQHkCXd3T1TqldJx3AH0kmVrgYXTbyOfsjJTNXFn+RtcaAW/Ez/Ttl6od3PSngAMBsuyjYpc2aiNokFUMjbblOhI2Df63xe1/W2MJod9jyDHypJC9zHVJUwGaWbkSIScQVs30ATWtcvtczuWbW0Pg4aeyIUPUergjN9Y1AmT6Tc6vAIU36ry8pa1plNuHCbLox5FMkWnrJVO9TMCoh8aUH9sze3JWO7u+ofM1ziuanj9CBAsWNRtNcnT9VNhaNjs3qRxYJAIFEKvMZ7J15Y8bbx19xfJRqsDiou99ZnKer6vsz1oyvyYlQGcmKJ3s74Kb/Fro6duueozriIcCxr4tIWxApgldE7/8Lr3yaT721O/Xtl9Hjr/yYWoABswoEEGGFmBnRUOQdLAIaR8pxVF9Cw3XrzPr/GvVssls2bx+hPpJUEQzPC28lOl2qrNz8+/MyIANJmVTBJjrHBapeQvaa0JtJbVmDjZ2ihOjDFO4qvL6sWV+WxUkQiVnBx+maoON26RI0b11Gj2eZpUn/tkj+TS9HGcRUi3yKYD1Or3KlznZ7OXRXucZVzGcL7JnAPhqRoCfA0wYSL7UYapKVmWhcnejgVhI2utMxQAn0pKrIZC4eAhX2/MlE6dzSLCPL+vrkp4btFFSeT5s3Gv7YVtA8BODQAeeaSiBKtg6q3wvhrQOlSAfBdYOAAMgwFgBVhAIhhQNqDQQczCMiZ6U+PNynVnSvxtvp/eNmRY9bx5kLg26bnnWEfWnlkfwT16oTmSdBmH9+wMHIkVJw/bKJQoKds3aFKAU1rJn+dTRvCC/QgHLv18ZiYSl1Y+aI0jsiHuFX+YEa3qQXHlZzdcyT0qwMtRMqcLMpVclFqFlircvQ9KMVUnNJV1m0IJazvdHAWBE9v5FlawyxoCoJ58XZxJBjJRGyqzIkLhcqDIpJHaDTnVz4jqXS+dlR7/ZZdsOcTekm29NVohyiiDW0X4NKagmTkhNgB2d1QU38FAw7PxvhzNZRm1XusP1wF3AHDUAKqQpScAElaAFWZDqnVhKzRTkIGHGOa6e5+Jnb+6bDp4WWbiM9c9mRxi/tOUXbUikTkHTO1eZlaCUqWl6x+zgoCIN7fMVyKxgLwqSJqhXMFX65I4Gb7ZVgnuptZU7BspLhMDRXPcybPYJGlwkDHOegxCK/gNCo/1EWBag/YY83MD2LUB+3M4gb2I9fMvOjFU+rK0Sh1g5DeQwmojhG3M1E5m1elgedfAf5UfEfQEkNy2UjOhabi/4rxbjXHK7sXEzppWMAj2hRHRoW32d+MC9LF2vz0ShlykorS3ASwWi6rRD6txyiGfrwtSx561VaJjb/a0QauCU1nmXLPgmC73uaIaG43xAgz6yleWY1BNy5/+NoCSHNq6ylT+lVaKKoVAqdKpQUPMTy6GNVnFlKrspw78CXdkIx10OCi+6yOBC87toxoVKuM647r5GeDFL50s1O0VjFM3NVQOfQ104PB4375Ar+LlY7I7cRPJeuSaqVzQbX0+r5RTsReKdZU2ADQOi6rCDSos+lYmbuDvWUqNTLKcKhNv345OdBdMrlgmWH8T4oAxDP7KNQNdCCcVCvsKXAUP7P9IrlmMKsF8gzy+EtJGkzvQSF9tdRLyKyQGC7OWgpT+LtgffDmGFVFG2XLF6cGVd6jQiY7aQ06BCnZ9pNxqIdylttwSBAZLNE9d4s4vo4Xg+oYh0oHvHn8lW8pqu1b19cvrk9MI9GKVAHbrp+N06v7//6//vJ+QAE11DCqvKA9TLNqdTKXB9atsghYkOiaQ+x1NPUiiQpwMGHCas2cme0+iXUM/f1upnpWzeX+gf58bShkA0gfNc3iJbmZ+uNbOCSufoc7Sz9u53CFf5tx21WeDBfCRM+DI0qyTJxgkaZQK+Y6VwrQqTWJmjbubtPCh77JxQBXqN9cwc4wIKWei+MMQVTXn0WM0c3M17t//LyObhbY8tGnVGgAyPX37yzQD1VeZ7DBJRg73lV6MYQrhvrrCtJJvboVja84cr2eiqcKJA/sSpIjCkJdP0ZoEa/djAUMlAB5/vXqSjRsvQjKZALhvra3tfiwAYPrr6seXg8CAAocJmLZgJSWUoD29xARA0eyCTU3FYACw259dd6TWgcnA8gSyGisDCUhaOBlgAiwWS6tdwn/Ur4hQHf4JAoQMDx4K14kr6zRlBpUqO3muZmXFllyb0dvb9mIEAPwVy6JnXGwKGDarC0xgaNfyd0sIupadU1P77xpq0WWZBAqZ0XE1XW0A5BmvmWw2u3YYvNgAGp3gApQJoLpK67VSERrh/eKmbd5uhUk1v2wnTktiqkCHDAJMKgVnJ5SwuvU93fVtC+8atz3m/w5t3CeLyfC8jxzJlyVBORnEuy4uRHYAPCILuwTWltGli+8L4ErQ/dTUvPNGrPXuOaKH/9RMvQ72MZVu1d9uAGwehcxY4dtdeCv7j9cEldzcEYhZcbJOsz8Jk0rvtoixd2/vaGwTlNWYidQZji4GeiZMHj0ZqGoDf4q8MhO2HFu8IN1iEjxs1tQ6lxN06yN90eGwRvulqlmkUI3o6KuR0VEUATwudU0hZOkSpBDOdgD0DsnKJUGSzAMcZHtVO0Kb2L94VRn0pZbRgM1iRHEyZm6sVkt+663qBFQePV1BOGNgi3nXuBOAMZw3W64laWq49J787pHPOy51jhiMOQf1mjspHlQePU3DOilwp9aqCRjJ2x9TFh91vg0ZNnnzI4TCA5vyVD/h80GMnVIATBq9WUFN71JmcujfNyAk+FFNlSwdaTm7HfYMQt7PJ5P3E4waWd5r/TmTAFQafV25q2WnJF89+8Ihavj28JzBuixRk/RErMBoPxJa9MG7nJgbrAG34gJUHtFmj3WKwBdT+2oOymCf2qCgRv17pKbZHp5b2WOZ+HitcNdla2lvjfuGevVa/P//fx1sIukqEdR2XPNxBmggyWR4qUvivey7nb1PkKSI6q0tHespY1GKM0Ph3oMPWqPqH0wmtYnhkCJzqr5e/AjQTZzRG4BiO5eSz6cDeoC/nYfGq9GdbbGmiaOUfrpy4R9qNk8HRBZ9DWTLVoPrxJk+AVLF+HoWlaPBVow2zwYNq6BSQbCRZC0arGG7TQIkFouSIXenVge40JxzfAMRjfeP03FFikvMxf9Qg7YTM6I9MI5GmyJeLgQAJB6Lh5HsKuEAlTD5xCvgho0/0alXZJqhlcrVpes1RgDTKL0WaUhAy8IaAFQqhWaHitRxe4JqbWWC0qG4PmBM6O9Spoc678bTefXwK3rPy2voPkaj843TjRhmOo74rwIMFv3WkyLb+pEpEH7qhC7X6Ltlg/KqSKFU6yVWt8aRZ/626qiBpOIGKrLbJ7rOsvWBJTOYxwpMHoVuRHq3zqlO+FEnaEz0WG0ljzKa7FvXs0PEsxDTeXXtunKmeGfwPZsLcRhXZMzNtGwEJBpLukR2bRUZq8c1iSsBpAanZUsRquSY5eTGRzuiTc0oD51G4l3CLcT5ODQiixpLFREyWgjiVX4DRsJT2FdaX65io4Xz7Sm4pKh2mV9KJX6h8ZUGBB59qKdkiaPkQthuB8iOBuUdIAQRWT5f1RU69coev69Opzatokhvn21aBPjvIegpo1/DdTIUIncAbQtkMZeQmRUafVVJIFANJleaWrY4iW+E/V2MhwwJoWp5ZbT8MzNVqZMd1uM3PLwbnwMkLsshxoe0bE3Bj0Xz+0cLtqWDGQNOQm6vUWCNVET7Mobz4OIJDP04U+VJWtuxZbfakFpvjweGAiRGS61nT9ZvN9fX6vbTBVoADfA6Ezlm4moj1P6GlfC1ueQrIaYlxvIndU3p8vB10IuoGLaQABr4DEjfNdLoX1JXdamfFU4o8X2v0+PN2npzT/br1QDgRT8AwN3kSyKBJLAAZYMBVJAlFbAwGzvpNDK8F5P156gRP/d3M1fPlc1m61xQzazHWAsJWVrEs7p8E9A4OXj4mIX5dvbKnOmoDiU6TyV7msQd67gRzNgqHjgeZ2KMUSEg9QY/Sod4x1SNFler5/9KDr+5OF4XDV9bcrLI/isULi4HKJCBEQDzV19zNLv9cevcXI5t2MPkQWaG887PdAhpsfubWiimuh1msBd6guvRnjpCYzIHYiB//4+nW8uhwBQl94lCWeefRRrbVoBIoFMAT2dnUwAAgI8CAAAAAADZXVE7DAAAAPofF3sx7O85MjMqKjE6OfotKykrMzTqKzI0NSwqKykqNTk5+/gnKzg2+y0oMzvp+CspLiwyNZ7YBESKV4K+7whN9wcAAFA74KEwkmZAJxgOGYCcLMJKMQUAAuXH5sett4xV7/wUPZjf/N3NyteiZCsf82opCUrVdwutGO9Eg77aOxiM6ZhcXg9IxJkY03phP3w/Xj+UMNGOwM+kRLyjHzS1nf4wZc11HJmNN1Ktj0moZZgJnEhlAhEvou+dejkGlc12NzJPjTQw7DJGjU2+NRgTrUmWmkr+ggTkdD5+hjzLt26PllJJFts6kOPLmi6QOpFUAwMUgEJfjqI0mqWOPAxXnQEAFpgqTU+aUsy9Wpqa8RfK+FYq5wKtWnEqH6pVChoAttckbNelCOPiqkgs3hvXp/nmGOEU3a+AcsBDo6uMeArBYMNJPT8NKJIpci83ht8K54sjNr5jerjV/b2Rs+b1ytO+1ryNQQ/fRpK2CxXZpLKy5mF6KW8mabsnb4woMvfCpS82jGX1VwmiIK5jyC6Pdw+m3dzMmPNJkLIZ1R5MBC+RD9gMavxrmMQTFQ+sFzI1+CB+d0w0RI0DWQZ+2z0TJXGUqhkQp0jEsczOTc2rhGghlpQ6lXhkhsQVdEEEpZkkfzod5kGTz5b7/oImKKulnoTfa5CAxJ1fhIjW5tYMjCnaLmQNbQDsvmcLtKUAKQB0HpkzanN55AfRwGDr1AlQusPFdoMR1Zjtf7ZPZTo/bczQniyENGyGzq6xYkpoK3Gtyt2U1PlzJgBsKtGskRwTuD0JXzZQjq0Pto5oIn7IO5sCSat3NEUnzIoDbox/lu1cdoQNFJjTWldrAWwm6RW4vjlHIcwPH6DLsZWc9siyssEz3Dt9Uc38Y3fK9fNc19Bb+MzMH6vTB09/jAyaYTQafU0DtwknOOZ/RQeIYyK5vGUrtsR0+S6NlzayCYldrXxZ1+rAb3grCSwWfc2GdEuXMpMb8lEHMIbTisZZ4mvMAQ2bX/JhSprYmk4Nz5Mt44foACQi/YIR5fXm/v4nC2Cd61NGPei6G9J0dAox/i3Xqjj4GhwdG0+8/fcmb3TX+mzvnwAkQgtL7LbBSVP8KNB9V8WxYKJBKwWbuY+XEQ27+pW5HuPZdHbIykx9N3NMZCU2gkzLc6tvOzshvQsHDC79xcHD4NuyYjOB0rutraOY9A7JJ7OPrx5PmcuSJtklGbSNyWWsfyKVKbF0pA79vtv26txvjNQS0gi1GFs8Yf72sHxmbdciZVP/uyYfMR8haluE0NMFgA1gASNkQEIc0NQIBmhENFYpHJzHN5uv3sjP/16TU9h0d7V+/jgujxgrxWItwzoqxt/zmdVaEyhAV43Vapi8mY4qeIzEgzMH7989NP3klaxEJMjw0Dbj1Y9bVtkWABBcqe9tQvbUegshMpPMU58BN/X05n8iafgCc/Y+WTglBdQ9CAw+15G/lWQO4VZca3fV5VszSxNwP7T7myZN6LBoabFrjdijsYmc7WdgRQ0LvfQajsgFJF5uypV2UJEBOJhqKOWcyxq9l9z26IRoieP62h4GZpvh54A4bAw0ACwq/dIzmfJ5XBKmxaroBBAHcLD9/UPj0iWVgQ22dVs8qPe3Fd8lj9RortHpAPwli1UQ+3gLaW69quwAIGIY8ReUm1hfGVTSdxcIehSRSo4bDJmVdDsI/QEkMn0kQHPbm7pY0w2AqelgmZMhjFKM5/NghEoxDoW75ntvGD908KmbAAwuS5UnUlhe+trsq9GIg67xAdOOSTDHWGM1WdkOkXDmfnpHEGhuFDdaCAB8JhGiIa34gLLsT1mCBj2EbfwxfqK4kyD7G677yes7vePna085+v+HXfziQUjNRKqLBQBcJgVphzTjICy767YNoKM7xu+bTpSKBHF7XOnZrDFOL7GWHJqbadWFyOHVvbd69eoDzLIM0ge1SVPpBxAhWffP330eRR2h7nm3CQAYAOahggzoSAOQbPwkYaKi2BJ+/RYLfzZzSf3gdGe6mToRAPgwra4k0BiG4/behQIRyTsYDsaxQozdN/YibN3l9scwj0e0QPRDjoSK8+vGg86cLUavyPIVqalMO6Ocx+lZ4xt6ukZG3/EqC1VVXD3Seaqz+3+TA6o3NnJulLFvUvlI5R6v96p2Yl3KA7CEnA+tBVr22+VMadTsEcEcagw1qgtaxeX9L9lsAEgFjsKmgLZcLdiWDdrZz9IqG72nUtrpJwfKZcAplQ8iM9ZBSFQjXgEKFCoLuR1Dtvwk+7bFT3tBHJCQGd47PSHx6hqcH/tjB+Z6lup6TAm6lkpHCiwyRRnwMfQjZBr2rUga9GT6/fS4uk3S++6lGEba6yO5o+Ai09qFkDa2q9b2pAR3jnwdZDJR7kGJ00dLg1XtNphoUBL7fzpBNgnHyrTWlhqGie4l9cd5XqMKbsES2ZpCkf1jjb9OQ3w2pbRn9NnpDly8VQ2gwQzj8YzzcFZ5u2Vu9cVHG2/r+dgnNitR9cxnd6vtnVUGKZaSZewEjCJhMNbBO+jAYn6SIFyi4e6XZxCyL+lad5eddGOm5zcqWwvPKgc3epbdFABsPrVgC+toprprkhJgBhdNMjJ9Q0OiuyW4RvWsU27orURfMKcfJNsYexyEQoG0MaRDR5n6sL7aDGAkP/K6omh1cRNlxnnHr6fwO5tutqRHz/yxUO4BjGaFpHRreoC3A6RkHcDbNntYeG1RwgI4VICPS6JukYvSQdIkWoNgqQG0VmkrdVVFQIDMvZEgouK76Yfoiggq+7aUawVcN0w9Oxylht0lgiOxxwB8Kll5G9bJf44CifjzbZCpvrPx6tiqJ5X/6TqdRrDLQ0/Tgyk1lcamYepfaEAetbOqKuiFJnxC0XKe2pNfu5DTFZiRaxoBJhpIjGOb1WFSRh4PWYMp07+rbYw6/XHTolbxt0bXUr1bKVnJxnZsGHwqKY8dg3eYakChuCbEobGcdTSVPozvUevGy1vfm5B4/hqIsSqWj/UswjG2a9mwzxdTznuGsrtEABpaZbOo2z2d3xb1Sm5uSAny0vq9M51f+tjZqg/CjgHAkgR7ApgGyIBtDP6A0ocjDUj5GNlYiu57GF8n2f5NymnW4wexXx/a4VzV25uriELCVcpkekt2XprQ8ChwruacE5PhS+clXJZW7cKW+QvzMwcfDdNj9MXU7ek19+3YZCY5KYBiAX13RPHPbQcsq2IC9WVM6hCmZX8wiH0pRu6D/X9EaLCrTQ6ukv0gOF3xFedYVpKsnnZbB7lRzfgRLeBKNxIuJbkD1AzMeA8/JDa6kAYWaFxST6wJpih/kgDlRmLuqmK+7+YGC1GZuCvIYoXTvuNzheDOsGtQOnYC9hflgBzbNrWPJKMVklz/AACe6gFAOgIUwDyMkAUAcQmMGX43sCBzJUoQTnH27hhDWMYiPg2F2zmaTA4hYgeqQIXitPmggbp4MFhvcVGvoTvo+X0XgGKjJz+Z0yqFCNJWjHIfdvG1UR16oZ8S7+Tu45f/Jq0TZ9GWP0Z+7+Q1iw7rYvFZsdLp/MnotAScdcWSBu4k6EezzO3lDZZhp+VdsN4/ma8wKwxeA5gJ8Rr6xSZsQFAQioZnAjPo8UeqlHPc9aFyAIr+UnJyh7OSkLYIBa9s9ns5xhnblYUF36RvwF76Tp+VQVtrU1lr2kpihilMYJbX1RwgIQFkNlHlebUOC279aQfQSbg6+a1sQlyqtSSf+BH0YJVSvS/f3WcFZBAcLv0qwSyhWYFCRvFJLx3ASDh8umX1xIq2mhEJfxa8MmYZkvP+Yt88hBEGFC71PBHWb1wBeippayFVOjNdHHntn0nfv9gntoshRs0Js+1dfTvXbrVyq8SdV0zu7v9ue+noRAEMLn0x2ArrUREbu31Dg3jg2Kz9Y56Y5BkhJFeGvx2+9Jlu2LZVlvq+o2Y/jZKneYjwzfL5QgMyCMWErKlW+WTBAVCYv3fMb67Di9wduvX1ZhcAR4IC2ANgKIAZrARjBst28BupRPiWYrexcbP1tkd7YLR2JMfVci+GyfXBxwEhBDI5stpz8ZBNaCIlPcryzoejye3RcR/zpACrKFURQWy7jyEQh6Oukpkp4c7/vLhgTa5RYpBtTwdvv1+EpPtc1FYM9PIeb1QNLZslDz9MZ4GJCjQH14POLitFsGtQujBPhsklkbU4v7sGSA7CkJ+xHrYB0hjem5sAKuNhHmJgmhX1DTAENIDIoQEiP2/ttKpoaRMr9nZsZc7mAtkw4YRqzfVPTmd+Mw6HQVKNw9jiABTYAPQxS3kCTGr/6oLik69RJ+jQK9F48qusDES/Kovjg3x3hb1I8K+zBgm6M4NDAiQ2fdZzijt+sJjiaBCugiSqFWI8wPFtUg5EuzaYq31/2yaCQj0bkwUUOsWyINrCfwUurzDiHQXIop3AXC0rXD/Pu6Nb5OnUsP3Xs0zESzSQ08mnr/uPRzYzoAFMQoXy9o9n7vSJ+gJD2VoadDSYMeC/n7eHAxshxv3bi/rBV3Tna+PSoYE+p5tObSye+YdwszZvK5CRANonzRLkEHsrHx/iQqu1XfL+7+087T32NtunGx+/OAPAkQBghc1BBtarn7wMqCLTGENEBq6/e5crJkxTa5HcsIu7MuX7XU6UNZReVLS3Lok+PWs+swQKVu2DIxprrMq2ISXSmBdol2b9O9+a4DEC2fHjn4/pmZKcNI/Thz/n7n4d/0mPlENbokUVWUwikGrZ2rbrlPW2YFmnkDavM2e96cctLhdeAvmRgXW/np9ZgGnxa4K8ilMVKMG+oMT9HoD7mbxQhJIKhJeAADDW88hUSQVKSkw9YNkWgK7cFgcXOyKG1qypRL/+zDoAFhglCNlTO8hiR4soBZ723+J17Dj1OrYIywBgRw08AIB+BfTnAAawMKmkYQ4WAiyRRMHA7OQvb+MkZr85v1K2F8fD1mkTAHDWqVkjiOGKyKzVWkktrAOhsstKSomlSMT3Q7ZoDIhUCq2WpB0ftM0uFqT2Sr5jy979/yeZS499t3Wp0auPxaqjKIoqbYR6spniiPWrB5jnMEGPxcB4E7W4dXqrFeTaF+WByacKNJT+WQXaIl2CqZCwZHxVbTIdlhUK0tW9/Tf1tr/LBUBLlE1lGPdM65SPqZ03qob4fB0N3tLFTm/e2fBy487YM1wtLdEUK9zAvM11FAA0MvXcw02YPidQN55Pg+ANb3d4KEsWV0X+ztIKUOCcPVVxPSMEVEoKSnQA5C1LTaJj3O0VxW6wL2xgJDzzS0Zcon/bCppMtUuueqvRhMquuYZvrQj0MQtYQsZ0+CMBe81bC10HQjj4+/oh1TPXcdDYWZiVHJFBRjLqpJu9fZF/MnUATCoFHqD5lRkozsV2nTIBRCS5CxuKGRGMg3onkJ8nBOiirrVTqL9KZJqvqgBcNoHz/EjdHEE0X+MNhMlZ5/T6XSArU9s0uTPi+mmgsPujn1dr5MSLhUjveB2lanHrAFwqKe4Z1q9MRKnfrKodYCJdIObflbaJOWXoYvYlTe160/HnuXD3vS/PDlgWJc/Zr1pLYx8FT2dnUwAAQMkCAAAAAADZXVE7DQAAAL+OTz0qNvY1Mzw3LCwwKy04Mzc5NTY3NPH58+j0NDboKysuKSk1NzUrNzXz5+3mPDYF6YnkJ36BHHVjjbMEEw1mYhXniK4mAvk0w9pl4i+DEU+aZ5NVbCZ+lTnx4Cs0/BlXeh4B8gdVkKn5mcIjqZIXomJS/s4naMdj531Kdr/vNgDpAOqAPQBeMsEAv8pMpIEk4AWUkhmoFk92su/rhHczjVvmfSURb7h3y1UkKquIz6FUTP7dFCjRUqL1UL7WpFrrSbS3EqAMUBHOZt6ANVAqy4VdtMrbxoULNqz7mK1Q+qEPOvTF9HCnkVxeac/TFbdSgbTxp7LAzRNQw3KzLrr5c2pk97JLIEsDOXZs/kykxjAZp3d2zMAcRf8XDiCM77zGDTb7XM1Xu9Tc816hxwmSF6BD5vtEXzExu7tjxqnoBsxva2y2ERQ+1iZW5K96RqEomEqrHmtDr3oAFD51KlEMyf0POblPtjUKJhqUgrfVwWx7vM3p3rhozq/GkIzmJNMMPfY7Kc9nyRmbQ3vEZwAkMj0FwTpye0OBTtuLBqxzHP2noRONGPysn9rpdP7/3djO+O6BOFjDlHbw4/99rwTS7wH8Qf1lgcfeST3FAdoa5uLVrZMS4BqMLLPRzSJnE/r7fCsxl9UfrVwzVzdb5+DtMeYbPKhiFnVpGxK3egIMLot8wTvpan/Rua63Nhc2s2ugA7dkvuLTwxSNfqPF21zxvmS5MuAqJz1ZvlHN1i2iURt8FAoALDZLkCCMO70qwbXRWgkm0+jg7e+p/cBoatMFiQ+JfyW6/uKOVqJkbJT1bwE0NgvFACke/+qCMoJ9oeqEB8Hm1z/UWyx5fsuC5VeAE7X3gk9hDkbnz6b1DRw6NU+ibe8TLxLUuV7FDqAjHrqBv+WbLDIey2xx3eM2QULTs0FKvtfgs5hSSFpuAAwy/XSC1kJzi5u/sapsgM50CRm6I8alJ26bFdWW0SzkU2K/gPzWjwZvlAI8Mj3Yc4y7XNTli3oGDWYQT8NdG9GwkCKU7iyXr0iz5jv65z2oPxDQOVZxBwBELgXiuU2ucgKLBSrddWQJCjousUKTBR/IRvK9WhuV038sJXujt3+NaYXD9KaVkw/TbX8vpqeXBAQy/UhwM7+W4oDa+3Vtg0lP53FYl6mMYHeKye5jutw2VtRJhd4f3qWlv4p+oLbeUnlNSfw5vYjnhc7RgVoGVHzMdagAEy0AZw/PrBlLYZ1xLYtP7NdGclzXj01e8YZQb/D8iUd2r+MLaQMEMr04YZL+44tadnFpB5iIg5lYpYEzI8kFk8E6MWnzy5zapd+Vjb6TMnEyJegjH+Dwf1n5cn3tQVREPmkSLJu3vDU5oXertUCCWcn1a7fM87PpdpqbV0nG546DeP4zmZVEbwa0GL+3ZJdVXLeQDjQ+BZUI63584qBetbZG4+JBYo93v5ID56PcHByD4U+f+1g6Ve834UWoYhv1HixbGo8aK641AwwydWhiNvmXT4kDUN+uqh0APR2rH7yL7D5DHo80yWpdp8K66a9PYCFVIcbPoLYdtdIVjPS35wAUNvU4MYzbf4jrhK2FSjqzwdj50Pev2J6mtGqrkGvYLG2jxgo27IH3b5+5l3lkOu2pxzkBGigF0PSLuPw2JCQwAN+jmH7djLB9wDMhAVhHAw0wB1vFAH+kGVyBlJc2TmZgZWCwOByJfeqfE/tJcaphKr62k5+b26srRZPeWxkYedh2pyoOnCd+mMgq06J0xaukwI140Pb318smMarFFrVSJh62Jq7lX62n4/TEuh/346C0lspKAsZq+7zsegTeaHbqJKwCv6jCgk+58ry3z6y4k07J1oJzILktIEeda6sDLAM0ARE7QoZmMIm8AbYMqYEH1RgzHLmK/640eHjAvHE8nVUlIrmteBlKSQb3qrKi3kGyqFyJ5deQDaWF91vPbTuMXoBKAL44ZSw2qR2uJGKkMHwSdhlUwt8vLQBIRwEVwB4AfzNBlgCMAsYBuTHoGqlGaQZWVyKd9tXWVbzlYpfxGkymOobUB5yI1RGXcdqr2mtRl+olCByfDiHUNCgxlkRKRR3QaK9ujPos4EFqLrVW2pz/+fdyRLxqBwNpLj6ZvR8mIuJehJaOXyIzH4ot3E5UPqGl1boz0vbYvkVHBmp2mMKOyyuvTNBT2Z3vWWaOSKQoGrVhZGDGnKsnUh4gEKn9MAiqsaUcAwXh1sz2HZEmAZb25Lcz8nUmHSgjd72y1RbVVc0x7OCwbwbLWAq4gjKiLclw+6/e2HNVTJiYAF4pjVhHRoIsGEmm6v4ygEWCAIAjQR2wB8B8AgawWikGY9cQaKSM1UyRt2rYsZrznpvI5KA3O0sN9gkAgiDWWQajjk0FUDuMWn7ESPNHLQVNrEsUG7lyGmml6K5mcHj8/muTuQx1lM5e6usPfEzf7iP7rTxiEWUsFdm52XajXhRRSc4ClILC6KcXMjHGhxLx+mz3Qo6H+OTCv0oQwPuy/C2mHfRaVSx3s4IGWABHvOF0gZSBqSf5ad2o0oSBjF2fPtRsmnGLg4HAkI8qN1RowtZPVeNKoNHYcic15o55t6OvfgPE8X1hE8AWcfeKc0q5GwQGAb4pjTqGnsCCvftlCd0DADALwJ4Av6oEBgBvwPWkIQOe5xSQ/Hvh9rrNX/8wPrlwcP42vr8CALVGwadcmdQ8OFWUVMSgQpPtGalsKdqga4l17kY0Nesu/B64vOWuOSXnQVn5fanebBtvHZmtV7RsljW1WqjJElxww1bsriS7VTNAafbAXuYbYzspxtWjH7xLr/0qGy//vWeHqXWnk3lki7QExnClTO2pZmaKHBIK3JXHFnKScGAOeQwYknTTMPNWEkzAP0vFSgLGjI2VSccU2vOF8YCtVFE9Mou4JYbXHeV8REbzB9xl+g3WF1VwG+OcygWcbtg/2TRyDWV7qkcAABgSsAfAb8AAH3TBSEHSBBqrGZg5ih34Hy0+C44mJZMaG+lqAsBXCVy0I3jbc5wAkqTlSnStYgiRqlzbpFUt9+cedlaqgmy0uPrilNZ9uhibKQ3rrYrJ3kgZlSsTIJ2/SqVlxezIDKs74cZvK0JpMktbv53gRsNkM1n3cu7u72cWIrGyYf/vjhrwAw5RzDv3BD6tjFs1S4rRZNLA4Z8NcMafP7OrhnFLZ2Vu7s821BfYowJkiTQYd5q5NftLlhZW/Y6JfoDxDG7qa7nNvG5ZP70H0dd1ho3ZQw+nSBtsRCoREkyJzUTaQd1mnbYBuGMn6an31kS95ZM+yubs//CYWKotbjX9HBF6JlJpwP/t6+iRAEQ2ifVMFItAbNK1AxQ0KK4+LMDpuSlW27EH3ZDFIpU0pddVlcMFdfUhPujFNpNMeKwFzCcTC/IXJbiUrClrI2N9fwCA/v11FwCZBtgL8AHw0wyiwVNGaKUY719R7F4DdMC+ett+PdjrPrTWPjCz2xTo2CV0HYMJpZIiSx8eHjkdJaEQ/M7N9ewt67pX65w7usCQ8xc5T1hus+L+VMu7G1beW4e0tIn3UfPzILQdSOGcpdlvfNFdUBjF8Ieaf2aBf+lKEyxdzdvnZZBOoM0Ej75+s6Yhr9KtnVJhO9pytNd2hGDURTr2u9XLboU3456mY8FluOls8sRxsUQMDOrxY5RhlNScP3ljGCaROPDaXOou+hKd5xHUjd9ZNsifSAA0LnXR09V8nMBIQP/TLIExlDFHdTui9HKGZN+kjnZBnU9++paQEcpz4WISHCo90TNGP+/iZVqjbQDG8KgpFOlIkd3mXgjXZivXy2xJSUeaQZuixFpnAAQ6vckztSYzEGn8YdfZVABo0CTjMsxDyWA4SCt4y8UK5XqjmsS8nUIXshrEPQEkMn0hsITbP8S1gLcWrjHhAq7Yz+40o1dQCb15LH70aLjQSorGjMZ851QuJQtEccpEBlfjTxIhXDI7f8OWoHiq9AHhCiNdMy7Tbj9EpSUD+EUBXCax9fwaoi1YqiKrVAPIxN5/Ljk0HmO/j5bkfPKSJz3F+Z/I7ZuHc4x+zqOxTnajX4r0pxscKmmbWB9CW3UcCLnWQgcNHc2x+z//tSRHm+zbLIPcRNNXXeN0vVvgs5JlXKg26qsstYLWWFYADDKFkNhpYbkC0QYaveKtetIRdaZ//pEMN5s4S9uiZ5aFWX1KPOg4Ionwy98W1Uu5Ju7SBBpEKmnpGdZ1bsR9ucY7gI6QivXtOZDEUXKtadRkeiXMd8xHhgDvB1dBKnoAJCYRnoBdSA0cItoqIwCki4v/Pue6s/Lmmiz1NCsROu8S/x0H//Pm4P0zf/N7+/t77f///z+eAEwyoQxk6fMXkTZTa6EbBR1c4dvvrHWSNi7nfVLZiW1cGJOrX1otzW4Z3qGI+Wr5h07z3rYBGggliLG00zRNwQlJ7P2/MNe17vG0bQ0GAJkC2BPQvwPopQMPui7gacWANmoxtvNdSJ6+TLbPuNwi+wKAJzGqm0lXQGhQsJk0m75GEhFKTDwKtffwzsQxoS1118KLVUek4+yMHUXNylWOdXn8/bpzsYWBTcQYJYkMyZtIoNaoZnJzbs0sb3FHCyhh8SLHBWwNXd9tJdUMGBfzHZpsOBnd+apNtLd24aSARNHzivJ/hqxp0gAN/tnQGAAYeXkMzaNTq6n3l/YgpZ5KEtZCNaePg6UZ86WFSJzgQkORY3F6bjcQQjbLS3lXp8nVY0+eYDx34SsBXvn0ukdUsgaQxPQ1AoEC/n4ZAEKmAfYCDBVAxYEHnS9VRjPwOZVnaJ70L9N6XMs29E6/9vZzddui+OiAlN/LmRXatHUIBHdREiSliO8KmCIjQ3Sq827ovVrsovAd3IWBclrafU9VZH1AXQ3VWpjF4YVcYhT08j7dh8c+17bywv6BeEjKE6PgXnnBapFCyBuNs4zlxPWVjOTB3ug0+IeSkE5xI9TEQmpqgXEpP77e++B6BoX3KL0CpAOoCXlHfBehxHuWiU+BEnBBOVWtnFA8RXYaSmkldU3WRqRx2X8nqrCBfRvsaGwAnvhkaIo3RwCY+yX0GRcAADIB2BPgzwUQbgcebJBYAEXaCUGB25Z6ZXr2zJa5FnN+UGVOuX/6AICPMTphTHjQQmQoeuKJDI83JhpGAUgG/OymJSusVZUyKk1A6AMRZb0jSgVYkKb6rdAvqYtTKqhEjb0CE+L6LrTPHCZorXBMPkkXSt7b0+dleqmc5DDw5mxuO65h47l7jXkRZ3d0kte0om6xxgjD/pq8R+IXcMMWeCW5J/9bDtAVbczAyixZiFO0uasRNTAscGnZId9wgCXRSgRLfUIDhst2xX8+1l4ZiDBjcWawQHM2mYWgN7sB/uiUtEf0RAGtxNwvRZsOAIBZAvYE+FMCVeHOCzTCZ+Cf1K3Lbu7KcuH23vNB5mrl8HoBAHMCVKzqbpIF9wrKwr7GNikNWBCVNin1SOitohVfXxxUYnFLmj5NOHOAwWbQbyXLuuL+1d0MagfZ8Yd3dNIi//zz3YtaR7R4JtCTNUfEGhD6AUUuCIt7KBDgXvR7labwBJhBjk77/suwvEOyNgIcP+TkGuadqlQLjRoKV1WNiouLyf/8FYm611YQ1ZBEJobEoLq295BIzIdsAzq37ilATNZXTdkotkVvCnC0A3Lus70pTgBPZ2dTAADAEwMAAAAAANldUTsOAAAAWeA56BfsKTY0NzLk3N/Q2Njh3uHb19/U1d/X0ZbXBFytQzhX0iE1+zsdcb55qeOKhOsVAAw1wJ4Acwmk7YCAFSAf8JRjoOH2nSc+BJ/R3M90ycuIj3398z6cLnJDUmeylZx9vuHL2LS8t6JgIUoi4z0rpFUBXqzePTyaoSQgFaXJvrh2GShKcKc9LSp0njIAHQy4VXIr4XAO2yU9RM8kzaoswvr+foTXXLIRGNixzH/oalzQBV1HXwjsXmXaYFxLEqs4o02gJabzH83XPyWEulEChc7JdwTf0YBmo5qlZPhoiumFSg0LH1a+4yZmh6ap5P0q89Dure7Jfa0aJXfZdgZctXpUaOAVxB0LQoKe9DjicFz1lmDCBRjSNmVkFmWjWkmMY/e1akKeTHwu6A8zYgJEFpn0PDfz9iF2hKf17tEA0tWfd+aISAZxmst6g40NLWw8CPbxFpf/mzzg8GBziN1EaibaZh9MHon11K3uGdEwWRMEaEjHfu4/HQmM2bfJON33enu9aM3zQlaA90MXZu+Vb7W7uHq2mvIDRBodCaLpg0AyAmFVlQDctfHgD60aGfaHZSXhtDlpz8FVnLwL385lxV2r4h+31E1XfL+K9SCxDiwamQmqCWREtVV1B9BhE5t7mFNy3EMeo/RgmsSQ5kxLibXP7WluAfMNWTs/Ld1zJ14AWsikrEY2lF5ZxEj4faOJlTF+dme1Gc99AEAGYB6GQiUZBOSjLLRWFOc/pm/3Vu1EDa8Nv+bSt4uorVVnLG2aSNfiWN5ryTZUSxwVr1FjCcU6EVPP7FatGlJCG5/OFSKOV6x4Gm/WACGhDaJkDOKuNGdpvmZx/eEx3KbxZSIKMmUHIr9P+9XN01ozFxHSGifdSoXJxJAg6qw9vQTabD53oCJmGfkKST4SjFyQq4478QY5r7N0oUuKSo2Oti73jThqDSjX1VxaUEEpr7D8I0KLUrIBHYsSNdqzHeD3haaUgvmzsRUAHrn0soQyALj9UnGsJACAAWBPgG9AmgwICBhDasUUP1Pjn7c/k0GJu7avb4lJdTzdAICvR0C1iYq3psWV1JdEjssaZR0IFYLS8pep6i7l9rCObs4GZLdd5Win9LnO5tLe1XATVxUNuTALuDBcEkgyvt/NuoiNJh5H8m58HSGCEZgMmobBeL2L42O8u/bMxFO3X/y7HPgbIMDjs5A4BAhLk8W919J3yc/ZNBfHFQKRrZdQ+H5mHyVin+JVzpjqLEd+gM0gEvhxHyaOS5lim4z6n3Crtc7e/7dA0s9LA56olKyGJiBj5u0GVCD5t38CQGMGsMGCqBgM4JvoCccUR9NeP50lLiTSrobbNi7f0U2TR2hx2OeSAO+5of0pXrK0oLAKoNJdJISzQVbVFFdESn1iF1wLKRd1IpFdmpg7bTuLJ4W8clY4+gYG1o7PuWzkB7+3bB4hycDr33fIgi4z1ZMhSUmIoB1fteM7OdCJbP2oJdjMC1HPKxehCeIe2K/D6JTmNcovKQCIjrqbaxFvgmuh6UfMaboQX1gO0xZKrToHph3tvsEyWNCSX0sqVRdroJVhYamF+prdFVgtyAC+qGSmh64AcPc/0VgCFgOAyQpjJCX72nisFcV6LLcJ06uT4+3Bgy5uEmoCAGKvXh7turYS+uvmEd0olUrRNlJLzckES10UcIWtGAHgeNtcmYnv4sJSkxYj510pOLRvWn4P07zUzSn2LLgWnczAlhQU24ZzaNYRp243WSOQYshyfn+CF6mg7UJ6ssyIlhgHo8OFFmSWZajoQzyIt67x7BBO/RcaW2SZL19FezJOVtGMIwfDseJijnPxGtJfS3grFIxO+foJXY5zUwMxViV5nyYAHol0uoWGoADfTuWbOfnPPwAA454AH4B8Wy6ktVWK4lD+1x+q/bePh/OWa7bHblxFfXS3efQqMA7qnm91UVLrqIj3p5QlToz3ybbr1sEqO4cemDYHxTAH1G0MUOXIyQD6iy2yTW4RSrMrPe/Tr/mcybFlhuf2tLUmJHLRReDhX0JZN8jfCAcs61M4zJAE913MFmsaGOzr10ZYbAx9fodPlCznZEcXiVjWoRNuuUAFiFw+TQJ6A9lhe/8Yk4W5FEt1vCMdSCudKdYP4juiiJQHKeb+Fnk2e9sA/mj0MsU2QgR4/VJnBQ0AoLeAIVFtJUY5JgXjwK3cnU1vsy9v5PWV3cannDUUABjNXQhxVqLnoJs17qzshlN2rDqUfF1HCMofqRN7ch41o2AKyXmmg9Mn7x976HR793BY8aFrl5DAqfUD+Qs8hnmCK90JIF/ODRq3+gpB02Xoyt8jvjfnBjrsLUNNL5A0KyT3bhtJKpQXnifqS5y0dEQ5795wp9626uTqxoyboxvutE4VTmTrpyAgD8JA78P39ms9eLJnfSmTKvc356O3bHyrQOImmVfMhN0BPmn0sSUrpg8g6+btipsP1xQA1AojtFFKDvlOacd41o9/vf/z+1P8cHrcNhz0pG+/4JoiqZeyxmUV9CGt96Ie3Bx0kRjdSNx26zRwVx0/gJ72kDK5v2MeNF2Aa/hKn3IrgoufzModo0ZiEGMHiTIFB2Ir3SN1pXY3KlHX9lXJryZvaxL9FqVpxWyLuyS/LKB5unDmkFucUBblZT4RdeXs/V2F+1r1TPR9rnszABGuGNSLI6DO1ttfQu57ZzXI8F9mw3qZN3uk0/blf6LiEHzfGEWZk28pPXYBwPxaVj0INAoAPln0roUiAPh23c2Dj/cAgHGFhphIJYluhWbGY/40c/Kdnjwgvz/6lk8DP84/SVHN9uTB8+OiMooLdLOznE+JoVTydBqtfTFzyoZsnklC9WYkcPzWgoUQiISnz3f0tO3K6g6Bq09hHqmMkYMwMaIc1KSeiI51YCPUx5/4MVUWS5KoW3q0kFpYzaltbyDmfRMxwWMVRrUFQpmaBtr10neUuab8okv+fNGFdqXL/T2MNEAtoAhmOagSULDD793uv35WLM+JIYpBy4YrJQGoha/2Zm836/1sDdJkYLXtEAIAnliUoALtBxkj/t2GLu1gtxIATDZomFYlLjHCsoLvbfrvi4cvXbKZ7xlRNlu275510dAOIOuiqBGpibAyaffy6xo6OyzpvFpsdjSyVo5Kewc1ydUZuPbCjAexs4wrz5GRgkgOIDqd3ABq1Jnwrt6WLXs7hYE0i0L9PmIiHgLPB5ig13ueGGp51aOrwlCaVK+7Y4QYBw1Xy6A5uV0a5jOE/G+qTQ9KEnEXvaGsEIkeaxhy8DzQ0e21t5s6KgQH6sy8qR8qF0S7MbaOUJ7Kd4CcBs/uzL1nq4PPtqPxcgRmV6ED/lg0ooZGAPDt2sPFPt0WgHaFiTbv66S0IDXj45aL937me55Lqe/BT//b2Fjemaf2V+bdhJEMROrCathUhvGQXQwgfJPZzzjb+uPRCwhPdgrqyAgUMx408ikGMh+89afN52e1VkAkPzjfabQgu3hx5QTXN/l6E4XxZqmZkq3VMVciR2JVVPbLQr/tZdDh9R+wMxBK4AL6qsc6Ki4O1NRL9u5pmnn+d9Q94G86WH3s1hfBQfRBu8DlZTCwjvT6CNDDkkAbsTSuMKB6lpuqSNqFPoC1lVVklaNWCmUD3kg0ooWAAPCusAUEUGNa5SdGKasotdXfV1/kUg7kq+yF7QOSef780WY9nbPfnGa54bRKnM/G93MhFvJzUaT6iAWha24Bgh/ablKsK1EPamb3OaczZsC9IxS8er0ZKUE9goyESMc/H8rI0m8nKRZIaajo6TOIKStO3/yH2PPbGkR2sTI/6sMzTFtNCGc4eXECV0HnizWnEVBc21SmXnqu7bLqdGt9DwppDD37ArgtDTQKpVnyLW6xVLmLM+1Fxd6Hb+/FinKXZoEz5F1B6WWYrviof2sNNgAeWUy+FYASAN/5KvsZhiVYAZIqX0501Epb+n5wvgf/TPcMzeSLrXYPn/YzdgcSm9KkvpnGuGhytJ/KrmnBkxKWkOst8U9rd/7AwVZJ881Y5YZi1paZvn6Xb/A3tdQZfUhMwbvxrC/VV9tGfgY1DmI3JUg4GK6N+DQuEtzt+ELnR9ZHhjQWDVOXiafCwWZp8yqHzjOHGzFB64WYPsMyzeEfxlrcMDUZW/ttyosgyjtKmOEIX1mkLTJzaavZUlkh4TwOKOpTSohVvv5WWFzmLacjfam6iCoAs2j5dggvdWADvlg0rAUIAL4zHEVrCYzR86Uqai08QTH48bUvvtz9TLye7+mzF/5u4+D0WUomaTJPF/ZC44+6OMzUATNQXhy773W2/TRcK5LhQXpmNvEXlcjdGJ3x0cWYtm72pUzal2cOX1n7prpFd3J1rCJILe2vUbZMzrP2xiGbTNlR/iJpj8zSDiC6oBrYl7+wgt7vdGXuLMNrG6Yrb1ZgUroy/bQSeiB8pUf03Y744hVOZ7YQl0kC3/PMLAaBNK9VyFJ+VrB9vdpgX/61KH2vd0UsotW1/m0OKDo+WGSgBkcA+G7hylH4BKrkpJF11KTWjNXjk/8/vmaH7eznsw7ubOTZ/Sn9vjfh47xbl5Bf3e97/YJVke+nnXGslZifJzzXnbJCJpf+OYWBiChVNAieX/REWVvuKi0IhuiJ7tXR+jpeZZysM+Z7WbhY/SazkctbrpRKLpSVfQ4ZwtNcUh/UATt8S9bKVXooPctbv97wblFmW14AeNRWaLF5FJ1kIagyIlShcQJ1PdkwqTIr4wpDxp1CXwdLdaGuwS26yvQWS59N/1Et/CqfvRjElL1tOgB+WDSgBiAAfNduS4MJmDZtyTGWUFor+nRqZnX/w629j082/R6czQxLvqkQEsnHTRHL0iTgHZOHaMSBObr2nax5V8bawVRdH+j7ymSLvvLdX6lUrHEzoa9MbzvX3VPgBF/BxDitTvSIuXMgRFO4oFsQhWXnDn0yF0RLugtltqj7vCBpInfp9PSBQiJzlPsxNVzOO1CNwU2MRKPUkyDZIR4t++pWWGTVoEXW6ypJff/gjpfPsOYYumsj4AfpU1tqpY990tldE0pa4/JxhlJ98KC0I8yGI4i2ELj+OEXeALgBXkgUtIZAAPhuflveizIGTNLsWJGotSA102WOKZOQOn975o0x8f3eYpmTeEwJn5/Z6PmiPfn58aqG4qlLI4Cf7ycJUe4KSsu67ffT2sa+rIzk0Enyt6fu1QubY1CdBKgdMKtna8vuS5mDmN8kRaJuguzfpCAxDvwlsqpmI6SzLsKhF0tIETg+TwEJvThoanflDfPVyA4RiSVFCu69o8vu9+7ehO2tYPkFYhzGckXawd9OZb1yppQK/6GY14HpKkTTaGJOkhZNugoKJv+KF2zAH/HFHY0GPAD+WCyyAvwA8F8K5wCMsWKqTUJkpZju+YEv9vzvF4//Hn3ozr+/N9+6nzf9c+rtn4fneHY6eoIUTwUQRuVsVposYiQ4fiKCJG86IxT461DXtxUYGGt+aG+cCPzmghlL9xg+2Q5nw+NHYSmSPDGHFyl0LjoKaxfM6RyVXBUR7dYG6duzm1oa95o2FHPLAVoi79WdW8c+0qqaBQd8FejUdLeFrKh3d7gkI1qEzpweMRAPoea/4mqr6ys/qbkUKPHX926zdHjX2wgFz6w1pj/YFaCBDk9nZ1MAAMBfAwAAAAAA2V1ROw8AAAAuJRyNE9bi09nX1N3c09PW0tnX2tve2NI+WUy+ByAAfNe+9AoUDmOiq0rLRlkmnH4xS9699t46/vv/rPxv62F7Mvtaex6G1gOvp6f42sqsjysg19ljUAH6UIZ+NDIE42TCbzVSr7dU6yzzN6Y1bdF8h/gN86P+nRtLHXBBXr5h8matwA6AmLzLWr5zlx6g8+gEDnhMVXeFGHZ2XFzR4v2IpvgrHj0vHoceOalzX1rv7tJHZu+RQ3oKGTowJolKt35JAFbbIqt+QYySUUhR3N/lqcd4M02hePbTvMo9xGJjacfi17fpZnWb89n0AEAHvkjUtEHFBwD/qeuFPMA4SdMqlxinLeP+3K/uHZrMbzyRe5fWB/4zfn2Puf3FcuHS2ZjIm1Vzdyf0k6CL1iKTMTgW6l/7vGAhSKuJoJtVXE62jNOe0XunZynEm9+TuoImKp97Ia09rqWOlIQkjnr7VbFPHqxWSk+E2fjuoNEy4qaPUZbY6d7AucWaWkQcWEVfPkdY7i64VLfogLek1JGUKM6dQw2a+HQxV1b9otO7jVFBMsLKRoD3XScVhINbs78ZkIp4bVgD74zKzZpI21Hi4JCdSMfLYOjW9sePp9xmjWy0Ah5IZKAEIAD8y2bjxpaMbVox8YVTpGLs7r3ff/5pPPC+Zdw3fn6x/6BWW00qnr68qQpeRs+n7NXxofMoZiae0kdEZTa52i856q6S+6xMTRlo9NhFOh1Tr4O7XcaoFoWNKia+YUYYr00jUVJyx3Cn8z1hw7hS0xfMByUL9ssGoraRTvL5Xlo6CE/ODUK3ZpCdZ1/wMriiDV142BqCVaulh1Mrl3YXdU5KrTgDIVzzXs+GMmmFXbE9CtUil9K+0DG5qVoOh256FU9D1qWr6OO71fgstAk+WBQgBQgAvjNsS6sBoKrK93Q5pbSic9vL4a37U5mfL+dbRbvHyg4cOjh48nSJ8SyOGjeNznTFNepYeZ2Z8JUT+MW+tJmvfEwBUYHvdOxgpMbbFoEwGQYcn+9etUNQWHbVyoX39ofqYTR72U2EoJ8UkcGmPbCcI/ywWUHI9ISVkBpqaEacu4jVmDlHkoQrjClnBNNj2izES/HSZuLEGE3U6nfCvCGKpM2aAxWllkdVxAUCLw6a4TR6xGEYD2iWa6psoz8dRrH6zp3XWsFCB1/hEXLDWg8UAAUA3lh0sgYgE8B/jV6ZCKDSkv0YPa2sVnDLy9l/PsjrW61zv3hxwd74+uLxvYH588zJMrFNeVwdeprhjZ8dyCTeaS4hEbkm2XdKF2d5LyDSM4xUtAeElR6EloC3d36WSnBiLkSdvCDa2ZpLpWDNPcw9jTNV4AeuOk3TrjI362Vo+L4QVK31gni932Q3SfF98E6PBearFm9Akp2ukDszHLM/V0/p0S1j/QHGeUAZ7bqYLiVCpuQRo92sbe6028HgtmVb52TWQ3SUHy8IRDtkZdoJbxxGZAbRgw4+WKSgBYFgAN/FstIKOmCcVMnlRc2CGQ+/ON9fxds/fybsZm8sFy5c2Lox+KIYa+u5tPWwrJoUPpoMYWgCFdMl75SLZ0sxty6PF6i0o/Kw/Ni9mW5W+xwwAt98CccnOVO8+e+geLZoff7xY4k1FF49scwyCYTCnT5xlJ52NvZ2KCihgOWsYYk5LESJfiX1wKwN8GzaQZxDbGuFSaaHaxPj/Y5SSTaw0j1cN/g5t3FBkDyWZDFY3C3Z3ZmzFmduryLzgrLBiZQdypxGTRiXY3pH6w1gA35Y1LSEYAaAd8KojgEKGKuqcjqRlTKMTQ9bfWi9lztw+j/Mf5n+fu7crbb/mDU0kvmSU5l62t6y66DTYdqEPTP/tjeT1n4t4vVTr7pOD21bvgQfp6vBUJB0ACeob6cKee84+8DomXrlPtTah9yTgdIu7SCi0Zj0YZWSbdba4IDTJFqrWymHywdkIffwkxfl2bQeY1SWW7v0VrjjSlvQ1LBfp9d6VfsFcOZIc6Na02xMVyiKfutOIQIFAH4d3QCnK3NWfHzchSWljOf+36tYq/im4R0YJBtY3xwevSkAflhkrCUKQQO+pzUK6iTQQFtVlcTEKG0pfXm/+p83ycl19PeZYxdppk1KyvtLidPQsltfT8l+Dr/Jdz3N0U7CmorCdHxdkT5os/Ha+dyoG2JimkUpgb1jQKmPpd8ZoVBB5lT8rk/YJioEhe0x/VlefVFkP9ytFOrNaz7J6bCoF9aa/okC0QIf/OXO4tBsCcZ5R32TcYbqfYVuJ6ouwyG2cqo8GDLSypa+pF2m3+qG2MCl1aV8hshDlX26K4yIV+pO7N1270/xjJKsACors/58OMs919sv20iCFAUTAP5YjKIEkAHgu1Yo5DIFTJJK5ETWntKCMZV9+aw2zd60YR5+bvw4tnv+r2n7X+5q2NhY3xtaVoWDqZ+SQx1wovjkCFZI7RCu1rqijwm+JjKh41PM0b/eBpeedd0UkCUxqbO+Nlg8bHRrFE5DTsN49ZvbIzYrJX4aMpFXPQoFmjk8STpn5AK1dLsD1TIsrkbvJiJBbXoUDpDeXHIRtaT7dtEBpQwmVqjbvN7AtwpNsN8Opn0s1geZDwu4n3E2SetCwEubJhCl+/5s9mXudVNbmd+l0AA+SNQgBggA3itXLAC2BkxbP/F9Ew0LVrQuh74fSMoRmnwYRZfEhOOZB8Zz66wl05xK0rTVEAIB67zX1mzXjCpwl1chEnFrykDvNUlyZVTQHDGPL1gmrKX91wW/ble3ab1pQSKUV80vCctg+7kT90vHQO5v9OK2oSeu0sah5mqnUJr5cuOiU7UgFvgWgoc3tIxfLEXwobETdFMCbkn01QqzYVUxG8THrPEIyk9OZhuby+0u2/HiSymWmn4KpS14PQqtZwZv+pv7KrxHEyKVDsAgYB0APlikuIVCAPjeBVgNChJtVSUhl2dhnIVcCi7sk+H2Lu/YNAiD5PzhaZuZZGKrJTO9WAi4tddc76nvLJI3VW2UwmxL8X6nJ1pmuy/UT3pMIQFDVCODvVtxFyKvilgfIzbFidh5IeorCY1cbUTztlLJf7yx2EBcppMnDhPGNP/r2u9AY2wJr83NI7m4YH2h66+ZMj2flQRjzLInLKGofBT13y7jkqkwaMdh+d32l/mrW6UK/5K15NK3Q2cva0O3HClPljx2mB25DbZuyBQVflGsfCWrGwRsAD5ZrC4GIAD8F/Rh+M7EWIlpta89rTRFzu7Vrz4eHo/nvVKVdpl/e/fpSdpELnryPyyWNOoyHqQMmt4nkSjTKxkZXKaibS7JCj/UWBEZdsSzmSaC+TchE9eAOzlrmbVK3FvYwgg1iyd2Fyoh7UT10n0Cyqud0IyoyDk7XBISzScFSf8JIrj0reblaDy0qRXfythBXUayJ9esvloXnWcqIczUSz2ZdYsJB73b+5wy0DCLuP63qVLefgHJuXzgzTIqZH1eyhKlDxdFXAJyEyxHLN4wG95YdDKFQAD4r4dezASoqop+Jdoaxdic//9rs+XS1eTBtsuzsUtMbdeKs203TvsqTMm8pcJzYK2CYvz1rXkJthqXJBkojrmphtX36tIEATLSzBhiltg9XMMuO9pgdyqJ+O1IHvyBGMu7ivvEJEWnjESUEDw6qZ+vD5EKTaOl3NczSW8fQa0Uxk7VQaEX1kIiRwhNLPxzwqd2N8v3QhTtyQrMJhpuADONRs+9iRNm6f7LuFoe4cE+W4pNv1eFFQ8oBZWknbTy3Pa0STMFszbd7dVyQaFUx+O3UAB+WJSihEKQgP8qLQdNqQPj6Fd5vqxJZkqn4s1okxt0IGe34mT72vwGe9uxN/P2klxc1ncmmtuk3yNoMCWBLU9NUd1Q4yZ5Igrxhu6Y4WtNdv80wEn2P6uTphJfV3F5qbH3KgiO5BB2aji4di7S15SSUFoW0dfzOhQWJHcMZkNEYAn4ukV96Zetz2mqc7l62b7RrqO79HYZqdNYsHBf+TMSY7W94cRrMHQ2VuvQxXpQS23m4UpmdRuyRbEljxF/dZvLjYvZc+pHjQaZnpXOtNpeoh8ba4fQAf5Y9LpGBDIAfJczBrZiI8CYVsk5bazSSuGV0NNY7z906W3zL99Ptb8Jc2zm/70w8LhlsJHIY+j6pQ6plTZ8pwR5VcUvg48RXLBccUqA/IGREpAb41nyMyYXXMlfX4kH0Q9Olst1WYx4TTR1yR/duIM08U1iiQZ9W8/rqPAjtqHBPW3Wr9q6D1bQzC+Z33O5VYw5XGrtwPUQ+mU5Fbbe1+rObp21BDAXs+PLnRpa6rKvae2tHA+AeMifHbMPmSmZheYAQjKPRHWNH+1yeR/Op9xn4xjV5S/zUQMAvlh0soROoEQG+z+14YN75gTUtMa8McYwa8aX7eGp17648mrmFxuzN9Ltrnycnz/bpT94vh51l6p5q4+jbFY5jBNtrLWRLHOG50qCzbnOggBnno0sTDUYyLJk/dlRq789iJg+8Q6D2JEU12sCztlDhbPlwUzROiCGWHWhaEv75S+enGLcB3HqyFjBE4vPLm1L069wA4pH28KRlQoTBjel/lqwDsrmvpoOTlXu9GhrsIFau/ozSY5wzAeuqhG+jS4ZpJljxdX9mt7FzaNvrbvpmnstDaHX6vxZnAkAnlgUoicaMinAd/k2Y3JgHCvKiV/aaKNwyTL465CXMJNpb+U84+oXPd/uLPXHpc35Lvl4IYk3HcE47SiNVm6aplNI9FruR8lpECEr5xTG7TZOtoh8qCrk1nIc8a6WBswZHGA6Ik5Qmh1oIcAZSx/EKNXqG0q/ba/Vg63+UO5wluVOcRy5ANytV89j2tf0HHt8G3f04JZ57lLCVF/c90vOxZmPEM1Cbx0kP9/00k/AReuhX7oguwoVOqWQb+6tj/wE0mVLCz7kmBaMsQtWR4h7ksyAWyVmZ6zlWcm4AP8CHkg0rqUWMmjAe3czIQkaAQSqrYq+ZuWYcWBmfHnArB0dFAZps3h056X95UPj1NSv5IWhNtnImLMYFv0ONb9os7mFjUR1p7oipqn0T692WElidwp0htNH9qRQ7wRXya1vNiSR6LpH+J2CPzBWmSFJRi2Ds+npIKDy6q/n6/FKTk8+17ZQstsI0zg21tepU8K5rnxKI3pEWAyR81vDYriUFQYd3luMnXLsiSfcMtKpdWuDTY4yxgufEUKU211TP/3mrquMNlmsBIn2HfSVCjPyFqvMvNucbyYA/lcsyUe7MAiQEN1bsgpmUwOYpGnSRqG1Jpli698L/7+Pr7zQNEd9PtyUzY/p5+aPzT3vzoV15VInmqFXwpS2NSM3DoDkgGMr/xoREgPCXPrhhWSF1cc28aTS9Xy8TVcvTaqErK7rY2DTGxcuuC4LSw/cDjg8R0ojEUalEa9hkTfR0RKIdOHC2iBEgBMFk7SJ5R5eixBHeZWIxRCSJdZ4w44zv/1QwzEQPG5lDO8hJKGJOBoNeGvNjA+rWmVxfte3Q/b2SjAYDop/lbrx0rrost8PT2dnUwAAQKYDAAAAAADZXVE7EAAAAN9PuZ4d09HW1dLT3s3N1iw2NTg49fH2KSssKioyMzny9vS+V3S6hkUA8F5hdQMRCaAqXG1UTmnNDDY6w/xqfuiq65/OH4zqWM1U/ZjtLb+vWfkyrC1yBkJ6RxWLvOsJjILxtb+EFkuJhDqhFj/kjddQxYvT1ShOX1KT7QP9czLwExzDpqks9d8NHHjY/ZYhGYWwIHkhkNbIa0+3axhZHdab7GuxobzpGlCb616TlzH7tQsSH6N0i8Ps67+RI6FX0piTChQJwifHP/LU5lthvEU63MgXTVgBpZse0oLMJXsrmsdzqPVzAU0fqKnB0nZJXdRsigcA3lf0sYbGoAHvvSEgF2oPSNs0tk552ilmXEXPFoqcZtOYmk7ih+/M1JfxPAVjeAhTs+vEhoo9PQbz+VZ3sZf8qHO6L4O6XLZqDNGRfVDCMlsUjYLJactyXO5lhptof1V0U0TLnmU03Nn5ESW2ZeK0vUoUagagwPVrLWsR/3JyhEMdrjjp7eHIhyu6sFSzctz+eIZCW9a9vQ+idOzmQbcsGP0tyR0LXkSE+D0wHqucxqtvAJCMl0s7lCzpDWYpPmxhvUTp8/qu5LucdbO7fpsh/AOeV9SuhUmMIgHvnUnYTCyBCWNVTKOwjlSKMSgwa06OH8cmiVNr3JnCw1+ccTc7nS85NFuuxaG4eYiYCSF1ZJ4czl6YpmhdVriXe1hROLWzUgJL5Rd0evwTvJf7D/PL+cxqWFQhQubVMgw3p0XZ1bDm2Gf2CSClfwbmB+mNfDhqHnq5vsVRv9Ha7EZeLPMlbdfFWTJ7uL72QcsOiwx6LuEo8xpXmb2dbZtt0iOLwTo3W3WM0VoxpDNhrz1y2wxNGZhXZpM9Xx9YsgKSlhIl+1QCW0iH7hQAXkgsZQyNQAHuLaXpAEyqkmpiZE1axuflFRtj5sG70w9e3nxxMrQMei1xyAxJ6xu6njcT/s3TgkNPnqYBo85Ha4VKfzJPG3LXwhBVYaNN02FGGiiUUz27FhHzyCi/inDpYhvUPlpGWw672n9CK23TNGQfBH+DxdGDEdXINOwoCKa0nu/lqDuBm7KIKBGnKj0RcGjuAsGt1ojd5y2awpaGdWtt/I5p4MuvUmvHb398OeNe1tm4V4zUFZCHTopTdtl0vfmlTdJGu27zCTJUdZ3yFkmDhAkAPlgssYTDAPBuQ5nQAGmlVYnQVgjN+PpOcv02/fLAp5a9uZue+f6u9Dk7rJu8MiS2pvGqXauLImaDJNGRYaPrJYu2Tz9ILJEWRD9HluFCWxbiXA4jpB45k8GMzuIR13GWPb3SQu6SGFn2Q+lIJD7ENF1IJZ2uu0a9qDrcVBKpERGuPGtddaeuZw/TVank3V7f8wytLNREMrNTWQJGX6ZWxdyy6xLRsSI5jm+sDa26Dfu86TK/zYHRW6CjYlYoTUGnKKWV8GnkFZzFjUAkUc3Uf9IBvlicaypppAHwrsEDEK5JpZGdNVpRrGYPHvz+w2nQoNTtap8/ddPvY9PrtH7gyM4PtWoUzRPTaOz7s+IFX60aN62ZifiI5R8FTQ2/iRxJdK43pMqxxxt5kDpob2fABpfOJ40Zbi9Zcn8MnXtgUs/SjiIPugzEf7SIaHWvzLKeLddzJDUN4QcmbU4iv+O+WUGhtR6SyD2IykpW00qkzqd2QPrDLGCL6bSaEnq+UylKOkJIfqKgbIbVep3A3hx1FrDkD8RZIYXyCrrrMg9Sn/Esf7htAP5InHqCFg9WgO8qs0F0QFVVJVqTShhFrz+/c+3TZJ6fPd81M75/YJW7OFri/ik5k7Je5WsN8Qo63KgfooZzOcqYRM8KzyVrlFVXNQQrRHZ81CaGahfVLw/J/f1WpMp5UTmdsGeFIM7QKmSewKNrZMsktyEt099Tnwt9oaCG+tR69VKNQx27WvS8lmAv5fXgwfUIHitq+myU5rEirTEHN4530OBGIU9dxwHdTz1shIPVc1H3TsU8xGKlEev93FgbeFs9jmgwj29ktA+LkWLW2VJ8xuSGx+Hb4j2E5kJQAN5XTCWGEgC4b4q1EgiAsVrnJ8ZzQimGyBGObz4fqclCo3FOEzucoasPnw3j4Y1c3Mv1W/5PIEsR1aMSDTQxbUtQULY9VyUd2ZLR4ZzG5B7qI4fGTvVLsA5p14yU69tdVujl2qRVI/2uYbtQNAWaiN1qyMn/W6n8OZA8cCG6jjpWWSqkiDf0s6iH3Rf24IimYJy2pDE7FDAV3klB5UAeAjXg4qM5vC3bPY0Klk1Y094UAN7mTZ7h8xN1YRBWE+y9nLUnQgC2I0uppFODBADeV3QphcWgBez3JmhYwpo9oKsuGUNCMyvLmP76kvZy9i7f8DJe33zIJHZLyGfjCZm9MW5uWuek+MlCI0y5uPiicXl7zn9AJQ6CCUOUTLdu1Xk4sMOf7M9t4xrhFWL9+m7lWnuyJ4P1AP0K5ae0Qm0KapyTpR8s04Dce8nLYFkeHUeZrgrQBLtKGuww+juVQVutxWlW1bSNiBwrx/fEAKhzXiXGKayRwSFHejCb9tOmyUudG4c4XHOVJKrBvJrxWVPJdqpPmrwMLQqKBggANlfUvoTGoADvTXxeqI8nbd3bR9IkxrSq8iqkWAiKlYP6Ve/OY1Te07+JNlwOPT08++ZrI7nKsL/48tGDf4OeA0pObV6HJcn75+RIfyvpujag/0eAS7N2LFVq8HDWSiKob1TmIkh36gHxGqnNED90Xo8kdTL3PJlW6zlrPuKhMz2HtHmOEeJ8DCm59Ngq+MyDUtXyemGNLA5vqwmVCTjMFKtN8Z2CwAQYSbDUbV0x7ZRkhD1Q3dO6Y/yOHTPNgZ9tPIwpIAEfXEa+spmHM4FGL6+SmHkpJtT9gAKVEIed/tJAOjfNxlMuzCR09HgKaDqDB0lXNdA452t3qNYfcHIgv70AvA1Ldnj2fGOr5Dy+qIFKYTJvnq3XufZf5YOS0yI4usN/Jlhndw0aYDqNPuWiYpT4HmMvqLUKrDVfFROVpiOmP6gDV9ESjZkd2I/8ObHUMJ7qB6PefoFErbOvZpj1PyODM2vniyMMlQh9tw3cMXeLwW3zHyMl5WqlXCMWiXU0sdbm1iN6iCabnHFR/HFhxkOPl/vR0u9A2ymj867pmf0+sXxBABwuS4HnCTnVlR3N6aUGD3pFsbzD2CP+vrwvObNk9ez1dJzlikVaUcalsrcJDL9X3eMl7oyZiwQAGtccToghQrX88tDpYwxnDfcHAEgLgC5nQBcYwAIEg9WRGuGchBCE4+wR3VpyXNTp610Rb7jExlFrYfHxOAUIQLtw6cqt4zNCy5x0QyzW3T8ekxEcFN/N/M48X2T5JLP7ycH3FS2yzronXnTH/c95PnoPWOgSMNQecxFMF94vSqR4hKN4dXbaeAKY2vZ9OGj2QdmFZ2uhRU0DLy6uRgJ97c4hOh4sCMMUbvyk9nRmUDZ79lMlNSPwlMEz0EMEhHB6MgE2d42a5caWYeJmdrTPaqaALPyOvqp2EABAH/sSvWouf4tdA7jqBSv7XsINsvnwBfrtmgIex7R4GpWh1YeudGKploPw/QAAgGl1WSgBcKEdYLwaSPaCiBwOPoBhilIzQBc9vLC3HGzZYd444OaRyItLAg71ACDVRE3mtpU3WC3np6cDNocOqTD5PdlhKuoKUOd7/MxTMXO4V0UZTl80+NqzOzqzQ3kPbm7b1kmjHeEH4tVMGPO3q6JTe8oAjNvRcdp/oS7zEABwQhMu6+fZ4o5t5drJ5zmS6cnvfzMjkNVVsViQwaSWbUxt/mciA4Crdhgos8FVI3wIljewoSoLffTkKAyDm+kbSgXKbcxGdsuM8wJR3Hz29gUUDjngGcDPxpBnDQAbFrfM8+X0KlMVrc6vpRr2DwBAA0omwLYTyBJIm3uCDCgM8ElP5iJJBta4jqJBvcFjT7Z+91wP43ZtNnF5evX/nHbAmTJSBv18voYEkZMF7jqZyCjrikBYENj0d+bCaeV4yJpKXG5v6SUr3f/b+3rbcKOyRs6R08874rr6IlK8JgKpkKJcazl7Mo+Es3zk653wrqK8EkBI9TuAZxb6IEXb4PUQJ8FxkHITTLO/pW+hLELqJ/z9nKDWIGP78m8p4IwNPp12Td5rtcHMuZOR/MuFE0cAcPXZh9dSmhzKqxpZAq39OeqxApnLzFl3jl3eoQouy2aVQkcAFBaLuXERt2mgYr0/ASngMFYwoQntWs5J/PpuBNUSWziN0gp4XUn6jwEkGguV4di0HEUEVaO1DiCiDD7m5Excn1bQaJZvE8DPkU/hb0/CMWqqfYMJ7A2Luae+i1iBkz/VmT8JoNdB/0ZUEwsaJZklJ/elfkIVZ1vDn8a9AK/tqQA0Gr3KWFuUDv46qW9buNRBbqPvpOJPE8yNzodRi2i0UjxMDayGHHmmCww8Fj1VWVu8GUUCjdzPlwAhHYxMhXGmxHRR6tby3CguwWnY1QxDd8mMpSZEJsUIpLd0N6jqW/lnAJfJt7ty4krmzMzGXBnnvxn8CnuHpDs+qbhNIPv6InV70nIWHSwiiwQPkSjKqU7Vt8plA5iZN7MyZfhflG62ybf9Zt2CRfczAfoy0/TechOMBM5+I27HB9w5rxKPVnwDaf5BhVDHzeXswAAobAdmkjJGtbHAadOspM5qM6rVa5H4ZM9OHusbO/jemR9FiqQdALrnHALm0tNO97vPxxL2n0j2um3YyffOujv3quflGQ+/fgfQsgAAXkNJwzqrSAI/QLnSvs9MQejL7Wq6229cO+HIn6jTRxKpq9WlS2ebstnVhS9mJpUFHCQUrbn79wCN0z7z+b976Zv++fXafAN3ddfT5K71yXVDKZPxYPk4vPxFWGQFX0xzEL+i1celEwzmU7KgKUydBebjIjHXHhggCjRhQtUo5RnPVkyFsOZG0/qaEQ3wJVbDdYBa9eGC1YSfgdvbLADn5ubCwxCnQKe1cktw6aE/IAA3qmXF9/Es1JEYPABsm9rxEy3Acdvodt0OeG8AvsfkSdmblxJ7FQ/DqPcHAHACG+wALgB8B20WANabAYJBawKthBwUYAYOlACr5f7bzHTvF/T7bnlaxeYfYxtJ4EmQBpjWn6wCLLGUlJHeAa6ErYgqpwQ56HY2mQCwyBBxuf7FoQ9Pcgd387w3j5EfqvSF0o9LS8uWOE7EqI6sGWVmQCXYvC5HorJoAF/DERUc97k/GZPW4kLCi90LzaFtGfsstQIGUuS7hIEEhLDRexQWYDjLzklvyXeQvbZGOu9XJdJMEM0i08wc2U23Kja5sOPaduJj3JS7Ni5OIANn4D188Yc3Cp82AMApycPWWnXB3wVY+gAAVsdUVLertnl1+khfQBnI9b2Zns+pj8zjtfD9AcEc6mBVXRYAtK8zggHSCkqDiMzAVi7ZirHjncnfVh7ve7B64NCs4dRU2MujBuMPzQcbd6DX+vznSCJQWB3E2JhlymTXw4OqIr67+vHp7uBZ+A09tWv96tBbSZUki+wS54LBPkk/5eiRX7ECQS8X2ZH/gOuYSTK8ITaUWQwwbGC+9W1ghrXr7D1PRzrhvmcrWSoBgC/qyMqIxHOtnZcRZJJBVEaglUVSIOv7SxIqu66hlcrGaPt7BNbsh9g40iMpQWhh/9afSK1CGmrQ8HzpX7vAbhHcDWYBAE9nZ1MAAIDdAwAAAAAA2V1ROxEAAAAfHug/OisuKissKTIyNjTz6/spLi0nJzU0NPYtKSgsLjU2MTU3My4pMjY0LSw2NDMqLDI2OfX69isrKSsqNzIsJj3O0JPfcGTwWGv+DlicS3iKcElkj1WiTIPNWeIVMXa62Cf7om0cqloA5Bl3NeZoPE6De9JoB0APJmF7BbQ6wv7/d6cyTqZEFuRHFYcnk1ZPyDrKxZK7APwhS5wdwleOzLxc/ibAjGgwtcVMUJJYiS2BRwvjcmbQ2abWwYjsWriYABwmC51EybYrcHLnzecoQRwTHWyWqFNLDgRNiI6xbTbgr4tvBL3DlYkQQQDkIUuTMXZpylM+17Ev5krQ6KjoN3lLHUxfh/RQrNmwI/MxZwO4Oqd7DtmEDQQmy5qnmeLt4K1z3XkCvQCRmuQSSQy6SnscrCp8A9F4b24JzHrryZ8VHCa9w7iMe1iyU6VdfQOLng3w1ySa1bQdU8PhqObONIsgu99ok2+rW7Cck55v1z030APkMXf7g7GbKW7x8Z4XUAXxo+n5NKce3760E9fyKYUM7B3+TKBNBP1WEuOuLgoJoF9PGhQ2S7SESMN1C0q3/XIIiy7tGkx2/mI1lCou65RFNPG2shrIbdPubG4L3/SsIMvd2fRnYlekAwQmC4V6YKnVI2x/uyqzBHOSljHPTHqTsmO+Zot307JcX9zoYd/VXxo+0lKKJygCs9sfAQX6pswGuKZhjV+fjE6RN7nvo3NoPcrQy/xj4ACAaQZQgxogDZYceTlXSjNF7OKON3QnzzfPbWw0aO4vPfDaQ6nTSd1PxmQy9RUpITto2yorDQTlQPOYdJpXzT9LkyoKtEYTzoxt08l4ZZP9plZLCBJLYtRae7YF4eW2zau8WAGFJOBHu/GmyDPCbYm+VmS/HDUVyKqdSTNqre40YN2eK34e8CJzKjumrYnqTfBuWfixxJYzG74fRgBpFXUWVURpjd9qGghgL1C4psRE5sPxvg7S4JbRVQRErDWatvrgyBbs9FiQZZnlA5U8biW2AfyfhdrEnAC+V4QKjkiJlwUFgvfup4UUOvVbDZQjQAPLDQBBwQoQjJ0NwxJZspAV40zfbixle2fDkuK8vr47nX1tntx8YtO6J/u8vYuM67+HS52OenWdl6EuC6KIHMtFrQIo4nDbOL1OVF2OC1rSpr8TdDN410k/Mm258MreDQlVwpR7Di3j6wEyba6j3BgDSW0Z/izu2wPr/fiGKtm+Dwm2T1F9FgYDeLpfyXNtr5n6dQG/in5LCK6grT4r89o+DwvXakAOr8/Z04mI5u7FFKOfHLriWzJC+ERxr+osMkMK3dNeSvpPQ4VYsPnsc/v13mgAFpgkgQ5BgGJN8n1f5pc2t7mD0uu9AMBjRx0AgIIDAviKYNAIkgaG0/jaE1orerX+kzvI+c32fJ8aY/7xZjVpr83RSaKXVNpgeXhumsnDKU6pCL2WPBZUtIpSkLGtg3osD8SpUT0c/+FdFwCXsDe9/5sLhWNQ0kPu/lY1OzEnU4asfiy7x02bN/Kq9WZPohJ6/fy+lcrudoTOQIkGyq+iDFkUl6/1QtgDJ5Cg4843GXc6IBUPCrGBr6VRoYcsBB5W7uwBGE2cGhYfzS2Q2Qal5W+39pjt19R10ExQPhLZR1kB9k95cPehuUUD0CPkS45M2PZQoGfpoMQIGgA0GkUUlG9LKF7qFQs0IOBooTJidBSrddV+mqtDU1a2EfSJmq5GdFNyBiz6/IwpYaaXpcHm/QrEhaaEHnaE7SxsIEvF0N9NfKML2XQGXgc98aHU0t6lBADUBYuA8pBW+1jq9/YA4gLB2pVAl1Ysazt/f85UV2SzaXuamWrX4iQdSY9vdgFMHmkDQohbfqvpFZnACP42BdFL0GNozA5TxadOvY5TNyKL9HhhpAAsDnXGgNS5YfiKOkHwgtGN5vEeyLCgzfW1ykQE5vFnb3KQXehjNQD87TzYfrBeOSEDfWGRLvJvTTu/T5zRUb0pafQ6uZ8anyK3+YdEXK+q+IVkufVkzE4z2z4HASwii3zSQxL+QvFdflQDmdhV4yydDjOjbqrzUR4cl3iu+eeCy5G4brP1DHk6nePvMbauFwAEMgu9jQB2uA60JF8hQINxsfduO+2hRDPunRGHGxy/zj58BEaezmX0TUhqWuWqOqvip+YEstcMAc2Iab/9RmNkAn/v2luOjnr0oLXbFmA8ADCraiaBYOirTZ7zxdop9P0Nc9iN3t31Dn2lT+/FeHX/85VLq1bZFuN0plYBdeG/C/la85hUxQFKJpOHZHHff/gtU0BLqNYaRA+T6f23QV+nmb//8Jezwd7CaFxVVVQ7OR7EMeTTv13DvlYOVO+v1qpr1pWzJVnMyUEWAIrYqnwEzeeXIs797TGTBsC0VzMA1jBVJ7ZnfPgzAuinCQBNGL9YyipT7oq4JLzBagujtph2BQUfrUxtwPCFG6eG1lHwcDAZKhtS2lZhsT6a5y5ammoJUvgta/0WJygFFAIpzfj00OVhius4FQUQrqK9vOtUItp/enhLum1RBr6t/qqmYReqruBSzC4AXAZRGhi5/mjFRjYLF4Qb+JDftD2Cm4W3a2xhfCIxhZ3ModIEIxj0pgAUCn1YGYxbvOC9ol4QUZFGPYxKT52pzDnLObcI2GY1gqvTD4sTPA4BBPp0iG0rnB+PnPCJGgheYsbB3dQKaHwc+OMpMteqAAtPd9Q/iFtI78jM0QD8Db2o3T6z+p80av92gJQsF2D3fjqzYl7imH3pjSKeO5Hxz3rwxsKsqxEhV+EMHBZR1DCKbehC2ra+JqUBOjivX5reSD2M4iE2JX1+n/bwgjF9TYDZlz/kVaZUVR2zvA5m4AEU7gD02BJRQq5w+jbRgJvXjienjZ68LXWohvUz8okestEqIav/2lPtt/R26K07VjtarVZHEQEM9hDEfmtqu+CnTwPIwprqBTWNqJnkR5vI5xfGHjZ+zw+obkfvPVEjbaVhtOY3XkIGJO5QYGhGmHxZyLO/zhbSRbxwtFp6r21L3GVrKnPIxqAvv9tpu1vnsCbdmeX+/l7/M/+/LyX8/QREGy3p75y7ZPrEEjQQETZnYE9zMTjt+yrsvqojV7cpFG++RRG7c4+yKr56fn5+fn5+Hl0B7Pl0gv0mJ2TsHPtWkSku26cNyTD/g4PsFzH+Cny10Pjpoz1NWzFNGpDofR5U171YixYADPI0zuwsvA9FFKXb9QwAxIWpcWiSvSkp6ajojzJcwriSjtt1uouwUnQxxWBFFizqPIoYBBeHT9w6lQCk4MbzZpqRVEmC9y5IMCOH/bXzgrdabJ8ug2kCBPpo4tlmifXSpr6a0aAnH9yS2/yE+GRVN5ktGHk4j1/J0zJekXleW5qU0Z3o0jmdZw88+jAkniz17kK+nxLo6C5eN3L2cUnXLKNVJbd7laLtUnMFeIPtkJUhmcquvbasdOno7e3XxQUUElFge5aO4GBz/2c10CGxq1pTFXEsNxmjaepku17V3oJ139ycGsS7hoaKlnwQvILjOiYABPZQzZaS3K8JxSXXRcOjQdPYcGkSQMcboz5RF+lLsiMfbxChz0gZP1Jj9zQB3PH8tO2RVH+BjjvnGyAudA072DC9SYmNy85EWPyO+7r168MKbg4G4QRfHAAU8kRg2HDEoXFfnoBG6m68oDQcWZE7HO3ycj4u8UNSSDl54c3YSn9TYvOb4G2IG2smUtGfDgIc9hCEfa6yObw0aW17mDTg2LaHBy/vRuaza9mG2AzXHI3EA799YRXmGKxNe3819YOU5S7ZVP4Ip0/opnMzWbcDcKSL1227n/Zi1zJf30GS3X/yIG05feYpw4kgFM8pOQDFee/58TgC/PH0WBsR3NiUTyRBRAlbyGtguhR+muxpoBI5J9J68441a2Vh99a2swUADPr0RHqg+lrxtX9XQhgpBotGayGBcPTwwpT4/ZUSq+UDXUrxptAKP/0J1QEE8iihCkjCX677K4AGXP2gIFmaWWbTOmluWWLGuHQz+cirp9hW5NviRxDvbjnnViMmAPQpd2p2G5Q7gQP1dp0nAC3AtDQb9pd0sjp2q7GR41aGtclO7SZPY06Ck+/SQ0oMDMkH53/cEvQ1ryGe++dJNRJLkm2N5kXAbOEDycjDeg8ZGUSZGb43mO5rbYNpvDueILNGn4ZKjFnGKldBo5IWBZr3HIZjxtQKvrFL0Be8+O79AQAs8AuA8wF2gHAGTCTGBTVAWEgpxxSn7GzI1eEyJkGcKxJmamagVqtZMKzr+H47eUCBnoXph4w231qTas1Q12ote3bltVcs2H26f1ziKbt8f3xtfr61UALs+2Dp7j80Ot73ct/jHPndtxucQ/mPvNXnklsqAJjnZTj7Owp+KjIYaIvssWq79A6oFdLiM2slCYTl/Yo7ZwEE+cT2jaffl4HOTAHsY47ZToxNy7o9Mk7LAoAwzBw/WAIWF5Wm8tQxCSSbPZAKY9pixeO+iIk+vKM7z6gokSuIsqe1Pa1Sud7C+hIAfmi0ZIktQ/NGHzdv7z2bEM1THYIqZeckHFMA4IAHkCUA4xmkguZ0QBKmJNFWR4bPcmhegSYizaRHay6fnv5Tq1pP7h9Pa5niwnlg4blhZkQAGquB4QCQSlo4hCyFLqWKNxyyXwARyCFay8Ply11Y5cV0Gr2dgv4Tyk9klK0CgJcjkDRXz+bdTtNnYcHjz/ehGQPyRJLJcoAyqWoqhnss/CZhI3zZg29rJ+CyZH3K1Qf0Nk7Gkdq0t75apwN4ozfMxg99ROlVtPVA1uoQtFUeoXypVXM3HpR2O1+64jFmMkJtANnJJaeTkEi4lfD8eKeX1ENhYXMWS+AnADY4tFxFcz7wLpyN//sBABCgHQkCNJMsAWzeGo3knCQAawTLGk4Gma2P5L4h8t16mn94QGRbX23qcm/ppp4/sO+CuOBhTHs9u0JKFFm/txFAAb8X4bpG99MdliTRpVvyb/xn0/PUXVe+3HPblxcMnPtr1yb3q4uo2JqKUUAnUL56ABBpCw5/dd+P93Zs/AAAI88JIZ8BmNFSQD+ZZMQamncGwA24Drp1qyEbLfjVmwa4alVbd1jnKZZcCfkmUuctganWUQTIubhyEgANdLqK/OkgGHVaVi+2knNtvKKhotKceGtTTsGr9PXDcgdSS20ekdrMn6WIAQT2ygLiZuTiUTuuta3AW8HbT4yW3elKK+zBSfya6x/DTAb6e+8ELs1F6wAc8nyGGCq3ndyPbK0KTLyKR44c3E32dAyi607dWps3zZsAz7RadCRsphUADPbKzAnyNitdyYvWHuh6FVzaSEkuo3YdQ1OR6LbWNB8xxlrw3laCyXQ8+jxKTjcjJ7mQ+HkE6DTsuljRTsJKK4sL8zt4Xh3ru43IJ7dJXdyJtwIBJPaKGmH/ijo6uRZb2w8ICV6c5K3XmDF0tRq0h1P8GIe8LabPO7cmSlcSDPr8SZETpuOjhGxVFgA+FgiJLYNxtKbIr/fMOiVcvrCnqarVksY9qXf7yOjNg0wl/kbvccG9AzTqNEuUW2oQiK6hxIIZNUK8aIhzr7PQTckDGlu1xvq2OJQ/j3ZR0b5GwWw8YyLfbscBT2dnUwAAwBYEAAAAAADZXVE7EgAAACJyLtgqNzs5OPPv/SkrLSorMTc6+e75LS0oLS0tNTg3/wL79iwuLSwqLTU1N+zp9Cl36hSE5Jmu3+zWNACsxFBcsf4m5EyTw+zKz3OdvVdTlKDLj00F3xbnFS7YnCOxa2nf0Ra2FeQxrwGBFiQen+v65dYpJcn5Fk2gBaBgTg8lK1FcbLiivj87Iaofh0yfo/Oit8xxQJuYp1g1Ef/oRAAA9DmvtUF62UeOz2pfbOtUbwJmiyZRvN0nQ6It1JdpM22ylncTKXmXHMOmtsQVgXGOseIM2DPGU7AHBDp3OM/4eegdztUSaVvbvoFexWczF3z9uD+fJZsv59ntSm1zuD9pFU5Fs0naJjtNUTRecioTdQA6t9wQtnFJUlow9nI4r9/7v+UhY3bN859uQ8PXMBsBMgAD2DAZu0U5IBg3kUucZYr689ziV/Rwt2maHv6/vharMmT+0oV7X81MJkrg7JQgKq7uYhWJGgHvwHT/MhljRPfTK13DffOt3czh74PJ1y9kKcFLAE5SS3b8+2CiiwLQj9UjXM4AAOfH253VqCNIE77/H5BZqwFlop0B90Vky4HbrZ7S2V6dx9kQQRobkgQe/o7ys7+HFAw64bIHGMzB5M8jYFh/j9VqKtNmXn9f4PPCymQKEHh0BQBYyo1GI/tRmA1sYlMVMyZA+9MSWRZBkRxgnA4+SYTex0hiRz+JHLbj/S81dPNUJ6+xOhwNDBFQGbBwwq+FDkiDhFVKCIGAzgxNHU++tY30Y5BIe/7jroXQDrz6X20VhsUZlg9rWkEhJH+epUngowSQJ2uTohnNktAJF/48W9vnZTf7daFKCE0IiFKrVV147SyjAsU4lykqUryKARyAUMf6z/rt4IsZ7cog7MdR81yQhaGLAuepc23fk1OiGqhcCR3lNf2BTCJpsrsYQhEo98Cea4jnN7PK8NmX3PhlUFEpWRr9jgmEz7tqYZC7/RlZoa9K6LaKWNQrWtf5w9fuwlIpS/1eXrR9Num9ALZXzLAaKRTZT+H85Pn7AQAogCNBAVOXJYBjK8FNGml8f2QNMVEr7MwxgC5a5fgz+Lhpum7cTp+eUf9V3SzzbXSgUO394vqSMvQqfKx8ObGATNq28ftZnOEcMEWrJ7g6vLP92qG8M1NgiraWF5ZtaRlz6L/dL8pdr/0B843YVjs+VOhsmthuUUqqfwgaNywgbT7uf4SVA1kuZjJ5ltCe4hpOMJsbFwAg2eepWaI0mt6vr9aaAoICFg10C3BrNthfY2qNABttNV6zS27Mn+PDBG6ou28JvrFi74Z9bKic5iUBy3tuZ8FK70/JRVzEiawLTZA40fL7RUgEjOqxACY8Cr0O8oY9HHX56QEESd4d+ThTMtJNUEDbz1MEDc69fN+S8S1QypdLAAzySu3TkC0ZCoPrzW8ALI7dEZsYrOikD8ni1wY12i5HNBu82MkvEcK36TQM8koiwc3GRG8Nu1W8Apip4uiGchosR4wLk4ZbIkiszYZSTCLRpTjnqrywvgEs+nyOkdM0By8V274aSEQeyu6vp92QSdM2CP+DrgmN7+gaXi0PO8FpnAr89YqsYjqXnWxb2wHTSh64lLCedkUwg1jdz7rc+gmR0o3h2k602pahIp0AJPr86ELKjlPhPI8RYC03dztu2W5U7aoK505fJ+0m3ub8+yrvDgiIm+ustvw82aISEwwyS31Guo2FDO5St4Y76gQIXHF/vXFE/ylzg4dKJ2E+PJyTyCi/daOS57hb+ZSVq/Sv0uw1VgD0Pcs8nrPso6JdM7rZVmUvgUJr4oNUm85p2IRecTj/d/QyklEYfqwE2ZaHMBGKkNmK8bHMFzAo3ggAuicdAuK+7Zd1+om0lZuevL8sy/HQGA+3rQzYzwDYoECaGhCeh4IV4AA1gECSZBUMaNbz4lpjh9+fr5bBqJOaq52ccVazVMz2p2lWoTRM8vDJ00ubskXJ2bcls6q1lm2ykhpLaGshvqzZR5IaleaT3LVstUKKiKLQWrV2lvmCuT6Qm+eC0aQaOCCbrG820rRg4We+np+vthXwUUvHrLmMWayE7kp3s4QMRBhPZHh9QlYqwDMWyeAAyFpP//1zB6CCN0kWYiGgknQG4/nJiPu6vCQf8KntLFBXPgYYREkm4zVWyzXlaWJe1Ba77In+00wFBXrTP5aZNagFHijlkYupp6w8szUDDvvXgqWP/3MAADiKAlRh2NWAdAGQboCNUr7nBAOsOSef6U7pV73MaDfvWqHfAwBxnXH2o4u3KK4IOXJ4Tx2MeHGtsdp0MPVMG1FEjXKbKhyt8OWvsxfTqDQJolBCT/7In/YDhL9WbVGYKzFQFvji3zLRAMgu4qlhGP+X2pJXZY2FEZQSjZBPuP2tfvgQydxDAKhkmoZzkL/6uddnY0+BYbz+CaixUgiA++tzOxNwD8m75xc0qeP+SEElJkPXlc8/jrqdvQ0DlIi2kw6cyS3yhnICztCcq0fW3G5NVetRdhMaAJY3tVnyBPCPxzQTUTLE8QcAQN43ADgBoAbS85EAYACDJO0G3JToEjYUiPqrsPQKSp/w9eMzu5vR1DSE69NUXJd94hJ46pJUgMxRxcPWjY0Onqdd9PxZ6pV1QAhlbaB8oVH1e1DPTqLZ1ZEqX4Xsfp+9c3fr9pq1959+oaZDd37PmgVi6WN36DVJ1ZcAb5mk71Gu31Ggmx6otXPExmdR2dXFt/w+I9qI3hvkLtGXIzpcEGX6s8ZgigEwtDqwPQL1spMvTqebYeCJ9sdfCEEGDQNTXctzM4FfhHY37eHKIsmb1jqlHkP1VtAPXboRwwTzcrF7p5lw40JVA8xFd8SEVLX8AuXUGrteq1GC+5sfyMP3kri01jBtdIdtgzY8bJmYeGSFo/eCBOQ9d7qEXET6oUNX//VNVQIeBjZSLtF9P4QPRsMdbX1nWC6P9ARR9k/a5vs0ABQyS12QT6r3ki7VV7mhF/z3aUrOpRt4rzgnqZ3llIn4wHL6y4fAmgkkNkvig0zF3kc32W3f5QWQ0kPyfKAjOnJI5CtDVRHkKsbNjreJqBq/BrJbQwG8OXeFBExZvmgFxluv2AcIELRk8xvXimTEJeQZtWjy+l5J8C0wkNZfTJQU1AUENgtrUGRqrhAd3o5mH7KgJkjYmnhgX9vQWj8N0Spw+ZtpJ/fJNaqXSKi4cALkQUt4YvIy3t/OyQ52q+gDTVIFJn7HJf5AmjGwMZN13D1cBCcL3u3BJjVhAwXbye/or7TYHAQyd+oDTC06kmpo6vQND1pwQfHdg1vTl82jzb6d51ofeua44ZHQ8Kl6zTOJKT1tUxIFHdB/wrkOBD53aMa2WDHRnnmft4poLEELPkhi64sZGa4YssN8tGHy7VT1RM5cHm44K8uFq3AJq3wCoRdrABooVSTqV2aNa/jp+AvU9n2+vwAAAABLaBhuBPh9GxMcoAWAMNfmSEVRH9sgOjSd1wasfQKA9tirt7YazopJV9fJ+e2/V7LZ1loTkCDxtBp8LAlBY0R8WqO6CkVZfqWkyfh3uSQXsispAQDnovAlxypG6PK76ugdcfdXC9/3b3N/RVdPFULw9jMwqraPFXcAdq8EDZ3CBaTBVfFbYjXNNVaqVompCAjmxsvlQ9XB5xLmgKAcL9CSO5+nK1kHjFzgQDDcmN8fX4kCkgwG/4NqBRBetGktSiZBkLDPeivITVBTgQYACZW1CH818Gls48m+0PauuTYXYG3kyq4KoASg66sAnjgFzLe5htlvP8m2XW4C718AAACA+2QE1JgOYF8HuhVWRbsBbYtEFKwURUgAuTthPi0AzJ2FWaLr+h5WeYmo0BK7PBT6nHJE3g0gEumAsPr9zLKywF4ErZCF/XG/mIxPbA+tXFQKMzpIY7cfP810obpX69ljpr/gmoiNdKZa7AP3TVitsGPSTyYcwc8EBhxa+/hH4axKGP7j7eUh6cj2CgOe0ueP62xhrG0Yg7IPc32EnMDa75pXX3sSwPBzOyAhDRzHqQmg6oRsf50UAEMbvQO7T1DcVg8e75YwRYVXlNF57dinafOo7Q4IWpHWxcUt+xREC9W+aj6yTQC2RyWhO0c+XtyFJyIfX+W4zuPZ5Dgq/8Ma+v8fABwEUIUdgLkEAAdMAJO4AbfaEk2jPAoYblujdbycNL8/1hbKDy0BueMeTxctK0feWr98T/sC/N8eRauWPC+qD0yFIFJpnOC8bVRRdIEKZrM2urQitYCkSmeZCBRhZBKbndKKiaNAck43IKrD0otueZbya9PTGuaWoPvw180EwKB+ktmv2gJ48KIQkVMiC3epAxGu4gO/x2IwhRVgZcAeUQzq16lEjkzIaHKsEUZhr4FVNo4fzgKDeYARr1XPWmOGAIoRliy+/Lhw0paopczKF/z8vrQ2F2Q9swHsOcvnxHjBQYfv0j9tDWIHAavdXyX6Ua2+I1o7waZapp4rI2TDSvwv2HZvAQw+y1fP6kvNd1qbzqp0gEfsIaGv6Ynj2DGtm510F5PDNk0pI1VQMUI7QhSDlC8cPouT52fK6aa1yF9lBxCU4bNZ8j0VDZQ1obUKOmopkLO8KoB0YgZMaFAPoQoMPv0mmKwPryKjWuD3mQQ8BPn/Q0L9TSc7G0UXge4jDCM+A36vQC1cMfNcAww2/S4hLsyHDt+ib2UNvQo2bo7nxPctGP8aNuY0JgKZlo8EGQZ6pyYsKew9S3MiJmF/iiCsW62FqiJxZfBni81YrC1ViRzkzONdRQvTJyGMcW+WeK0fHexFPTwxOsmNDsnBfhX5YH2hNQHO7v1zaTkjJzt/ZLchusplLwdy4U/FRI+c0rtl/W9eQUcP/C2vUgEZSujPLfgvn7wN2SGiGO7lyDgZLVz8UNlhv+jJr3M7gU/tjkVy4+B8gZbm8h7MtwLsMa+FHuloWaTEeeNm/8lxLLJ3OIXRO3C4NTcRc1qz0zyXCnlbZ/OlsqHoS47noNrZ271LuDYAegcNAHQDHB7dw7T6chLo+s0v1Yeu123E8I/BXAM3GFBgAJgH3gJasALIOqDyrCieOoN5dn4t9ue39+6Y1mxt6mh7aJPCVkevm1mllBjDwd/pQDUh1sG3khKfno7pDy4CUK2JFNXkwyYhxsmYjBxy+1cNbSvKhdeuXMqWUU2o6hoeZN6fArkaH1bGRGPKBe7XxZUbYEuSbfvG4J9+pRsxADojCbw1TMleU2ns+Bvh2C5TMgMAQBqmplBTp7tp3VT83NtZR46ggUJhjPv88AFAstvpk5ZuyXTAfQUFtO+1off01pBlSlZQuIgAPACeuKRSZjRLYqbOnsP+GtCBSQxw/SfYl8CRAAk7EvgOANDMw4ZMgloySLFgitmFv4b9dU1nxyK2kwMRVnw3ahZRjlaqN+niPJ3XVxrsp6hIwdKaRusdUaPJ2LXpqspRHyF6GbCbZYbrFUBL5iCQgRKHE/Hl6+zw0KbuJOQGBJ9/RsbStd2YfgED8aBg2Wb/XJF7AfQapUPqkwS4BnWQEEJnz/3r6BNyLCTuGGsXwVqdgJDNaU75g1hxWHIqW/rUdzvbZuQ+tINyUT7aSX+GjBhrfR6ULcCLa3pb4A0BL4wYK8rgN4f7fE5oAE9nZ1MAAABTBAAAAAAA2V1ROxMAAADIoKWuL/MsLCsqKiwqMTo2+fP6LSgsKiwrMTc38OrvLCstKisoKjM29+roKSwrLC0rKDE3VqckVdNHW5oo6HyQrut3TH+0ldceR95bwHEXAEfRgYAsFQkg0WwgGAAWAJwq4SuKmKNb9mxNk/OpuS84yH/SYnLMe7rN0RAyXhNLUBbj7JoHhmmBSQiuQgy2V6tXlRZBHV6HbiXGLWaqg0hJFk++SHu+jB5He8i1TKEJXRiKNlyjiMS7t44uX2z+5zsFC0jOqE4n5rDD+/cBn33Mq1Pd5IR9azm3q5NqELliZAAStWIKI+GSS0GzubXlzqhKELpamwQ2snFs2X+3PCLkAJ5KXDa7lZbaavlifcRFlCMcF8hGJIs7bo/0fAh0TxFqxFSodSYN9CF3JM/rVM21tZqZ0c6ggSC4LO6GJUlYfvfSNupVGx8RcSXFXXE+A5e+DAD8HUui57LKY0cH6cq8woCmV8Hu0JkoyldwKpVQGj3rBZ31/ZwBLXP3wR2dAgwai6NndBbnl8y9GBak4aGgr/Q01OD5gFIILlWA0gL+UUsq4Gd2ElYZrA4EIkuiJ5zaZao3re0rCExgaIMtLnoKPhxUQUv+xFbKyKyDPPlzDVS6WwQUIguy53Eb7Pno8Bayem/oDJw/s5ceFlWME6yzfCq2XC2X36bIs5Ah6g4EHotDUFRCTuhStVYKknhgeCfvimbZ05FEZ9WRjFZCkvLdH9SgBqBr4qqgAfwhS6MnJisnHn2ZPusEU4IPG59akp3RtrHhwjr/LZU+8u2sCNRgjfrZAPQhiyjPUEXGh4JLU7NPQJRGTY8oayQp/Kc1S1Vt1Ds/NUyLfk1H11r7v1uSRSytsgHkHa9DPQmXlHvYza0JSjSmVgc0CsxZmpzH8TGzyN6ZimGcz8RxtI5xvn4wLBku8vS8NpDKh+y76+AGBDp3gSCc8ZkypU1V7uMW0DuK1aFmT2S/wM9p090umUF94/6QU+6KTPOgCebVciMVZ2CmnD0AugdVEK7XNyXEaubelyepJu4fAAAGMFTCEiADMA+wgDZZATJgKSrI5bSi0MdeG514HgKoOlepNNsvuOUQIJo7+y3ZiFMIE2d3J6ono1ZoP681qtGagEbVSdrWPBI9xrh34M+c7JiMNJxr8yuJAk5Ey8toxkaY828BDfdc6rz8X96+YmFlp5MeXvZyLWNCmPlVnFUE4lKBduyFtYUtkaupyQQ2QedjNclVfVw8Nut4zoa2nEI+OHo8MQDAafkqtxlTd2eQMQ4PQY9nSq0kAwDajP5MVX4Gyhi00TJD/TRocLi0NnHKXmbgpdGAhZpvS/iPZ0p4QQ32yRkA3qh0ktUhOTEqOq9j4f0CAAAA7EgAPACOBBMmK8AcLMwRIFrJrHSIIgOQrN8W2AvMENbz1JkQK4gmidKnJOCsaYvUwYNaX6H5OhpNAYX2iiVEKrBqsyzBMx2c6ipbUoyH55uAS2TcOH7x589nw2xurS+yiqoro9gbFUf5zVHjsFGs56oEITypXliQUsqqdP3YCoB6fMhD958rXJTJv3CNcXNoyz83bQ3XbDrK/rhSJVmvl9cAAo0vIw4YLE1lc+7xx+2hHLGP++SCfeeSUVGmmA6pOsEd+vkh7jrtgA49aynnr5DqdpN42xJITHRItxr23Q4A9qdkQA6Zq7R2BD4YQXS/aVHe6UAZdfyRKkFVYIAjAAYh83DMAWwg8DuTAVCsNaPwvx/F1ZVufGswtjcyNR+Gxd1iX0JEGS92S6UbGKt7HXYSDbLqIj4mzp+mOoIEIVx4XkWLVZm/n2pvokCo6Nl9sczthCIE8WHuhfWypDFClGdeq2w21vBLrxQdfx1rZ0LFew1x5HJkoL4jOKQHN0YJwZuiu4Tp+xQ6u1kZMxQ4tjE1L7Yn2idqcHVIAwngCI8L+9A9c+2g3Y+LRSgDRLkU7bWGw/V1Wq2yZ6+nngYGHLbFDSPk62MJscQTltchsB3r13FgIZSzWWIKACwSC5JthRjX8+t7s1pBBmIu77C1y8QyeO7EA/LqpJOECuZUIZSKUkrqvHX5ABwOi7OhLpQM9aNtHyCixHQxVsOze44XN2XA82YQRireFXj/CvKCMwAcGosbww1yDMfeAZqOIEY5kFB399Hb2Sd7nSg7kb2Q6yxeS6bBf+tiFkzTAOQRy1wAdbVOqRKPC8gg9mvXxYBKg5mModLRPpPMTJoeCiAF52IjbnN2ABQKfcFDs/B4TkHfbDs0B8P11H+5CTdh+Y69lxHXVT3ITxwgCD3a/WQg+SwNLBJ12S5cIhOWU8xAvI5A1Jw+ccbg8tw64p3afv2f9v7k5QTpvaQaYd0eAfQR/UIAQIb9V3PByiLzMT3JyvhILvrznBfUToc9EO9TkuK7lqZ1gFPv+oi4IQBwhAJELgspkOSkTqBytVYP6PEgHmBXJxa/RyLTNmbn1SdHPbS3U8uMZiKo0XbXI7MHmhl/CwITZywALDaLKM/G4tr8HlBHr8ksLnw1wNXP5geGZk7HnQy1bj2wFnUmX88G2WqbGLvCswbWOnjCF/byAHrHzPGw257ufvVYOg+cqFSixP99V5+L2N05mI6eu1AD7IsZMCMsPYAhuwRJYI0cfSslwUyxsfjSuDdee2/1AfMYJvXBrBz/KtjKBdrq/qGT4YB/lBgjMe/3FqVUFtnu08L9w04/CwBEjwcPxq8ztrZV88T8RhI1ysKf1RaWAsC4NB1jz0yYK/lONTHgchynmdqre3Udz7zM/fy8ARQ0bfHrxb9blMrgSzBD3h8CZQo3VZzYJJjBb7WIoJ3epxMRQFmrLrETPlzjleNOa9ELvirqBPPl1hnyHnGUh8ME4Ewo/ML6WA9UweF6RnhKSvzFA964ZEiPKVLLl6xzMtL7HQChY4hJwCsSrB0FJFiw01ADSA4A2qQjhScRIJniSvA4tPT6KDQWx4ufX05L7E3emFgOehuh10zCSi7+RsGkSbVlwoAA69Mg1u9356X3tkrG5dJvS4bNERSgu3uUi/XTlyJQjXWt9jaZac4+LlbcUJN7XEp76k4z4/yVjJDRALBX//VXp4K/fw3yHh+rNmbC9ZvLreGUDZx1cgkOFh0qBWLUJgb2hQVx326LOQXO3R5Ts4bh17H3Na6jxq9IkVQgTQZY5Pl9rcwDUs1eNcXrO/aw4oMKNvOJ7BIKAHa3tC3f1VW5qoiTUd87L6dFXAPRl7kfCjgCBFiRAZAGVjscAFiYpmUiaUihFBqi6nOFJwsb2s7fV7OhJ7m8kXt+fUIbPDIdQzZtC569rmaRLHEP4XoOpaZSoZbsrwn+w8vXaFVuYgQFoa9OPRpn4XnaKXEmUIifz39wjR1FZXTqz94tfXA1WaeGEIyYea+UT6DkSze5RnYR3kvNJEePz89mjATyzd4dt85V9GXpTrNRKXvLjCeAvjwMOnl+2fheoSRCw+0D6m42VUu1zReqsqiiBMyeCvNj8e7J0qaAms/J7iXi5HrlesXk1cJ4oQAAFCaLmy2neJtFX7i6fv2RwKrgn9dCdMkWa8cB0n3QI8SbPdMMqin3k2VkSwEUEkujRnaXo0hQVVzDBWC6Rv7qLZz0ZjVIuPg27Q3fFSMF1YkQYxxNP1AALBaLmyFLv7HPGZ63VhdASMWf965nJ9KnpaRrXN4tiRI9YZiYoR2c1jvILzQA9AVLjR1jsh25U8qvUweAFBRP+kpn/XE5WaRtY4GvQDGpBFcEVKnNlxYaNBL91Yj0DoHLMuMhQKrYYA410ibm+rr1sxM89WVMmpC9R9PrhwmZuLTSEkwmPUM7xjEZmQpBfZ8ARsKtqUEWrbzRkM/CItNrzejzL9ESreA+WQAsCvUGlPBZ5RTJ569AkIqF5z6esW5P0JrT+q7xnUGGdqSyrbhyou6R/AP8CYv0noqRKgb19P36ATxRrQ3rYXE/OrXj1I5TL/ikmXgS3nb3EwtCa6fTuX77dH5ljQ38NXdQtjJYRv/XUOdeFQtqzOponD2S8x0pLyckJyqPhhstrvmYzsZfUtGaODdGTmlYxYBQPwCa58wi2LXS6F4+Xp2HEmdW/+/8icj52l5b8fLrbwiA/RoHmMBakDT8Ni4MhAaAa4w2RIZSolAM06js6YHh8kbbVuFV1/miYcV/W4kMpa92ra0gibWxWrcA+v7Y5gJwjXEynbyyJUtr7dLZpWN9aF7/enaMALGArRp8z+xbLuh5MM1uVy7PYVIZoOftYcgoUzKyb8ZxGOn+qhgSXv1ubE169CDp219RSYkOnvHsD1FSXX71BFRBcHxhzAXD8cXVLxEUj6kqmOFBXF5JiQ9iiGV8GLiSwO3SM5OSyW/JBQRLYfT4+IsrgsrLuFHK8+4X96SwMPfepykBHsgkOZfuZcaXqPPAq0jvDwAACaMs1ADwJvgZGO9DBsqS1Fk2kgcAwcACQHTWDoob5l5kvxNu+4X/bGOzCsBEQ6HEKngVqZVMb2x62zO+TPlX1dEqEcbzFl///hg2n1nmJroYDigKuUmrF5KlNV1lO8lryZz9tbSNULFxh6MA1DYgQNiDejI7iYHesRqipCBAG3fh8OkoeZKLvDCp98JUwsioOWJAo/YSRibI2SQzre4nwTmtDa0HPDjWwA27GoJcS0D7LXYK4yKPeerG3CVlfObZmhIMWB40AYCBczsUELHyR5HWmvf7MgIANse0LD1ErPGIIs4Web84TQhxQc/HcwewONRBFyQ9AOYLMmCoFD2iHxDMFNsdzeS3/VG4N03uWstq/tDUVCKDwIyPf8LUAzYfUtyRKfBx+MW8vQlvKRHDOjd6Tb5ISSiXaQ/Dz+8yMn+d3x9fQf7Tfkk6PHvSMYrlYFzN1dIbE2TRm1qdFoKpvq33wa3h75NADoSYH0MSBok7tz8+TeNF//Bgi2J6mtsK7K1vCjsHrZtgKVrsgzu27Nqmrrym3T3NDxdpRSw0yh0XH67I0DYwD6cBStguXsRYvZFfjqU69FhBXsOezIdNACwi/cl4jP920VeOvg8SB4Oe5yR58iTZTND636S8QZQyjhhc40gfnS0LTBZ1SXuFa5joOCrj2hewEA8k3L3E1NgRuS7EFDbevPy7Q0JD8Fmljq1xMQRcGvWZPCbdTZm5Iq7jFUAPEnzQsNNMSTrewrqqXYddTqIY0dmTqZeL81ISPCK9ye4YvzRHRQR1xpUvABgDmpvWA1gy28aalPsg/l/ox7eTkj3TPeJKLAP0EUuDsbbMmFOMsnM4m7ESuIomOd29BTnq0q8+ov5TkuixkhasRer7KM2jzAY0Hj3R2MeUo4igEPIp6gThKpg/cEslyVr46QsOOm1TBSqvhJ6OXYlDu7AAHBb9wdatt0x8Bx+3BCEl6NGaKE4C/oCHKlRD6scLSDsy2GBY2NWyDzQSxSLjO/qz4H19FU45n9693vlRm6b+skV7x60dJ6nr87y11potaPjHrbb/BFPb3SosPgtKPQ17ax7EFau2rxayODnyQExMktbvfUTbX/u23nKV4b/7VYk3XMw+YU46EOuZL0kN/RgAT2dnUwAAgIwEAAAAAADZXVE7FAAAAN6F81Y06vPyKyspKSkqKzU66PcqLCkpLSs0MzMrKysrKSs0NDno8esrKywsKissMTbyLSkqKiw3MZrntLhsHWr9fHz6JWorSVbf90vfV8zzEIlwTa8OHFUAFCtM1AA+ECZKZbWCKd4WkuHe98W1vPuH/sfCusaY/Lxylii50JoJSdX96cP/tWqtHPdUYye1QgJVK+NpBIgxJu8/+D53JdtaQ/FkjHH/cEzuHuebADkhI/J3b//1uPjCP1SnzRSdKI0SagDS1Kq2NRp63hSOHZ+ccl+vPx7/Wugn2bx0nAVDJQGVmMKvhZGnBOZrxHQSwxNlAU4VhvnmoYcajnFnhjNqr6r8WA91q41gWnVwz2MX4Pra9dCvV4SiwzxfF4C/XNs+AJ7oNByoKtvt8kACofsLAAAAsKMGFgB9hgWsDhlojQy0PVkAvATAIzZJZAYAgPFaJicA6NliJEeQqiJygpl6RvINACGrEyUF8CKR7zsxU0VVE5XW8m7Vx56frn20Rh+pN/ky36emiSIBPcxhI43dVHForvxz0QfOTErTeUXP8gYDGrzX/P8ybcUJ0raSkLaj8+3tYjSufDtg8LRn/PSmQmQXGBuR9aT+d0XaBIxgqBMYDQi4gP2pADdm6qrjqo+2oQg0kdzOzrklyY+bX3eTHbzOLcs07aAkyJuihH161owkDVDmRzgX1La7QejkbZFssE2mALbXhDxcmU7n98WKVIXWd+eYRpzPdvWRx/AF2JGgAXCMWWEQ4QEMHTIwCqxLEk8z8HM0Lyi0sYKHh9lLzclPv/bdA4MHJxLDcKB0aJj9IN0uZQzuhoPWHyUlbK203nqjWIjgVO/jl88SYeLE1sX7Klt/Vlfn93NF662YHv4zalpujz2KfQtJnU1Rg44fqqR3misEzkTq7O0nVd8NtEwAGM/C/HH7Io6SQn8TYZDzFdUVMqvXgMzF4MNpxxm4XArzmQGILGL02VvsmHUfcNCTBi5NfU7+7tPCGP1+DPVKk9G4AFXhtkEUFyDEm/jShE7fztkmNDr1xBP7fM1noDnv0w3QgIThQ45oBmEQWQJ37OyMygQJmK7GvMBLsmpNARwefcxT3rLlbs5VstlmIw6KpO2gq4zOPtPcwes0SlI4PULwKRe1q3kJpQPsNf10Ah6x/g9F7JdbgogK6sWEnQadWAedLW+GoMEufSvPzisJlxqwbBwq/dieoQ+E1tbjpUFKEG+mnZRUw8oloGYVML2E+aqaFnWgTJPgXh4AFCL9zBO7lA9W4zxAHDTD2vevVVBZo8YKfiO1vxV9upa1XGB5+1CHnAQEPjWQeDxLxZ/Urt2XJUYFP+880xTMp0/3pIdkq7qc22gZKmU0lXqH2QAUHgtM0NyS5nqOHlbNsiQeioTF9otkQ6dcQ3T9bnFCVXUAHLMnY75WJUxs3CkLvInnkfA7xTK397GAzOTF9VpOUHnB3r8IAjrepxNratf+s/+N5ffzjpG49v/ysZVGLwAERst7PKM4cZCuK554rdUOJhpsTk7nuz6/y2yW1ZbFHy9tWvfQ85ecf6EJ933TUt10XjjdFnBV2Q4CmvfM4GCkvs7nhwVt24DV97vvcV0dGTUdbRI+XgIAjhEAmgUsT2oAEmFsdFZSMMX55pzmf4Y8t94MLgrYdPHKYL6colNBYBMdMqKiyZlxPbMhJa3N05QIru4H15YeFaS1+U3ycfLAdDIqrhFp7eyfK6/N+TCtkZ5hJuF8iy38NfI+dmfabOHVF+vcKoSTrGkrTledjuf6oR3z8n5lufQ4lrWOzcPjAHBs7vHbc5nIrJ6JwB9UZgHhfnYrAdRlaooJAA+25f3Kw+UyvA9RkPbwKtpN0DY7nL5lwJ4wQHWYOs5FAdh3l3cnAJb3BBw6N3rN36tfsi6JgTT6+vw71UTUdTif9QkAzIBV7QV4AphmwEqTwToglW9CimRg9S2t79M1reHudzjZuYyl5fb8dBgWvefyi1aUOxdDtVdpbuPiK8NAAADSP//NaVjrqEWznUaYmv347+dQuSGN/QuDNw2y2xTX3TXvcHrwVJvpNMAEQC1kqxlJksR2r8kKGcplY2QRIwW36a4JI4Z5WiRHL37Va0JLPm2jIdnOGhQUEFAAOH1FAkDe8bLW70G/LsphdJstDX76+Q1g/lFHu3QgrUiYsyxRjaJj+9ECKuC1GHvavDheNnZOIVpwEYCrJV0zwQQMJjU0Mfb+4oWepV5K2Ijk6t2jmrJYzRPjtkBRcyXchW9iXPtWu+EE5wYkKr0yQd7nd7tmuRCKvlBBRAW/tx0ME5epjHhWzppTRhgXKbrqnndfzg/WATRC9TbA4PIpxUpIfl8SuIT15/9bx5NPczvS4vi7Gulut5Mfj6oFVhEM/CF9NojnEcEUGqavLgmSfHxSfRc5ZT9RfYNXwl9zJzOtjb78QiiHGgAUOr0yuG5h/V8SFxqi9RU6Ijh4Puh6cIMD2IuelxG1Pm6MwzPNfkFoaXL2SgEcPgW0YwP9Z1Ae7Xen2ALoNMZkWhmzhfGRn/Qq73+/PdnM9Rak/kOQ1UoeFB4FJBG7sL5A+f9eb76DY2f/P6jT9HualClrrQYum8023brihskVyJjASqr4NqmpvXpBAhRGRZUYj6j8H8uib1gSD8VpfTygj6a/UyO5Ff+z3FQOX0q+OVzo/o5bfedCmBWemsnWACw6NRxE61NtoF1sra3ERIOZ3Mj/Rdun55dNmsNmNx9i2F97vJKv/PB0TcItsxEQ2J/0AQwq/cBz3fdneMxvNQvXiIMp+Xd1RE7FfDjVBlJG7dQofXqyLoL8EpaJQwDkQQVPvzKgntWz3HrXFypdRPDn/taYiPK9rYDXvSRqLWC8VXPHJvAuTycF7C0L0IS+68x8ZGzde3UDiGjkZxoUy6C+GdyiKStxBuyTOtPIgRDFxGqjAQQ6C1lQ7HL03WIx074vCVJjxgNzjDPIptoaX61y69SMpYJt8qVG8jJx1yUkQkUSzC6Z/rBbeS3oiGgw8Llhs5A32IrKTpbiETU6DjOJAXNwMmK1AxQqPczz/CytF7Tf66tL4mFq8OpjcvNCW0fMVtLsLAqZisM6i9hwGLxjOQH8RTWWC/vUM/g592zvxdYgo4yN/iUrEoLbV+7itq273FQ4NSXNX29UKj2WK0XOiK9ncCAA7D0LdySS25EnMBQYY/+pAnjC3VRzDskw2fb/884WQf7/LT/8/yFu/pMoW8Pdg7sFuk21ABRCSws82zavryBySrFTrzMOMNFAhEaxt7Yj0tjvY5Nl8ZuYXMd8tfy6iyv4rpKpTkwBd6OvPe3yBxo4JUTWDhDT+K0PE1x1JJHuvvk77rplDywOz70JAMcIAM0KHZUBq49kVRxioqW4WdtgW/PuXi/ya7Xon6buR+1vo59Klaa92VRRFc2J3t26qUkBbmZLmuBIUS8+JZMAtDY/f6EOJ2MEdY8xJif3Z/83/ywrBcslWkb95ffHpybljzFD+d3yFf6OBTm2luODRvvkOrZnzQDYqqoAUx0KXy5D5HKT9/zsXvE/clappOaKAIOoxOd+ePQJESSX713MorCPU1LwQM2ZQjl+FKMLJkPJKjuyCvxYCAO7RNKj/9COLxpsTP6moQGeKPUC9Ewez1+LHu1ihWm32vA28PdLCwDYUQEA8FyssFXkM8A0sN4liCI/GsHArEu2X97a+6+9mnn6kOjrcfxY48fDkIBwWSLjtG5LdbUT0WpMqgOYMKBQxJXjV0kbKHjy0udB80MQ3ZkxDpHlyot5STNKU20pfy4PK/9MvRN1YIdt+v3F97JmFyn6wt9W67g8OUf9IbdVLvTa3IiAdiiKZLTYlHWnxhEGBmuEz8tt7F6YA7Cap+4MShGG5O4/bICVOfJ6I4LBOXa2V6HHuvSmvUBgMIYHbSgNz8gPNvavUn7UbqZTfWKLYItVl7eHYwIAtifFAG+DPue1eCBVSfZXnt/ytFHUdQhRBQBgRwMAsAUrLGIcwMKQgQbPeR5JUmD4rCeep7cm05PhnaVJc6r3BQD+BL+4daPncmUqSEDgKCpv4fc3OVoRBCSE7FfWvijdWCdGsxlyybI/M0k1R9bE2f+zdz/1SIvDpmoXVtdK2fp0Wp9GIZSWbsuyG0D1i5VgjLnAf2xTFQOFIJ08YedeOQKEdYaIMvbfEtTvczSplyOFxWnAUSTxiSMZqHlQ0IrPA5EVVM9znR8GJysgx+sBZhQjUfWBZvKXmDMxQgH/vBqlNZO5fV5pStCaDSRC9YgHj367yU29uy0I17g2dGiXFMVcMa3XR6K/WtVJFXNePUTcS2zwBQAUPr0gmLEvTLHwfy+OBHHQVdD42EvrBJyhYlFW1kOntmdlbq14W/Tlcq0I5En9aK6I5z0rsXx/31ghDmjw6vffYFGdFsIgbTs7qGE1TwV/Ge3E7mofqwDkOQtxQvPoa5jijLH6+mwKjIGngnXSZuwIiqLxj87S9+/+ImXGhelCmsoABwxCfSyguzS9KYTH1lbhBCKCWtM4u7fQXMeS1wl59JCx0isz10DeZXGJDvRJfSSXPPozkux72vt0B6BTwfr+i+pA9pK6sGh5Sh3wE3C9c4eUpvYMlQAMOmnSI1DGnsBJnC49ZQRo0AUjv49BkdK9axqamOb/NH2DGbnYDDuXdZh2BywykbLgskNdH17b81qQyeUffJvF1ug1u3twF+A4dXbXT5YpqbdZaEIen+eHgJSUGAwkRv2FQcPeFUckxUPbWpZ0NOjJtW1CLy6SEicJXcvkgI7raY/9In74qSI6I99OnRUvLeC87wLSJ+Vh0Eed7t9+9yGKZlUx3X2/8EYfn8s60X09+0wAADOADTYH4wxsk2AAUTZhmSmMOk2vPRfc3av4ttxPJWE8J97blblKV7QijiG4TyhRmDyYOmAIuPskyZ/V//Or1spxoPHs2gO5WQra2mp+/te2lMdNm2QynaR1na0WWS5DYyDPGIAGSdNeRSyuesWUBDrWacADpZhWW5jVGMoqmPHMDtYPI22auwIwHQeu6680vLAslJhAljsDAkzwnjRAleCYamYcTK4bIAjhz7Qu4c+2YA0KQHMTQz9S+soYXW2kEDAHFqhiQbG2Y1QnwAh/3doIAPwlC3Cwecop9xPqyFVGDSYa0KjtzouKReg2OcQuIq3n4Duh+96CrFZDN5hBByw+RZBw7v35Hmu7VF8ahEs4eO9vMxWbptoQgAVvm7OV2rTPsN5hSMcfLDI1EMyzSFxsj41+SUqYefiVPuKTVCbJjpvesArwrwrU/xX7Vn91mVsKBC49aIBH5Df0fNNsW5UGJMy9O6dOcB7U1yrfKdf3t9MVOfSnU/cJxGwBzEXLscRM8fPvT8MSulvlFgAiBpayRxOn0HQ7l2XxBouvwLYOzQEHUUaQP8UULjWWUO4ivw80sN065QygQXPMpKBfFkXaHwba2qj9RDCHp1W7bRgv1Zq79euznpIisWcvvTgAPC4VnRh7r3mNP/ZtS5+O3T+W1YnE3/aBa0FESoylqP3KdVgHu08+nn2avaC5U3uGAE9nZ1MAAMDLBAAAAAAA2V1ROxUAAADa5VBnHPArNDXw/P8F9ikoKyk0NDTl9f8D8fD/BPfu9OjyBzUqeI/y2q8uLAg/bVVh+Mrb7LlMd3d3t/Bc3QA4GgA2sMJyTHqS8KMg75pGGwrMdJZrxcOfyU7S19fRvK29j3bt282y3U7iUpQju3yIyfRaqtXiqsWu89iK6sv5j8m1iTso2jVtJpWgYsMnk6B39tLnWlZLsBTGpCdoPo0Je4JMaW3y29EwYPSm5+2a00qWCabJhD0utCwvwrz8e123TOKAGhpgN8dTMVSgaOTrsVPCpKp62MGZq+UqCQrg3d/QgDkfmiHSBvcISm74DGo1RT+4TnDqSjNL+wVmeiYbBdcodWrgm/q945IWKXexlAnEScuZxOQYmv/CZSZUgAZFAnfaWJOhqDXZSIWndo5IKRlX25nC5HQTIaEAPCqtvgcjdHYtZ0rTdbLQHQ2KY8PDQzIUWYLLOq7OcyyZbcKLTais1nWn3dYXvDVZtJ+JDjwyARVUH13Bl4HWxda2JR3xUJzH80VzlZOrYRDGZGOFvrJMS1wum0m/Vy9HvbeaNK85KkYAOhiVPBxS1/Oj9ymI5iRO1u/T8NRdvsx1CrbwNAA4CgBWtQfAUAALgAxABrdG50yeDQPH7E794bYl9zXm7/fkZ+hxSnM1mNuf7c+lUim7d+0B71uHikRUfOwJyGWb0Noqa1yPCoBKpJopykEQWClIXBoukk1ir21SxBp78p9NS76NpBQ4q8GHz49fy9NlGePe7TPH5ktbQRNL9ypkKJsWC4UdxCewjrbOF51UsCIEQJrhhSb7Ow1cwuV0PFFIjkdsgg8sKvcZobI7GZPQkOLZANellrH6McAqa9VJ3zlF8oUbGWICwiA3C6/Gze+cjCgN3igtglXr1/3q9ULlasCS0v3zIjcTXC8AADsKAABV2APgtQYOAGAGv8KA7RoCXtISiQxs9u5jm1tWWwQk6MD3nViTAgD0Jf4kTYJEpMS9usCJRwpIRafMUSAWFqBl74cglSUgwcNkojS+J6cIIlpkxxawx8NqvfJRvbVqH+7aai7WWlTD2d9PH8ZKshernKSGE3osEApLtAYiN82VK8+IYEDzDT66+KHhz1TtZ3jLNH4ZJ+UDALQ0vCNVRoemdTnC0Drcs0pCNgLt0VEhf4uhgUYD4qypQFIgnPkHJMLigbvDsiYt981CCmq/ubuXUmGia36lCYPRbYMVktgAvihNUpTJV/vIeknbWCKNfwEAAAB2XQIAuKbsBex3BNgAMmCXBvSGDWADmqYRWgEBAFTcXAMA+JrTfwOGOM0hwCXiio4RQL26PiYAAIJkGRMrtBUobRpOmwSiXvTKkHbwNjrptGfDuHmbg0gxns4uf9i2Z+h8c4fgnHpaACC4ijaA6rdaMTjx5rFxs3bofrpG6Lbx4DzPHzqS+SoiYLAMbgx4B8EJ7AiRHbIO2nlEEuNjBqqeKrmuKe9BIU8BoL8A5CJG/uGJq4isDCP6qdp/A3GcN3i5GoiX57fj6gPwDUljU4VOnheamcryJnJ4wQP89aPleQJRDu3O74mXuFcL52sAGgnWN9VQv694xq/sdyk2ieMVxHwxUjX2GaKEPa+vEwDYEQAAumSFBdFlwIgZL9F5gc0EWDCQRdSB5xttCBYctf6jdjkwaa4X6/V6WAyBGuJWo6U/aVRvjVIpCfpFxAFRjIt/Ed8BYPn66SrGQlhwGmR3t7aOOZeoHXN4c+i1JxYX944yx3GNWimgPnntheblLaVoGlTa/hd33QES0x7yx+TtG39skIdc/8+cGaoyuzvnhMkNCOCnRwUAAIBjaKd2NTBMgrxkKHiyF3dKrXnv/632wYzSUQKwxIxNI1IAFOAevh0X83Jx9v371b/Kbyp0aVKg1O8AJgAcNgWVSDd/Pz9u1fdJHDQJ19Pc0WmDDy49lDlRKNNNI4JjWlyWQ2ELFgxKdSoxffQTuoFt3xQEGbj047NkIa/CpOyVpjSqv9NJl4LutfqrUwL0NQtMgr5l8pWiEqZn52QGLjjQ0GHicLWy3aqKnZFusiOW3szqluUqF70B/EFFnIiHv1/MY3vpBCJKsBi9EU4gr7YphyUe4goF85Oc46/TivOKNgYkTtGUyB/Z9M+n5x70V+UOgCmTlzihqQHzqzRtyIBObIRtb0+pVKx26wrmmIWaUf/TI7EEVCZBss+Dj/WgrMoI0NFgOrYWvcWkGtqkeS1oipkZW9nmhzk2ro6XJG8qpLUxL1GaRLbtA0RGI+kgYpHeeZbLrfJaaGjAudHwbnlMcrwbYNmZk7ygq92vuOfryr5ariDklWn1lumhywAaGDVIJ9PwXPkFgr3/n/+gFNfb+hgMqAoAcA8ABi1gEF14CdBYYRXJFK3RDKNtzGmJ1x4aBvtN59kPAOiuyckW7bFcFulj0qOwhkly0v/LBAAm01+fbclmgkB7097mZ7krgPLINlqV2Y5MplV2LnacYMtVj3p9ObkmWQ2+z60RW6MaNJ7Piu3dAU3MlS3CZhEKyR/KK1WBjNh8nI2tq0phEGB2FNWaIMD9tJPWMdBAeQpYMofOJV9tZ0j7YBIzss57v4E79v9heh9l35ALoeJVn1QGWw4Q9h5GeEluerXeeuoM7AQdPiiNOJbGj+eLi9qBgG8q6QU85/77RyUA7A4AANdbHkAWAMAMBBnQOEeAS+i6riMVBYofa5Y5v9o4eON4KbH0uU8cxxBCICkwp4s58Y/2ZqNQFiVL3LuFhlIQeXNNCQDAKvutZyiVsIi6qGMXfYe691AhSDLgV6tXTVht4EqNM++u2DRH8A2DMF5vQMOlVcWLmfbTtw5PRgKwGdSAon/n8QV8ktTT1hGeNwh9/OOfAhAAfEcnvDEkAvIZCL4IDMC7AXjQY/B3QaYAJN8l7wKA7CTi8/coaSgsYaZGamMjoUMlLSP3+kvJAsE2smpjYqD0eVZZvAb+F43Ul5kf969kRTEJ9hdqrAb1pAAA/fIAAIC9AH8DOACQhI+Q4BIOJQCwAJrABqA0AysFl3ag9yH55pSiRLPZ5eABAKGJv5gdDJBepQCACgAAh1H/JOI4lipd9pgw0upXSj3Y1KV8BMWzVRrmKe7aa/QrNMcFkqMMn14St4j4JBEEKL7DhjggwSkou4bOUA4ADAGq3hpePE2rKqrRN0Qoz0HPeECBCNgCVtEXIs8YDjBQoK0mCKq5IrjCACTu0snfF2XQtZuu4gT9QstQGwfOvvnUq3bfXXhCiM0TsSiREgRAm7dTOgwBXJVkgDMjjq1dzLlDglTgqNRs8e4UAxcqsQG+F3VkbCXTvqKLCgH7C4udgT4DALA7AAA8Y/YA+JrABjrBAEcADIcNIBDohEcpgs2utv/o+Y6rsgo0t6ZPNwCg/TT7dE4dERXUA1auApUHlMUWBQAAdPzEBiUFnIaqLgI8ps0ekHLFy5tMjitlAHDRXjgdBQDKS8tTMzZlu6BIQYnfnrquVQSwP/1Ea9BjI4xlwmar2eZ1/0tsEKTM/W8j1289OPuHFlUAu95S2FepSPAdoCYWwL8agA8ow/2tkegmAU4hbhrAEIhyHjRkLhKgJ1/eyCKgzgHstgHTsuvEr9E1Zh9ooh7bejlob7CSmwcA/ueMZKrCy+xZqT4qTPtXQi1h7wIA7JgAALY6ewHqSmADnfQ8ASRsAAugaDplGNi1gtadk/P/phkPkE/v6REAIPwQZtmIlkv0iXpIvXWkAwnYo3kGAADpMOYwlrGgIKJIFnp6S2Mq1GgpltkAAF10+em/fqgZ4eQRoHTLw2gBBUVNAIVvoFUf6kZIAtIEckTgARlJPvWsCsyq1M7+G2RQBRD1dEStKvs3eNzPoow2MOWUn69JnwsAHN5mITXJICp0AbltVdNuyBbw6W+AxjaqMp37bSdAsjEftC9eoa0NOJk2oSyEvKWo3bbsr+8NgCwAvtf0OLapyngED2DYX6m2jggwV8MAoB8A0JOyF+BjAA50QHIAAOcBHhwEAALdAkAbStHPfavduefoRXMnkexLgayRAJAQ1FgZWhAPzioHACyAq+evCMkFRG1xCX3tEmVD8kfKXbUJxnJHtcqKaJTWevtVi3Qvf6cSzcheeqkhhXofO/LuCd3xitUV9u9+aS7RQ45eOGM9ZqYaoVxwQBT7ggsAVF+lBTQHgSioTO1MgTSS4AdwEu1r16YyNao5po1ZNcBJ5T3EhXA58Z3CFcAZlByaP4yVETxeFVC4IlsMkkQIpPgy+zABfDIJ2ssSV2axEAXtKkx+Kaa1pOedGW333kMHAP7HbNCXibCvzmMopxZMXydYAder//6HAGAHAAAfyx4An2vgQAcEBwAT51OCBxtAkzZKMKARmOR89p4/kydHE5Qto+kfU0lBAWsJGiwXQ7xt6+sGEt7cLRDXaQ0AJe+/sBIAIFeCMyAgoAKelSb47evmbIuUuucQd8ylSvOpaDk1+jsJMs6L5wkFYc8mqFm0Jnywo9QoVIB179J8fAyjdE06IMD3eCocBFLkCD6ZwwL2HV/wF9mWACwGBv5zU3IioWoUj+65BpyfIOAzXFwyMknAcnRUUAXyG6Dv/wEjcsRFBiFpUc3xDAghlKiwSqO6QubqLJbHxAYeyEyyRJLaJ4B5fxwJNXBMDABACAsAsAfAqQLoAkcCPmCDRJM2WjCgeY5i+nfLQ2tzShI8OpdJAQAA0BUsAMC6ZyaKss7LjiQG0NUIQElRrW5Sb0VHuyQVQWHedoh3QFTzj/NgwFiKSFphpKkF89+Ad+MUZdCR79uWZRQGGFjDgyTwg7yo3QZ1gP3ZWgAMC0yej8BuSWqh6IYHYC7xt2gASPQSHTh/b6QAOICT/JuQqkJSaB/NHi7fixqglRETT3w9yg0gDWqOfyqkTCQrz5j2TmjB+KoAEZA9BywK1nBTsdGbZqU9PVCxROd2lw8A/qesyA+haV/Bg2qiaX+9NLWAHQEAZAEAdsxegO8ANoDuHAEEbACen9dKAf+bK8uztj8tyB/F4TQRx2sCAEBQEUwDIDg2ZQEAAMrmWA7lUOmKZOsU+IeLw2yMgj+xFWWQSEAZVaDO1muySg27FlHR4eY53iQ2PL1DF8mFkHYQooK/lV/bXYc+h8oC4GajZr5XS4Gk9JmXf0i0KFiBae27UTudj1AGPmIwg8EsQqG+SFKEvHCjrT1FcH7+Lsdu4d12pt7kqOwRgplUSWnb92k8ZujN6Oe3fcBK3bww+M+vW0oZ5zTeH0aw7Ha5Uclu28wyFkHSAd6n9KB2LzUe9FQT7W8OAgPoqd+/BABkAQCeEXsAfE1gInUOQEA3D5DktWMKYTQT08tYwUXGJMKV42ixeTHWulCDTkhANaCyA0ADkVp57QkoAEhYYxZgCaVEzkHHc3UAQYJ2lgy5EJg45QFEAOB7Qc6ffw5U+ji98eBLM0B20pUSBrbim8rqinSEAZNfKVFfR9U9dEFgrwOAfI9lFjIZVv2zfjU3GzC0PE7nKwBQfGEVuIY8d6JLf6wYx1F+SIVtOEtFpBpGIXg9y9tRoHq49OzogQjttEwkhKV37NKlF2KzvpiNbUMpwAZPZ2dTAABAFwUAAAAAANldUTsWAAAApAHm9xnq4tzl4ejd1trV0ycqJyYyNjLc1tXU0djl/pdswjUmzH5lK7D3nyQE0JUAADsKAABV2AsQJXBgApL0AAAWkGCplFlRBK8/QdRUeNzYaGBS7f/EmpwAEKRzOWmChCYycVlWIDSRBBR5hxxLQCEBrImQHECsUKwlJjpuk0tlTYHgFBlQPoX4bcvEmWuqoywlwM1AF9ZRUdVC8YkMhFaKoPxioGshgjcglUKfbUMFUcXeMwPIix24jnd74f6TA7hSjIF7GzVoPSJHa44O44U86yWLMx+e0BeBLUzxkDJsb2D6WB02EpHFncQC5Wbs5/a46+tXc62RLad+l82sz2bKAMwtpgQePnhswhWEGVioEOz9+SMtQeD5AADY0QAAXMseAB8JdE1ncjqknaK4fZ6eXGFqV3PERyhzI/79AAAcM3woEaL2haZMSahISm+lla8m8AAkAboz2UR6Qm33xFxjpGUQqRDwWrkiNPWGNnJL0w2EPepFwNrsQLqIM+a5BqJ434npelNhPzSPp3V8DLuEgcdtyr92ABBVzPGTSbQJMJp47QuERKLMT+b8xjRgdViRDyufcUHS5gA9ap/OrSsMrioL7di3hw109RDW1yVh4DZ7so3zd/W1zCkxib6VEotiRvdPWE0kAH54nKRpCDFxgfTuv3NDmgGTEgCQJQB0yZ4AtwBWMPGmDTurBDPOf/KpGBjdZSIo1WfekPMhAwAA6RKZgFIni2MWgKUgkCaDEk4C09LB0WrzdtorhpBUN51KhVjZEYw10ndVxl+ky8voMfMFAUxfdyIdEbvjZgaIxKrePqBcQRyDXkIe9BZEtz6VSDA3pvTvq7uDCBvBi97owbHDDsDxeMihgYU7OTAgvvGuDOMmlJw/8TICV5vEs5bGZTiWmhUlnMgoQ8iKwWXL/2qnx2L1YwlGwR44a3ay5sObSAC+iNy1LkWZs2YLUgv296kEAfTh48sHAPQDAHbMngBZABNvAwgpTwunKD4PGqdXotcbOZ+EyajzXuTECL2koSRpDltDPCCO+oq1lgDdfxYAAFgy9tJ6K1qkvr0T8zqumFGAhwq9Xjqn1hNbFNmG6Lhuc2gfHaid3kutBNyk7YnqiBfSHfX0TN9cB9d1cmKtU3Bz0xXZh7wOdMIW+xqgMKl8RWs3RRixa62+5bDMJdH8QVMaz3JhEUycBN/9LTcZxb58q8y5WC30svYv2IaCPjd5G0p47gOWKhesPdaqU6jJeCmVLE0NHlhM0rXazb0kNaiWCO7+8xKEAAMAwAxYVb8CPAGkSSOzM8JoCsNKtiG5uW/+iWa1itlHO14LAEKLkvMsFHCd5kCtBMa/niBRhGa7vNYa/EhajdLP8poUnghLW9JROaijH10Lf6bn+rr3OIzgVaa1IxHdWWxkBLWTv2sUyTSsFYRK2xPXknd3/zeErfdxKvli2rxF00ynyHT6DRbm6+o2k1EKOTaxsKGfjY0TLPsDtqy+m3INYs24cTTCegLviMDoXfghtF0T5SYiwUI1a/9W1Xl3UFprR+NwQZsc2HBwvpkNXlicqS7U2RB1lJMFbz8hNWALAIAsAIAK9gR4EpjELpRPLAtmRD+fMgLObFMm06Az9eu4y+kkAIClLkAXHhCnoh0kBRxQPDM7EhJIZ1/97j4E7LLdo4CMruvE8oHjc35UaAMt5Lzo6vhp3LJRDrj4Zx1nQQmI1V8xSvLK0gSJ/BKWxwVB9NgrC5w7TyROPZBeiz8is2bONPWi1G41s2jcFFfZh5JSAfSeYGrA/vjfSG/jwtCSTj7+AYOPiaoa96htGWuvpGN2/p6zaj2+OLab1Qq1N4uulqqxMbw2q280IvsornZVM3cCAF5IrNGXUrDnSjdoRdrdVdMQks3+vg8ABmDQChMVs0NC9pRRFDL7tWB76N//860eHje+bAm9r7Hy4UhkxawoZsbxIFK9mvQo/uxfCdUpBBlQRGhEJSXz4Cszz6zpzF+YnAbiBk4plIK3I4bAhcR/XuFL2ca/6bqE26OENSPGcS4GeIpwakt208ubjLf1a1Kr9CG/PMuSvGNwpfHWPbUDwwv/LjDBN8KzkUi+lji6BeRYCehQ01JH1tttwtNAVtoZwNgOc+f6bJtBIwvHJ0LY1B536U20JrRoJbEfC9IE3kd0JjUarKxVB6L7fdZoC5qXs0UCIAPQhnUlwsksFMNwNPHf9cv7q3YsNcWBaf46YwvMjLmWetn1HBdILuqKNDzOLd271MvnvZiAFV6fr79/2YAB4C4089Zq6aJ5dSQZbOAywd0blhTHzSkn9tbYPZHtVv8HgABeV3o0rT++xDSjNf9A0lZU/Z5fKMB2SHT8ajvMtj9vczUS3VJizYi0tHp+0WwQrKDe0ClNX89eKYxwqDRXM/EdVzLNbcxFP/PU9re9bpp2tR2JSnR9EZTsXXtjuJJAB75YnFILkAHA2w2RMpk+3gEA4TEfw31GC60s4+PnzEP5Hp9dWg0cCm093WrThhiRZHNcaTzhSujX/QeVWTTH9GibrufFiJJngjxozzRmp4titK0RmAd1qRUKhlxzkMVeGMdd0XUrBvWSmGz9aRMSA7a8H2O1RefUK7vWtZz8GERbNTIioIkFtqqIMLS2NoORFazuXGmvakWWquWsUCEEs9qv67Dl8yFKW3oEV8S5sufitQRksQ9WWcMP0kLPuULIOtqtILkE2DiktrM3WPJw5yKNleBCma3S1GgAXlhMsaZKWCOFZO4u6nSaPgGAVKpLKirnnNYU9p+PrR9YJxO3rmcrX39gcLqZP2hT0cq2jzcUQwadrb2KI1vAI5Nvb52s9IhD3d+mhc86FhszT6e3jo7X6O5KIlU/7krbH35JHRmy7CF7RooDYQWdUYisB3TAn5gdLNJZpYHdMnw3jOvwuEtx2NMZCiFQXXD+mAyxFILVgkkudNXPwEXOOALl31F836OOFkIQr7cef6Ih//YIdYNoZCbcUgzht0PkclytM1mAtJDXgNznQwWZcSHdVp8AFldkrhQCMa4OVHO/17zFZZi3BzaDCQCgTOoqidopwxQmp0l2LTMw4KYyEX7/c6nvWRq9les4Fl5GSPxR28v86Qh4WmlIwuuPVDyDwxS5TwIKGQ3T+quIaUnGV+57m19JMr0M8QBJu3rJW8B1F5yccVgtsB7Mort98Kr47Y76QWprw1vkwrKf0dzLxtzZhaUOSALz7hZvEPPMzqzsDgXytdkMwsbnGIUmUX6yQ8oxmUUyKIjca0MoP2Ztm0U7Oaewvt3afeWb7kpru2v7W+VjpZtbAqz5RGOgipY5ku7XHMBIFmk/R0qNrdA0K0GXhHOLiiG3jtilMJKkS7T5aGfnyqtzBG6zmoI4IPna/3lZSbJSGvaq/XUpzu7S1S2bjHQPMO0hAnz1CpONbjXnZKZaB3AJy7UtL1oNbvOiDfjOcd/7CcHKZU1JUowoB3T19NwTMDNDYP8YgE5SWzsrR2ClF6V+TWaB17B7Si0mFC9ejuIAxPlg0hAGBLb09wkLlMWGV03McWru3VkhllGeV2uB5NU7maifNPMev76JwY335zD37wAMCpWURwgkNmkHKBd7EqiZpFjfo1C2BKfNgtWDNr1sm2NJSjr0aZTXrnfK8z3JBWnq39qSjgUEBplREJyJP/q/m0ADUWxOGzsJJuirNMNk+zbXa9+PFwfaMhaJ9ZYl2c709mSkF/DaCXpHFKkkgxBN4H33FlEOMaZXzMQzAIC07aIZZe2U1oyflz6jmTST//TxLLOd589/H6N6glFQ2hqnBDgDhX2PmtlYJEt7bpd6vkNZBdOk2z7VKslTPUNxCNYGxEaQZOYXdxMntLKTg6qvcL0T4bKd1RgtV3N2Jj4FwF+aMjTCHGMqwtwUG+ws3otKB45kNrIVvYuYw5aZpLtQN3G3EYuh8JoG+XUKyKv4+E4/LgD3LfQvZcwWwTihinW8LVXkN0BZDC0KiNOJKKJrajaIVYJM3lQJXlQlNS6PfRMSjQBeWIyxxENACdjvK2QCBGwBAMaa6lRpWSujpEN0zF+lfUzTf+14trn72bewWWjUqyyPoXEf5iKFx1zFPzSTpsZtkhywNKxKzjmy+ypEHhWr5UB/P7OvEfpeyeOCJ1qhtEyF1jfuDhM0i8Y4p01XiHzsNqzDG+dQHXei63r8/KjjmuolHcKlNJ29J2+bIsPE1H+A1dADq8F8XSg08A6JohKfv3E5TtBvKdLbPNJSNiG4HlYRLywg9i8nP2oKRSGkR7mo+ddNeoBREL69IIsSIvNcG/NyRjsyPkiMscaVwADuDbHAVQ0DxqokjdY4oRzFYduru7OBL788N5bZuSdXrrz+Lndlcz+s6/2K0zVu6qrVqu7AEJBGkN+/gFRrHHFz6m4yHHEZy9Oh2lg7XKxCL1A2/Mb1s7RPS6OeQoi0n5Dno+FOnI45ONbaMtyDUlMKE3k93AxJVZRNYfniRZTG2AkLx0n5Z0woIsQTrZ7LziXLS0VUye7UCz3CtB2G+/kl3gW47WPzWJm5FULGHCjWkldf8WA9A6Zt4M3CEXGL6Vo47e5pTwoQ1xemKhMAflhsPcZdQcl477YxEKcJMOlVTDyhhacVhf27rbeW+rhue+m5WdMvzXfpT2PadW7NIcZxcjN7fue9cDHamI0IWVF4mixs2d6tRWSsdsnOtcZaciaXTxGWTNbMRMvCiboq9Q125JFOlJIpuhBGGeZt2FFcK4L7goD0rKtTLmhuJ927hY+lMlXNI/ZPqJQd37TtSzO4mdoKdzJVIXSeCU3hC813SSrTB03T86WUlW6QOysBSiop6IRvLRUoUL6Lh6rNKpVqVlniNtuFMEEuQVr1YyInJwO+V3S+BhgA3sn9sjIlwKjDKtXKkKwdI/f+gPXZQ09fv2xcmbN149gb6Q+K5sG1DZ+kDmN2dQWmt8FR28FHJp0HJhT32z6/H2j/y64s21FChOOv3BZYfR0bGfR2jjiHosumnYxZif4mI8x87YboC6BJDAtsSv+slbT6rW11/hHJjN6vsrE+2rf9dG/m91+YBFGyW8IeK2dlClK3lqpL4kWOp3c22714+/HUp4DGQNaPXspGt3/lkHmpW0SrjhblsxqQWMt+gPUmEiRMutZrGXYHAP5XNKUFF9CA+8qgSYLWHTBWVUVTQjnL0KOvBM2d3KZJYMx8j2PeXxweTOLAT6MlFqt2sd7CrS03PCHJ2NicP0JyVFj1HyYqNSG0Aa9LWiBwR26K9NIL4KvsEXZ6mSH6wlU5GniRNyMWe/5xWUEBSkWCUio7sJuWokMowlxPyR4zgbu5HgiCyJzBnajlMFOzZijJumRmn5Lhrnbl7faBcG6RuVEsZOjruOq2ECXFUuEVIKXbyWLB69bHqRVf7ZXpJKfuAfro5KWv9AfHqFvO2y7NIX3D0mxTA3ZWZCAGwSBinPcDAPCAaY0xregZNpZRO+4yZvSS0OIDH04HuqZMgh7RPq5dzen88ud1dzXsxP3Yrk2Td46Mdsa4Fz+t5SxSIJulATU47FWhaxoNgj5Om1/zLd9Skk7nplTD8ohgI3Oe9TYnzGrumvJOfMnviPlzpqSozyOxMn1pBXkKaBwBCSWvWyYPl5GPm/HyoG3VVHci8gqR9Z8yAg2GwpbSL+cHDc0lY65PO7U1u5qha1J/nzk6Gii/HWQL2eyB+2FVTD8jqpNcObCmlV9ooWasQ5RYU/UUjj1gD9rM1rolLgBPZ2dTAADAUwUAAAAAANldUTsXAAAAD87cRywoKTM0Ovzs7CgrKykoLDU2NfXp9ywoKSwpLTI1NOnt6CwqKyosKigyODnr4Kz1dBYcxmYJIzZT7QG4YEMht62TSk4KJ9gtCd5/2T2cDsc/R2NXmACk+TTO0AlfUcKc6dw3AVdRw7vuc452gIuH92yv8tfdjlsxVdG2KhoFE9TxvB6g2lQEHeb3AtJSKJ7q2mKdqt/KxS4XKYPP8BGbXJxZLRtWGuOOxz5zirsrdUYjNtQtX0PZF0HWtFl6bvYlQSbTDKTvrSU+lM/LkZf/dIe8HmLOh3x994qcBTV+9f0zqwySdwDUMa/TBY3Na/Pn/ItVtEYKWgAtAOxYZhvYJNkxPG/UZZ3G+9DOTIT0XLK8yXuCZb9jF6ZNGUCYJ/cDevccwKAYhRnXh4fewzMkktXuBwCgASULAOAJw+o6MAAEgySNsmkDhMiMa+awLAPQu361aX7+Qsjen56OGg++bjgH54glsFWgHk6D169t3k62CepnE5BxkqxWoiEZ/9mUnW8xxjhJxsl0n/PxvMHFa39w+T3PfmUPcNOmVR7HJ18f/z7oOFYIP64J1gQA1C/WWACD/deqNVhSyekDyk2CjPJn95Qm2efpWK1gzIrYAF9rhlwzhlFooWe3ecn4eb8fSTcBuIH9+kkztdsLOM+2gdEmkJ7jQWvbcw8IozgD7KrY4w9qfDn+fKkCIgHaOCm+gDiAYsHq3k0V6CQAfsfkeJpGmPlDn9fqYy4qKu4HACCpJpuvAIDlBg3oSQOFppGdJ0UyEGZQAi53saPms9bUm3xJRFb2B66ONCajulSr8Qm0Bj5N1+X8yb/7zUwZa0331ty6DipFrVqj95RHM5+ZSC3S9obZUh669Wk1RAhLNDWSIgB2VmukBAPQqx43FpNZJh3TsCvBXLtm/fYIKBvXpciX0biuvMpfesoS1BZROomABTD3OSpEUb13UFZ5Kg2jPTmCK0mum9CeOwK/KzNaTAuyYar0wHjF8aOnLeUAELBNptw13i8HJYAKwLaB+GqaMBYDmJbnxxP2xgQKsWzWmsuHrrIT3B8AQAYQ6FcDAC2CAcLB4Egt6XcpkQLD6rdshyXgfPjz0UNHBnab+yQ444rZtza6LuScxbWHpq3mUXppP/38PCdV9NfbJMWN4Mi9iqYGqKz2Ctcu5F4zp0mw8fmrnYdcNunn1dVe/caLEhqfA059mQWGpkmtlWoiAKZcufV+3eAUT4VvCnl9v/vUH85Ag5lUblfmf8ERAqDXGTS7q+IplRbV6abwaNufPRVMA+T73KG6WOEma8DUAHD2d0OSvrQ5ynM/uoGEAMk5BdNW0Xs/J9oAyQA0GNo/6PoAADIGACQaNeJhNhdixm8/7oANEmD/VTy0uGWL0RZYSXqUDu1eq350F3BdUxoUGr2IvRydOo/z75dHgHg6ymAtw2T4VPaBWCGYjDahPYOexnbkJ9ryNZABJBY1Zo8hslgoIespn4AMN5DZ5WeEVsYQ37rKTXqsGana+FuNooCtFehFAyQWKUTRh5daxLae/EuyqQxu+E2glF7j23fPXONbOsqisFzofP/BtUQBDBp93J7Rz2bCeuIh6YiBmy/hoQD4wj83c/mG0XM3GjiBEHZZsXKhRewdi4OHHLxNUzxHpk2zKQnX8dYr1se0kLbud4OVeV48WbPFkYQQnKpIvDA29B09yn5sPhspznPrPGuIEhYqyuhosTKwtmF5Qrb9it/WLNo58ffDt2Z7sxYBB1aFc6F2TQD8Ea+gngarC3nOhaD7QqMaNNpfmTs15atXq1TDgZnZcqhSlv53bE2fT7mFT2aaLLAhl8GG7gH0MXepQGryaJa++upLRe/QoPFj3HTYWi3PWacVPVHamJh3tinHf0n1++tHHZIUnX6LExnrAzrXzJNsFdn2EcW8uMqOcOJ/X4zL3FXWOof+9XcAox0AAPgYBF8VyIAdwaCGVEiyF0SSTBFjEh01+GCjtgf/d/5a16L/v3JpU1YfOj7Oz3uMwdwmrVpr2dZaa20+KgmplIRK13PLlY808XI6fUzGGGPMBY0lQstW60Y9uT2fbUBrqwvzz7bZHH1xb8YUXfWA/b+69IOD6KUzVU+moIqM4mN0coxlAINNXz1oDQY/OR4WtYkB83xruIi25QouFqB/dnBWFREsz6uIiX1ubkXoAKozo1y9CNI8zmtEW/EF5mCxQ7/VPQaAxoiHe955O8BeFFCAAn4BHtikwBRNtJM/dcviNB/vPwDgEhyAp9jVAQBwvbOCSwIDQDCst0rXSNggUjAAWAWwlZmwRKZ0QGMmRCnZz31feK0KnKEvY1mwsNaBIWr56u/VRTFmPaiwgkIiRsd1bfwMUyl7ETeBiCP168r+XDcz72uQOnUy8/WVqxqlL1LXXwWnaIuNpQhVkNrPSkOLOeygwA81v9tL3C1BgtaQFGGdAWC+XzkVum4z98ARPBS5dIh9Rd7y4HPrMg3Gt2H8AsnLsqvz4YhXxZ8rYMvZbHm8rHHGAMS4/zK3XloRAIHYdmVqdOAujmzHBAA218SK2GW2zseH33Uu2NOmHwAAQLsCAEoGlwCCUewYoH0xaXwbRAoG5rlAr3E3rMvhF0cGD74XvhpqRLrcPW0KQYaGoRIL3KyRpENwGY63Mq9uyX0/qp0EhIknJmL6OEL1H7Zz3/K+PldTBMJdMN8f/JudK4/e5QCnka76j/6y/uZNO7ffsyuJSyti/M/lgFqnl659wm3ZfLsoY1NNupxV/s+AYgZsTyOqrAggQwr5ET8AAI7aPD963Fb/DzsFdqSxpEljZGClwQ9Z0fqlvnV4cKx1zvlasiFUvSkv6g5G6FBYfIYBwDuu5XpsadKMLtdQBvZgMREADCa9yUPuXSKm3KkV5vkEiAMaq3yi4Ym4c8RO2pmprRqTqcYjaJukoZJNmwD0IYucJwavXNT18xtoTAT3LqYTBXvcygxwUoKckK/Buw6Ti7r/7lIBJCL1VrHIzK32vD3xJxARA+1B4TKQ4I/82/zvavycCQcRZjBi5jrP1TI0JrVsx+hrLolK4K7ZyiSY4fp/y37WuU20MX8wmp9gRt9UbZdJqD0ltOeUAPwdC4In3/xKfcqy2cr0buDggeT7hfo47CNac8Ex9anmAs4A5k9FFRUZJCJ9w2iKb9SfDNvpNquUNJgaPH9q3nQlQ+UUFOzW+mHwCbW0yrix9lCuUX4CRCZBsrc7x6486tx9SboK8f4xm9u5GgfpFDvF2cfzdQlQ4V067x4s8Z29qVjslS04PgAUKss89jtV4scWG+brC2hQikdTEdmp9Ddd2c7H+mNjwXhEWhfQ/kmLzjyxbvnI45GNWzaYAAQuSz3Bj4Hsv3mct5YAGpTi55k/sjmrxvsUH9RWu0p6fmk82WrY3E7QZnyWdaNVm1MavgYat8zbfL/YjIaXj3e0tn5lYd+XfykS46OGfnZvCQDjEkDOAEiCgyw8P0RkilF6nNOi+7vHrzTbv92/fBwyfhykUkr1qbWWOPDp/t/8i0tb5ucF2pIdSCpQXnngERWfzBxOTv8/rXenY8S+K9ahubu7YciQsWrWmFwPmZoBINfrPtEl8yS8NFDfTVpDel91Swa5MRTgoHzfcccZXhRMTab8DKAIJIkd0Fr4TB/5WiKsK8jLAtrmei6SFaGYuc1YdAWAcGxwscMChOcl4S4FsQ667i/vP1T7f/3yrl4Xhiw/V6Vs2tn30sE4AN5XhAA3KQ8jf3glRPv9AQByp4At4KgCYMoAibABHMF4iSe8vGVNUQpQAMOae0e4HU8quWXglAEyJfLaykIwKbfqsIk4uKt6Wx+ccskbdqdcyqe/6kHj/teuUuqxz07EJdk99uVHYrLZtm0ZtHL1fPV+N5nlh+7oJLlHW6iq74F9nRnOT4RADtnvM3UD9g3v3+sxmC0SMYlxhbkkfEQeSSLgCWVXXb0wsAmPNOKiwPQwuOYhwm03i61+cf+u7o9QwA7HbgBQgVqgQiOFOBg1FbMVOCk0beAc59nm6lJ16oDQx9YgyQhCQJ95r52RE7ZHpBTUcUgl/uZXUxLn98bTcTPE3bMtvt+7lMLWHAGAZpgwQ1AGQBqAR0CSrBVjOMfktXCd8s8iq+zkdPTy59BvfUwJQ9l7PFy6qNV1eHVjrblqtISE7oXIUtpzy+03mxDtZqnQtBfG8URimHZloEJpv3fUECFbm4zsanjF5umzTwcxHLi+Xu/NdOE9g+cLWqdrz2z1bTY9qyg26EJwVd/Zts1U06Q+EibXuCjhAMdxXc5DwWFT1cnVSvLfCAYD+4Lo3LRdqLFBME/Rmimnic4DQQ2t0HbvsIGCMHFKagbPbbkXPMVhVwDU+UqBpzGJ/pelImTf0MBofP8x/+YJcmaWf9K8OzbGO3x/kz5zKJQWZu+vAQz2vMyepOuhfTXFATSgYjkQZfJmEfe4BHjXl08jxG6yi8i4Sz/va2kDACT2PFgZlM7b+Pe+fYiDqfGL1f56zz2Hacl01EYkqSHppS7MNxEaIt+2KQEc9vQUsxm5/tjST317CBfc8orur1tbbSClsOY7o232d6a/Pe64Q+7dFgDM+Qqlp32SuZhha8MTnTgg+fd2ytlUyXAH9tLM1sSadb4N0vp8JLRifYUuHtT9ilUAZfwO8MafIhMiKm5Ys0npEG4M1YXWsS1lQ1P0GFI+y0rOxXQKAPz1fNi4U9R7Vr7sAxMXfHuXkcaIZJrMuJCK6TPANWkLxbxFZDeGtQ4U+gTNNsitUCgLw2aVkMntd9hqhsTdR75r163fgk7d6N961RrS4zMTOqAv11n3BbNHNsQxr+qCNzXOW4oUsfoG6GjFd5f+tQ5Ozif4aZhJH7+8Hfu3mPTKVkbWW2R1wOl0emDHOaE1cxgApDF3FDcu0XN+PlH6Vmt4oaBDcfXfK8lUWU1/J+RHcWmilWZiiT8GE7tKvEkaBE16HbVHGWhE/SgA+sbMYsIBLE3j9Qq8uexOk+8PAKBfAliw0sAM3Jg0QMwApMEOgr0YIhm4phAiXqd+AC2dbX/Pma1DFTNcOotqZwOf3KAhznJmOIBIrUT/TgZHLc0CAtkmtdhPJjP/bxEUj6UxwsqrXdiUyfzxTeG0qbUFlUNWji5nJlfvEdXMnvBrf3Ucg4sTe3oA7D78tdhrHe/rqppKnjNqYKolgYEhrVE4/8TyOp5ngftyparZAM7tR5bBVw5wcnntDFQ04OKW7cM2UP7xmiY5AfnUNAJtBIC8LpcsSEpzjTZCVpp6y1JYWNeJYEC3jbmoAh5X5EmazCYeVtC9j0XklWCCvleAbTiqAJhmQOMCwTgRPEEmVigGf8PZZOW39bGxwxYjIS/fcJLG0hnRZWcO4s6SQPJ8IJGPJbqyC6XR0VowoM5nRfDeYLieOHb3stOElHEcb+b/OTZwMdU+aAE2Lx5tNTHvAYCfSmfUCC3OZUdY62cdg3ri9JzeIgxo9cYGN7uSFqQNPKtdj4kSYPb1BOe5QN3JTj+0HvBc1Gb0bDWGANBKuCiLAMjxZrQPbuUA9uzis2k5idkgWTj1ADyUP8GnMY46XO7GafxH04KKogYAT2dnUwAAAJAFAAAAAADZXVE7GAAAAP4+qw4w7iorKystKjA4N+nx7SgoKyopKioyODbx7fUqKSsrKyk4Nzz/AvLuLy8vLC4rNzk6FkdEEJfDGPjNY1AT3/s9o3GIOj+dyZVbPWJjwVbA0QDAAB7/AAogGGwHSTrHsmCMC/mRt+WmO694D8WFDNOfnuuipSH4V7GMKIoNn/rqYu/qHT8vE6LZ1VXpev4BlqACk2o6fXemXMrBIU6bbh23LH++D5rqBLJYNVki58PqG9NPDttP6xcnIy6krrfeu180N3ACXOPX8cJV6wfC43zSZcC0ToFbLefMLQCUU10qOu4v8OsOpwSU+Rb26t3FEgAGbbIMzYBSPZoIcCuzabQo5XCwoJ282gh0xjDkWiiYUK72qtIeFydCWOLuJ1IBAOT1CojxKdF1S8vL6RJoninImlfqXREVbzvVpgMphzpQWU/4SK5z3sOcCcT1CgTt+eZav0B41QyLJlzSbtDAzVupr+qinWo5MfL3TMHVjGVfYOndrwD0+Xyo8tzQ/DN2q79GgDjoKtg+FzZ1lPXsV3ea7WS4L8tOa4d3o0lB/C0P/Pk0vf2+nbuNxRXXaU7gCRdsforiN4rSrZEPLKHKO6u8lVRs97Ab87HfBPT1NNr+aZTjJysU9VY5AxARDMQkRqOIHOZ4TzNMPEN2Gp247nPVtCvTlfFSAKT1ymBgb9j+m1237xBR8cPdQ1fNRm5jfheEbhvxnljpnXQ6FvsEVV2zA/z9RMFuZyk/uPZvErizMfei3SBHgej53Wb6dFQ3Xmk1+bZb1quwgWgpZkUf9PYlEtwpX4Mw7TDiJbfxtFY/wUoABh178EdG3nAvZfpkJKcMduc2wXu1v9ZW9pmfEkrd2L1OYhX0TKMA5DGvQzyGz67POKV217gUGm9fxf1FIIP91Cj1rD4O8S3c0n4K8/ZKCr2hrMP4YW8PSQG7MpcLADrX3Dhc1lW2kuZ/W1TKfu/9W3mKIVMUvu8MmbgRZmPAKA2srorYLVyCDHSEQsYycJR9xcmJYIo/OLPS9HrPTPZ/tDiZ/v3k1U2bstJYtmWiAHES1w5S4t7H6enjl7c8mZsSdxWffJiJkRiTGimJotKNftruClCGX70LcHb3ERrixGOidaPcUXCXwrXBr+2v2fTC8+v5OWA4ct0E/wx9RShi+A6e1nDraw1oAlArjoTWJLAPZRuCBSUPmig0HgEI1uSiFmdATwjf8ne0AFqsQuOdm/vCqGV7zoQZCqAQm7Eu2L/WMc/OQAAFvlYcTsTkVeCuVM367wcAQKGgH1cCAAcApAMASdLzpMGokbOameIG0EEZwue/yd59On3mw5VW3f87EEGIpURK0UhE4cPjLZRWcyuusYoySmmyG2gzIm8RLa8qDa6gzji3pK/brJm82i+yrU889XSz/W4hkuzq+rUMm/plHhZtr+I2UfGRspX4rrojgAG5tQPIgH038ukMMNlibwBwPFijqgW3kmAw65UKH5IAe6UfNypbMRvXbrw5Egbje5ZjAGSPtfrve84GdDI5+GmsRiER+co09qgvQO2PUS1GgeBV97zam94PbutuRxc6dPk5DP3c7PZWzAEfSLALU9H2fW+mFb1R91X4/V4UJPRDCUMDbCQY4Geo1JPGgVCOtWCsPf9+3ghnv9yvJjioFc+TKqdAwLifnO7NmJaWvjiYjNK1Gj6+OxNB8S3ez8UYNgptsFRy1JS3S7Nm5wioRP95ceaAGQtoQVVUP06TJBBN0QxNffD/31aJPlEq0zS2agJkD0zlt1nNaO5qq0MBBhu8NsP+QZzT4BX3jHjpeGc+tkFojgzuJB8pgkFWVzQEtmly9TcwLtg74TMbYwlojKd1KCuJdriMQwDLObueYAqZxRlDPS4/xMaXX0GsIyrOuAdIABQCiyRju/CL0gLxLgE9Cgfz5t7AsizxtmabHgunRJlUGHxGcaGuZO8M9kqjTOV0ZDxqegSESZJDwVgsQ6twH3mdpWLmyJiJkZe+QjgcQjkE5AV3O8kcLo486uVeqgKALFmoqZmGVleiMmzCa03ncxVOQlfkb78kltFoCRz6/JIxk6mL2AK55ikAegnZl9CEmSg76fWb8jxWhc0/ArJhouZD8ZEzAQz2Ch1ZllE7utplraMEAI+Sx+FF6yNJoutgxR9arf1rHnrgpnERjE8BFAILIpsuxUxev9OKKQBISyjc+Ewqy4hd6yr467z1u5q9DHiGvzE0vL8DFPr8jk3HIFatXKKvDq7itX8vbxrdDgXTmnX9wFHBwzSbcGZRsMQS5a0AJAILKIDgxS0C3Wwl0rm3zXZ3MlOmqu2s33D5QX8wLRY6/2//N25OHJ9xwpyRmQv1VAD0Ka/DntpiyXSlcNaoIWG2AIqd/9l5UgroKt/8VfTsXrY8UY/1wwg9SN2xH5pwUaWhkIbtG1VRBfwtr2f29rOfNT4X6/aqHgvQY4F4wClTmu/2uUjFsiWJp2ynZUq5j8VSsh4oafmQcy2OgcBDHxrH3EQ6bRemMbzTw7esfH+/fXlibX1+Zvj9RADsFHDWQAOEpQFbyJOFdQLCQs5oSrHsj/pZ9qSj/9WWbPFo8WOmIahmGs4G7owtodLDx/ja5ibVqpUsosMHjqtE1CE7n20AJG8nJ7c9v90Xx2yM2TdHv8pYBMGTgC4ytL4+1m3fUhpAAe7hyk+tBPz0ulhuPG/YZANA+yu77FsE8m2ECQ8p4s5Z2lqTqIZWr0/ovM7Q6ahJPax1Os/Nv8tXTAlokD/gQq8WZ+Bkb2kLVsQWFd/Pr+MUwI8b5e9Qen9v7ECE+/k5RK/t+XXDbS4xMKJFawDeV8zgFJfBiN6J+vW+3zuTCbp0nUVKhneOKhgiIDyAht/XSAKFOYBIsqXoNTflVlmN5rWRqzemY8106vWwav324eGskgUn/ypTQmsF4DFxPUdXoqvjY6CA1ZbRDLuDY0hhtUmXRdt53uEPV/8Eo7QJAOWppX9cCxR61qh7q5JsbAC1QRIZf2Wsb3+JDSBpiPUYHIsPjeQMLA6zTWAzwozcLSz6sFbidaDaavnVnT6UhHQXJMCe2QOqdlOLnbyuCumnuYyiJ++1xFBvXjkbs6Y7v1oVfW91D9ZWK8me1elnqFZ9M+2M4tgKh2u6JgB2RhwEpRsZ5OounarZuz8AMB5DPw8KABTAAKQB7JJcniRoCJGsFeNDFnQxQoUpSf98cDHzB+vkir+jMpXGRflbJNaBAiWmH26bhEQzIrQ9iwsqjir4cBnwjUJwlw0j/7toO6v1XDcXXS7lWd7ne4WgmI91dFiwUGednV58zAT9n5u3tHOofOKpFHWYgn8eIG0a1YjBnq8RcfwsHNYn1Jo1LTj258OvazOHbYbgHJTC+e7qn54GV7BSAj2JlWk637kqQ+TiBrSv50dQ/s193UzPv2E3MMlphd8rGbgfwBBP7Mu7gBOjD2p00SuTyu4JhWB/s7MAAPz5PESLKtUFCf89hxCAKYjGNJXgl6aoU2c2zHZl/NU7HaQvb+Sd8ZKvBCT2ihspXhgpox2cvv2IBxLckMwsCdFyMYIPJAZr6E8SsX/PHPJY6OUBPP78YSHHky7Zdp2eIwBpFY9M06IuzcSN+2a1mz3Y9TnAht/BN7tkrmB0AAz6SgM1t+QXoS4/vAIBIDi/kmm7xIk7UKfbEevVwNnHrRWn74R43H7ucQAc+grDKuXhtSJjF/I9AhC04Kh4U28njjJoVcO2qpFbyhkAmKvyDSuvSFoHNAK9CWTWZ82t72s4SUBHKgj46ZN0L71tSZ50ZHYSCnIDxrE6omm/6wH09coopMPmRWt0uSpqACUGhRXG8NmOjA5H2TyZ8CPI363DwQHE8aVn2u6ytdY1+/rnIlsCrTUFAOQtd2sKgvQs3jVJrigBFWI9SYXsWeddHSjNaM5xqbuZ5/8mrbUgVbgqic2o6exNqy8xJx5TMgD8OXcg9sNhT++KxQpUGqZcU69A02KXNMAWsxFtn6bIDo/NE9LgdzOi1ibxJUtJPXzVmH95iHxkeIDmqQoaOM0L/bnWluX2HkK3dc0Uve+dothYsXXfOYD5vQGwwQSh02MAQOjQtwEAeZ4ROGDpGiCDBmlltQRA/WehUutGxgevo4vfo6BytZPm8CVfR9rLppSOVIaeR4nxORXuuqweJdaJrJQ0palSVG6qSHppmui52dJBIqtLZrvcivmiNQooqqGxDj109vq1f69kSoTWmiDAC4tRbXXPRiLQoI0lrW3Nn6MZNcqVS2GZ1BMNoSgYaC1D6CyV9wNYPeHzfXuvdT/77uA4Kz0mBUjktdchFy14E4L+0wSDJNCmw/wETUeRcXN+xkUT4MY+L3m+7+JkKEiJUc1iUZtxnFnAPmZEB75HtXHMoCNxeg9zSkkK7C8BChOqAgBgI0ximIAsoMeggVTWAyRAUOtZy8BC5sI4GUXN1PLV6ZxxDND/AYA3ls9J/JRqiq7tvQ69bgl0b0WydyIFhz1O9fq4+CbQEsI4bY1oVb0lx6fHjH/SSO4kMdaqCbiSqnq9+lsQb9QsNyab0j/0NCREsx5Vpn5SL8gJw11dRB3NB18nGe6CO8aDgC4M1uHdkYJXbzibNMVBqM/aXsV4Tgegvfqz0uzbYikLQAGggcfVj4F9a5NLriHrgZgwaT9l5Vp428PpwODqD278sm3SPAuqRSsponczPooEOhoAdkcdlJN3wPnxeHtP2lT4yvI0RqjY95oY2M8AmPTD3wIABIOOnH3AxhKAIKJvFQWsHvuylEfBMPeZ3UfX6/X6rPDpOiceaMQekUG8FEWBEZoIgUhYUkTxIMF+Sd03bF9fjEB5rcQRyq0PJwatLyZCHq1VEzQLpYTj2bi5JOAt9E8BV5O/t5dbgpzYs8B8WOZv9dO5yUuBg8vXXhD3uQ5ibnqXvivh6CmyadMtTi4ji1MCjmxngDcjIYDQVd8TYQAI/vq2xJlkbCk+ALoHwc8nbSvowwV5wLmIQwDmsu+JBz00FxHyEBwfKlYbJYzRAKxBy6uE463kN5hWTK7y2wACJAKqFnCbAaRUFFr+iVGsDEPXIUeHF8okG3QxurQC5EFLnWft0vpBN/LB9gk+AFLuSqCCb9Mv3WpCSccMBUSRc6FgnEbRSRhSboHFGwP8Qb0qAZfxvYNpwWz0oFuVXoFATRCwErvj2omU4oPcmUcG5Unhhu39UxO7wgzmAwxCC00wn3a+ALoJD++VWQOrRNGEn6IIh3G+AWH+rFK/b+u+AEIKVYI6tJAA9D2LYxAXW08gMlMrv1XpAKAmKNGkycARR1R0jkfaYlFNq5BsjPw6MV51+34iE+RBy2KgdtHvQOrlrUoFgDANxMIbY5oqWj+9mjSzceccsAWqHYZ0oiYFFzrsPQthgvRK5gukNenEDUMmFMBa/sw7nlIzgxeiyY4ge4ibq3Kv6Afv1UcAblDx/34cD7JjDVgAzC3L6xPsLUQNoiWzudFHq1IDAj4pxXHNaj/Auu0NTFPJfKmXvEtt6OWf/wvPmLbD0GsKBtuDbN4BxDnLezyegqhHsVhn1kNzVaMJJLFLLH3LucHeOGmd/DHxV3JnfzKUZWgdjfJ/sQNEJ+J26iUhqw8UAE9nZ1MAAEDMBQAAAAAA2V1ROxkAAABJtfctKTn/AvnvLjAvLy0uMjfx6vApLCopKywpNDY8/OvwKiwqKigqMjI36O7pdDFfRYOflnGe+OJawA2QK+sLKEqL4mDB6PyTSS5IxXrziP7vskFt16h7uWmqjWZJwQdWf/tMWFSRmhcdNO68mst1fBPf0fYKePp6z8uNI5X5/x8BH/8HAEsoIHT2DQCQxgg0c4zAgfXyDaoASRgDYd4cgCEAVvtzTOdWbxceBLeTryxV2ezmqfl8ylXOOTflNKZ7RGN8vrS2Sqg2DG5EMdIT55yGKunbcP1ry/d/mcZq5a7FhNWY/vNS5iWHVbZiAZTEyeTzhb0Ls2x+pGxaXghZQSTivHKAyXTMy/Ck4goAEFWafjw+MeEGwBlGzsvlow68ScDFS3lwLDxfgdEaZsduNPhtiT1bNGWeeJjv+gNcsN2H7qoazr9AhGxZuSSbms6g3EOq2NifHJiAZIjPcC3WDynuECiGdgB+V82wlnGN9MdT1cpmgqT7q5gCuf+0AAyAg+IA07AyDMgCu1MASGU9MOoDtxIwYDn4bA0F+o02d/Z+L1YmQSBwOrB9BgAQTt0W9bet+SueTOa9RCnUVulHioN/Ll9wwSh8obuJ5GnukWgmJYmK4VAoyjFHLQlTW1ev35uxv90tPsjURUIJkDhbtMnb9wFrAPUoQpZa+zWNwwlbSZPiGmcH3inYDCmiDDGOarfbVjaGE/l/l2gAxWmIZfizD8u3UpuUoBK3SnNNOgYDhgQg3xWNlwAOzXI+bRxH6LT/joptvU3gK86XWen9Vuh4IL2U/K/iHgnVyTmkYgKWR1VA8gFoT7u+ZqFdKBkhvi5ORw5PR9cbQNw/AVhCOtLz6wQAwQ4wfQ8AMspsAImAsQbAlDBqvV28qddr2eOPnpxMpmdr3eivsV70RZaWuBGZMIs2WkyPMWkU/avnKxmIIGJS01kIh9q7Oe9Nl/DvXh+FAN5KR4gs3zizz03j5dc1T6mFIglcBog0sE3g9yNgRjPqi1P32LNIUbTJtfB5Qfzy1WISrTNTHcJ7W/YhdUu9CbYwY14lcC+tw8lu/fktpiGjAqbNvwNpE1zqTTHqpxcwr/krGFra0rEagLJ5Kte5QwchtovJQkUq90uBBuRBS3hiLNU/RQbD6bWGVYGAS5RxfvBjotRoMg409PnQBxzQ2ISaD8ar1NgfUAH8Qf22x6Bt3kG0Zs3cCvciZtCCmUiYt/yQjCVp1eMbXpUxALSgx38SuDvCCI4OMwj0QQtdQl6t3iFashjN7pbyBiQBEoQgGv2JlGEVdSwp5I36awC8S2irQnAfbfmtAOQ9C53n9tb8oJtGq+tnfAM1JYgURJ1MxCvUl9Mc8LXg+TUIcezcPtYwpPZXiAoA/D19Mdirtk7ktne7uryAIABwMMXhrMvSid7sA1Rat6SNuMAncpluZzEPfWgAzD3L1cTozHUHEVBCUK0BdQRII8Lv5CsrztRlb7s0lqzVk+XhUWWDGWVR8WMqANRBS4XECQM5CCSvTPtSDWyCsHVWl0k7j3x1WwR6etJAtd1mEncLTUA7Pk/dcbB4/zEN5ClfZUHSmWRSGB2tj/5PEnSIAR+aNQVF2hWM/y1GXYgej4l7kNoEIlM0wHNeqhtYox6vgDqeD/r2zBO0X6Wp1E6JHz4PEvUPAICoAD0BzgHokHnQzAMsYGmhlcwilM1Mcd0V2orBsrxJqFXn5m1dKdV4GDjnWov/Z0UpK5ENwwvFfX29NanWivZpzmyrCtT8Pw8FLxo01ONEJ5O54hCJ09Mfj13P/3+mJH2dzzfYv4Syaibp0f3y52lp1+fvwx8XFx7sjRem/ACAmSqaQabdtS9iNcwKwLOVUoIbC8x6PT9P4lFaJdjc/f6XR39BAqfV4SbcoqN3LG4GjRr9RJZ3DdpioKTkUdF07HDY7O7uXPQhqKrq+dkNALJpZ+WIPqr5RYGv7MDGLgCepyQ5XfOswUi9p7D/AAAY7icww5F4aLAjgAtAgjcPt3okUyeZrWWKYiaQeAbxWBBzEyB8/TLXlO3fRnZTQ7H32FWkDGgtOyU5jTGpIeKeVBjLq0nv4kzt3RFRekiTXS8qIEK4ePWB52eJNDvuSHJ5dhaV7IORXHaX+l0l2IbaX1HiHD40PFlQZQs3jaRRH1+mKNDeripmH1DgGAPADCPCr6/hc/ugybUOH1NQjKRaaTZgLHGzioQYBIq/j1OWW+mLMnh48lmJgnRnrgzO2gQN3l7ozxojipI/4Nuni3P7SFe406BSz914QAEWlww4d25YsAN7Cus3aX7JpZcz+Xr8kxWwnwBwBECBYQImC5gDaUYO25Bgiqgt21pObVqxfRJz0ztohPL4+2tFoyG22k7i0uliaV87PryI88J0d4i5Q4noUSuhfvieXaqIu1IHZklQYrGCqfcp48XaSoPyfoc+gLnAYGbD6RfqR6Tg8aunpVVjo+VGg1ZgOGs8XU2qUo3k1FAHLwAwMDH06xHLlXYyAUP1XZwAasO61UG5r1hZZ8RwcW+9fbpBX7blI5a+rxoUhdh+19vSnbTz0gfHdYSA7K9xIgRttntFh2Kxr1Q7DQWK5kzb6rQACgAMDsslG5dUO7zZNp0X6INokjVYC8VD+5U7g2/mIeSvdQw8Jw1j5A41ABQSd1bb/Cn5OoZSFHEWrhANgm0PtonouYV6uaamoIFAE29f4Ar7I2OsausAHBaLso1biS4VV33BpjUTQfA2iVmTO2Az1hJo5uti5aDadFrb3i+GuhAKLBp1xjPcKCtbOy9mwARio/GzZ5zIJfR1BFnP8mMipVe/QOZXK4n6UwUUHkuqR3SJfKZD9yISZCBurY8Zlml7e887oMbvOK1YmMWqRUj9KBHWvwgAHB4Lm43bk3a2l6q1eoHAg+DfIxZtejtUpfUgzfhL6QzokyTDKMrIyoBqegAkIv3ZnpBq8C+vb2vigpOzB3zCutmI0xQhqsGJ1nO6+FTbIwY7rmjSBAwiC4wnDJphSG4A9Wks6BDhbZXnq9G7Wv+9muvamRY83fVrLPp/1h9AE64/709GctyLJwD8La+BnqepJS5Fes3+BZAVD7C/1ZceDcZMJW0HqncZwTFGNND7z2w216G8rojSLR038+LsSAKsNV/P7MZbsrEz7aPfDuBPqwMCgOUsJGf7N/U/7D8lkb+M1EdDrnco2WbpDvw6e/Pa3ewvfFj5E/3tXQ5a58wiUS+y4xkvuyxeb5+wrn8AADy/gRscAAoMAAvg7Qlg6BLyYR4AQnlLgXt3wlpzxybmjyCuYeN7ncKNvwzbubrSyMd09egxKj2RjDHqOPmdWu6UwHSutyqj8Hjzbu5EXWESuzNM9vHQAICkkNmXMqYdb5pqQovz6z/7qXPbSAIax2lWJ2s+JvEFE3L07D7iXto8lrwiQ2rMFeh5e8c8YQrd6EBTdEIsrHpvd76PKzJAoj2T58l4weJqfx0EJstIgaq9zqKrrbp0H9c9sSiVBeMkJJCt/iBsAgBT0Z2+UOzVBDQY9d/j1hhQnhgIFzknS4Bh1jCal6Lv1VX+lrQUk8w2uZP0PoP1m2QvUOKfmKF/AexL4CgACUsCrKCzwi0UfpiDWChFcfRVXgfBbPbasoXT3wmV1NbORxZ+tDJ8DEcY2/z/LmAC65QoCJ478oKEuDdZkFpmI7JyB6lyKGEiaibtU1bzOC1R4nOyN/9a2sb5Sj5Q/QSMGal+ZJpVWsZGCWWGnSp9QgrG0Z7/foLKNG+GaSJoqOMgF02Us2+ZuyNFYS2Md0G/GMBVKUlmTTl2tBu7O9fMfrHnpu3Rvr9ehPcys7A4PJ8XbDPo7KOruP2o7AQklMuVVl4iaeHcDoSfMnxqLIAC9pZUFdcH2VxZiosP1PH63c9hh0CM1XG2ExgDDUfgYUE4Aqzhyd4D0J1j0HU2iGRjKS4HX0p+9P9t+P5M11c2F+v1+vzLmkYk5ORM1EniI7vvDqFHrT0JThDfe/BKqXaKUg3+eiuHUqq35dptFxnp9C+/JgIKmRL7ayzY+is7JRwosLbU3HfxjrGL6KQRwHP7QrmC207/uRsFUNUO9xQidd+wv8sFyvkV9H0dvV4rj9TWrtgiGTiGmrBkI6ryHHahru062TzVjw/iubMqx4d0PgjghwANGruX0jt4G0JA2QY+ftyMRw93BCocJ7R1dGwTNBbLJsO6QCxcXrPaCAVxeOjaxaTvTHw8RzZOLdCIfLwR3u2crwaJfQIKLA6Lk8LPKCal2+nbX8hAPLR877X4HhpdaysgexVpVFcrfDtCfj/dkjLY6wocDguajWknpfE4N10QVTE6tjtKUDISkUF9ULx66mzJa9/FZMqiEQTRGwkkDr3OHmcJbpeqWUXB4wC8+uDPeKrvoPredGDwbUIEFaSoGK/lZSBUeAckDosmhc/OYU7bjBtG45X0B4yRlenu9qT9ZTQZ09n75wxWA7TyzRkA9BFLqx1Kioou6UBNxTeQgSG3514vIq6izpTgfYskZpDMvPUQzRFMmNcNDBq16DnO+uR24L2oE60c45dztgeeuVkYzdhZqoh32qsTrcdTalT3XxheCsnPWKE0CwAsCvUeTxjlN6EQqhcD4AXGUQXteJ4vHp/nvngQbB90zv9/S936SZwDlJiC95cv5wyYBvQxrxDb0Bzs/QyF8H5ygu4mLYyBpydzW0XvZkznyIz7FGW2cfgz9HcGaMmM8TL+90vTLKaMEA061xzgWTVedr18Li/XbSmf8/sDACwCwC0POMAMyYRJTi0ZCluhKIaItZa1VphF77mNqnE4tFdPVapk74kgRh+ttKJYzuansyCAmHEyHfXI9ezYevtezfnsBtdyZJre1KizZ51ncmORFqGFY24EJuYg4tkNxe3y+vj4dbxqxBl1H7pjMiVPcAMAULX+ELfM2UMH+Gph9AAFTEDebpH31hrMrACevUCntBeB2uZ2fbJvSWIDgPNQsLYS3+JBXhAqPzddKiA2R1HZRlPE3BWwOu9Q+tn1IwCOszh28GcHsgCA3Lh49voIKAkA/rbMWD7em67TLauedPL+/kYvSyjdvv4BnAGNK3cELgBgp2EA0gH4ArIEMJTQnUcKyVYoIPTuKm2vw4Z2LRN5+YGVhWtuiimZUyfR6kyzMbtAKtt8I69RC1i8pAiUbK8XES6dqsTFHBexyakQ8FXFHrXsbCpknfwD++nG0npblBYobEmo9bEHedwnTB01SIyp6VPSfYBIrnPupXS4Mu/fKHNkbZWeA/wrr4FJY44eUnoYz4SkS8UUUjeUymdyfgYB7fXziHvwURYIAHnfVHkUGDS7L+81EXv2AeKPrRcBLPUTiHK5e9zY/ThSNhSACda2zFvp9JmIuoWS/P4AANhzABwNAo0uA56gXk6QcpA1TJERvaUehHCZ9z8gvvdHdxmRYDfBCm+a0d9Xp3uRS08NAVzERmJPYrM3oOvbIpVFlHAruTbr3eG/zUqSqN/Dxdy0rtW88shWegFVANzuh4r33m4xqWDT4/aVnEJ50M0AAADc4v89RAuQlLHM90kch9LzyETtjc7qaYhlgsNjq3sWDrbv0r+WjF3D9L9p9vAQsgYw2g1UWkU7g90Y0R4NUM1YPMnfBxHxtk/cd1HIpAAwW7Vm9fagElE5UNjQXKv2Gx2Yil7YKZgAT2dnUwAAwAoGAAAAAADZXVE7GgAAAH+e0dswJykrKysoKTU46PD4JisrLSgpKjQ47ev0Ki0sKi4tLjQ0OPHj9y0rLSwrLDI1NvP6NBaLq/HvTjr4x746GMlXM7ZZwuKbieqGekM4Cg07pOMBLf+CSAYJ5Bl3Rk8kFwddWgiwWQeRQMSc0t7Gs/1Pncqzyr4aLtz7QiFq0ZR3kwA8GouH9mGZLp+rY98HIcM551dlOMYpS18mPZv7dx3Xqt+WdbouybmDGxYNLBZ9TnPjHq8yr/fXJ0DI8DkZRKjKsnQ+NaYIufNkJT8rM9CBaGudCNMVAAQSd3TtUpdX2VEIxVT9BiIa2z2mcVKW1fuhEl7ok9WyaaNM3NWfMR8dzAIcFguqkeRXXHbqYD4f0C7g3DhSZBm8uxFp7L1WwDpQIIi2Avt1rzoBLCJLNuMP3Ti6rPpsdkmqYLORMHKj5wbXV76Hbe8HMua7560rE9e6oS8MFgtRTzRaBU6h6b3sBJGORWbnGhQN47XegfOv/zt1tljcBYnrA7XWi+BN7zX7yK4B2RoHAfwxy1uPfZGLmQZKS5d9KR9LdEx+fXBqZ8nGf9MsPYtfj6oBlme3G8e/jf+eS7t97GSJqzCjgEMCeufMK3TXqt41+m1dPODC5ZNMvvcy9DGNvjtk1/bzL9Y06AcA9JQ8MIEkSKRWsipFUoomQ5lf2Lpwtk8mr/29WzNfb8E/iGkSp+P04byt2daatNYK9f3/L0QAWElbzTexPTLd5ler/XszMzHG4zHGCBTx4P2HlgMPWutSdmpKTsaV3DhmGyGzJb7tZo3W+N1AAKgNH+eHApA1db9e/VIACH8R0tbaeRowS4Yiq+C+0Ioo+pBYc56Zu7vP7jKA7dkNNgAMD5RA8eklD9a5qXb1F8gzAF/9E8f+dTGZaVeBW/ZtYTc97WQFHf7XBKopXLSJJTOWSO4/AEACgGPyBwAegAY9IbUzX4AkEKT5gC/ZExQYG0CyTcxTafGJVKy0E16mvF/XWI6MQkhhaWrjxnBEARhVlEuq1ZPt1Nebpz6m9VcsuZ5TKqBExMfB+f7s/rTp51t/JOxWtNmUTbzjnPjQva6BAQn5tYZCpqM1/suegGmQPHQzZhWCbLVlKHumEZQxo183wIBg+iJ6ISN5KrXyDpBUcdNLJgbSfESs5DMtQlMeQVZxWeE7tz0i0s4dUocT5jMIJN+qa5IU5rOIqY05QrbMCh3sJBXi2WkbhiMgTHHXngDmoWLkEFbXtPm6NKbz6nSdlNpkMb/3ftp5vcnWeTz3EOCAT2BmlyFAMKwLAx6SoCYYwJEM1BvY5t7+RoEzvfq6WJ7EHJo6MHU1SHROq+HjxpSJSX6UVhNaGkvvXVXrJ4tnGfQy3zCOF/q/y820WZkf9wJA9B1h3P/vVclXPkSJDXnXqlOiaJO1T2OXm54yFVi6DwYoznuyZivwJP37s1H85UTB8qP+jsyE9q8FB4wMb/Wbt5igTdszbocDiEPO4BeqhTqObxT7cFHFF4LnGSGZN8F/BaBmT4T3t3N2+AwFsvm/dvICwJcc+XTlsxa0Euj7aeZwjSpkbbMFwQQANCYLsqG6k2645IsjgAuoNxAiiuhjFBx/9jKXui4UZFKZ5pRR+xssHkuGdoTXVkWCemx+ugEiGvvrbCCmMks6j+SbQ2gFG3qPpHKwxWbMuCkBJCILK7tSSO1fjIVQf/oXiBi4S/MMtk4OC/UN4kUQ15jhUhNwjQK1694wAxQeSyZtShdZkUMlkPz0O0EDBvptUyIrKqIxrYrjMXbyi8pywsXehEg41yJOATwmi7qy1KfHY1hNMSdwFTSPRQRxpMTMC2cm+nPFxaPSL2LuJIQRBwvcJct3G6qXjq/6/VQJa3RQ3bQqpEQm7UVb3JepPcQhba0yRSTHfFRtAwway7oB4/Ylj1vX+8IlxvDAjTmptSRcs9SafhF+mJT0muB2k8ZE7oChAAQWCwo9y1bPLzSkP+oEafl31cCKtWz2kHf9NE391Nq4+/kjyNJX6z/7eyUeNzi+nNigKwHkSYuLgvcPqyykMrd0117AIjp68V434R7e0PJdGh1O6+Qp830nthehZHah8B61HGubXmq+9AweAFrX3JAgTvGs+fHQ4/2RDdB+MY8ZDEPaeuiDswDARgHzAANYXepJg20MWMeoFVO8h5uq4FRgFzaeFo1fh7W1uMlHrSSogimzC2jQWgtPU5MR8Bj3lWpUdv7C96ejqTFGBFPnN71o81P95Rfrm0nR2ny9+Ofr9N9bsq21OxheXkj4fdTB1sL3j9eSNU/f+Ww3GAmZAKtDLWBv1mtVzICbz+bLUBLw/Lzc8nUB/HVdCgBM/OOxXDA15S9jivR5SUn5jyqus8cA7uG6IpoLIxQoheHBnyQRxswbDVMFPDXlh/v5RUHMgVHta1Cq1Q2AKv735JAota1xdTII7e8MgkRXrLHvLwMARwMFnD0AvgPIEFSZgSfDbzwY5zUeM7DWaLKy26ULvQLyJbz9PTSwFetyMrIkLq5SjrlFDzOSBAfWNjp7KgJDL0p/rCxICuJk6u8CtoorEHpcv8z2+URu1dfLpmxNZkYVUOrdJNYQcUft9eLPbRUsUsqoo3zxLT4NqXIFi3zOLAxooS6LDfo6E7zgJu7dPhkfo4ICfoIYMf+dAGxxT9MwahC+qqO+YGjsqp/wrM4aaAR63Xji6hH2ksAQaL+uTrFdXIcG1Pm5Rg5qRcrR4rQ97tIKJgAW6OSA7OaU9pl1XXIzkBVS95096ztl6K31bMOOALCOAhro5mEYZuCKNhgKvNaGWDBFOf/7ux/cmGr87Suas5uDxUkwlMnr08gMIUhuOZXtuZURNLjCd2aiNaVhSvBQw10SwENIZK9e7FtzXRucu12+ZOynLf8+Drt0V/1+sm3bv3cqNVQ1heZCMsn1TYK4MtLpNA3PFAxBsAPn53ZITCA4lF06lKvh7+3I5WsG5Vq/CNPnFLSoWEJW8Q4JgvvTG2q6saWjS3AHIjwH1gPM1YgGBUSL1C+zTTlGnnK6i69oRVi4cAMDcc5xrdN+zYABh3d0OzUANC4Logc2M77UKrHKDDAR2ED+8wHxlqVl9BKzLm1eTIvoVW885QijsywA5CVLZRAlmb7AnJcfO0AcdBUvhm6otIowak7EsG73SUL68pfpZirrHuS34SQBHCb1MNBH//KXot1Ea9sKEBeKhHxcj8nyeIZWIFzzgOk8zbfDwrbFQpWubwEMJotYcDb+6abvWPddkBLS96eN+VOofaJJw1cHc9ZbGbeTQspTGQrN2QIcHn3YU03+9haF/F/Ve0FHuOTTMcfLkiE1O7h2Y4eOzOh3O/Y/0f7QRej5684AVDYpYuyDT/xEXNveqogSdIRL+J6XhlIGchzEqDrJ06Cq/BPew9GLL/SCUbYBLCa9RqNk0kGJG422n3w0aEBytWUdUgbWXWPsP/QSE5S5f4Nu4gtpm6mMVMJOABQu9crzXiL7BQ6+t4oIAFk87I0y25QTf3/KRTNOfT+3yqo71YFrvsrQoy53OBphUoayTQAcIsVywf7MNBeSCO5ev+gF1tKQv0sySRiezrshjtN5jMRq/eec0bh1xtuTrAMwPein1iUADE6L/Z7vRlf5AqLcYrMqJFhO75jOjcgtPS65rp6OMyVtrtZUJZIfspymLVDOC4mLx+b6/6O8mADaB80Zctlztd9+WRYp7f4iSd/+N/OuaWfwq0csAMAGsCeAKSANdKSkwepXITk7RCQyIH8iay3sNGsProPRq2nbmgAAWmvZD7OnYwTgQnTOEVubOaoVypRKSVEnpt6fOTz76OsvMntLxhiTwwe//Gfgx9FkMqrnUdrfumlWhn6+7y0urvL/dgO0YuDHxvudCP4SrJEklPhBsZsAlasE/m0CaGri/spa9/PV0ibHAteFpnjrSuB0r1PO96XvkgBg7u6+vA+XnggIucZgDJAYFikylMYVR+FPo+sDlG8CGJelhv4mb+PstEgw1EhO5clcnyYAvvhE0nRvzYuBfeX1SyGA6wzp40sPADjqoAbYA+B1CmTActIMdw8vkFiWYEAQvTkwDRlZ56SLRkW/pQo4zWJA0KHWoeznkO30CxFEICYSuY0GfnSlwIUHcApLiCTVLSu0Zqqo0tyKEBO2f75gMbSgfbj81Z7lPhs5ypA2LJwpesC4gNLbpZVNcMOXb1xRZ+N1PVip1kD5ixsIYS6yqVTrM7M3QjU0F39JM8sGckUNGZoAIEdeJ+ENDOlOR7PPmXYXgUzpagsv0EM3r6JlMLvTopKVbqfmZqUAALDv4lZmO4dm6gC297SEH/lzzN8Tl0S9Qjbg9AcAcJ0BQDgqoIBuT4DvBMLJwKkh9WRPyQwcj4NBsCGGifvM3OLs9HSkXvTWy0VfExGrpblURLto+jA4fgERb35mBfAghI4em6a5VCl2AvFjdu7sw+uw6WSEsYizFy5q5/bye/+wdDj92JezS9x1ognZ8Tk66ahCEHSu34hl13Tq0du6IIYDACR0n/X7fzxP3YxxPsj3ow06XYaT2CdoLxkZA/ZwLI8RKJjySaScYL8ZTb7HvK7UEnvjauwz0OZ/l0drh8xpltX1TWsIaEyWt1TXTA15qgw1vqYwl1Z3GE0dMe9a07EBDC4LsWdsfUUGivjOxppsAOAGhuvfyoPxp7tePUoGQ0zmdEHbFwWNrIhZbQkA5DFLYCLGvmVEsKRl3xikgbeN22KMhmyqkmD8SE7ElJ1Kk/pmAVMfZc+VNhQyC3EA01Uozpe8t4o6AMQFEpq53zZNiFzsjFJztdMySfIrXeUXr0hXNZZpBQwufdgTzY8vUKy7zMo8gQ6jMdb4KhxJ6zzdRxHfwpjWq0u3zPuH5zCkVY4DFDJ9zHN2qfwj/jJ9q1UyMGzNfw33tY+zSt041CHA+qIwz73nxXsKmVylAbwtd6gEPfnxF6a1scotAMRBkQBjI60XWfq2+ASRgaFSFr6zabSkpi0qiVAKHD7F6DmjX7qGWG0AW2ulMZlRh+WjWQnSmm8DZjY610DB3IX3Skz0SnlPiaJ9dT7ZBxgMIv3lPPn2MQ6EkofPLEE6ea0Pslhm49dpEeTpdDqdWjs+v5xob+j/99jrt6z///8fIjEEABRO/YWePe1fEG1gmLe2ErgGzXIqf2pIuUvy9sBqNHm2CSOP3PyyN1JpvHtLlNJZ1P0nZcccAFoHHRT8lubUfvsl15TS1mqmTb1fAAAAgAMIwAI2IwN21IBt3EpIqBgKkQxcxWwtQj+dCWsoANA4OXy8lQjg8S6vC1pNqjVhMp8FYvOY3P919JVNrTUAPDkTY//x7oqxtE0XNs1v+vPw8X+/tkRFOVJb7KX7Pm56PnmbPTe2XlIlXiiuXZnPybat7OzsTKvIwCxTTUTv50XmZLZE01gp6MG2ngO2OncXWQwlZrmM1eoB99/A9dcFgATX9z2HtpGpppYyQ3GcqcMgAHROuJpGWM/acjPFz2HJDrIQP7IcFxjlqwEgjoNyLIbqQEt6dqT9Q4HoAL4Xtags5X7NzyCtzbsdKWuy7h9FQuL3GQAA7AhwAwDsAfC7BGagRlAwUhAIBnSvKcPAgkBFxsFVi1m2i83RVeJ4dgAkjTVlea9VGsC7OclRsGJbtCB2euwsAKrk5PYjL+yyrqQgOtND7FPHp2Z5RSKVO+29Mne2uRKb1iqbBYTgIoC9aVtEmzQYjKyi5NzYbWeV5FXRuZHEEYIRMlfoQit2ga6DxJeHSxDAxii0QDdCmfbiEwbiPtaLa0pGAqPGnw7JY2idVtXWyECVszOPzAwEUHFTj7ApaYyLUdn7MQvIhmtUraEt78Op8gErhOZUg88N27jCuKYJEABPZ2dTAADASwYAAAAAANldUTsbAAAAz0WajB7/BS0pLS4sLCo1ODj68Oj4/wH6/vf6/wD7/wH/Afi2J7WkuTb7T/m9SUJ053UJlbU/AIDrBAB2JHgBgGQPgHGFgAFuU7MCBGOdyAB0qTGOAjt50kHSh1XcZz4XG6frjfXQe1/UULS29sEjI4i4JAonIfWeegpCGFFaQNp6fXrw4mV1mCEO1egsk+zUE7vJfSNLi65ueiGrfLvfepapyPzlvG2LXXa9mm+CghalmqxtKkwqbXpxmv37ig5aceELWuzW+dFm4WVZbt3JvuMQpdesLsJ7w3HwOnY9UlVbwM0AZjSBPBFg4A7xBQ1cARAAvsV5H04Gj+Tg/o4uJAgSD4LpjCt5AWoUs5nqB8K3FAikBq32birxLlNrCZgg67O9cgeLB8wxS9AEjJ3dULzsVZFjpI5ww9iYCZdjBdK7eI/+XoMRdH9lp2KjJjjMtjgGG9Qxd/BE1f4JQ2/r5VODCI7m60OiShaXqGURH5jSwVv/EJnVaSS+os4DDDYLcTCms1V0KnndFz6IC12JM2l/Sy1RCF0bF9N+I8HFubJTL0rH76FOciYABDr9SICxWzqwOO3/t8o8AfSIgYHMo56MpBovemiFFWEI1s8YbWtVNyEe9iUiAgQ2i1RwpF9L8VLi9jrtACaM5NbAgvKl6HxeI6q5D3Ba/21qttgiPsmIdRsH/DULreeMfu0vjur3qtwCTMQBAyzbYYjVYknpo9JSojTck4MeOcp3KKAEhwQcMj3cMzH8N0S0Jl6eLwheA84vY3UpsL9XdXPGI9NQmqZrP+QT/iwSfTYUPr3So8ouOYEivvduZZZgOeKBE5dCbpUIyM2PGpPVHmqlS0++z0r59frgbWGLM3jWmNv6Dgwq9bt+VgKv+ES1QOasfGnQESlMe0WoF47iw4dXkxYPpGxhMNX8c9G/0+9O853QxVoDrR2f7RIABEqL9Ql2xbXlQLQG8/tb1aAwGxS94vcXS5hfW32y2h1EU6UvU17Gu3N/xptJ5xrDqlF0PtJeMQHaJ81TsNiv9vtDv2Y/ZdcFgdP1e42ivqfbwU6A6y0AOKoAYC+gjYFg0PAy3OqvNiQB2MrKMgMP8yj8b943FYvHqD30525Gr//MzDQESlKV9jLSY7yfsE0CRbX55NdJxLWy4FEbKKWQZjc/+7O+IhYEqrXsi0uXXjt2+ODhpjpJTk9ffeWfL66lrQa01pqUSLXVE7uggAi+iqAdA9UsMOGhgiMNqS1J3fr7VkIRszrK75VS4p/tUdmwQZt5/57mLJ6atgSNzwwuKh9rfGIwLoFaxr7vZ1tVEaoM5vIJ+KNrufiyKavXKM9gPbufGZj+StZe2N3FYoR4pUgAnhiFWpRmXuVFWaRcDW0D8LR/vAjwPQYAwI4aeAEA7AWox0AGbCgVzA2TGCuVRM1AeR8pbOI2ngTtsNVzvbRNJwAwqamase8lArhlpdFC2TaIpRizIQDRKtC0h20hWRBGhMp0ZdVffl4zMREIr+ru2ouQzLMC7uur+AaiFJjmC6QhDTJ5LsB2WnpNAJsTqC5AOYhnMv+zv6nm1QxH6ba125oX9G7wtIle0AcY89/nB0zMDmsV0J32upXAcGfvT1SEVj0AKupv/JS4jHTDBfyUoukgUSz2ehcmqR8y1FJ34Ad5GE40e3k6dnXXVs5V4k4B/kjVXhfp/BkLrqrdNqC2XyTA3xEAAHZUwQcAOtkD4HcAvSYYH0g7LycEBS5ir7OTqXjSz5/62SBW9OUJAHiRP3cvEiQJ7mrcsbB4Z2Ct/IpSAKSkNlgmPc8caeGWoBvnXDpy4KCnSJdxptfPkpJSCoO/8ZAU57nD/dKo3yvw4LH5DqBNW7OjqZeKZp4GqAOazj2rX6CQe+C/3M8FE8IZNkD8uNDWegCo5fRffhmAAfdKDL3LlDEgTSr9qx2KbFqh178F/Yzj7LT7OxUQrUFyxA8lNC6lB8Y0Rup5k+0Uu3prsqwSo46DDt5H5Zgbaf1TPgKy98pKul8AAACAD14A8AoA2AvwuQAy8AuQPWD5JgSDQmdCQjAwVACsMlhTAgCodLWHBQNAAMDWZ6YkrBwAIcBTDiigJLUkbOjR8GTgUEBlrWz+6s/1RaTFRt9/euf6+24xmphjQYELfhpjR/+UY1x987NytkQ9345QEyG4HaQJmGKBhCUN9Po5AL5OSMc6BfsTN+3cpgky0KcnsdX1Q8gjSGyUDfjXAPWo6kLdRYypwgxkAKPxK9q1MtBkqPg7W4FqoR6p1fk0AnZd+zOHNulGAH98tJ2Eux/rI6DlMGglxrZlSmsTtjtROtmHfmID3jclcSzS/JkfRRCSr9BXlP8AAH7/kQGQdiyCUQKwWMDAYIDbjkMBgAwMgzTQ2ACkTcAGoIgUSAHQZZDargAAWADWlwSJybnHYkMcyoVrYgHazwFg+40kQDNLbp5v/X/bihVFlFMr7e1p8v358jcZm4J856IQTE1k5i6+N1BxADyEBULyw1ndT3MRj9EBcAJ8BkMRcdBRWUn72XRcZ1AFHWhFw7onaQG0lQn0kyv3dHQnzlPxdcWHz+UNML2oqE07+qeYdG1doPYgfk0oCwuIuqg1qDQHiUlJTjS1e5QsSIv6CgHkr9GhApyEuxVKuTCL87Nil2g7MERvN0XONLOUB943JVlP6qP2MRQ8rcQvAAAAwI6hwTgAWOwF+DsDA5hMBm7DJFIBSQCbA/KCAiTA0ww3108AoK8SuTQWoKCYOTUGkeTNwlqyM6EAvIUK3+/mFhglPSVRmJ5sbwc+brGkZjWyWi48vnz6PtipzUnk561yqQoIIFpa9WssUCrgbfH/qJMvOEZeaidcNktdIPi3cKIAIQVQWkMA/D0EsRjLrmOXRloAYUe02AxHkDC0vp7B37QoABvmejbDIcrKwJpr6j0YXbM1B2AVOOfoIAC0UPUBBANWYVHtdbX5Bg3wNgIKAIDMR9iABBUYnxxOd9Z7zFoT9VK4gOktOwA+OIUyJd2j8TGkPvmaZqxu/wEafp8dAAAflAnAG9CgsSfA1wO4AgDDyQAcAB6CATagkNQBmwdyJAUeDvrStYU3AZzlC1jpXU4nAQC0utLyCMBIwBLSPA8AByyAhMMHgFJRh08fHWOtt/htKkqlKoyrEJs2KR03UOu9zHRfzPilNgIUCpoyJqkb+8J9CZoV1S7I9/fUx92BeTMnAiqAC9jXlHohBboXFDwBLNMCsFEAQKjxgFpH7WABhsHd+W6B4BEMjWfAUcUl8Ah2+kHj6YDcOW7JJsiWZcIBI+At7CdSlKV2dAErnGjzEgQA8KcBBN9QT+PK7EmF4QEBmr0bAL5HhaKVQ7/G5wBHVZk/AID//pEAkHbUwK8B0NgDoC6BA4CejOcAtsRE1wR3wDkAgDUF6gFQi/Jk3QSwqg6A0D4qan6TLjQUFk82rAAWRQag8pQCgKiI89XCR2yaWqDSdopTpDH0FQW4KR6e/L02Wd3UJvXwxFRXKqENs01o/ulYvD09a7JQ+PuLAtQBoFAArnaNQOwdXCjnjwlR3ID6MHq2tHLqZfqYUOp05g6bXQyYh5vJ7CyMMtDGZrfSx49OLjXQ0ZJvCBY5zIwHcCaImAAMuKoJ4iMSV7FhIbVvrSjkebpptKXAX1WQpTMLXV7GkcHGOBOjhwLeNwVsKtM5xmtwcforsb8iMmj4OzEIANjRwA8ALPYA+OcBGAC8nQOAqQAMABvQBBfAAGAjA7mmmv/w+S1C/IRrzDqI/QKAIOBm2qCKNNBc1BQBbANAnNzkAFJ2rUMt+/LOlZY4ihJo4uefP6+nq8zo+lQcaSSQrotS1DI8Y7NxWUFmGdYVARd0UGsoFMBSOLw15+l1AsQFKAAD4E0LKBHgi09igMyVIMpFfEVKVJXDnvXFbN0jmoF4IORjvif2YC+Ckih6kiViE5yTHmCggUnnKawZXI+v+2D9X4tLhkLjKq3+g6UC2hDbrRyrGt6GRa0zRCwkpJaqgYYAngcl2Fhms7XHljSHviK/AAAAAP24A4DFHgD/FsAAPyYduAbBIOiCJ+BMAGAeQFNgB4DXAXx4AwCiC6kUbVsSENyGBKCSSJDu5kVSdJCU4OotYnxx/D8za8k0DGmr71nntw7GvqiAAjj46z2W41EhxB1aVAH4QBRoTkJgXVXo38aiTsARL9eS7144LrQMWR5/Mn0groeRTeP1hqZT63gC6AoMjWfxQbWU50xcxgQCT0cNZc6riAUil2ZdV6eRbtt6wVp8/RUKJLImT7Tu+D0KEOWVYe3SpJ0yyAaAUaGcEoIhZwCipD+1BReNuNBtyh1VKqHSDURarLxzlAoaVIENHihlYi5sn9Jry6Rdw/61DOCZBAAAdjRQBgCwJ0BZBcjAFDIARwAOHACosgGF1AbgFAXa6XNr49l2RGwf5PwKCBwPkACwlsS43wyXqip185TrANETYi3iIQVQBCTscdSwh5TQoiRRGga/OrQfY2pLtSscjwgsQoeeLi41ZmlR0DaWseVlPE1NrN4oV8MFdC4AuIOgrnBNANQBL7MD3yOOrz6NnVaQBcR+RSQAKAZjyutCaXp8qHi81hHDiCT4UWUv21GdaG9lB0wIgHPgibRpM6tP4b/zgvEDpJyqrHMehphwVZuKpDntWiQlkF1oHu8ZklrRWu+LAaxaVgee9yTYXqQ9+by1leNV5hcAAAAgy2kC0Oh3AAAZ2HWS8wCXcACg0UmcB5igERSoB6B3w+XUBIDmFhBCRaqDujJOCWC9nQEQJuKxfdmeboTzlIa8swOtsbkrJYRKb7eWoUWSq0DETRRWc1Ca4iUCHnonTaNwajwkuQKMXsqOVkUG0ZF14fScNzit/n6ZbFRTKFbqJaXfC7knBNQRGIZxkMI3VroXAYJuoPHas+9MDCnBn2nzm28mZ/s+s1MvV++TfE2pw2FU75eGVMzBFYzMYpr9/wLACIapX7OFUAaPP/zvPGj4ogNsAFl4Z1hkzuik7aCZTTkbtOeqgkgL4icUcysAXuck6Npkq5TPI+E4SuyvFGj4PQUAwI4JbgCAfgcAkIH1MRzgPMCBAWAFGkkdsAF4mgIX8o7dXX/b1Sj95ldDiIdTAAAM8+U7CxhRy4vxpg8WUhECIAxAAN4UAUxZG9KW1YXP5/bVr8svoyNxRDvLSmUDowTtvluoamVEvC7k7nqapBJBXQodQT8rOADCSED4lKu4GlQOIQsAlNC/RosqZmIoMzhr794G3wpASlNIDMAD1URCghFM+LglYUXDnIO25eakWcvcICduhx7ZKDDyN0ACKOyS9DuQU/Tve2y2sux8pceykYA6/FfM8jS3yqo+7kY6lngFUfAu8DMI69A5AL7XpGJO6sHH1jApTPsnEk3DxxkAAOxo4BsAiz0AKqpNkIFeSM8DXEI3DxQSXeuYYsid/prGxzVq+/TCrLV6/wAAp5lf59GkGoUrDkCtspAlwTUAICWepUGtE2NFAjRwaRqXzS0v25dEQPfyO+CT6igloeljNuRfSSRCQVHRQCV+J1WNtq7xIIWKwCdqsiC6fYPkTgWbJ00W52NWmtRzt4SQ5rciXE6gBB+RbQPOrYgNKqQT8i12ne1UKKwSlTmzn8q+oiAxYSZCQCeipY2XwEOr6B9yA1LpLidr/4I25dhuB92eHBrdaDed3IrVGOuqR0g4mxSJCSQAT2dnUwAAwJcGAAAAAADZXVE7HAAAAEpbZ/YT8Pfs9+7c6eTZ4uvR3s7SytDO0J7HpGJu0nIeg4VZefoFAAAA2FHAJwBAvwMACMsHgARpADmpVAsGLhJABZ7uBQCMTf7MqAijO8hBvpWQooVVyHAJAJ4VgRIJ9kh3tRYCqsCYvNkbkRJVoUCCiT4cBPVbecpFlGLp08ViTptErmwar/8mIVhShOBTEmCEEf71Ihu4hADQG4OsXgdTGSaX3ctV1ZBAUjdq5c1h43Zxbsp+g/WHnUCnk36gkL2W71l0YcwjTDs3SJ035lqfDLoMNrr3ZoBkAt8gP3cAlY6hhHs2/wY1rvVaL8383C3pFmH7RN1gZbqba6iV40hoG19uB9nRAf7HFHqJWS69kkDK6Vac919qM/A9AQwA+nEKAKDfAQAMoJM5wDkACRmAOaCR6kpT4M/9s0/ZnGOD9vwuJi1hrJkA0BQLC7CeAOpOYwHwPACVHgVt42v2Fwua/KiiDBzx8tJpH67sY8XKaRMVBNVwtou3ysBLIgCuKvyHEukQFToC76SUJDuqSBC2sATBhUPn7YvxbgQYzPHxg7GubDveU4CgEd2q1oqXCFUKznCVg6C0Cz3ELKARxaJIvT4i0fqQvAWB3a5XGt57MhijUgBx4m2bG5QqEv4kjYUoadueB/AO1DTxXHQjRmoN2eiVdzhDHkGfy8tHFQBep6RybtIS6bNwMUhR1+9dBST+nsPfPyoBIMsiAYA9AcoqQC9wDuDBAAqNNICOmSkkObdB/8qO1THzlwPYWW9ElISWUiJpjj+JUbDOUWoJ6hoCC4IEhJhu8SACNEtLllJZTAEQbdV2s7PrbHopQAl4XOjPQbR7WidSToRG8Rndw6LWclcBAAhGLPRft31bdAk2Wh6VpCyavQSp9JlAae65/iV1RRwZoG30Iq4yyRRMZAIeQMOXGeU8Mdav7cLN7DPxYarRANDigAQQelFO9VfHmZRaUe/nMVi0I9jjvSV9wn2yTGk/bd3sWQAmAP6XlHpq5DTpswmkPhCFdX9LGmwFAACyvAEA+h0AQDjzgHMAgNQcgFQbBVP03pyEha+9/HAU/JhsFOEyFAAs5sCDQDnqMbYUAG8D8Du5JkSngJFYCz9tRDUuhYKq0eg/LLoTRyW60CkigLwFJzg/SkdQmrSKBba+xA6uT+TtxZAjkZEvCWy8dy8vAggYVK2ic5JaGU8XQD9IwVQZGLvWslO61luI/Ym3zaSsnUoN9VqldiCFyr+tZRJL/9EXRIRfYz+sRV7AtOIBCddLCol24jA75lF1UrkmC5aUuS9cGf389ua96dodlaUoBjwxHP+yMCgrNw86MwC+hxRyClOkjyRlDrTi3v+qAXoyAAB2FPANACDkAwCktRFAKq8raqZ4FIiRXE5ejrhR726YWaX3DQBwT7bHiUoklOAMTQCwRQVCcZUQB/AmAaf6IHBwjyrKWr8nl0aIOBOVbExFIjCBk+3mRj4SAlyZBzGUtg9iZf3N/q2UCvWs9hNXT/YWSHdpGu6oRLuStbvg9xQR8F8baoASSIs1X8JpEiz/ma7hAKconJlfQS/kNvtPAnkWYZxVDtH6T3Rx8F69mkjS6Ih1YvPpLjbRtI48o7YuY5DpZk6pGH4EDQUZuIOdhFx/LaugaZpmw9MB3ncUboycwoOCWeLuL8Si8TEDACDLCwCwB0BRFQhLdaQTTisG8rknd4s2I+1sd5yKlfT0CADAyXoChlKRijJ1IArEOrjMiBoAETBxNVVVhR9GjR+Zkk/A3d/WbCfUZF1A1Z49xHpYNqY62fDoVEtqpA/08wg5rbyJf2c/Vft0YMhMknJFjCz/Flaq9TaoSkK/gkZSgcG4CEFvXb1fynfLwZmXtzJaC4aBdZeQu9/mqNq0os2PnU0dNDKqjyrWN1KoffJ1jtGNH1A9wbg/yTMWUwybw89+KmbcqLhGAj5nBGKKXCQ9goJDkXz7KzoBrkoAAGTqgD0A/rkEKu2koq5ECIq848+oPnfbMApiB+dSg6VOAoAlk6aOI0utAyjnACmvfh8UqAVV3nOXmvEtoxLZtoUyioGw8rfpn0caET3QZ7Pcua3LOvX45dKVzn7u+v/ictDPm1NjJOImubvMZqXroQXfIf3fnsY9G3XZSPwdcUEmzAjWYUt6DcbIIj7NzG85/sTrH+2RwGYHpYRY0fLx+m7vY+Uw/SMr0jrDzi6ZX9EvuHVSAxQ6ul/ges9RyTdJ0gvzpVEN56Mzllp5p81Cq370KDwA/lf0scU05BEFXC0Lvy8MsFAV/vvvA4BZAPYE+LcAWn9AQMDqXKKZ4t39JF/74dXrzniNB60qTg5MZdxWoJRywWiOpXUkUWWqd3GUUKsIsDLqAwWANcXo9hKVogTtCtZMq2pwAVYbJEyBtTojUvZ0y058BvAg5wCOx/xPQph5NU7+Udv0WKI2VLO4PWTEkUs+ocos1ailaQ8bRA6M8g2QQTheozJY1u4ZXStCWNE5Ss2aS+WitWSXQTyamAcQ+rxXnAPGdAplp9PbLuJY0OiU+smyDAgMMNvGu+3tViqJKKOKXR4PXlistYROPCqo5dufAp3YEgAAsypgT4CsAMpLTY5JzUyx/oiJIHJcYA+jR/mmoXQ+CQBspAmuQSiie3mDpcRSi2EpKaUAOpMkC7p+ZITvRyolEev94qJESjIG2mX8ogkZDJW96xLWdaEgkZN+NEY7MR4SFk07MgfdYk4POPnSx95ultwy7ForQaenCp991YIllagGtxS0Nit7LhaDCBoky15/wENs5X2K+D3HM8RFl7IbsD7tZlL1fP+2i3K+6M3Qb/SpFqzKRWrMaazbNckXk/F2u80tIw7wAL5XdKZETmYJUkqulkhw/WJ54SsAAIYaoF8B/lwAaX4F4MjOKUWRm//468Kyv93nB+L/PizHawIA/i8PGp1EIi7TkXIUCaQ/GChyQEHEaYnvUwleLkaKkEydG5nc9n3fm62IYqKseOmrcWrFVMnLElI6mjftudgULhDNZvWuZkHJRo1MHRQxboaK8Z5UT5WhaBXIV8cKI0nQzXGbcSxzZkFC7FtfLHL0BigklrU0x/tZDuxp3D/s66Cl0Kcd2Qg427St9xqnBZFZYceFuR0fKLXAxZru8fVe+GEzr35me74dehv+R6wmRTRCEtFKQm//mKBBDQCALFwAgD0BvgLSanU0xjAzZvaDl/GYfXPKhIdfccmLp2sBwKeChyM+FIktiqKTnlICWY9Mk7gjTn5VnSBpOSiNaiWj2m1mHB8G08tHkU7wQox2ckd//mFokCNpvp4/JR9l35ClBrzkDPkLF3L+sHjlLsMfZJTQbg7d5Wp7AfOSNU4zALe3DO0AQzb7evt5SFzECvKpzOZZt9e9iw1WoRYCIl0r53LbWJA/eroPMqwcQxw413Xm4eqIJBJvibymOmP9lcsqeumD5njdTKv+V6z2YUnlJalNjScAflfUckyVgADiu39SASAaAIAax1IuCtIJpribIe3vmUcD2efp7Ltc77EKAP4saLS3EnHY5bTtaSkt1R+c+97sAHxBhYzAR+MoCNMYPsLnctqKGUl+Cw1Xqk7PNGcrrtuU4hxJnoy4iB6YGNeDQpF8/byaMD/bej5OgCPS9KkSDFzr0b5OqUu/pSyLU/YsPFUsQ8P4EylzyaZpdAHNPiSvBv43ccMIQgzdvix8XekW/sTMBidSTV/RWrRLF2d6/97KHySh4Z7d7ptrLVTVg0YOvgaeV4xujEQQQbJ072qpcDx3AUDXtn75VYnWzPjyzrYnPzizThLb7w48ybv/e1wHo8mPV+KktDRRsTnP3xhHYcuegdULuTR33lgFUZ6EqDuQOCg2Xe0SciKo6tDVyYxsceyLI3ekFLg3rQ4u5xU0t+YwFZigIwKefDi+KD7OD4rjD1UJwc1s3T8Atl4dP4bEKvcGdSSSYiEmUt9DyxuZDlnORNbHOzNnyR5pRM44aMAI3rJLNBR6RJc998JpNKfpXIeUtnr/Cps1HougHluiR5nKc5lrq5C07FboenbUkQA+VzRpjHRmjRKSBHdXMVly7EQaAGmTlEu0Y0sqitTV1icfUvwgxsMXxv9EW49azXsLgoneWxZdTmQlX42hYaCMP7GzrSUQ3mrJ6pIN/jppQHq5jR75h1BglPWSfMHzssnjL9rNOw0jysqC2KXLkw2jphbXxgsoKPODNU+tlH2wzbLMSB/xpoh+QBK8Wm+1XRMEZWE8OUj9P7CXpUfUOZCVNunifGCvztaCksfaS91x8jlkE8zshpC1x9llsY15ZKrVKoShHqLSF08JWly1AH5XjGkKpQCwd1WKu9DvBQDGmrgmOqGNYYpX0h45cGDySqqu9p9tfSX/HDeVb1L6CUoOQVKvdw8R59EUxuhEWpKKljP12OR8gq3YEPpd4ouMlEZxfAJHIJOCZnhZ58ts7VuB8qmsxOZS+UXVyTGt4EwYgUilS/Qo7MOlfV7ReIf1pTUWT9WGntTbPg0v6wtZspOnWNr71q6a8YoqB7a5Nrgq08/tnAN6IGwRFXR7yURucGRDu/t4XWD7+sewvWyF3IGwbEeBU1Y2teXtDTuVR1LKBh5XjGYMJSBgYX9l0IAU7ToAwLgAaNvRY46smLHOnU9+kmXr6LqcBKr/HcXbSAgxaIRdsiIqBZwSHRB1L+MZUihBs4FKo7P+pyot4VPirM0qdNpb6eeoNQO+z7VaT3j2f6OAr1QW4P26DDGTlVTSviQRH4RbojMpLDiq6V5cWknRPe1Sp+KEirD/qLJE/Za+Xoox+gXkqZXu95VF6fk78iJWE875Ba4iQSs5I8FpsxGg8XPJaDDNNLD6aisH9Pb6fgqbiwWdQnwkaADeVox6SoWggiTW3aZkPrISAIxtWhWN0TpkKc5ufyHJAXO9eVb6AxJ/JAce79k1KENa69KSFdmLnCmuAiGceS4aofs0aoHE2FsPWqH/CJtkJg+Frrc3zzoDM2NtDFz8yaxMRyA7Rv+maoZMJPj5l0Vs8tSgDncuokZ8z3pB1yUR/JVL7DbmhHsitVWD4FZxzZTdaM3g8h4NV4FKtUqritJ4OGhIruilC5nqGhYi2rEbPXtZUinrSkuWWoIc9OdxSLCDNULtK5V1G5f3BGiUjiABHkccyxhgAFjfGw2wsKkKjK3stUk0pNbMuG7/dCdiYyQ2ETeomO8r7zF5brm85W5ibhuwVPaGcSOfLuTbnigrXT0hVxc5ssSsGf6lmemlWQnCLcE2iy/QKJW808L2u/ONLO4VULuZDNVaiipDURQRFKGyl2JN8auJNyOiEDT+CBlRjy6j1sp8N4823TTUtSBK9lWTuq48BHTXXDxVidyotI0bJqM5LPqucbFAtGg62uUSrr2MaBGGdPkhsvMOebQ6U9xbtdD02hXraA57oAC+RmylhxKQMMZ8vY5+seEBytimbasdC6GY8bX5hSkP2tveOZhNHy/apuYf5l5/IJm6yhuTz71/x3aa7LfibD8wtDmX1CmZwHCO4IoVAWH/9yWcnIW5QxlisM46r27RFxly76w6fkkflqgXhvxEpL0OtfbNVIop3Nl+L2L1KLDJhwBVtHCXSYudif67rAnQblRQ1qkURVFZX3ut9hRWyA98/9ZoeaXPnedXdiNPcoK1Bo7C+oi+Du+oTZx2VhFKWtSurVTXQ1mtW88uAtH8AyYAT2dnUwAAgNoGAAAAAADZXVE7HQAAAG41NFwnzM/Mzc/VJygxMjPp5OkqKisqKSYnMjY39eTqKDk2KzMxMzM69isn3lac6hhcQQLxfMPS0e22ERjbpBJnDLNh4Ifdocnu9uD/d+vMh7LH7285u/310VzInd2aqB9NZBNtp3qI8J6t0+QJXvOJEe8GC37nNaUpiW+FmljsXOZROVysXTvMAwiLUz6pdMaXELjPBPcgKbwH3MNCOVDT0VbshGyruPzM9rOa1ICllKSkcrv9BZVsYdpHvXY/serkkr5j09qg7VYMy+F1I9qhGpp7s/Q2JtuMVrJX16ZO0/rPq2DbmFGPCBxs/kpH5pZ76+fWFeIGPlYsfQlNQQGGq/+xzB+gr+35rdNaaKco7t7fe8+Pn/YW69/zlMHrT+/O9E/i33j70F1/nj/ut8eWnj2EgAa1nYUnxXbKdy8u5blx+gsGFIRody/KEpvw3GQq+fi716No4rkOzSYbGtNzGslo7G6ad9UO+3UeEtHqrIpszSUEQscgQieqKGnVt/LtrzWYzDEiAgMfgmqm+xFxlonWmZKi++C4iMlOJg8FZh7T4aE3LlGwDMI4UPsITEEVZBhwuILvwEXrQzsho8ZCjpzKooMNHmac2pJQw6oB3HAmUgLVjFW+U8ylgHjsez7Vp6fyf8r7nDrzzxcbGV8cOKiPg/f36kJ4pVaOuNAGA/rS2ZMQepSyPL3r7vpFLUaTKtv9WoX+tcxpzBWCzD61JX0oL7aAKJkOB6YGYVI/8C6QT8Vzv6hJPfzazz8CI6ce3tlZGZxXlp9Zr1a9H7E+UiNADQZXkVlVMoMwqCrBPwj9QvXBlDBRuBnnN9WlrtaacwOWDe7aVwtZwAwZtd3IcNCU4mMpPRjfRzhxd/Hq3pTyvkVc6nTREETHwnRwywTAmIyVyJ4W0TGws5/rme3gwTRX7C69HTqemObTV3d03QyLhOEuotuBigakINKkic7NbJq7g+HicCknYhn3VaE9KKMcy/TfzOTMI9GdtnhvSmYnDHWoNsz9YPh4D/Aw3QOSA6nJ3ibj+/fog6HUHvNqV80a6P8DBkGJhwcfyLCbdgwlcUknjgk+eWwSoyWi2vPXos1FMqI2YjAMFZT5uQMfWNiHXxV0zJrEDXkzLqKLIowxxVvnYgkBU2Yu6xwEAJ5GLMIPX8WGnQz52j6pcwUYx5gmztNKG8KB46m7rwYe2KsR4+6TmT8948c/bXWyDtcvzTvNy1lVypx3N7qSrpbdU07tioiKo9zYFqBp09k7odgiIv4nxaeb4z8+IlCqV6bKrPc0mZ2AdZRxYY29BcFUPqSAcurZv/Hrpq8X+aZkPFiWSlSEvZ/4cgXkSJMMgC7qtY01dYrqHjoGw2eCEqoH+ZshQBmn2y6dHjJoa5sp9IOiaSXDgJ4JMcIsi4lgESshZb+WQpcmZhoSGA9nDfZVhCL2vCegQSq/UWfXca4ZYmhlTtC2FW6drBRrpph9fHOtRzPrfbiv7T9O7QfzxbGLA/qk9xpzcaNyZy/nd0FbjEwwc0bvHvEKi94a7n+YLo28MiIV9sApvxG5/M8zruhckt++Z8dJ1dt4V2fs49ELaoTl+AyCSfKqm3CKMjWolfr96EoBbdTNFgw3Ep9FlNAe+onVKlmI0H8TAiveN8+NTvk1mX8azzbhsOzecqXRyhIrWyIBOe/vfYdZHLapFz3K+eqx7O8GKxgyl0sirVko3hUACrT9sAWCpbKBN1VCQkjAW14yZEtpJcrSQJ2KkqjAK23iMC1t89DOAcwBuQFF1IqtXXEqooFLKPy+jBPRVge8vPmwdrOr1R3Ic9vOa9fgWQq0BaUDytaODOscf6cAos4cyvdu3JAuD37ZpFbNvvm1XS2Czl4ohStl9Gu5NYDil74AvPkEioidOgYUQv3qBeDxsBCeNpowIzeeDShy/tA/J1/Q4Xf9YU+SCbPDs6HPhpMEEEy0/Qok9mP4TMidC6Fd92+wGOwQXCwMaF/j5ohS92Y3bsP3eXH7u4mei6qgaZ+TBM94mAWaVrRBHX7SiJfr1fsdLB/y/sriZY6+q466w1Z1AMCVGWAlS3oAwzCUIAkKiCGikFBaMVqXgw/rf3/7z//3GTG8mCufu6OSrTW8w46qSq5fLtQxRwTpd99FqaB61V2/kba/aaHBASBOpqf/P3j0/cHUyobrbrmfbEnBgyU4GEFXhqvO79SMo0ARZ3q/VozSyFNyKVAqOItJy8OPdOTDz+6GEipUm0lXNI8dDql5QJE8bnERIUNGm5yqCXAS4mLnXnRkjt/3Q0NUALh4mSSwtIMWCGbjnlx3TiXNhvyrrL19MZcrFVOZO1IAAr5HlMAD/gHAe2QNYmEEKEMBm6VZAODKQAYMMfhGMclaKWTvOK2CFRkVy3+6azg8Ns1X680qnrVtG9JnDdIwUXEk4TrxMfoI+HiiSSh7+s4zVdJKrJAwakn5mPbBvMRNvCVUms/Wf+UIA7cmnDkWsGKZ2Eipi8H7eqd/PmO9EWJNaej82CMQN1N/iXMeVgfnRtpiSyo+lo2JG/HfCg8P4yZCZfcIhm9xp0Tbh86tlXbSVlypiPEkD81j2jdDjPcYF/MqypXyU7YCW2CT7ypfqjhnbKwYeWi7XO3BV1uBjYhRcde2BhZHhMAD8YEOxP+b+KeO7C7Udaf6FzQgA0xtBgwjAwTjtFJCaYXigHlFHtemb75nD2Y4zZuX//9s5vvBklmdMtP+81NKyBFVNNxkml3cxTVVE6lpf5kE1yXni+r60XglYZ+Z2cJO4s7BBYieQ5COGI0QMoRA8HgHFzRNCBPFEMMF4fcyV4pFK9AN+hprBxtlPptO4frOJWVkQDt7zLLAoPUVGCM/wPhaRqKm8Yw5BAuX6NTmaoPrLY5k0Z1L7d4kpcRYoTxlZezH7YgtGgkt6znafYD5sUQgrXim4tc+P+DrSxnTjXeYvSsd/PHQoGkyU67VUPv4AlKy+HMVWkc75k07UnUIfpe5cIUSBdVfrj3I59EA7PUoZ9QS7uPdYPvpAISUqLlo4TsmKSYNkMhV4OXc0UdxTLIs3K0Yn9kLHPYQxd6SSylX8dMQQLnE2IvBVLRiwBPNBFstPEuJ2E4ZKewmWnalLadKAQTyhASMngTSYZSz9nFgcDz233nmmAw7poOKbl8iP5j2GJMljofV9d+AAOz1dBVYZ3O68PuXDRCkxI1cSionFombN+wRy1Eb/CSdO29tylXSjykA1PU80UDmzcGb6gsYyf76W7SVQXVvcYqj3T4hdZVajjDdPqfcFhO08QqcPdI7BEjxthVGxfDl/uWelIkeavo7ULuSmpULnlDZDkJHeggk+rADLiMgkT5hgXQtj9shejr5ZF+uM/D+fKpareO1j/yd6fX99NK6tLz/LEqftNhOALz5ihB79u69kDAVwvPJElQ8HDdPW7LFuj9WUfHV9v/O7bg2vP8v8X6kE2+hkIHtvYzIksINCfwRfVLZDY1B3M2sEMx6ZgBXDUa8u43tCb3dSZ10U9r3q75WnC9+E/6s0nI8mHqNWk7OhJ09rgD6RySEQcj52xbdJxn/SUPi/6pfw6CNcm5H9H06pQW4ZZYA4IYsPYCd5ylIgwbChDQUEETFJOPm8vboqedC47jj5a0ww3xHXcWkq5xEatos1u+1S0UlVVIqmXYjB0WzI7ZWIwcNnHzzWQOIA2ittS8uzC9nr1wKMcaDMf5NRiWCoky1ZfWCANq3hoJX7949Ho7JtGrZGjVtNpq1tfj5eREAFBeG+0AWFZFhOYe3kBHsUnKLdfHUwY1TEcSoUHpzEpscpoYBoB64DeWZd4MOBlnGRhKGqclUUZ7rL/2z4MauzuUT/nZ7hh6+ZRvqLe8cP52Y6aPXOn44NMABuoMOI/V7cS4CluSVBP1YACioYOgDCYbf41srZKW0gumiedr32DbzEFXsw/XK03yhX4v7frbfvOvBTE5pIS2IzBA5+rCiGu18Wcqf1ePTtApoaLET81pm7nJe7oLdA0NP2aRlMy5ZbFW3kICkcO2tYon66ZTjGlfuikhxNRtbl4/4FszakiL3NMGfJEbT36ekdfmbtN6LA72iKbZmHkIP7dNZZZcWTisk9e3N291hq2JACdGbf8D0rTc28B/XFfN8lTCRw2GxIfa8y6Yry2Qu6KEHBD0VHUn8N9uqyqGiAbY3RCACdYOMgei99Ee8nee1mWtNEAEGoKgBdDJgOAFPKBZCKyrfYlZWpwZ4WcSEK8vz9EeK7fzmPj+/d97xaQ9vsRxtyJC68FqvsYssrJapNniYKUHQsyFONuY/ZjOm1NR66NK/s5eM3rANjKzR56wqZxV2vSpYDseoUsOnePV7lItKupiipJEAeg0RfYdRhXpRlz7eAMi24t/hMDmfou8cqUn2Xpu5EcLrFpIql+I7tVaxGGkjYq8WMVRWv7n93NuLA1o1EXCbAxMGnNXW0x+TW0MSBu++UcB+QW63kZOC141RhZOaXiZuADTy6ERO/J6UkzbFDASW/D7S4z4hufm6nT9ledzFWS6lPFI9dlxKBwrk9WjnCcEYsBFunVmwmDbNWZKvzWSCsTLviZxV/Nm+a35uChnPm5fl3SlwkoW+5i4zOMRrwYL5AQD09bRoQAhZZTlg1ygSGovl4mLRKAh0OaPD+Dhy8wWzCC80kZKues5mB7qydJSo+w5Atr4sKgAcBimnUNyaFREmB7smbQBCKqbkrk4kzQ2or1nZJURFyoB/MtjodGlCbKUBxPEKomc5wyIP0Jcl6XI1aNujQfo/6Z8RKe2x2fRVtR5XbrrE4Fn0i1R2fy/fi77/qocAPOpglBDWiDSHvvoo1zhinK2ZvuNDpkpbcJMystggn/EHzX5h2SELdbH/RUpQNLXWANz1KGePgMmcY25fBcqiy5+M7Ibk7McDfckoRZJptUZasYV3Iwcd5ziMf5WwcUvTvaJrABT2/D4gV0HDAnj/VwHSaDEDYE9nlfv80tppbEN8umD674skvh2iW24wDSI6lzf9fBgsCyQGmb/2wYM1d0pwF3TtmpABHA1aiirmKbl26JwF608nZrYnE5HFP1Bi4QZ+LN1BVXnJ+MIT/0vbVQDyN+Qwrnki8/FSTtNSrLi0vesllaPX3txOwjZBTA6YADKgcICpBgQxWZq1VnhZf0/D/xv/XjVfDMSf3PSD/vWmtsKc18mM1d4MQLXmcXY8eHhORwGAGPvZr3zVKlKtwdT4PBeYEGMUSkJSnEq5mRM33UYFYm0ZJh0FjN9n0b2qQCJL3b4y6yZdx+qLzOB4Ev36IZUPCvDLON7jdbyOIkvqnSpgnnLG3/mVPHcNq8ax34OyhAjkpiLHvIM2XolQEPlo3wxWhqKfECSIQyw7DdR30+wIFRzHwnK17c54RVWNlk5H9LaO4zjuw3U3pvQ1qkWNjmbMCAAM9vROGSVBIMibkwRxUFQcfuRlzVIp2Y3WRR7rsW6JzF13sB+RRFX+A4MU3PGKpT1Sl5NNy0wFiCAyNO2PpAx11660k01WOLl1eKezVsSpyGsBT2dnUwAAgBcHAAAAAADZXVE7HgAAADndOwotNTU4NuniMjI46ScsKTcy5OgmJzI3NvLk7SknJicpJzM4Nu7b5SYnJygpJiUzLPbQqLXM6KSE258L0IBr50PGh2MxXGv1z044Hc+nQrXEW98/6n34MMfjon41LPBITP1Y/wAk9lDJbFmqADF+m4F041YHXFdkI4oz5R3pw0r3XQ3+R2G6W6FmaX+r9KeGPEDUZ9RMNrXsAPT1aGnclBQAAeuZAfQObnoGo3rqGVmbuu3fTWXalLe8QjOHLSZd7dy1J5Ix8cy9fMbJ7u7jNgkAFPIUavcYyFS3JY2t2wIm8SAkBmSwqilWKzHJsSLxskYjJNtwADnUuVSmY9Kfpo+LgbGM11AAWmiU2FRArAD/q3hTeFqEXRF1V6ANwKADGtAIZ0BHstbWKMGMp/zVOW7u0ayQp8fklZnqqlxMebF1tQz3nD2+Ni61iVs1xgh8b+xRbVHE0kUx3nIZFZDCaCpyJ+NNysfU3nDpcczbnnBp7X4RWbc1nJvBTYPCENesDa3h4Mz9QTpYC3Skl0PRpVU0UeklhJSuLXyeeqQgAOcW9qLsUbyZ/6Uk2R+oiN9gGSPbtT9R/Q9t5Y7IXPkps+JvtPc/z+iGhoWgGpI014vgKra5dKkoTbSL0s+dTRUTSyhZXzJn5EWL0SffB8ndCQAWSCRwCgUBkPjfqTqRLboWPW8DHAUAVLgXDKOENEYJJRSN0T7l9L6To8+Lr1+PO6P8e5bffu/RM5thJg9ZLqvpGz8tu5Zri3jRpyVCckUD3i7nIrEVzvCjfcrF5II3T18MJv4MvQHa3q7cgUK6n+QSLxYzGlqaWfv2NynuEiSCFFTXeJUdBMBfSV+fbzozd9WLfQWdaelDJHr2HK3bJCC9Bs8FH9UYlJe+lW2Mxk7vgZX12cRroBbqpUS2lblX79DKhV02wPAfnIA3qeb29xTnecLCLBotE95Q0IXlrJyNDR0A7P0EZ9iUSHVyX71Kgy7L16nhdlEkM+hYKDv7UdvisMRKLzftgPr8M0T635DJzacWYwAU9nyoYdOllMzm/p8G0sk9KYhnMnbaFzh1tp0P9cb6OB9Kw7HNzlEqV29TsW79d3IsANwF/Vo9wR7ypzaLTd7ahoB+jIpH5t5sXGzD1fk/fRdlo4Xv86h1SwTB+EZ//whjNvcd7MiIXJkAskfkBCw2WeB3RpCgEplS952G5zhdmzvnypb+yAtgmWwANVMFJOE12I/MQlCE283bAwvNyqBZ68Q/xzeCy/WtpmlWLFG56rbtqILWLj2zVOvvZ/siFheHLD1EaK211fyFK19dyr4zWs0LUcV9lKG7M3hIvG4r9Y6gmpOpYgBqDe+/j1vjd6QoIVg4pWm8boZybloCigCYs7vPqy7PxBg/apdSkLuzP1oEshsc1WbXxfHoBDAZ0yQNfxqy4TkwGVzI4cHa2pdizi+T2zc3rvE3funcwAWYml+8u0G7M97/2rNYaBCsyyzEwANUFtEEBEw2+S8jQRxMJU6W5LhNxbhUJhEseKXCdHls5uFecY79qQYE8miiPMGa7oM0aJk7gDT82hmYOrRWpbg0pqw2lSCzVWF6XSi91j5uikvOGuTxvMq+FXfpFPuqHSBcxfDMOJMoWY5vNBjbjG1mJlKPrthKKy9lsc4BDAYhI/cAHrADZJprAdnFG0dWYmFiRNZ0YLqjUMw6oM8bcHi/uTag9m62CPaDSttP4m03SfoDAET+ZCT2oRkY4bcAKkhcHMRKbTdMF38enqS4a/ajXslbRLzSQfsZNWTii6nX8Pt5BO4JmlfkQAxO6JWCAP2/OKZeX/qFJDsuHRJgHQDQHVASrKmUMKLwHJOOcOR2hR9r+GzO5XV6/VG1eJC3cFrAoyeJRRJqWHR3H6SyCvSCEHOIzmMGI0ii5opZ3kGD16j1Q15DDcTHIkr4J38f1TNI0NNxVCWFjuO4uuHulFVmnARD/MxHZK1NrWZ47BBnloqlkmtY22Aem5v1l9gs6t7dN7SNQ2TBQyNX9HnmTi1Deck7eMOXNvD4xbTKgmS/+tq7vb4L249aLJwxbmnX2c5Rf+brB/7uc2QJbNfQmIUWbI7ag7ZofeoBVlfkQWxyQQBm/jcqS/NoKLbnXGuVgcpGAZOYSoMO0pg8G8WInto6NG5a+L4x3ma6kaXx9+WJ5UnefiWfRQ9he66cxKXEinFPshMlIlR1VvH0+c/V8nHW/J+HaRlFAaMcUs1OaftPt5atDxLoL28hUOmOXydjGRq8LmzpVb0Iof29YHo47nO+54IL0qKHi8pU30rwx5dKDnXMcDKhzfQ1V9CT3FxuTnFvddiF1lIQYs5+7iHSaE/GOl44RTjWG0euPIr0v6kP5ZpmT4ff7laWhoBglfy9VW13HSk2gMmMza162LrmmrlBBxT2dEGhUwKUmSxAREU8FfYXYUPbT0xh9QyAljfJb4HUV2tnF6AA5PU8xrZTBpjx1TSQkkLBt82AUK9Q8DNRn0nuta7X4LmHaVjwJWgTLAo5VjYhiTC8+d8AKkXPrOmhIvzVNfpZUcH0jGw+hXUnEiFGtKJzokLm+yKutv9eDAL0DcsRMPXdbaA7ojUswYxh0KJfPpzGhr3By9TFO4fg92stIPRLtpoh47Dd2Qcl8S4k+u6g4GED5CXLmG24pOGNBvWzryohNegxcMZ5U4R7ODpgYzQT2va2F0h9+aomH+rCTVW4pbryv1b4T5cCGmccTqTiygnDfkSnlX3te9v7+mo+lfPuAEnBAFDBQJD9vlQLoTSDv32nbSpnLgTtSe4x/4xJn5v5ZNXa/JOZZDLqvryzbd1jcAVZd1Flmkk8ePjw7bQ/Xt/SWi/P1j8Sk1lvlGw+d3G6YZWqSjs4T9rYXmU/2t7uCjlG+NlbAPBr25t3IxVNH1Mx44rp3a8MtgyCy+ScRhX/EpFunGAD3i1sq+TQ8GAzmSSwolLh96JtcTpWIdaFr+ubKksrfcU5hOEtOO12VTQskvse/ZjSK8K9iRSS8rDMNh9Yt8ve+2eVBUquMbRWrvLFtrDuB5uqngB+SCSBCyAAtLfKq8CuTL1AmxVA2qvoVwmtnMLWdUg7OH9i38qgL3/eZA58J45ef2oUajeoz+sbz1E8rAg1Vow1mTWvMtrMVtIMaPwr6Yly8K/8ku6hd9ge+GWk7SVMv78I62Fq0kA8+8bTqyNcuC9B5IU92RaOUWuvnEjXSFRlklqGakMV+tu0bxeZSlKOXKqZblhvwhrEBQ+IvpfnB8NCQmRDkIiAlV5vzD+V0ziBRDGgyZCX/Z0pVysUoUyUCpREBBQz+THXZBZVXht/ceW40y70NUYTWyNsCQfBCqI1csy8AQCWRwzJVJEIdgDdu17G3fUL8czdHToT7TQt44VjFCGhaLd7lTGaekhD07y79vfce7N/4N+Bb9+TfL3lVp+Urvu/neaYy9Q5QsigDby2COyjMw7ayCOl2cu0CJeZ0Ou0XhUn9VEjoeo5z2/kvvO2Ebwoq+lE8sUioOJ1/Wn7KMCc89+XVWYprqFuBwZEx5HnvNkxJo4LLeKCaObRz3p08ZCNDvXDdfLmLZRGDVDIdHWbuR71+XqepmweIZeP4eDqUI6dUu0Cwsh9xd42uBz6lA04Q5zhFrnxl8aPN806e9w69N0oXtod3KZbSkc3TQAM7nwSGE7gszMXgF5y4NK0LQaW1lw+QM1x/0YUXhoct7QVx603QRsnAPzxfMqGGxDgN1sNjOSmD1uX+bNy/SweCT/8gWzBSnzdy6cKkShsNhzy/ApkoHDTi0yQgtunqU+cZ5g6tNcmetA6CXugo3u50clx61YC/PE82JAAjqg776iBSzYklyOfQtWJeqgygofOhmEvYT7dFmbFjl0AFAZpaJRGlLPkyE41Abjkef6zUQqi79YdKKdYyVxX0z8soMu7NmRErAH07bzcDpQQBDe+1wtwFTy9Hami9cS15TL75NGNA/2vzwfarlipKDDk+fzBrjkIoMT9DlCW5QsY3qoxThEr2hybkE+1dROrytC+NASssNjmApnwrcNg40V8pgD8AUuhkZcZXoNKn7K1AnwMK44dPEt7aLixYeT2TznR86+3C8Jy8KJK+Mdc9juGoU2w59acMBojABQqy9hbs718w1lfDv31ZgHnYujO/pebyhW18fmT+Z3Qs+zR7l71/I97SmXE9kFYj23R7rWaAhp3zBGpHDMFd5/J++8bittvJ6OdSVF3AGPA0AFtFgDEyxzw47wPkAEQSgtmHIz+Bu57Av6XT6Lrpq1hLbv5u8NNkvsZkSFOS9enmm8tNC+vodS8hHJOUrxFP5BPs61lPvvnFRRPxkYMUrgSozln875OKwWZn0fkPCGe61c3ucwRtiy1jouF/FH0/e3cmSI0Y2HYEhGPBbPJmnmW4XOjL+xcxsfTqAVBu8Maps5p1rCF6R11MBiYLvTl1FxAqRooCS/NAiYYTGtV9PyPyy/Ab9oahC8Yp1Hy8BxsAjLkn49RxmL1rBM6e0+lXe+3yQYeSCSBDwgAfLdhiowclKlh1gAZgAyYtDpJFTMpGP++pegpeTBkPJS+efaLV2feJhcsdnPNM5tVmqy05Oh2OW/VvYZeVSJFRKkS+bEYvpygeutL3EjkPllitgSFu9It124ggfRy1rytq114XrlOUkwsixxrfkmqqvYiMkl4YbQPmbs9Gcy7ELfYbaWwv3UC92K8J+eN9RG9oWYK7M6KFkBuKxvI+q2zUCDhIUTkXDUrxOWrPRZNvELT9jnNHBXf4xal4N8yFfSjVLEDeptRzDRSbgSP0O629bq5vQl2V7RhLQYEJJD/d357+/S0S0xrHb0nSNPU1zF1mrVmqn637rrZ5oXFyOCLcXRzY8rH6c1zcvl5yD5gYmYv8Hr4Qkkn/qmRyuGMZpepjXhYQVWodcyHjlDSb99nrYtAYtu2xHoCYLDL5XO31/j0wJLJe/DwNUMoXrzLjsXt5506tiW5iNfsqn20mZSj6qMpd5UNN/RF4ud4i6OYS4EegLq4Xdky8/emjd9EJTVPWlMNnVgdlpMbvbYfcTpKFzx4d/1xxnlov50aohcG39YleW1z5UHdrVsRpLZAF5gF5uzl4EYoeFgA5PGKnKFkUME0W4VecuBZ+qiJCUkh3bNQG0oOM3yh+LeTIlV3awUs9mgDrJwyMfY/ygSOiPbXXek8ka2kpKxVPE+r0gJNUX7SOWXARgEM9nQWKKjgfdoLHMd8wy0nZQlDZCyw8qE92AJz9HuHzQr3e3A1ZiQE9kRiQNK8iNH9cQF6SfvbUXOiVK2ZAhq/qBOZp6jK8ru6biHcVRAABPLEKDVLU4i+NmUGwGu8am3lZqkSKzTq/evshdtZRS8roanfYnRLcx089sQKKqTk+/MaQEjw5njR4JVuw8+V0CLORBcndIKYNI/O3pidCbz1fFx7sqCCN6MZMBK44U4S96RUtfC8XO6AY8Mz+f58jWR43jDc+XSEHbI2b5ltUf3WCcoVC81ROErEnnhI5QKxVmRrkSmluvmisfYxyU8mvldVdfhTGQBPZ2dTAADAVAcAAAAAANldUTsfAAAANd/WEyw3Nv8B5+MsLCsoLCk0Ojf/C+nmLC4sKy0qMzY29OXvKigpKicpKTI3NvTo6OQVy0R7Ljsz0WHr41vnuUAjJimOMrdCcZrmaH0ZdV3Jmf+WFephV9YVtmVADZrsy2tlihtDBwD0EUuB3XjsZKCb7H4/QYMWXFLMablAaVySJaP5dB2UGqPZQjTU26/Y97DmBOrWXT7PRBwCGAC6p8wAXwynzW46XZaq+c7vu3P3oq+tDXUcAX0CwEEDEqSpAe0GsKCBA6z+AgBJ6GD9OdBxTNFywHl9z8s0r7mT33Nz0a0q/ftzrnSid9XEk1GCkkSrbOaRdAf6AiITMUs0mtRk9fOLRIw0EbzV4pQgghHsr1z6Z1Nr9OyWI/PSREGhsq05KD7R7G7/0oHMhw7PTE9PxxgjgET3GKcfvHihNREaQFFQ/LpcKri++Z/xuj2hXOZRq+Kz3KrBrio4NCK3hpDsCXQg3rZ7hTTmt+krdcCLi4WOWr4g/m81MgRuXKBkgFp13kV6fMx22scQNMD5ZkAhG+Z2RFYG0C8CrpAAvpgUIAYCAO5uPq5ns78MgBkCMn0EpCt0tBMp35nIFJ8+vUjkhoe+LbtZP1eDtuxPR/Lbh4Ysd0pauwQlHGxRuZU6dLIO/HiZap+sgEd1YnmBZjvxadp1a7jqZvrfbehcgwnWPof7v0ZsM0hxCLPr6LqywIExXv/NpNKY3tIs1D5tyti5kLYBJgSypY69jUODYslkw9T3NfdD8v0kYCCREvqxVgAs8/7mrkxpBnFj+vir11002MbZpaVtkyJppXw0cTGiCpkASn476rwWoz/VDB+YYKQjhafFtOBk+1L9+2w7fh25G18A9nbMErUO7iga8L4fu8efu36drbx1dDv/BkAGCZlLQCqbnAEIHYVRFFFNWS7n8PNiO/NIm5v/jOuj9P/so8iO4nYUYqKqCWiKRV3akqSSBzcNVRuuosEMPqCJ1hCpGrYorknzJonYdjAkTf3I0Cj0k5/FiawfNxXA0t6oTOwE4i3tsurNE4Crvk6gvTqL+PE7qrM9NG7diAAfYI1p/q2Olav1PS8kPtJlRAIIZbd7yhRkPc1VeqFFymUTQ1wr1EZ0wXRmqVrLkAGXMjJAFZRE5dllBziSK2V+Ur9CWbnZlMYyNADcAUuNfQ3TXNAF7gBqgooVDWpQPsHxSTuURwZKsqUqIodUVHWDtOPtLBsLTAwGvdYOFyxa9D+OBQEdKq6bGlfKOdpetQqiLaf/4DkWcsyFCBpdJV8pUFEAzAXLB4+89DY3GfxqTYcGoJeQF/VIJRtXWmldgl88nDBPOtcmE5/cDNsZAsQBywXPqIQfivsJDuAGggUTImWbsePnyNZcvCCW8RfU4YxtZsm10h4k/mhnr5KI/JRIW9sCQQseksvMQ6mmLBYPW0swm56cnyB91wM6ljGsm2JxAuz5CoN9d2EzG9uXnUAvWTTNBJKOHOZHJm6Uad7e5ewWiUntwwAdf+gJxA2LckIWTVVOvoPZqoYmsUU5cjFu+E1eqsyJlVKp+lfF2kaH4+6OWOfNm88FJxDOdpdHA+QZy1P2ZEm+wlp/1mQNPokbwJMgBuT//BJNnxhp97dIXIsp/5qbpbQtn6IrSmH/pJd07coga0egegKsFa+FtnIwLHTzO82aCiBAyhYlKN4+PIjtWlf11dHglV8mVBqAV83zUcaOyo1gISnVT+3CEzwG+qbMKrrEy8Ad2dkIaUL9BQAAANgL0CUw3DaB2uCxUcABv7rVT0ASRqD1HOiQTHEAPadxplmNPL4CgECkHJro3aHKUcAmzXwHXsu2lm1FteZeVGvz82K5tmlqOmqzJOfmP6wxQlURoRqNknH62ZYPfzPC6asHDx8+mIwxCSAlUpyVbStaK6QcpwjFr80dJFm9c3YndRQ57nt82rzf/c82WtXX0n7TZs+yUs2zJ7vRhCpX75QDNFrPJ5/9SSYFBmkQGOMpJRx66kVlQ4ZFEyCgCUQ8b8AAlQTyFg+HuDWYKt1yjcUySHKxJaELR8ub53tkBMaoEX07kMovLtJKanC4lOq8sycRzWw6aAB+qGQghgpQKuMGeF9BHwA1Uv5RADiYQELmE4jzcGhnANIAnPU0U9y3hu+P7ronEqy7aWG9mxTcXmj0/tdUkgRVJmJ6W7QLN59ixGVpEOgt27Qhoev6461NRHGc8mLe0R7oRppvu/mERuYmhLWglKqjRUGtXrkmnBCByNNfInSY1BUNq9ASwaNylEb5+I7HHsDhJUxW3roiXg0AACcF+D5IineYGbClmd0/nC6/b0ePEg3uzfU8CHPocVBoC30witK+RlFn6aeP67GkkmOvmK6fpYvZZm5frr0LLirCn4RXTtiij7fNRjQeANaXBMzXrbr9IGOY++3omY9Tz3EgG/odABxMIGDoVSCO5AYgiFHIimLh/AOFj6a5h9vfJP/hoO867XyRy3ojzVqUbWuZVBGYGrytu0DAkZayMqtBDaUsp1/VxWlVQNZxEZcCjEnqwHoyrXbD/X32oukOZ0ExDw7ilMiE2OKTmnSQc6SfWbCwCwuv+dxpjrymuiuQ0AvLrNqg/lcCHYRyhQSarboPLgNsk5rXlMayK+aUHYHBMXk0ND7qKdw910UzpylSzZES2WvaMkiNTHv+gAbHX9CEr8blgEwv3wrYzmt7iznFLDQAFAp1xn5NNh/a9Ak7gICDivrVW9vLFcvFLe7gdPmSZrvbvjYzoXoVdpGxBQD0BQudB8faDjITDbk/Y0HAQ8WZvKE6lYozPNR7wA3ORxMv1i5mUZiK2IG1KC4A5P2KnecsQsyIDsf87tBAL1l9FTUWRU1u/cbadwvuPqr9Gc7QfN0ZHuQVsQHsCUuafa8E86NDtX/JBVbF+MdBCbf30GeVLrxq0ehjWqtiOMQ04TVLZ9wADAZp6dk1yj1HGoX0fXAZYZKHtr3/TRlWm85BByiP0zcLXj0GwfRYBAG+tS4BFP78CdzKmehQg25G+QAr+bhDKciS7VaA4sopKgae+F8Mw0bOX4LfBFMFzAGLe6BPtfVFBs56FTVIy8HDb0XZXiOxrdJ8RmSvrntmdjV3kOfL2V4jYloqUjQau/IB3AnLY61MDxs8kie5XpQAWqARwQTs2Ib2NFnFvp4c6+zN0axvhGiMb7YdFZLqc83N33YcA0kF/B3LWbv0ep78oyOVsvcJInj0iWJernBX+a4ar2GammoWB/3+30Cs2zfGYJrulbmbk9ol7fAOGmcMCFpssiD0noP35Zuh/x8AAFkJOiE8E8A80C3A6lelPRXkK6Eo9ptjaxbLuEhyua40yyTtfi8Ezrk6bN8FYjIeTi7zSAFACevMV149qhSo+4z50I9ff6adixq3r/HXejuzp/6yee9/GmjNw/8y+SqGovCusmqPP9zd3UFwC/dWCiomaCoINCWRN22y5x1CxUUg/TqE8yBF7IvTtdY0FQADiDVY+zl0oAjGBuDzq3UVAAyTqSnlbZLM7QRLlihQifZ4tdKbAFBs13LPc6ek5sg8B8AEeOHZojO2noE+3ZNS5hmu6kYF0oHOGnWGQd/L4GdqAB5ZdNIHGAC+3TCixFWxBQCOABjD8IDsOSiFNjUBzzrNuJjx49mmce7nX5n/u83jfxZH9po7xaTvy2CQLSI+9DKSGEpRy8TbpFdNNF8aI0SPanQn3TRDcHiqZ9KDVC+Xtnxv/vbY0MaIrFO02igoAQCJnffft7slKKNS+NPu2h5Xsn/C4Ts3cAHhAETcLUmrYFtnWjt9ePUcjxGW/vBqs9zEpvjkCwp586BLVZsj8cJWy5eIZQ0bPTeyCcZGPOM2i10tGPc5W5mVOSlehfxNAYbRJxUhYDLLWq6rQCc1bxF5x/+6BACWR+SIUo6CDUmJXCHs8N57nYl2yojQDmggg4RZB+QX0FCt09aQltF8l3uwk8lbuTw7PzzXVzJbPh+ZI7Ve5XKyS+1GbBHUuJYvAOIu/vDrubUq6ErKFHW6itTTt5RNmWGJ/Yk8eIOuzSDWHoM4lYbegmNr0JoyIcTj9uWrStZxHpsM9bZ+IrR9wuAoroMOgYY+IKLEAZ7hZzK8dfDIH5YgFsNeUOH0WQK21XJO0b/Ub1AusayfQYSWau5yJINw7l0aj/vaPEC9lxhnvEPxDLilWl1U6bP+O3u/uiisVrmVzpSquSvhf10t1zijT2p0AOz1gPLMJkM2px3VB1ZJA/x37TRUb5SqNUnPFFF0UNqP59LMAR64S/JhABz2aGdkKjIgrjOtE6TkbfOZbYRSC1w4QPoFWB9YyBmMUXoIjoPSrxrU8YqbViRFbuPNXQFcYL2dwVTjLJv2XMbJ6u9M45BzpcrEm8C0jE/2A+z1CoKRTHuWcUE3jwRxQMXyYy7wYgfflIfssKq2Wd3mZEW1xmxoqlwVCQTyvAk4J3Bss83AVcya982Upsag+V90lR9L1466IBRM4rSKEfzRANTxSrKNmySws3+PBG74UPybs7IYJnqDh6Zv7Am37xTOGrSC5zUr4Nwe/AU9yQ5UAqYNwFWsAAYuGKYeopJctb6O+By/9QHUqnRCqF8pRip32QDk/fTEzgDyh1N/ggTWqN+kOZ1EK/n6yKVWcZJPco6U50889Wdrees/uZvDTdMzV3WsAeQNd0pbylrKL3fr2z4ByJhO1+BD+lOv624ujjNps6Bu7k2bnbbRpLg9dlx+zbPJbc/WQE+KpwnEIV9pj8aemXhZ10e/r8+4NeFJHvieMiJPGFOTzXxqZssI79EmdGkr9mhMGJNxPht3YoFkWwXaZ+SB69tk6I3Y+aqUkr/37ut4CBuxMfQRwI4BY8gcPCvwsUJXSAUDyUgJpVlBm8PTdFpeC1+vgr//h6n9rUvDyZ/m0YwH8zZlm2hMxsMHyQBx0Gh8m6hDa4+f/jGKkhJo1dh3TbNVABBYXj969P+jh6cRsq2JeC1zHpqZnl7bTzq606gOfT3o8OWTdznqnfKpDcqLDJToMxgYZwHqVdvGW2q/1ZIOIrOSCC7qO3LwY0CRYxgWpJwQjNm2jUhAvfrt3KMpAZIpu9UwlQ2gUealhZfbWkZ/azfuPpg2SIODh+wb9304XM2rCzlz7glmRjA2AyYAnlgUMMalUJiBFYfvnTck8JK6ZHUcAZDQ65sHCAS8IJ+NouCfdpL4XEHMo2nAdxsm4sOWg7tpOYBh6Y+zT3UadWn2sokGotJMQqI1vh6IALpDNFaXmr+V+lBikqM1H/XIjIU1zVOg/Z8c1sgwKZslFSUBVE+0Lh/HYLSCQdSjs9wQ6fJ+vsAR4rpSUuZAkrw7lbc8wBOFhFugvMqXe+aa3drXQYvTK1kKeUuFSaXukjnDPVLQyy1blsFPfxQbznMvmmiTRyRScjar/Sjr3zcEGEi9Q6U049DPw7T8Cco2Ij9e23tlmk7mBJZX5EBNJhDZwIHH/14MQ1GYuw77md5rYEANBoB2AVABLTvWgiKv9/J48y13fpbbm9+7xf3sg2YN+jh7U/IsOGaT3OhjFPnYuyrQY/sTBRUhTqaNGMgFeuta35vak5BrYiv2VoeEPnnyzAtT7LOw6NwAkSson7PIoynw3EhQY+uC3+Vr7Rha8/5AjbJH3akBevX6IKA4k7Wi7beqXgtDJfgAOoaMrI0RB6JFbchS1zuOtlohu3v3yAjsSvY7SmP5eblewUJf1GmnPPvUrc6v036SSJfgby/Sp7Bm05fNng3o1u4qcrzP4QBPZ2dTAADAkgcAAAAAANldUTsgAAAArlplmi8nKCYnKigyNzj14eQqJywqKigoNDY6OPLt7ScnKSkmMzY48u/tKyomLCgoMDf66DzydBUsngSEbLM9uIrzE8sc0Vv62jnuNm65NBXRozGoeV6FDxY3APT1vNmI86YYvWarDdf4a+9O6/oO4koPjfxssNXBe5vjPSuJ1i+07Aoc8rwVTOCgzdMJUolRCzGpSJVR7uiaEbZbNfNEviretU+FHtEqAQTyCjPIwlQccibO6sNIHmdgHf2U7bynf8oUkq+azuVvfoQtUimqCQzyijopLqLUfl4iNOcLpOBH+FgsVUkJj6ix2RZMwpT2MQNdKCsdqukbANzxSmYFJxAUO0WxICQ5ENtDshBZyrWIAm/UuKHoebF+0xEgxabEbQIE+lBmkNYxVdI0fNygpWXrKZPlQKeHUu/288bf1vDFm6cfbukooL/X4WL7LjGmPbHeAfwZC4Chja6tupht1oRcWMxaQJyAC7U7H4rhQ6pmjWRf/ecslRLZZ7spdVBn/H74kdJjmoF1BAEELguNYVf8nuoV0bhrDQVc12lhtQEutfRZeb4cS+71SedpWq9KGDU8p7R3SXlxPZdfUSSjMwnaOpp3VIHptgX1oT6qE16MUaJ9/fm4LvPy+uLKqpIEcMssAIAbkqUHMMfLmwBhQYowJVkbwQg/ow+KeTQus8uHLdKyqM1rkFHNbQOyeq9dve8US0cgcyAVTcIPoaPOVbWgdmLaHL9+N1un68XiaT4gClO4lEXIonjOtdaZlPoWSZALqlGObu26/34DwOC+jCyaVbPn+YVYmbAU1B7He+UrBqoAwDpvPFs/8t5eflcVEcikrMdLN3Y38BDGg5wdVlGGUwDwIF7PWNf6K4E8e02MRNJya7b/hds9TVgIO6o5hU7ft5wmzmHV5XltXGw2sGL5NVVVaiYJ3lck+ZpwxgLK/E8CDebzKR6lH0ACBRUMowXCAOC8RPuWBeO7Xs9OcVbo8XhctUyXY/9i5sdn9G1JamD83XZYAqk2GCkpLb9pnCBLgfEFRzLSjiLiulblxNd/vn4XZeKGxeto1HRqgFMSCPSwlqm8xZLQe6lvs4QUL82UCKDEz+uPWLSy9+P+zYkAM+yjkHg9j+mCFBgVtoe8KaWhRdl7AjBCv/B2UYCu7zYbkWTi0ym+XqpRq6xNSl6GfK5Ux5OokJ3K+nRlRY1ZT/xnaxNR0h4f012wNTpbT473Umg/gAQAlkdUlFKbs2ExUea98yziEdMMdUS/+dlABjWKygDMwJF4whklmGnvp809Egz1W6Z9OOjHzN2vz/3BRDtQpo/j7uKUbYLKZr8korWMYwSH0CY3qQO7jRbKcTCqZa7lypYkuYcbTbkOYbr2IqzdjJ5Z/wO/GcZ0MX8sciMwPi3P2iftzRuzt16gIsmMU+FdT9J1MDKbv/kDRHrFgPNl0zSa35g+e2saBCN23UWkj5rbGEbFPyzYIoIbMadGvTYpfbypG3WpL6xrx73yqqH5JcoyVgm7MqI61/zpfMY+tLYE0cdRNIAO/PEKqkbntspMMeTFBQQzjAsepbVxNsAcmuUjO/qlPj5kAdJIc3kartA2LPa0Doz/c6j2ozqANPSLsXHr5LiZNo3nw26YXCaqy2oav/JVBDEB3AVLGzlxjzmwPBfZHcAFdyuAu1U1VYTvZ7WsDpx9lvYwp6oCSbnB6bs2vQTc7cqtCsI9WiAHNpMK4JKxM5dFQqs0frrz4yOPDwdHOtzEP1rTaVnWOQDc8YqzERfFZUH7szUI4ZmT/+88gtK1hdawupTxJntnpsgfKak1gtHNsAEE8nzNgDBxZLJzeoAGEKnxRyWlotLIACKsOv1PkteLqiforkfovlk2BPK8CbgqBTpqjPZtDyP57zr1ZGU/UtEMjV6Np7efzM+eHOs40holPDT6AAPNGdygds5fboLseJ5cRGW6if7aVfHh8vWp23ptLNQHpn5qrf3/Oe8fYnUJ7AbK3QAMIguJkeaMy8W0XuUBoHdPG/A0mzT5KrqUDakxOdG4S3d271dNFhAQ6XIEJBLb667OmyE0TAL8Mf3S7lnx7ebwM7XmrWqBxr5lgt5CBzZe5N7TIg0nNSaLm1GoO8HlQG4VQqhxLvMCxu633aIeu/AADCZ9zjhK59k10+UOud6sBqxj0IFitp2KlhUOmOEi7elXInHSZG1HUXI62+Z4fSiwMv9QclKzkgDaV+RB6aJpy4q6jyp3KizeG2UOd2KHbLOcRwAZYBdpBuY2Q5BUlIYGSrIWmmItMZCkdxkM5Bv3rgeazX7wPI+j+ed24mR6evaWT1FVa9890t5efT0r1VproZHmK/P3a5nZggnc5As9C3QWHuTS4C9h0lsiWdjdXLbfh37QHRzRVITjCOBBheFqz3WeAAAAxLR/dX8m/i6eKtYx0SMAFJvN5csmNuUwbVBNCTz4MHGCOA0uFnUJUCpFahOWFuM5bnUDVu31axfWqvE838vvkgxgMTS1HYfCYhmhsdbGTr95AVUsQ1fOpqlK1LsOVwilU6eKAB5YREpJOYMAgv9BA/ACGGUJAMZUFgD0LSEDvzD4UtrISgjG69xCe248ZWre3NgPLfu3/uRL+q/U+SGJ+QN66d2rzQQ2IO/wNJE3H1ZSKiqfSN9UCaJGYEVQodV+v3v0VZtzk6sqo7Q7ecMZdFKPLnDq38NP6ApqJxbC5OmaJHMrJ7vEwcBg+1RvIFJbREcza9O9yPATmuNMaGmckAiq2EuOEbhIqWCod7iV3FcLYhxYCFb2ukkqISralfI5/zRpi1WXuTh3yDBE4RYFpre2ssusaNtqsj5bE4MwG9kYd+ykjd/Cs+IDRn7p+u4bAFZXtFFv6KzBgkT4/wEAOAVkgKYyIJAGELAmllbMuMuS8xwZUuhS/2H3659h/vPT+e58N1bP5qp2DL266K2jUMVQUjxlOOuoHFSUQugafRW+uhh0pe3wrtuO7WRMkvtGT7+Y7+DDo81V1H15GzrzKIdw5yKnYWTv3iAc4KDfEkGYejGmEtPnAV4s4daDTGwmTBd7r1ubMKrnEUKkwonV+2RXvd9t4OhSxxcEwXDgpVNPnL5Ewx9z0Tc3RielZouIZcCexS8AhFxSOIogKnEXXW4vyytBEug+Fius51zvc7DYKgYUXI1ta5RhUs8AAOz5/MMA1ub04+cHQDYwcGfMtyINJGRLXE7rLxmvfogMtI3tOjsQbiz2kAAG987BfRQJjOTuS46otezSjK1JU224cYyZUt05lpo1FtDSJuz5/N0AuhVQPT+VoAFJt8rWGXhu9Mc30CYS1ey3qYrQSkZrEdN409EB9PUKmobKTUD47wuVGMlt71MWbWbrDEv4dIY/zX4SpftVhGFX5bBaVgDU9YqzESGkQvidygswEvLDGM9S2u0eekXKfnYO68kBft5G4tzcDPT5dDojCvFCkeqjCyg9VlU9UrOnjf2L7fQ+Sbvrz4PpxF/3Exp3x++2L1TbRTogrrUsBfwhC/wGttB84lwx673IAA1mDMgMhoQf43TOa3DkWZqfm7tplPL913rfhlwuvjM/NzsM/x60DTQWaUHb7f3KJPT8s54IMNHCdBR7WkM5VaSa29vMSc7HfKyGF+CPvcP3fJ081sjbqqSniNJoNMQaOpdUeNiz3spn1keyZinn1L26vt5eT93bQx/E1YGjAGDQAtbJVLI0BASDw6gkpJlim9MQVTS6tOY337TTcPSYtPIkbJLzzGjuZmuZjrS0h3MeHZBQj0l8ITg+Pf62NhEBL+Vx/kic1kjsrckq/yaZ91jiSTwCMMbpvxfmm8BstPBshlVk3ULzarWW0ry0L5eMuKzvT3idlSWwBGNrce80nP0XhCZDD6ewCMCUalfVhvq+TqOGMldxC7Lkvx07ihuaJmm7/KIK0NPxjJEd+VMn1Cclk1ZgPCjZSKzQ3B6bxCRq2GRx2BrPWcKMGT+AGW9HbwDeiGQyRk4DQHD3ExaQ+g0AwNEAsNkeAE7ADFQY4BoZfIFnnBFCUcwI9Pz79TFF9shg2b5zJgIACW58mhMUqTXucYJKIOmosp7qEHhq4XxwlTBSspJe0QlZzb4+kL8YamcNrBIb+9PVc01N9/6g7dvWf+d7QXN8u7CDKSnUFLHqlO8dR2cgtvchrJMPo0kvZidlDkeukcjXNT2xd2H91YtE4Heu5dHbGQW54fgFKVj0mYajgjuZc1kNhMWkFVwdJPbVRHyEiGeLb9D6O1rB+w7zqFUqQ0HA8k//LKcKn2lj+MtlxuU3CGPSMbW3rrNGB9ZnxAQrTKnyqnoFoeR7ephQ59tMMmX5BZgBYwsoCGdAJxgddIye0FY6PDfOmTxxt6Y4zOdeXfZFbTbDJ7tcZu+jpyY9WxurIiut3Jn8+b21HEBEzu5twBCqpOi0C0vGw1t3OooXWWmvP5+e5SG4uzseCe+xGXu5kRiHsUuLSZo7tZBl1TaG8dHKBm6PimrIbFJzKEfKfBdofQi2Ifw7UAuDwFGaKxEyaOW+X7ypxwW1c8P3BOel8dB3dJZdVI09cS8sDCwVx66KX804PPL4OuSaG9CcrKQyAqrb7cineKt7u6gX1CWBMEdgRIOgAPT19JSBLfYfRjrlExQgYqDYkMs4SjtjM2znCGNYX8JFhTgkbXUeS2ZWSgDMAUuZZyR/fYFKd970goiK15N8K4lkT+crE2uy0fDTGqFHFOjVECIqVQAECj3Kjubmguy21V0CI5j+8lhnURG6OH1icND4V9nYGTOYqhYhH9T1vCBAc8srLOb1r0ODiIrDJxPSCckyVZuHtA3G8hOgCM9Yo9gRJN9WogoA5AGLrCesnx8Id33hg4iBzPG5LKH18rlxmqI8lwyt8mUGaBzOqGmYBvz1/MaGcaUbV2lWP4mDKTmf8UqJhOZDL1W3c01k/ZQwLGF16Up0WBME+lDBMwZw4Il5q0FFFH1H3xBqNFeZIe7fpNYGTJzLuwBHY+gRVOtBJ09+Z8an0gC8KcsVejZsf0KiWIz9V7UbYCKTOcWQKRqk+bRttWSHyS7itnra6YHoPVdOs2ibTpX2OzaWLnMCupckIF9Zqz1eXgJKyfelO+enl+PZsGGb+wEANgqYg+XJdICa4SRhm9sIKZnHEMkU9z+bn1vZg8KZbPR2rjaqYLv5u5/m2lyqZS11DNOy2va+1lRVjarJIQittdW7P8emk+46HQ9SZFcPn+0dvPfA4XKt+Qv/fEifzFxrHivrJolWO7X+imhQPpZm0fN9pIiQ64AJg28e+v295ExZvhPPGEQDwnr7CuWrav6ZSMgJFgAA8PPF6cqzsvxTU2GCAT9QAZcArO157DgmZhVQhCJ2A/v8S1hCM5zyghYkwddUW8hULPZp7Vh8qy5eg+F0av00d63iCjStyMLsAH6IxDBWWoAoIEjQT2qAEIXrvQIAdgAAoGBPgJcE0gFAGh/DICU4aqEoFnm+6cteHdwVb/n/emRhbbIrNBCsciVTtK5f3WDqxTnekFFVxM0ElLAU0lqIsYEEiJVWjmOZOIF3yE428M6Y/sqgNNPqyXkjqL7l3x2dN4COsAvzzJnuiDo/xaeIvghKGyDf/+6uKidzIhL1mm9nla2lP/C4JiWQilKB0aGGb/dBuutcVVefANp5JNZWVvDDa5SLJqcMEYgJrkVjCWQ158bUBjI+go8xNFG/XFBWhVD41HHcg7JxoFFbw3oreABPZ2dTAABA2AcAAAAAANldUTshAAAATzkrXRvf8zM38eboKyosKysqKjI37Obe3uTd5d7d2tueeKTYh24mAmbJu5vDp2Q7H+8CgAHYbIVAOoBOMPYrgWWhhFEUUW0yXmx7/VcKqTqc9X295zRntsFKLXQOoYpJhiXrYbVKUH3/ITIVx0ny6pYSyan6+UKZfTy4v9p+fZqlZenD2elvg189aipAhj08lnKopesFNKVQ8VAF6uX8+PfecLqw6SnVY+yz8ZJHuygh5oUfRVaSGoSgBd06CgBX6zuyTztqWYEjpeLntHpm9yD0JYsSJGTsvvQzV7ufaN8km4UyNXe0P6L1bdiDCD+rbDje780eWBh82Y4yn/4AlmfkoE/ezY2MmfcLAAAAcADA2AoF6QBKkoa2DQNmrZXRjL3mNWb3JqRVzzAAAAk/eknSPadSmoU2IYKE6bNz0zsKQeT2g+aqi0qtKNFkbvCGzs5caaJYe8w/Z6vcPq1MqPlXfFYwq+OLiT4dOnHXi23Ne0e055auYU/o9obQ30GKSSjOnBlcb6pUSVqYNTcRkNl3H7SoC62bK816qWl+74Vstcjiai3KbvQfc7diYJueisKSnnsv4nE609wg1mR7fy6KrpklKuuSF8JCpgj2woXlLbnbLS0JDmt902I/VtOAeRvDUeEPlES3zQt6eLOnLQIA5An1RZ4z7m+hSNUf1tEXr3xq0/3i2H3p2ul0Ot3sO+uWBwtN7dSsisAP/+PBwmP1ZicBHC41n7E8+dsfYov4fygsum6cnBe0kgeMWXnig6RWW34/DKse1zouaDs/SSF4DqknY8O1oqiyAZrHJLDS03z8+vRCilCqfhN6n19myDzoXtd7NgBwVADQzMMOYwYKJGHZQXacrTUDN39cfdZU2Hiy1VsdvP8+M0GUJnqqmqBoEcQ1pMH8/w9bJ+Wgzc2EFt1dm2q7ZSMgVW3TatOWO8PooDFKcuLT06/etY5ydpaPyfT09MzP/7/+f7Yyn2U9u4Hpk93nJooK2QeVBAK0WuBR3AldQYBJ0eJqsRUkjgNMhDzIMgAA3Pf3FxZei6apdWrgCt2UWBwHLb7B9Zd2wJxt6aG7h8tf3I8r8/z8/Kxhyj8f5Z+aqkEX7tsCz18ouDKzoWRrAAXYMAFeuMQohhYAcPcH2aCRJQDAjgQAoGBPACOgBrhFpMFAkDmiE5oppn+Gh/ZJ12AWfNCr+NLaJiYAIB4zEt67dBoKdXUGEoR4Kz90s0y8VA6pOhwc8BoFInEaJnFJ5H+ze5umBSFpHnz1z8DBVA/zlPXiyCFaTbFfXDbVAektW85YYoGF068Sbe9e8fTnQ3T96WSceHUd2S60tfwuV0O4pcqonJfDTGSjlX9onYBGYotvwC9TZigDb+/uLW0ZJoKTCa3rcGqL5wpz5kVEBvMf4X/baCnAM3kTF1Vfo+YaIYroNzQR81gNAJanBMBkrDBf0YqF+9331FnGNB2dacNzDgAOANjaCju0MyBIw33iCZKVURTXd3TBOGr3Mtt/evT3Xh8uYrrPZAsBhyGakgaKMLb3FtzntcSpyq1iiYcA2fWbaqkquD+Z3fupTO9jJJYzv77ySVeJhOJ+tv6+pg9fWy0tR4HPmWL2Yeusl+b5uV3x3WTrw5spo+TpzU2LQQPPI5lm8llnI75DW0ESC4YSAeGsWkqbwhiLwmAaOIN9iqddOsEcR/FZscUfb61lP7N6H1q3b19NORssg9PXUvQDqr+YoEpWlVuYhCWyBHTYKADMEQtlgOadk65IvgNEDGsFEK3n6XsjZEYM7pK4ky/g94pXw8f6RipWux8S1AGLiCeGSPyActtmdY24QHCdPSxjjpXpmgo/51xffJ8MvydJ360zKxQAFA4pxDOxz8j79P2v3zZBHJDwptqyYhLZWxnOD5tUN9MHzflIkVuovVQl2QAEBnXWc4zXVsj8FEeABl1yOfRENASsYYyxkbW3f/DIMRrmPtAqkWtTEC0BFP40a8vNv00wfWDQmIqKDz3wG9MwVpKMNuInoNiTZw3xFHLAP1XaE9sWANwNNRzMLmozkOa/kCAOioSFvv96CblixMpUvjPtlRQ6d1eNQGXzEc0GA/wNRRWguUxfGKdqDiAOioqcmQVWdGBjmGzAaeNnqd0+pKrl10PaMqk+COwRPZoHVm9f4EIRvokoQDqXdymhGk3U2fr//f/vTqdmdHxJBu3+j/+3ZYP1Q0zifBQA7Ck9xZ62weIvnos5blVcQEdHC6PwdCHJpFd4MxJLm2/Zblyccfbuh2C7oJ3mduef0K+5YxacAFq35BSrNP0aj8takraRUrp979RHDPpubUCH6wAARxUAxRxsDsYZjDYiCUDC41AkFdBaCwyZSfN/rRNjyORmj7q5lw0HRWtrmmoJB6ox7n/ns1mJEFBz1Y3QiA3UkxelWgCNycnk8ctX57PVJOpI0VaH/n/5ITuMqTU/Pz+/6deLrExPTydLfD+rcjOfI2DA68wJ65jWx79/70FTWhHARYTU7haGl5Uqget+4AQAAPB5f9Ua7WNnLpoAXJv5Y3V6068/A5wSLH5cuMMuOqcktsb4gvLnERTlQTHkbFF15xpdhmgyUwZzroItRAEJnpiUwISWoMOIux9Sk+AEAHDUADC2J8AFqAx8IRilQDHpWDNja3C3k0nOhReCWqnxm6ZUAMDi1Hgh7EXpuPeVu3e0FnUxLr6ighKgyi2PBRMKBjbblhAQtd76vvaiuqvSpo7kty6vTo/S4frG9RM2OlSLZ0d2o95O6VNXMGTifzrbAiHP5Si5/J+iRHFtSB8nuvoLjDKe9NWeBntkJzxJkHUViUMB7BXXuTThh7TUjbjoFRgYM5ixa2acYEt+wEXzRF3enycFlM0+i4GJxtjZfSYQJsMJrPnwjtWM99zfzUqcT9FCEgCeeNTABRQA3kfA0nDzfAYAOxoAACXzsAC8YPBIw0PieYq1YMyJ/vmSpPea7ruRaKMm8/Xf/uYgtXu+YkGyONMQ72vQRBh3jFXSW1empaPwFBoqxkJUmv+xJDUpEcKpREmM+1sPph9QRhW5P+6nqfw3GwqIY9fVoYrZ7FSeB+yuK7pr5gXXOkdvp5wtjO1LH4KajKwdBrO0YZC0Rib14tKZckDTSd3xgmIrAWUpq2if9MboUGRsph5GpWJTnJexdxVG+tTyvDXhtf9puH5ajKRZRGPklLyAaWCvzAOLNwE+iISEC91BlaySdF9qFr3Ywk4CAGSAZoWGygBIQ9mWwNOkZVYUmv2X0WQthtt/3HdIZSfY+Kq1TBcS3bFhVWdZue7VSrwLxvT4cFRvCu66zLeJuHhTJ0ByPvWhtIfFs2hQuXCam7lnjxVQ2XG8dBzLeX+vnAtgXJ85GUhoZzruEmZxdKNQ3LP1e1GUkMM1Ntw9gynfMk9iHVmxHaCJhWKIgG32ETlwzFfM+lmufKV5JXjh/M3OhgRtZdvNcmzTmHy7sN6dxZaxZEVEbLrxOXbA+SE5GZ+TUHnTLkpE2wD+d4RkbGQzTVaRLPG+StssoA/X/QHAAHQrNNQMPNIwBmOF0JopnePnvh5E5y9EtwtgJ4sx+UfDAdcQxnusL1ELkpGeNFsbEWm/ktJRFfW+3LmaWYqWniho693c/MNZ0Zg4WhPba0831WVxU1VhOYufi020giFQBiCbz/yyuJbQi2zbDsW8LqfUzuPhJAJz7Qd3tc16pps/w+C9CIGPLrhZYLW0KEMXpFt2e+XF+Ryh1dx77mD/s2UgY5Fljee8Y0tzQLiRyYMFA8IeHlKB4ICeKKjg6pX3ugQaXFsR36HpWvcAEwB+aJREDC6gUib0vksfkLEwuE4AYAZ0bdNJw67BaeVZoyj9pG/mtVKcXui/GuUt+Ufa9EMJaVRNhtopyxpsDFI5DE+U2ceN0Epom+bl63dTMyb7E4Z2WuUpginWKE+dALmdGv+KF2OyL+uRlc+X6b5cskdRTDXB8HPtP5eP5rS/i4SCNggSQZjPFbwd5n7wFwKW2HJlDZTCdzjQgrCcgnJ68AOJU+l/3ADUlm+X7j0Z21+5bmy7g1m13bRUmZLBWIIZWNqYAWe/kCguJmtrDWruOVSD/S1AKb+LnjaACd5YlLKECUHFQrt/LaADBQDADChWKJhmAALaGc2kVYh/Pfw8DUVH1o3/mmn2eJ1hALAyS4hRJHidnkhES3rpOG9PrqsWSVkt7ge5+HHjiSvnrIU7zO8LJX28UFHoe4jIrR2BAjMNVMCgKhF2UrbTSQNp99bZl4bm2nDZWU7UiHlr1jRb/F1Vjch81UUtnez8wqmLV4RRKELZyWB8RzjgD/ioXFZikOOds2P6Dko5YbK2awyqomTesRIAdZIaoBtGzwKq7Vb3GKJM2eZX7jb5OqND+Q5EVcm1ajX0QZdRsb56FRIIiwS+SBSsAu0HgH8X299p7PcFAAZgWgH8URqA00IbUjPs6otj+4OMB2eyt6Y2ut22wt5vzYBOuJ2etJeTibdFl9CVJajWxCiPUjHqavzo6ngTBKSyV95fyawo4GdvEIceamLFSBw4/N21r2wjTnM2hUR3fId4s0foGFpqSjayT7FA0tiEM/1HW+fFFPVlQvbAk0JyXbKRTNAssii4zcGHQJdDjIvCqlFN69nTM4QZCHccWjXekZ5QJuBxrlyxG8U67SXkL9lQQf5nuofpLfQssWZNQW5igwL8HisTV9p+jADeWDS0ofDbALS75g8L2AoAkAGmBXS0RViUVWJZM8Yt37/+ubP1e/t4+3Cdv5yl5awzEW1j9iSFKhG3olkjmB3JhuXpHDrDVgos16WZBE8j80H4hhLnaTxG1tUqOgallPvoZ8UTG4xAkjRt79TufisEVYDfAAVscCE+hdyD/rekrG2SO67jwkaLSqHH+BJIoB7kHmUOOz+Ysy2piDZVBPPFQSyfbG59C/YWQ7TKjpnKLQW6+/zorth7WCxnTaCYjmahF8q+9tYovtbuLSyVXUh3Ej6EXEtEbXS0sUABE35IFCIVA6gB8F1u26+xMMtqQJddbUDWpRWpFLYN/urT63fDaw8c3fp+03Jz4fl5Gm+ru5OpvhgLrbM4d5dCq2g5jAOoHYUvX1I3njmb1V+F75bARdccf7OH9/mCbmIZJ2dA99GOLdidk1YfcAMysookgw2grCKwdgnLE1O10ZNXvX1HcYNcjrUg+kTtwug0/brxnt8qarAW0vUHfdXm1q13m4XGFdEh9B2zktuZQIU3XFDRYXt0WTYBKUgqiuVKC8VSE5hiEVsDKNEufswS/aYf3DVquysQgQIAfliUoAYgALSXVcgtKwlkgK6tVo4m7xlWFLeWVx64eHXz50Np8/IPzHz97u6gx8krnrDblJhsIKEJvoQkLnHZBauhhTP7aYcYzSSJNdpVevl9lIyqPN59HniQn4UpqM1sGtd4y1wf0gayMqQshdUTIfyunrBFvdrSyWKUCqdMytUnkw5ihcoZgbW/iBaElciOaxGJRVpbnxDt2UilkbaacD/ZEDGmIM0MveHN7SEEC1GOhxrDjt4xg2xP+3Qb5onCbisOFg7TAa8yLo/dtEPkvSSCdL5aM3/PJeUBT2dnUwAAwCQIAAAAAADZXVE7IgAAAOmp0gkb2NPZ19Tb2CYpKCsoJjAzMOHN0tjZ1M/Y0trhPljEoIaCANDuhhXTJuxYA6DyY+JVJbJiTTHz/sX4IWsee5u2e/Dm36JxOXk6KCtZioNwJWMuOBvF+O/E3U+C3ANj3b3PDwrpAWfBefOAKPC5INd+TjdrHIocJFJUdQTWqvDn2xbUMIrMvhpbD9sayrqXU3Cq3hL5eKmy2G8rU/IFNejxgbmHFR53Q0ygUEGKKX6ZQVUTyK+J4VOUrCcyp+dgke44aK9Q2P5EymjsJOcRObwMDe/bLFPbxJ0GJFNt9XRStpptY21VWNXFOwC1FsfuIhfWzfUHPlgEoIUiAPhv2TlQOkirjbLvZK1JxXjw99Xzsy6/Hl/LTgadpU/u/Mrmk63ZeZk2iPttGLnA4W4SezEOXdf7R6YyVNvl1yyY0pG2VjmHGe1h3JFIQZDfpGsylfVtvQ5MLNUjbQ80VslnN9bHdrj/tLWZTFX6x0ppqsEyj3rfNuMaLQW7TWJ6YG6AssP+ZfK0JrTebnKpS052p3RCmD+iNDMUM9enpyEITmUVyfdZAppqOcXp0FICDdOfkC0ayXmPNl8towUV9+3FjkPbquXuWmEDAB5oxKCGQgD4vyorgUUhFABgMlYRZd/TVjPDGtqjO3PeWo5wtR3bYLrPLSqSyRRV5NCclJarf+o5D1ZmAtrYyGcpUdGJC2ETUnNDu95PZmRFUZmUWGO/MWXu3yFQXIsqzj3tBCAIvfTfX8X6z386t/J4+9E5dioQgkrYYojspbsChVI48K4ly+TPbdOdCa1rYQ5v4q/YbUMwerubj1UGp6fM97I9WCwcKzmTvfBWlVy12lxrGZWoU5hzJggdr4K5b56IFcAVXEPw9mVEpbmz9BjSVM0ooUzPawB+WBSgBUcA+C+jTSQBxpKXAJ7z8kIrwUhkpoe9C6/+t3vlUru/kfny7Z6RO15hSaw9VSV1N8m6E3wbrpLDyzbpCm6kkdAi0F/pvk34aBvNoITMy+5pNLUON6hKf50GM7KK1HONQRcrWnqwPSDiFcjBJmcx25ElIX0NVfa46BZcsDSnBLlIPpLtLwUPmCbR5ha7pMPdzXXS0XrtpwGMR015e85R4lPHhf9ihVlhiUsWX+OC4J5AZ/MfM9fdfYzKVjtD03rYPS7+xJRH0nYg20mErtSNuVwCAH5YlKCGIAD477agIYGqKi2bGGXNFAe/P1pO9q+nzm950GKc2xze/3ClP1FDBplmcInj8Z88pTSHfQ75UcT/HhQ740e+I8b3azOOokA1C/Le8fmBo+QuEGbto8G4d73e9PhSM/O4lnmnVbA/Knnc/BoO3JJnXOaJ5TxPz8nRUUvbfmkPgyaax6VPAqO/UJVfI7Tc+22advwG4sqLBzFJC9KofeUxV1GsTOUvZFX5B6TEOvj3O4271ORhbHk6LRhgtKwjiPT47tP4ACWHwZ5i56YZxc4J/lg0poUgAPiu2hHZsiphbKv1fTLqkFCMpzNlP/doduvFZ1tnHpC3jMyLf/JfsmRcu7k5PZnEqvB1ImW12p1nFCEupvZSkdq0M1S3o82CFs+gelEkPJ4uXJKIGKrf5VgzoPEqSakgRFkB8kyJLq6IQT+XYhSptQ2/abUJGM2QhCCNZCnM3QaZiZn/Wvft7Tqb/rROP8feec4Wt56SUBl40FnZT08VWKGHyrUW+I5Fpp0v09jqbcsy52YGDUraKdbb1MryHN/ZCPIRnTQeNFMiQ32RF/ttV+3oJAsAdlfkYS+GQgQF+J9R9KdxXvKImHsbAtVWxdLGasOU0uPjnFnLcPqYFWn8NNte/R547cl0mLInJ2NCh4kvn3LBxAITj+GJEe8dBstSaTFYOWleU9UL6t1lUzaiU5MfVZs/F405Xt1biiGqnUsHF+6cS3YtYWq7w6t6eUO8ByIV68RU0vDhwUdVwdSmxBticoh4axDGJqU/hMrNGvY/Zwqxz091De58N83YqI+Ze41u/llWFih3/FZWYUbrLWdoRwsCZJAHtOZa+Dk0Z15JS1grRTi+AuTRxmAC7PH0ScoOALfZELiKX/59oCeIuhkJrLVmv/qLKe5EJHgFY/d+VxQE8ijLFhUEaJ+WgBtGm7xFio4qe+OJsKvXnJWVyjsvSSv7jolY6wo/APz1tMwWpVnQYtxMlEBEQvR0lx8US1/7rVGjyNRZ2KTfdEX73Yn1LQ289XzVFsmxSRJ7fSuDiKT1i+OGlYRrzW08K02hD50x1/vU0ETJKbFaQ+oAzPH8zoDg6MCxv9sCjOHue9wYhPVv8DZvNaLdBdR+95ry7E2qM3qQACT60EgtwMHOmQFwydvXeSYILX1vGK2nvoQV1d3ZyhmXTEVVS6kBHApJI3OwiYVex78LSGf+e0GDrllhp/JrTAPnk8yKInSOOtV8S8Vt3K8QMpKt/e4QHAaxAwIUkD4hgHRjDwdHY/ZAbRHbx3N5Ju2YnjrmHb/4+B1xS6RMvT6/oLIMcSzWZw8AHAY5lwaBq4P39ySQKTq826Aqc+zr4Oz8Q2+J3uJbjCszNogMxYkrD+3f5bNGIKEAWgnVLgHxA8D3AwAgG8HY9lWS+FoIFSmeomiQbdGMhqvyj5n5brtf5/fns9X0Q1+44J9x23Tua1zmYYeNl/+47HyjpVTh2lvyaEJEbbEk6P1TOUpBKs9tKWrLoA/DfNCB0NG5bkaZluXl8YBdHOtgBiNojj6DKUOJSAVpkALlpGm+0744pGT05L0+e3B2rBkBEspV0EJIaz86mC5D3tJc6odzlDo4PK1HJMlmb8EujWZS4dPf3hmWzrrzmDdaexxxgjFt6Gt2qNlH599Ko0PyZf98jXUCUhloCxVKf4+5DSQAnvlsvjegGgDzm3ZikQj3QDiJJXu6tJYZ0EcmFW+m74tGLjgWpfGsn36TPfhryqyNLUfrwrgcE3p0QqpjyXnpT2SFzi0ZWpPp4zXPrqIhUs7vXK2QxTmRTOMAyLj6yeZLs7ZgqDwFvMN1utLVf6QgEmIqryQLNBJ+ws6gZ8YjfiEekn/tZr9yJN/K6+VF0ON6jqnjuYGv2sJiYr61UFBANY365FWAE1E9GmHyOiyt3O5+w+dQUjG0kSm/gNkuRFCvgYGPUG0lLRe/AmAOBz5pjLqGIAD4L66UI3eAGqs85yVWkcw070Xytd/ZH8v158dSd1+tzveO2wwPjuOUbW5k0ansufSqUBHpCFV8321z9/aX6aim9fys1pF12CxJFTJ7sBxITDtWGo0J9O0Q/+ldteeWeJRCjn9oYsBYQs+PLKATg3qRPYOr00V9L00og9ejvZPud1xo+0626qKF5hu0H6kjsiLQLHb1l3V1oGCFL6h9tnCDeZllZ3rEBQbO8bkCBz7C/GHWrDhILxO+piQrR2XhTrNPFGBrW5n0ngATAH5YlKAFgSAB3zsDoNEaYNLKZSomUQsmnJqP9eujlreXB26tSAq+2MRda82bibjRbC8ZmglmPlTnDQDOJVIjEUEVC3fdOYtMesoo+6yU1sn0W18T0UT/A9LL9gVCS4c68tCuQ2GfH110Uk6XlKpTIVE2BmiFOFtA+faj8rarlktmc/zAc0dwQiMHvIiu7FXhQ0mkZ/5IZFE6+/xtJ6a7rkZIrjHhR/HodWiX2xPExRc5I44NhVsqDOtK6XVLW2CFYPnyqanqA86FTq13VlolJ9vkQv8KlAAmAB5JNL6HQjCA/9XWAtpbAL00Np6O5bRgpr8n1/crX7zNW6lXNPc+sDk8mnPlx5PpLatLh8KSiEp2EsKzapEiypgPmTSD+ZTQ7jZiSfwF4tZ30AgaoHCet9iLsDvaTR6vEvVm31bmhJJr7VIvcoBfNzJYNAYuPSLqYef7qJpLb3+X7RMK/BSc1kq16Vf91ZNlIn3MvN7yOGSxMEs6CWeI5n2Q7IE4ZdWahqNrVgfGwDxZ09bo8Vl0LxamYbrFCDZMmZ2WmsSYHuUioh2gvJZV7a6VlTINGyYASwDeWJS6hcYA8L8XBBloNYCkqmRP9hM2iukTcof/1WvU+THLnbQoJufvplb5pvqm6+yVJMO8JVcufgldlFzDmBNeKWVUsz7eHEMkuk9aqI16wreUECknb0WrC3/EnoKO9EiLaRpOKawz02ThAEXk6/ByWd/mAEmyjy8vR0w/Xba1UHduZ6dKtcq41Gh3pPdOSESwHv44rk3ia9ZJRcPHg8isroXKc4eJa32qNnbgVMfe4/sq7Zsys+dfFcRJiLf3c+lcTVsO3ELDOA2I5OJPIwcBhQc0AJ5IZLqFTgDwXaqeSQdUJX2hgPMSzUzpymbj838p4dl4Xf7o3evRtpsZ1he3N5vBjJYyLgmF/sCtVHNGxX7rPu/zvKe7C5MkdxvPoXiUKbKlCyhC7qmZGxDz9jHKkR7VSa7Z2Irm5HfN+mjpPLRUEa9TjaFaHTsZKuImS+H+p61QjFiuYFyF9Me8UNt5azbTIzSj2FjRMMi+vwWn0A0wdOc9ddN8kHD7lfjwnkiSAg3UIEQVOo6OoSGcL8kzK9ZKLpWMpTqradzfNfh6tO9oAB5YhLjFNAIFI74rszSSLyCcVsmyiY6VZfpny2/Lz+WUO3bpwaevmZ//2l44e5vesLVLnIKorrsh1G2IxvPLb7ayjVNrDD+I450fn3XCZRHovYKh3p5MVUoRC55K2hgh8iB3y6xtl/y+cN+VNW8T83SBlk428MfLt3Ibz6gaomElWFhtw9DCgdic/qqMYg58i2IW8pYMdycT2W9pqSD8E2PuUD77Vo/+UdDduXmaQaPaT0+BaNFcbzZmrXP4bQ3ssgPk4UDoijIRjOwd8x31O3upNX/sAgRgBL5I1KIGJxAx8V2mEIwUMFaN2jPCU5qZ/mbOMv3H/uOc+1sTEn+2u8n48V+7OU9CbG5dbpV4sOZ1DkDDwhFWL8VyISZpvVGgXirFSdS9eD6kXocvK9W4jQu2o1CAOhYRhIWyn7VAAsqQyIbmKc2L56CZ8l5f9Rkiv+Thp29tX1/Wy+OeJJmiwdDvvx4prt3uxqi/YxSNUHenrrfVrXLtKYpSTru4ODUfJDe5PSIJ5zMGJ6+AS7aE0cW0F6uvyBUqAVjInpwguXozUx9E/Uu6vQ2gA/5YdLKFIAD4rmzG/DI0oK1eebJOQkIpprfWf2+lXzITVy/93Zbm1nV5fv2Jv9JOdmfzJ23nbf294ihOHeoFWocRH/9N+9Ss37Dy00HddiPziBkPxSfOr0jtPugpPuKb0Uii3K17zEQOP9CrMy2SiPEXbQsjdDLaa5OLvdXnPt+JUFDPbZIrJTzAaUdQUxYnUBetScFkFLMcxZ5t4iqM4sV0PJMUaHWJZOL9DIS5sYu082XFXh+bO/mAgbqhtEJaZA1Wtg/muvGrqX2j8oyi4WypET13WBEbNNAB1ldktBQjCADfOxXFnHtsLYYw64BpVVXIaK00M23Oy2mPN1gDFyf/vqhzx6vvU56m209S1pytV9nkaKQislFnpFv65E3Tdr6cx9CvU0fFta6qmGjIrRaTw2g7+aKH05WFPmlUlRqgpJA2Prz7ytJ2fRzTdjxdXvyoikvzoLHNCddx3iodYrkCj0gZlkPN3YmGQTvmKdrslWrWoCCKEUIOpObqq4Weo/MnjhJqxXhrEfb6UVWSfgfTqrpQ/4TZBWr77PfPbM8wAchNRtTi6wgyg+53N8j4X/lu6X/OPrdxADoAT2dnUwAAwFkIAAAAAADZXVE7IwAAAGtwLttAMDUyMDgz5iokJzUyNC7l4OPqKSsxMjE1NzgvNzg3KzU2NTU1NCsqKyspNTMyKjA4NCgsKywoNDM2NzUuLD80+fz1oDVgCa1c+zMNZGLbsWtVvHfUXbo+VAi9nliaz4ei6pwnt7sTPi44lB2NUxSUAvwRBWsgKAKLsAOki9oGtF9eVvEV2Vkb/da8fN6LoJZrFr2sc3dObMdPP33gzfyCBbZt26sArPX8yaNk4GD7tqIiWubne+mb6smogCLYWrhXfBrB4momhJMrOK80M6XN3d+1/h3nmQYM+phhCqCC16wyUi/u/JO9YA5vu6M/XM+eyklfj6aVvz4RkcQpP9cj9vCeqQx1rAYs+qCTNDiUQdDHkaDc/K8viIQ37f0mlfQjxyZ3VjTd7t6X/XKM+BvbB69qZLjj+mUVzNzxjm8WABT2QDRyMQQGd1XUgKRcXJ8P+7rYvTbId3KjVsdGueAPSmvDsZKCNV49oMrxL4jUud9MANJHRKwB8dMvBip876ecPLct7MaRqQHaNlb5FaPWiikKhb3HyS27EW+9eXw0mXvgsPlmvXi791Yzdvs+iT/M3ZUzWB2bc6E3PtJKX2gpyRmiLbSz6PkOhGsfX1Z9BMOUK6Nrkla4s8Yq+NTiinN530cvhlwSDPc0ijADtJVHhK2pRwT1xWW6BcJi9ryrgaMyuWFOBPS1DZHEyyZTIFP8eMzWtmi1MuFpu92sSa7cMCrAsEQyOlWBXwYYqEeo4p4octVl5LznLC5EiYa1vxszrLQSLZSNSgp/erLMboljQuut/O4AARMAzPH8SUpZGEEKkukigON40ZjvK+/dA1n7pdd9KKP3cDJYl3FfF391XXkADOpoCzJQECZeAJd87YYJK1mr/kyWYTzzyCJ2VTgYmLc0nMcDFPLoAJQawTdzt4EUzPs91Dkhwl1nMXVnnuTU+HB6B11fFK3M0qIBFO4Y0VBhlI60+fcGKDdRK/k+mJjji/rR5bvJ0zh4ynE3LgTa2undmfUlbk1WAvbPkO67XgQk+qADKoQE+XcPoIPRhm4byvZ0Ujy5f5xMU21d+xbd8/0kiqkqUsh9D/rx/EwLiiVVAFQCHVeTkgoBPyUJ6+K/jxsKfJd7nYJloGz6WT7Rahw5r1Vv/ums5+jSdYhEVyZ68mR+zABULmUGDjLMf1eCStZ751R9VGTuhs6INvQ9NkGKDXwftMwmpsolcEOYKy51xk8AGkgEIAF1A8B7ld/3OVU4oiMiWNnAOGZXRc8TQjlFi41+fTh+t3jFPKw3K3U7c3Yo81P+ubFuC8vpTabDAWXhSmhFLg1w61de+4ccxlERrdlp4s40Wi++y0utlkgBnMUQTPTWUqshh36NiaQRtPPcMnng1vVn/euGIJy6LCJ4i7kmIYmxeAcbRoWeh0j3o+rxK2Z47EmtsIpT6QltLwUtrGdSr3TfjgnrhVk9Xpx9r+7s8V1ZNptal6+H3KoX0x11ai4/YPQp/v/ZAN7+wbmM1+HBJtG0CSHPzVEagKtfcQCFcxo6AN5ZbDECcQPAd7d0BRrDwWRS5ZfRRhvNkEy7l7vL8b318qefZ4fmWLZlPs0NDNxqZxZnXryvA6a3fWTDBiqAivJD9usSnA8IAUjn+ZAtCrdWDT1Za51b9re1TlJaAdy69usSVy5ZVnxbuBNOYegPO3+72dhYwGA7akyX29TO5ozndZ1EE9RmEFKGBwxyk0U92Slml7kwVBL9Kgv3aDlne9/Hf8E4vZIorK3CT1UR1NGenf6qpcREU7DccYAQr7MIDWvtbgHdVzppncJXuWCuMcpFKYjgDOemrq34v+tk0NcnfpmsJoLhAYDvqb6oF5ESwDRpk5K1NlFrBZwb7ovL5u1FEdyC83VnawZjcJyee2xM1vNsdhy8i9JxN+dsHEFqwHpigtVFBtSspsJWLNY7ifUC83aaeVgAwVPFr5Tcrw1EEnFti0h3IH6ZkeL7pSbuZ+eWaHSLkFA1FsUFz3OIRg1aQQveTNoSxZd5XnaQmHxiL0p6pZGvlBE1XYHXNfZ+iSB+nHVULYRKNcFjH2vFpRSqsAN11KeogUmn21pbm8pb1ywfmwjB942mpzOISnurB9fefH3I4XubFckQpqNBHdxk7wB2aBQiIXIeE4D33CqOw7iHzKPFVr6BaVp+yXIoOtJTQPJDI4UL30Y9M1dvPScD/17++eH2ZUu75GawxKHvWSpD4hODjZn0gfptoUFOQp8MixClF7aXYK1xxIUsquf3aJmTSjLI9JEsafYyxXTvTEb+yJWMJUbzLN09fg/iaVwbwJ/MdGdX0MV8qWLUddyxyyZCj4JtxlVik0LwmlKufdVZTqJyuMGO++wpCroI+L74YqyMijljhgr0bu1ZQLNuPe7typLHyNCF87JEUQpDfJzneb4R4/o/0AtEbHtyY7sbnawF3SCvxYldMQMk7hxQ9gMA8Ml1Apfo6j9H7BD4eicCWvvPKhwjSrxNeyd1o5e2jFA1EwQi6QqwmhDkA7oH4JLTgHvnbLLURUqSkiU6iwsnvrlsPXin4Ju2YtXniA48EpUEVqWD+DcLpIvWjbdOA9uLz/miOWweQ+vA9N2tT5LxkyZrD8D+/l77////V0sAFAqh0xIgjZCYV5tA1MWlG6plO6h9OYWKCsRrf6wW6y3qU198ytdjKprut4RD1btktAYM7kAAUkaA8mIFVGKvQz1cLput/pQ2qbe+tFp4mk0OlSwnrYkkR+xAUavLbfmRr7EBHPoE2jA8WajBhSA/bSA7FsXFZX8mY+MTRKsm/dXzNtbWLd6O4xqPFIfcf7dbtWdqgzaDoQIsFkVsv9v01CXPFXydC2hhdp14OL7eCmcZG4qppBrq+6+A0QztBylFluzza2OfwuX0a6BXUjYAJCpp4sk+TDGzTLGnTDuA5mIQ4lAWWN69azL0rYa2UOQfKPbW6VpC5gPd7gOyv1BjZDuubd5AAwAkHjVreOx9Jb6cpjp8VYmAlTQmEmaahT8R2FVxm5wK/xU1IC65yE5QLvb5e7APBhT+NGl4jKbMKZ1M+Na2ALPRcfF7NgemA9us6zcftU+h2RmR84m722j/O1hFb0tIdrNfS3/6YQAc+lDnaTdwoR/IjRA376FxAYpKTY9Sr3Elvkt54SyRwgPjSzWvOoeK4exFfvMBOujC1piUe0OoASwGkWBru3DMc7qZmuFfZQmyUuwahbl8yV4oZpVkgZ8nPlWGw/tocLvhioTvnLc9QNpI34XKQAMcIr1DG5LTKjH87wApoQyw4zntVWoidGWEmpIfIHcVjJl4JlzjEEe5JhXL9BGp6PmzJoa60WNwVZHQUK4Yaoj6DAJNOy6+MtP9X1CpLo3922RqI1ZkqtFwe7eahvG+7QD89bzRA1VHC3Jr4R/oYAzzafek5fJnK0MqsczGqGOSc+kGdaY/9br42lOc1jcnrvUq4pptBwDs+TzZhpFFXile2wFsivIGlrrmynfo5fRNv0Lf9o80P/A3JyOyUPpFgjBe3KisvFDs9m8NBSQCQbYVxCjwVVZrFRxmN2kAW75Oc9OyiRZDzrCGFswiU6olqGro2/y/7MtyP35ReFzzjfUOTAqJNUpJMTnzJbz8TAdkurbyU9iJOzu3+TZV4efw7V7Y20Sr3H9K9qFp5W6/nsoo7hWSFwDs+fQuYBHWc6aSu6YCAqyLekFhPMPIczPmj9r3v9V/x6UKXph3hi3pqxFjDS6un97BhBoA7PH0RtmNFoqjrSwCYLqSODCmHYbIVVps4m6XwHrcaVawo5F+ta4QCa0QABT2REuU4rZaxOa3PQ8QEVjTfEKiHJ0uRNC7yiB8QWPmEVsx5qcsDeJCABTyBGk0xmReCkofbwCX2FButBgSRLFvSs5LpuuHXf5UHBWh9LkdFt4T6AQc5uiopWQVPonAmfwAhYhyFVcTUtnb6ynmWOJvCC5/awGzMhl1H0UYy0kHFPaEYE+RUb7S7JOI5AMDdu9s6edQqPRbBF5CAbJX2qNNL0dWkWq9oAEs9kCSiopmN0JlnSSAck34wW3rQWKWO3Maw5gSmFYlEDSt3PDKd9vrDAcCxt+myidNrVJiAzQKmTJg5BwQnj6OBFVyJRsHZap1fdty6rFia/Q+SLETVQl8VBkc7reV0Oelu8u4L14aAOz5tOSBFUZJsd9aOEBZmqv0CzM562k12sfuWdsIPqTnheY4UGnDIL+l7NCoaeetUUwFJPaoJFkppE4IzOw54BJldFfnSqr91lbmHwn+VSuuLDFkyZHfNCNEGdEABPbQ5LEBxILXFxZdx7Hfq4yea2LfMExTEjKsD+nxilemgMjjdq/CuB8OyjxE8R4rDAYFxZYpFwEB0A4A6dqeBtaykZXp4aDR5shVSqmowZpXT17sKjw69fNJGfY8L0p3uc/eaHPfYAK0/TQVSIMzONgdoAEXFQGmWb0bEk5Hzi7UK630WH3YZL2lVmSfcwYqz16nWBWUmretB6YARAZBAMakUmPA7woQJMnUwlEORT2H3sqsP7n9YulfoxKVnzPNYt6LCvT1vNkuKTeeBzmUHSBIsmwBnYxMUmmSRpediRVjdSfn0qSs2L6u8s6EQTIBBPJoa8dmZSNvIjdm7QsAIcFhUyaSQ9RSGq115pIcb70AvQ5C0H8u7NI7APT59NautnBXP6TIBhAVUFnA930746Semm5dda9a3e2eTWynIkdQylV2id4ADP701gY6FUyzoUkcwHE3OCU1SM0ro32sivQb9kfxqYWvQTpSnQ6tByz6FLENAAn42wadbpZvhe0qkY796/93w7t2ewos6qjCVcpuFWfa9674TLENEjYozsNFFwAs5qgkNRWS0xPWV4F0aXfYJ/OyfpW3D/LY4ze5nZ1tPqZUzu16c1TqEcW3DVA5x3fWCgAM/kTaMIycMKhOsao0ABkPC+H6z/lsKOt0avhQid4xRNFK/LPRQX+G5dsHreJfOcWhHA85WwAMGnW8SjCKkdlxnDVNiwe6STyMKD33OqTknlu/mvr7p6b22Ug8hAssD305qQx95J/8OQibLOUBHCL1piyMVlnbUYeviQDSjIGl+xIHDFTss0YzJyE+EHrz0h9J52efxvWooFzkiJvcAjbU3gAMFn3Jtm+uUSc6zHVojVaj0RvQWB/KG7NQI+puh1WH4TXoE+lOVCgt1HE2s4UCHPpEbDc8OTbnlaRtbcWB2ZgIvjCTLwNslhoQRy+Bprh6FpfpOClpXW2V03ws/mAybM+8jSx4PQmG1rbwuK6T2o/tvEwjdaj79SHLsg2yR806YdcHqppUSYt+Uefnbaq279a8DY3fRKeeLQFEBhU3pie/LWa9su7yoCEd+7poXoVnmsx2eJFh/1O4buttbkevpOAIsvrl22ROc6aiStYIehckCYNwnR0L6nHNMvF9ZV19p91z9dB2vjuBNgP2pCnAADYggzNOiZaFUcpq2hqTWVn7njophTMHZdl6OMjuYPIQNu3gumVXZ1+gFTVEohInH79aVvOJ7xUKLrgheI/QwcY288Cfg9Mx6lgx7senavvk0+C+v7o5zDyF72YcGruRQ0f7RiZteWWNvOP1CnGY+YAQTo8Ex3T7MexWVrzX3iEDvF6+rEIlVBvakgJ9KUB6NcjrOUJMT6W7EwMrChxgi1emOAt1tyOxc1tQEycVSzkL5NNllg5FR7BSnO7yW3EEo5dmu/3w3B3OQzvgkuJPP3WJs+CgB6kBT2dnUwAAAJcIAAAAAADZXVE7JAAAAJ76IXAq5vknMjM0ODb44uYyNTQpMy8zOPXu9C0rJSgsKS87N/Y6NPTeKSspKSky3hiMQAJMALgvQkuArQjABQBYyzSAVAYksiO1Uqoi/b2JYp/6bvPE4sWkF3hK65vO7CwiiXMIOsf8Q0JLDWvop6YIRlhypIi7Rs2fOsP7qRR3EDTq0IMnKQIySf3zT0rI+hR31OiEKnGPwwczFei1hOG2SHokJPnhtkz3E4z1bjUL0mo734af2GZHeMJmbqIa4P+bBfeyfmFPVMpUuOU5f+NbtwYY0MK5mRmoxXTiYK1eo89ZrQJstSzTKrpp9eTr8LnZ2mxsi9wTZt4bZ9g+0SP0SHc5CfLguB12nQyaE7kKwlbUYQM2F1T5CLQFusyA+97Md7c+zceL7PbpZQIuAcAkz0CQAcOQndZa6+joYMHhx2LO8+ZdcJbzeVff2+aRZ/2dajzJJhdzmdRo5KQF1fm1jrSlgqNeGpRc//nFkSzEIV384m17VFTcy7WRmvLp+M4u50FswGT67zJNsaa4FYqbKAqR7o0NC+XOzehDbzr/UiQNC4LrLvkK4iqaEVXaVnjkK7oClGaeiBHlNQK+BjaLSaPuEDJyA3kNqB6IWvqMLOe5sa/DoBmspDT6jgj6vQtSsI8w0vg8jpAr8BE1bM9D6Ygs9JMWcbzH4Tu0mIdJ1cehzpmcN/dKoIyc1hMM7rRkoFlC0MLLHDfAJdsXfjoDO+PVLsX7M7BOKj22jNc+abF0qgnU9bTo+ThYRmXBfdmgq7D9ynStJjUfNjWF0M9+ZYoSJMXfYqsIaAboNUhSqvWRhmlMLQwWizzaVi+6eAtEZV8oZHFL2vV6rYnLprYHgvXhe494e6TTIEdHHTC16bg956hZUuOSABQihcKg7dmah1ssylWtANCg69lwX8gVKIN7F3hacV7H2/at1dmKYNo8f6KJeO0gchkZ1iQkEkXK4/Gg89Ao+6xqLYAGn9rc5oOoB47dbMchl6kKkzxTV8ZwTZcs+z/N0A3dEt/t7itO7wueASwaUTRoHFF/WpdtwTVhgRo6OGP6H8iUDfFx8Yuhzg6yZwxD7McdRTon5SeqfSGm+cFzVVGZAJpHJBVcUyaa3m+zlPdN/Gn/DS95esp5NE8DUezLZECDjQKOCQD8VBoCEjlkjTYKMqKaltr0wZRPmzoNzUc9D4NBb6+Ituw/DhwjT009tN1cjereI0qc7H9lyqQLQapq5ai4ZoXsPz5Nq9ZqdTnznzA3fWXEoujraAexBL4rqZTCnW/4MbavHvPPwROOu+0AiQuEsuP+2L9YmtXaMZlTcwEIkIqk0gUIGIYqm/uNOPjX8lT5Q+L7SzcdfkiAORYnPp2qhLMfl1uJ+AOG671+XG0VnT0EX+/VdSTsJeWiNYFQvwCY+Ptj6JixgN94P8anVmhoM3A0j1UAnkjENAWHAPDtKtxP2wGghKMDoBsA/J40GEE5n7VwChvWT/8MTo//zL51unYo+/kj2UpmXx3pJJrtGe819GAo+d/eJLJGGyQRViKFN85yocnQVJxY8fsBi1dDg8eenMyxN7emZnEtP+6nxjBQE2sRzn5K25DyoAj0WxqU5YK1lLb9biReWZlFl5Ed4GoSfgBfldwTs5QAvXZpvdjtdbv0aYy0PAFv0TJGrG8pxtEYy4FbnVcQan3PNI8ud9RihroJkyRVATgUW6oWlxUIb8r73SY9szshjKsj4RI/UObWyVKXADZIFMyBNa8ZXyAgX/tedq7rrTQcQc7jhDUZoFuSQCoDIA32iTIu0cyMtzxD1b4UbAZMpNUoZvP7mGnRqfF2yvzm839GGcuMYraxBU8UH5eXCLUb4iZmo1OlrRAofK43UY90U8NU9nHwi+RkRGn9WAWSSWcWdSNGs0TuKvpBwMd9730i6SPmS2J5kssjkXh7Gh9mOvdsnDRAoNf2KWDAHML39sT5qFarDROtuKPqatXXvg/n+JMxbdaO2lOY+jvkbq8as8E1fGwqHXoHBQe9PiX2jMLuOZebszFgLfqFtX7uEHorBLInZAaVBcogGemnA0jX+vobOWEkXV7W/vuwtrSrkzwdKmNPDTu5H6yK1F+36CnJdvbpOwA0FiWX2qCakI+5ssZJA8rFprFp9hC8w8dU0rbzrPhtZcn0mhUINWzFRUv7vP8D9b9mhqkEHQzygNR2A51u7v7OATSCVHu+NPSENU4nNHvTuixnN1GT0LstxDyka9mRstHEBJZXfJcL1RQc7kSi0REXkNbaXiQIl2zpmnyIVho8/yyTera0bGGKiJqraG9o0VDPAjwCHTBuicmY8DMJpGsNQ6b5rOimLO4iudDZPX/BcWxUtw0xfxmt+Jk3O5YZbaIlzkp8HUwiLTcA6AFwP6FBZxJzrKAB4cHxlLQtbe+pN6mffF+u7rukZ7nP9vRC3pXpRicA7BkLC+wHsRELBUrYFxEPikf1gZYzkvP6HKtZn34qT1tfMbMIvX1q65ggt4x82QfSdxAA7BX1hZ49e773gwjt+69xJihoMB2d/suUM95yfoV2qULU+GM0Dd+7pS/yiktjljxL17m+uBX2iQZaeGQSCgKQ/YorUNM6BpPvDwCwLxWZoMFKAQcArkqTwbCD8xOttVY4Gu550DoQaKfztwqyOi2CfItUUY8et05yw8nENTA28INfPjU6F+bb/GoRreDgNZn+/DtN/lBRXeNyKPXHbS7e1onev++XvY/evbYrrXvHi9kFNB5TIpeqs8E45QnKAK2RZVbelTaUXdO5jdXybrzuUJn18wAz5k4vSIEQXqmE05i04b2iPv4u8m5Q4BMN3GvMJDCF3BGyJvcVEhRWnItYwbxzt8V2NjwLKOIHpk5LR7HsoBXgqmiX2WbtnVC0Be4R72wQYGWqGgrOzLX4B34ZrNEgcrtAD9K3Gw2gMHx7AUrYCw8AMgBVwTCwIIjaGnaKvps5tZMkbDbdpOvk+NzJ1atc0+dKyynvpihV1mfM3EcNa0WfJJLQUiRXuIP/KwfUJIcX+uvFscubP0t+HAtKr643/r0Gc/lhfv2CMGe8MzIzP+OPJT17UbaAPSWsVQZHJWi+zpz72oVaK0QmEUS9TubkQbidFncUqTVbdRHOWtQ7AcT341s4JEmVpTswmCZVwk5sLEdNRzpmqm974Uq5gqXUpEfuoVE+r7W7w8C+61HX9g+Xb2qtJm3eqh9YsaFyZFqp81ffidUCJh32J2TMgLE78bIA99Xjlzyy41yEKERP1kwPADSSTho8otY6pLWmp2/5xT7TjbWGvUl0Z/a8wHYmbE95nppSfJ8jRinEQUbraqK9QMUdpNTftjwZXI1qTeVyf/XBjzOOUUO3Y0UbMJmw2eAJo7iWxrqVCk291WRMHuYpmIgX5tAlQwGS9gj/yhjSZ28JBEDrXPk+6IHH1pj7toKisMEhCJRcXaV7xJ2/TCK2wqbA3m6KT1iple/4vYl+2QBaV6yKGVG0huvALIBphctGDJc1Fq+Jz+TO75F9ZM9lCgbl0GQtdk9ek9fkMXD+yHe1B9aYZPKrgBMADPYESipK6/nJgq7ORCkgYpgxyvArYtm6P7mtA9sbAduDxElcM+oUe64x0IsGxAk9iPIwTHwMFesWQFwgYT+AqNWr2rWDY8p1U4L0fO3uqpmcP8iUB/c6YzQOQRCbggB/3iyAl2BkwllOaFwqqXhl7eljtqtHtWIqyv5ASQH89XRKG6RKgPeXGTAad4ZNxxl4/4TwI9Tz42Y6vrcX1paDwtuEpk0ApPHKSbsi5RpBRCha68OSlPxoTZnbR5XvgIy1aRrNkq5agPSzqi3c+xnK3gDE8Qql3aggcPNlygFIjZq+OK9GfbJ1RKhcNUvYt5eyCGWdeYNeT2pJAEQGDVMGwALvN0AmttEy15hLqshEY7tIWe29hrDLIx4M3+m2ZdqmFp9oe4CwC/8E/A13A2qOub2SPXlkvSsB9jEsPF7cR+W4YnFW5YzLMtZyJH9hItdeVZkpT4H/uUX/t6R1cVyzrW9OCwDULa+zPzMZ8JdcItcaxwJcLBlFuRX7YKpG/dlatyemnD94awZ1jArhN1YiBpuZ/n1KIjnOiqEF0qccpGOxES6ZvpWL7y/bf+81fmxZz3OEuVzwwzBrgAEgCwBrfpkhp/M+AGFaFloxBKtPmYXi9XoPE91z+/RC9n7ky2xy4QvLHHM6GWNM3DHdozcD0EA22QFhlW2GvKUjSsI5jGceY4rP15zK0ermooCrlAASllFRVFVJVRvrZ9/q3LEhU2SNAtLrgszz87MHwNOMGoKgaPb0OjeZ9LW2yFKrnZ5tZz33eVluIk+DrK7xNaB0Rv+2f3T0GVvCgId70zxYhKFky4Bi1VLm+J4RnF4IpC9PjYTRzzeiAMlVhUQg7EJvHNUo+rnZKPWNPnC3RCwNy94ALO5EqTAJUeUCDYOtoQrQAjDy+rvnnR9hPjclDztPbXuyfkNmymDRIHJx0Ipd3eN7WdL6/z8TvXoRACQKvc3mf804NYqrajZALxf+8LNOJ9qq1isym/E1ePLQf3SJXGedAS5X4Nmo8dUWNUz5xwHaaMQmQuYPgREJlL377tz7vZm0na/szgcyDTADjQH0UEEuoLXWOkSnm6aeM0OjRXF3pH7J8eGsO+t3kynffZ4+Hdfo8nipiUhT8daJLaiKePOi3vYMN8STGnVP4sT65OrVFVmVTzCAIIqiHr4RhHQ9WmEWZhbVcmdSHQmlPnyL5j8VrmEsMikWEiK5PP4UvO8mvkkizXOwyWvTxliONnb9IPXjBsQ34FVYqkAFViIZ0GBIBW6lmqIdoo9LwDpY5SpaeAytiH6E3HDGJg7DGrYEtt0alnCYmxAO8aSpYvq5ZlVpYRN21QxLj7QTzVg0dINZFCYAFlcMlBRgsBOy6v+yK8uiRdijsFRIZCYgDQaJnwFQEsoJoZmu5gta9lf5bw+6ydBmR+/MHPyX6fmDM7KpZq1O9IeOgQi9TDdWESriPNX1Rl4Gd1NGAdyDqrS0i6laC9WrhuSOpKAYHf2Fxa6ZgUyROVTWPnZqDizlsnnbIW9ilS/PoXUggJD+mQuaoh0gnbHBaKLUggwoYWxfX9xRGQLaFvFMyoINFJmu6ZNafZjCDJIT5EyM5GsEKQi2LzJgpIp3qFFQD0VuZzBis4j3ILUH+EOPDXC33tf2fi46ARMApPXKGQO4khvoGl+5gF6yP1+7WCVWHEa6Ye9nRISjKRSDN/YSBMkWug687coFQwmCLMsZ2QGkipUj0Mk3l3S2kVJqjjCufd5M+yNPepx5XBknwioJ9PFEoyTBrZhyNaR/OQS4YHaHiTVDJzvR5rDVtdctLmA2x2eG6u+n7wAM8nQBdEmAJXb/GeCS5x8vo64siSc9CT4VEsWtAloQb7PB8ba2FZclAAzyKA4gTRVkCf3bGXAlrvVqGw4ViJDVGaNvl91yxNCSeeK1nHWbPSo3DPp0KFlcTS90GGdcJ6hgmJAxqTq+6Ktt1etcSM/0pPOzjQUhT/IaN5tdZDGcBRFZ9QJPZ2dTAACAyQgAAAAAANldUTslAAAAuX1FMDw1OS8uNjjs7ys1MjIoKSozNTAyOzo8Ov8G8+8sKystNTk7/Tc5Ni0rMC0uNzY1LDc2OCo3OC0tLC0pNzfEJV+RBnMr4qXv01tnAdBbOBQne7VhFMq+VLPZy8rNLlU9sZqvs1owEOOlIiZJLHkyzei8Tfwxd7EfUm9ZcqfSYdc7JOj2MYyLy05PlErmxPUY7O1rctR2ouKe364RLoolfgLD8q4LWBESueZBAPQZd1tbLMZPlMLVFDefVglIXAGgDLRDspcuvXcWWoqDSYbiMIn44Z3rftq4ksAaNB6LnCHfmnljaomC6zUl4AMAD+a8AwNNoqk3uQRhyh6ExSz25vh7XMk+yvUoDAwai5Jn8mcTNSaUsmht/5TOuoPzwQefpqkybDGHFwtz1jT+fRFz/LV7A8SjR9UGCsSLCVWOdOQBd1QPlsFBRkJ2gFjCiDq9gE9pb76xVvx+tYPd3Sbal3ze4Xc0iteQZPcGWlC9J4++k37zkV4C+ke0Zc1GMrZ3olR2e2/evb09xGvnULEIHzgCNECbgR7J1DwAYayVtkz1O9OPloM80+ej17MGexCV744ZHjdd+nSWNgZdKkbCMH+AVg2qLa/MRFQx6U5yhJZttVhEdNUGzTHP2oT1tqxDVSsRoXERYRRtale+PCBgZqo7hqc/WEg4g0EgcdMbdMOF+BXfsY0qrDujiV4ENoRJC1pQ5s6s0Mxvc67qV82PAFSuoyt7+0W1AfQ5f6z3uP5zlIgjgyDQ86MYvKgzitwRQS++j9N656BtQhCtuLCo7Mf/QOyrD0Lo8yCuDuvalfQIKACWV1SJGiSBE5C7/3muZ7pxZM/XAd8UHAkqgFQaWIDUzwccC08zbbZNveXWQ19M0/BU3q/et5o8vft5tbo4f+nmZK1cc2rKxl0Nl+BISJsz19B7tqpORhAhm6xJq9E8ZRzoRS2MJUy2LM7MCqrkF9/RF2ePY3V2/yh2D8iaWYj0ji9zXeGCA0GPBKe7gJymu6TaD0L9oz/yb/lHlUyyMY6oleXgLFCJ2aK270zOpT37bDGiM0XJBIbmxLvbJy85GU8xh0nGBjfxoR5Obvb/UlDJdSMSxtaRJYe2+H1N8O6n5nMQ0oI+OUiJvPaVOzaAAgzuPFFLXcmKQ0VkrgHQC6YH4yhNYu1A1fOsXfm7qtUWZi/H6ZVkst3EnAAk8kTHtktxgLCfmYEyJq+/qwk7bHbvuhc1rYK/aRd8nJRN2qRJwFn78b3a/v7rF18t4vcfACwC6QQyBBAmHw9AuTh+G2SMSKSoWAn1+YaHC9JrnuYLtWfVwV5KynKRfZo67392Ix4HJALRRLTPiIP7uwFUMPXT/34acQbN8RzbbH9ZHBr8Bdd1nK30tuoya0ZuLaT6m33HSwE0AikLQjXOQU5aZ1ICBAm6bG4Mqag41CpP8kEseXM5niZvBrniU0UHHAIpqSVnhZhlcsHcjQYueax/64pBsObTtk/jndBCVhCvvgo5c45rbAAM8jwGVKYqR9y/ugAhgeb11tPxyNo52wLalf5GuUADhPNr5Q7rqvZHowAkGpEglcoQYHeASlEG2P6XqZkKjlieroHW20/oerJiUigJ4TYsX9maaa1/aUOGjMUfSgAU8gSLIUthORG4bjWA7sYUjebtwcgx+cdKXVe97p+N5kIcyfnEd7nmJe+es6Z44RiKpis3ABwKtSYNXaFDjr5KAOVcO6xrO9BqlEGK8AeWKq+m4DJxqZh09R2euyVf28WL8xmDAAwiAaLsE+eGXo0dwBbLE0j6sa/bV/bKc9HTU3KvmrpZMt/mD7bzIZANunDgSp+otiUCFC69ooFsl1/FZgBtOmu6CxRi+6CF0sC/uzv5mq1qwfxPZDyzl9cfTKWqawwly89+z2qqVIf2HD20IgAEKsshRl7DtRTXwqy6Xe8IIJS4AbwAHaChXOSOhsTUh/9n4eUUrXGc2O2GE5UdcxdRkfhjeKh1q8kZBBb1nsCuE+tVbNZaCc2aYCCQWgvAteHiBRH3KonJ50mVORtjkf3ZZIy2sZX8sC0xdeyfmdc4n0xE3dcBBCK9ILBbD52KzQJqx1rvWKAoMUw1J7Bl3IguNZmunxLaNDe9upKE2pSix2IhTdKG/eQ1LD9K3i9iGXrXzNKSMRLFTFQxoXzfD9X2SJ2i/rfoDDx/BABWKJCenQYABDMC/oIEB44GkIahIXp5zRSGJ6Od85Rjnju4jCpHs/MnpDZ5WdeziaLSoKepqGMk3S+nK6KhqcL+7yZXczXG1oiFJa727w1anbJGClGoTVPLzWv5kKoIhcwbXRbDbG0ZPp6/MpDYXx3OFa6UOiBQxLp+a3LYnCRRkgKV0kUjgkPz9r2ewZVXWin1TfpUqThRUPE2DL0Ny6gD/uRQhT0+/M65mIuRuQEtO9w7nT4UUxwh8WL6Z25UyxXrYxJ1s8UuKElQ+99X052VIFRUqsPhxQ0mdwzh9xCy1RZTS4z66sF4AP64hKaFcjAwpQS3X4YrhAoAwBIg0xMIBiB6By5bAYSNDnlM8ePa7Xcv4o/dnhw9vfrk1XnE2QEg47zbK6vdQUWeSjeO22xalQGBICMue5OX30NjGPV5SBUlqri6GcT3/rXITZr/p42VISsn2V1jSVqRlWdQyZuvaLGvdwSRrkJq+ARJuYxmHU6JaJwGBvqKcKUtsXbUld3L7BT22UtCUs20//Ts9pb1LsnXSswlDBIvgmfmAB6O+V5lk5aJtH6oUZV1tczgTXr3w/r89woZ4urMA3MQkZNqMBMF+kw/KCg9xmTNlO0Hlf6ZXYZGNLJBw3knAPanVFnrQ6limIm1wtv/efRkPae0nzkAAEwzl0AGwPcP/NQAUloIoyg+s0nLaGOj0Di/uXzrJbMwDID44DFLCiGIaxsL6XE9FbZprQtQIlCiYoJ+fn3w8y8PnzwI7i64gG5tHOzhwomKHHp9VswrgoktkmpqPHWU/Ad4OBMo/chhNKyhR/s+n9bQTPRIf5BJIp1nGuHT3BvnfRIxD7wpfPjhFA/fG6gZKdPJ/N5Ahge6UgxAn8BjQDKCdkx28yOC0S8CLtbTmenDR05fWoKBbFu7YW+H2OttAzdg5VK9qpHeCCetEqhhB2dnub4gzyoBFAo1KXEbdaGbLHVXRRQAAgCRIy/IWiYl7ttEdFkbxzqwDui23FouFOMloQAkDlHpGVUROYDMJH2aCSwiBzhrGk1bovCFTQtPmjgZriwCHbaqdbRL6aE6NBIx8UAoDroJ0Qdr6KV4rw/n9D1VGXHQgfBPxtrJd4lBg++w3NUi2RtQAwwWPdlTVkI7OsDEbwcAq8QyDWQZKvqm5/cNZZVR2uIl7d54VQgkV5Z2bZfvJhweaRagC3vJafRxrskWCMoVJ3laTzn8WUM2L549Bf1uQZ6udOj4fKrGvRjrvuWbkEwEugAA/DV9es8GI/mJKyYj1MT70TZAypYFKGh4GpmSaWk46b5kifWU7lQ5TWL10t7UbIxsTrRY+WduJ9MJNDL9glYuZd5V8Vpj1h57TQWJVJCyvQQo7jwWFjH2HJ386ej/w/h/kQBtPkKzx9SS4ZL3/PZUqyXAVQXy98xqXVy0wzq8T9LX1kgKYn8vxz0Xe3TGxxrovn5xAZhIz94GAMiSnd8sAGalgCWQJGF1CfbnwA7BQEadx7pJ7m37lX/9OvmJy9FryH8cTUpL7aRBhcHUUfRubm9WzyoqU4qZs63y7pkJK2uGddb1Tc3cSNUYXYkQY4yxJtDC9L5dPL3iUV2Gl/59KJlMalQowIwRNqazWZGYCYWkj/uQw6WhJNQOeYR9f0uLjxU27BiANGxb43d4AFMMA1NM+7LOrtNAWLbFp/463LKYvapQBYD1Y5WtN3F2+U/d4c5azX1kz4VkFmlxCSfgmC2hfMjLKNKlSXwmOOcWAZwkNCqhCqZK0dGShW8GXGdpAC24VBzbmo5K90pTzq8+4TpvGw2pv0jY2GwotFEiusrNE32xISztCEQiMQsM01g7MqPWWqAOtEAqrv7wnIfakrmxy3Kt1fzePpIS3lxb4tIUEn7Ksbsl+S59df+uItPSA/w1vTGYSsw3qIqhPe9S1EASW8MpMP1m5YAXk88fUKnnp3rWu6BbQmFtNdNJM6vPBaI9NziEACQmBRNQIcQJoEP+Q60FE4GaDxzY1jIQMbJNzIJbOsxnq2i13ipxAhHvKneRBgQqC1KAS4lZ0c24in4mAjgeng0fEdlIRR7/JtmTs3COXm7qjh3ZEHZYTgzELXfExNeP+qvIAlTJ1leRBDwkH49eGVyVi41PptRert5NR5Q4CTznk0YOjN/48QQEJotyEC8bE62ZKcX4fVSjJGz92n7xMXbLB4XmQUhJSo1t+saMrGaVUPpJgQDUJYtjArJ0JtqYTe1ZO4BVQZkGXec6WXbMlqWjRPQJ2gVcQt9CJkDL8Mr6y50CDDLFHEQm4woVkwFK/fW2H6ApMRTnWmO6F499e/jurUR+jUvCpjx8J5seHJEIdMq7KZvQKeJ7NiQmEZ6wJKp167W4PQAlsI5VNFCqKZSYDjrPOd+OVBxdT/dBpf/Q3tVqhERrATuAdACpVXfiBQwy9TERi10HLZi79oSt0oAYWE6lHp/XYUqmsf5SK2Ra+SLXRMISEinCa9IVpLugLvwhjfEKPDJ1yROd3hPdbNQpVxE1gAAQcOH3rHQMK21OI6a6vq/muHwqHn3RdHneDH8cKjUXYEq1o5tMaweAFkgcq0gwGf+Ujm4MvX+PsTfzfABPjCGJhxqejp6SElyduK8iWe2sTPRYXC4V84wAB91szu6aIJAksUsSmzYqRhKYJDpJScp4ST0lsUgvOfb29LiRmfKgjAVzZS3tvlIFNC6FGCQuLS6RUAQfN1c1AEoQcHDFUeRMpKuBJi3KupX0eH9T/u6tr4q/fWLpy58BTCkHoU1PggIEJn02AZX0K4gMdmeyGSCtAlODadFShnyYmIPV3EW2ahElJyOnrVG/od80JhHmOcH0KqJpWe9qIIh1OMbbPyXFMauN+eaw+KMZ0tqXekgcyhFrPtmZQU4HP77PhpQ3vecPTCrRYGQSqyuOOWhH/MT5gNgsWGzueTRSPVm9vn8kq1fp6Sud9COCaqaq1dgdr41DN+04ovSzpQkcIvXGE5OcB22sTMH7IhoE7GCY53YSq1vPg52iKWx1Zn+ytSOKlzUHbdxMAhIMInU8AZ2NL4huOdyPHCAGkvxYkwYUiaifEUSjbKuy0R00F3024A7jsGuBNQDsJQtdMFM6N1o2G5TD772CS5pT56Yu6pT9ZPYG10BsRv2TagU1jgsOXrjGBCQqvdnz3Km+6IY55D+SIAAkT2bHDT4unfwRzAVTYzViuln/VVJLN7O1BFstADQqxerB0WonH3BNBTgEk8BclyFNNVJPJy3Nsl31e8v6LafcXwqzMwUWBDY9IBGFJhEgFww0+SkHEIPkUMuPptzLzsV/X93ctfpCK6c8nZrd9WutcTS+6w80GDJ8Nk2jAuQpX0PsTWasTAHoolL0P80Z9D2KkseXGrGnPj60GMzXkgrqu6+ihI5tdQk2+EqMo4FX0cgGGwNPZ2dTAABAAgkAAAAAANldUTsmAAAAGbpYhDby5vEqKyoqKCg3NTo37vrzKSkoJycqJzU1OTg5NPYrMDEzKiwrKjMxKyotKzI1MisxODc36uE6CM0w1i90idkzL97zMwstFveNXutr6M2uzV1RgjEww4AxDJ/4mhX4WMHqE5AGJCGrkGCK/ej/7iNqddOf3hRMNH1Z42H6upMkSqV33LlagBgnk4Nf2qYBgFbcOxKj4tp+fHV/mqKqAcSWXTH4+jwCra3a5G39z+wYk0Fp1doIfvPQTFJBP9GOdlETN1cy8qrcPPaqgRZm0aI0REEJZVsskTTyK6ElNWDm06fPXWutMRiYxlMV1MTMfYyRbV1oLw3387O74FmDwCJnq1nkJgBwPz8/R4YGOgg3wV+lXy9e97oAvDkxCL7Pl6G4GNpHwCx0AL6oxCCGPMApix3vmzMCkvQZxKSgx4kdAYAxgOEA7QJWC9VZWbNjiioTy6V5zhcYywGDv6/1ll64YCmlIvts1FGij5p4tWnAXdptF+I9rFsoYClAYKV/kWZliOPRsEZ1BUaPtTz4yioTwzINt+urzhSuU9ANJPSyvz71E+TG+YrqybIZOiziOrnnjK9lsi/YjEx9N3wdbDmRQAFlZvxXv464dWXC3QFfUKl1TbMBOOvBLqosS2DCt9cKpwrq41IzJqQslgxuzblUbBoUwhDk/uVVyECXXWHaELRMN8Z9qzX17H+8QyoBdqdUuJgsU2SldT5Q3h8AAH0/AXAkQA2GGcBkg1EnzVuiIpWiGHvrmbSJfJ3ls/zf66oYpoQbHU77RMauDWfMelXSRiCEGpzL61pAee77viU4gu9mT1cv0ISJ5u2d5bcf8wX/cW7dvxua9gXbrPawhPMRNtzuXq7zDVeC+wYCQOCQz9ZadTbms3dDMhucE15E0krRM0tvMomxRw0RX/lUACUSf8aEjRNlnn01fPDb2goxG03cBtyuuLO+C31QISgscYszIrQmKtY5nbJyrc+vkKF+0brDZUqd8swUKo8Kul67l5jiis6Wedc39aOnFuN2AdQVd1XPcUI4ZbmuroEgXOM0LpWIDutir+Ou4LNidh61pZqJxDFvZlEvACQOC5SBy1A7pXdj9pZoUUHxogYd75rI8fybrv2GVzrrx00kdqYv3uFeTQA8Bn3NRlZcScmd8gjQJwQPuo0sg5RHxthw1DtH7VEqFpfGQG5vsGNHjw00Cgu7jU5iMNRT2zgSxAHJgkkOo1A0dzuVaLDGJ2WBdPGbz+nuGTd+1AYUCss1GxelYuf2VcAlD1pfsxZPum0XxFPW3DpKP1m/kSR72UW9kx8CBArLJSNOfbGRf5VskIIq25hpg3AzFa5jY78Qhuf2+o0aWlpprW3xAPwJi7Ln5laqHx0ksi930foFLo45a8WRtAb+HBXtg7CxmhrLPuaBr8p8HIXQaZj3cUqy0l8mjgA8Ar3ASIgWEL3fukGl1vxfFNtyNeiuSou/dLao96nZtKDTZ6e11hN9diaomKC+aTW2WPKXAiwqdzNbymwJnFIYP5MLekc3DPXn57vj0J5mJvnjxKd3FU9bE0Cbcfjez6ziGahk3ZIDfPKCUM0MEQD8Pa9h9m0yLSf4MtQHt7oULF7FgK3i8jaxbyRujN+yM5RriWQH/7a6l0z1piN8b0iE4YC9Sl4KOuhUoO7XbZqq3S3epf8d37enfq3z1vWR3A3UGTPNPBibB7p5sNBIZcAHJZmtYYpmtspdH74wvtsQMJ9ML+LM9MGHiDFO/31tU2vNfL8yqrXmNY7rA1FjjBFgoqf2Z/vRJK6ejDEm3/36/+uZSWyoNhilVu9evzS/CTuyT4Ayigm64oqrql7m7uwG2F/97xukpqFRfJMCDVPyD3BruPBeBNxb0/2whps8nOfikks6w/Xk8uriCtCWxm2eLOClXmnUoggZ8KqhzzTCJQOgO/o0fEHRw475fX42anF14cZ9mxJeGhNy4XMdTnuyCtA1AB55lEJHGEOnRQ7d/H01oLP578L+bjDAjgaAcwBHgBXobAALgECrB50Cx6SjmOhnjVfL681DIzVa6FlQr7ZqsxOSb7O62VgqGpbIl+rdpTcNLYbwSOOvQg4kiKKK4DIIqY0YFBFPvG4r4CpYHz6gUR3QRg1129nkwMRxMNUfjz88mSM91c1hbRX/o38n1eclOv7JmFpruhkgtodJ59TS7V8mSM5+jTzqJHAkGCUyO1CA0f6vms1mfEH/ZwigzFq8YrtgiIHHW8YmmCJ31pS6T+Cwn5oLJdNxBcg4nG2S7Zoum97Ghzjk4zkXDwG1o+J2r3lbBzySKJSZJwB2d1Q4X0dpYOIpvC9Hm0Ndd5fNPx3ACwCOAjAQhjWgbwFtkLTVPSs0UyQMb5Iv3i2G1Xi17+MXaz19O8mx90rP9bJyRVptbA1iEJrrxF3otVH55yYERLyZn65IV6Aet1UaWkE3Vb+Zepk3FSWX0u0J0W+SPd0gAhbG83J5f1lNQe0hx+q1a6lebpwZ5FPz51GncKIAdi7AcgP8cTK2zVfD+ptGYYb977YZnrC8/MVAEKvNw7D1oMUJFCrHSvvUQ3+dP3ZaO4iohkoVbDTcHV+G+H5ZF342daWbLyiFYG9GRAet2UJUQYxnOcKP9bIyKlDa2wAkFn3BQCgaTG20ZdlYEY3d3RqpbNtmBvPXmB4xJ7LG+0OZqJjY62qVABz2yoKRTtbqkdf2dheECz4f3NQTjLnLXvsnjH+aOWiqeFLmCRdjRd4aXBL9M1gcxbjoQyik4Ouf/k4VId1SSamIdT4K2xDrp3iDmc3Aj1mpAxwGy3fJXKDCNPMFhAyn3FsZR1u+5/qIQsaVXWkOlbWeqTymi1zpBQwSi6InHLNC1ewbA7wG33lzJ2vMrEFtFofHitzz7GcR04u7v5NFB/QFdzRP4qY2Fupi32aSQfA+bb7MBI+SWigoJMZ5S4au7RokIj+aEjyOdfQFd1Z7KoFDfU3VCzA4MG7IiUQwZkN7nZE++oRK7M9Gjez5FqNqAzQCfTrInXMY3ELDvEsg0sL2A5NxdDBqRLMC9fzYves5ha6cTuedPYJ5P7507Tid9F5v/80GDCp3M49SLNN8zQuh+qQboDom9LZ1ViumLSFIrPPVQxGeXll3C0F7ZHb8UT81qIXWvqmBuhUkMssoz7bBf7gVyTT2Je+6TsdATm+xuWss8bmhi20uGpm2sOKune38diy49w9dbOZ8BfjTh5BxXhfcRcvLhA/j3nIKPea3tyozFhnoEGVMvDFDNdQkXZe9XilHm4+v1Qozmqjid0xLs10fz33T7hxxByQ2i51ne6nKrkgGyvXWaQMWWqaJlpjsChu4KvBZJmdF6kB1HkT7HMcD37fwgzGZ/lY2n6Y9TuubASw2/dHTQ+qtOoAScK94AMxK9j0HKwYb5+WXm1T1rB1brRJkBmug/KklSDDPW/RIv1Cq9QLyt1SA23I1rVv1a+8qXRKj7wcAgALVAyQKa0EDgCSYH9pIRmkA1jBjPHMqEWGtUc9D3yUN85Xpfb2ru+Tk4AN5WpGuk+qot0sDqKjq+l8D13j4dzJOJoQvt682Pbb1HHcAPHYhPUO+uCzxRMn8KZvYs7fGFIA9vug8RC6mUzuu9rua1XhsplY3lW1+Cb22RlbUCF1WkRleg9vfsW91V5WKWjh8K2O3TtJUAKEk0sbn0IZ/xxNZGUTlQ7ZaxwbcpxK5phmw+mVNdQCmwk15sVu6OjQVEgAWppHGXDDkg69uqlaBUmCm0Cw+3t3eDQQxtd9gepAjCgDcGa+Z7MnmPlJc48x7BkbFv/9umSRCWWS2OWuObq4Stal/12ehqSrrz6ADXB51TUJ9u4MMK8dPR4BM4oramqwetJYjtDvVPF/OzFzlIRN82jdcg6E/dl51IWwJXB71DbhaHJ8ylXOAcrHwwh0zdeZberaqeJxh1w+JF73dUFnXPOON8oJe9hrRExGpDnwuQWWZBMEtBLHK10BD7ybO42tTGrrXDQ3mehhrUIzmlaqYviNT46yNRrD/ucD8Ist2B1wePdnw4ttnoKDbtwqX/PLVvJQwxpHQNNo/zTaOqGSbB5lwa2vksGRDAVweddkQ1mr18VIG37eZuOGDGxn7XZdVFR/mP5FLuvCBiTAWPVxQ5glj39YB7BWvDBtTJcuMmP5FlyANuUYFibMjjTc9J56B86YKZnk9FohlVA33l9o5ARQeC5vHwin9dIVArx4JXImXubVG4spcSioNEZ1+QvYdYngXaQ1lHRMaAFwexdk21TtKuvDpC4sOjqWnzl2vduElectHDBaeRB7m51vUxLM16zsrfo79Wzv7PZveA1wi6WajM6lCjP34AirV+w7rlaK3q8rsIh6flohxXzbjd3DK5IQOe8aW4UeueTeGkgZMGgsm5Ryh3vTVq60YAsTRMdAsDUxZyvqoXAadYre2J4Jo4kQjqgkQ34MARBZ9VVnhstUFrl4z7QBxTCSvYiyTSB8QxU6EwfvPR1xPxr6IQNXNRgQA/BXLVfuubhmBEnyhAT/OABHDD3Gt5pIqYYqhN2VuzQICom+yOug0RGgcC2QBBB7Lhidc9+4LaMzg24oM4Eo0H4Q10YrTI5KjbJSdnYKlISgxN1dWm0W9ASQqvc0DV231gBKWfvEdoJyTjrCi7kagPPg+g9uOykvHx7z4J87Nhj2ZVvK9m/+z0DwQPBZFo+BCVnQi4dfxDRozXYR3wkDH3VoYx0FO25au1er21HeyV/6SL3ZsdmQzj4o0fT72QAJEGoVsAKstaiGkV8wJyhV+sQlsO3yLt8lEflsiGKuB9/oELnNKu+U+h/1iMwHSd8g1AFQWCzuzlmxziaX6WMWRAIIkD0zYLnxFrC4uPm+nZeR68+VLl3vaIpii5wFMKrXJCMJk/D1ZvyISVJJ761KxHK/7TL08Vj2sqw+etggx4fl6F+JExK9DrP4s15IAPBo9lA3DT5WB0th+RSeoFvYJdjJGoev0SEp7r9/HXtucU5zqD6Zpod4aTQ8WWuvFYvHgQUCGOgAsJkuA3W6wLN/JVAj8FQPI6mgsXDBMs7E2SrtKrVPe9an4mdtdoO22vajozHTCVndcFkh76/AAJDKLUfun5pScqtesfeOjBNtNilpr9BWdWCMv5rTVWLlcksCXr1RXcqPfqhOJ9YdYx39iShiqAJr3zJIyHlXd4NFnN0yYrYwy3g8AQBAYz4AuSBqTiSQwDKmS0L4lKuChcGkElj7uXhvTfp65PhnC/Hx2dUgcYN2K1s4OPzxT7Wz+3bGvZw4mHzykIEi1SiAv/uQe2Mt51nvfepMcw8TZSzpd1bCuNs1Eobu7O5vzvOzFVKQU8aOfhbddh4nDUXWTBhFwL3Nro26On3h4L14JFICypm7nVuot9mApABTkJSWlWNUhAIBnaHqpw/+yxtJA5UKeKd4/o67cOAlbKfbNed4m8qgfRFNyES6grapOK5kAPQTCBSeYxAaAsX1glpABBZ7YJMiaVkkgd70AhVK8X9OrYeD6pQCAj+GAB2wmFURYIGdckNUMtC5731+qAyND+ppDG6djNv1KI5tZFUWcast4ePrmgU1iMhmtvuzbNFSI3CuxCSwJb0M6GlIdhXp/EU0/JsOQXDe3OHnlBrG034tf2nLZ/vetWTPcVUcRAFw7bvVVWJ3WZvJ6WrxZtSCg/qFesVxpCjIr/ECCE/zdgE6NeJUE+6izeYlM3hgNfAKnJVyXwiI5pvfxM2gD26aYwlVzXQDAreQUrWGwsmCvruOCN8uDP8FprRusZ9tFqqgSCU9nZ1MAAIA6CQAAAAAA2V1ROycAAAAMW1McNeo2MjUqKig3ODc3MC41NzIqLCwpKi0zMe8rNTUtNjQpLS04OuX2LScoOTP5Kik1POv29S4rltckAldLQ3t9eHWMJ0XvlfUbL3tF8mKPuwAHPIA0wwSS4LaC1HmJr0im2L3IXhXGbToTbuRfZqvZcfDe/pNNbpetVcjF65tWVZiFFLZej3FNKxUuEkq4s32rqTn7j18PeErzq/lcO4D2XnH/+rEDe6fEYvJaKKXFqOndhaoHc1v0ejzcXtMGbj9VS3F8Zy2drI1TXcAkKAq/eDDOBHk5uJ13s3wFkFB/ZoX7i1GqTkMb7SVCFhoROw6V/h9XUoI9jZo9/KG0A7MtGzGPZUC8hCZi4SS1G81YKrsofKu0MQ57/z440MeKiZoATCrRbMzWiX50zoUWuY5X0Iiuk3zkiFrFqTeOseXXiX2InM2tOPTs4qhRYEkDOnxGzioWorVIfCJJULAu6wbIYftpBtLF5mU00dvyMh5bBPRT1Mm/CEzRfh/1i8m7ZH8mea1Fn2trShJULqlg54O79MX3xVdughhaYqe5mq5lNV9Rmoq/C753Jy9xLvmvUhncYjZlm6APKqaCsozWAGQadTMLZpLyZnLD9sEkJHk8kdv3hTvGwpNHBH7OJlRxIiVym1d0r5tuOgwaC6sd0jHqMRTC/CQ6QUTC2xXNBoTWBTbT2NWgbTUQl/dQPvw/xF0tLXwahQ5clxVi5PWVoAED5xcmnknsmPKP0Aweya0tn1zVsAJ694WYXgT0HQuLSGmp/hNxYUrxs3YAT5Y8AROjcNJUqaw4urFY9KdXm1Bt/5dM6pNYAlov7u7616sZbQYBJEaLSjy20V2meC4QfVfFADQ0aJbCgmsXryj7/nhuaHLhtqz66P3dvum8wwpVLuxEhn0skQToDAA0Lj0Fnj2eJ4esLqh3rYUK0Bs05+dtW/18FevHA5YQGa5qRbSuvhjmf9CKpsAaJjkq+88mmWoNNCr9qGdY09xqoJpcxZGgM+NhF+XURg0DuVy7yjSCqfsXMNnZjo8Perz3zJBsfYYuTznir2pJACwmSyjPsH7DEp2Ly+gbXoga+Crjj6RLrG+/kypbv4SD5e++Hf7N4GIzyGX6yBHaAQwmfULw7uGzWVzbpFa5ASYaNAnfyYJY+aL0beomah1V1iK3DsIdVNHsI3yU3AY0JkUhQPONtxrQ21hVLZjIxDauX1TilDBObIcyiRfJ6aDsX83OT+tHldLwTTucq6em3SOBAWQmBeiRbFSmjkKdcpWbALOjpHh6itPxdLy2no3preao6UMjXMxE5RVt0zMp8YKD82tHev9ylwI0KjXmOclrq0F17CoiNBo9kwWfL8xrkXbe9jQkZGUrKT5iu52zLwE6bo4wjGnw2NgwAzQi/cSDEskXFZ6Hr+gAKXn99o1iBZ8qCjM8EEwHtjdbPtzaiGwRx7YIADwyddxzhnQ4mhyo9RedIB0OZkbUyLqAo2RWuqNs0kjt2x8TTRt+pUfbK4YBJCa9JMDgkweeWBUGgGtAwurshcglnPZoER2b/BByBsv7tXYRjG/HiOxkyQAkKgusZwzhLgIHFfuFAEEGrncKmBoYb2vy5Nvv0R+keN5SYOLqkm+BbRwyS7gHMmw/AzW5imsBBK8c3GkfUknIpLcevaVNY29o6jJ7o/7J1d7EJNwpd0hPlMi+HLW+iq0EEBe6xs/1OB0lJPFcRETt3FzEPWErlWw0WhsauUtJAHwuIbfDOrEg99ZpgYkGgwZb3X6UPW07kTTashcfF/KWhPIcRsUC1kwWW3/MbGav2cxu6VwmIfeg6Cy48JcADbrFzpsaKtKeBL1PV6vDluPRmrPujC3s+m9pDzMPNef9jADRwgDyBw1QKtJc5SOCjMz6xVOf92hU6xiSuq/XXQAMACsEgkEnnMEEjwykLBTwtVgv/p3/nnMan8ytZHn+StjuzetrWbQlfHVh77o4DJ3owbf3LloiIoN/510sJRJZfL1TJP/bxq1xXGSiybXVdsuDZaxWqzOy0+MDBaUlKHTrLmBhO+3l9XFhO0mb24B8WBCR1lGMvUAGZvq/qpSFsHL15imRQMaijEaADkTDYpqC0mKZyPrXfdXU4CqWHuElbvX9xc0gkQCwCRc4x2IK6NoL4zOrhgUobfdamRWc1hnoMX8qq3Zfzyi8ry1cSWCY784zE/wlS6Antqz4B46j8/jJWYKI5KbghnVgROsxNtqLrbrES5vQvk5HUw4fSABEKmnlOYPXLDDrtDWYaMAxhvuLdsJTKxuVdXLfXPoyOCTCwOtrUerunmp6mx/+e0vq2/9KAkQ+BeI5Q4YPu5c7QLqiVoC+lYspyhT3PO+Tfqvp673Qq/q+uvCHJ5JOpzXIWZUNo1djbgQBZCoJ82DvaxHgRCX/mwPEBZLzwpVikiAJ6jsWTftUBa3dFEojl1cruYgmRm4AhC6t9Exululzeuf+DDTlWvFzV9dfYfxUVXyJL1s9h9j08xFM2w0VH4x9qX+7rgq6V9WM0CYBdEYR6QEWtwAMulXtBujMuNCSO739hEm5NTXnDUN8Jvi4jv1dinnmjhSyXQ7GCUaefN35GaxKuQItHrKEyVtnegEYRLYNYsmCFX3AdRfqECSxZ59L5iKWGtUOHigJtGZxBIIeh5iuHQBdj+OwBCErOVxsd1xbLRakqvC/pTZHNhZdyUuWzr7ZljcArFIpRwiVjWYYoP3evUADKmYOrJUBDRpNDcKgGXJqlhcr8zOh0jYQjXyli6IDpC7tbondU5BQYE6u8y4AZCktHPHFGtsr++tbYwjDA4uFtmnxYFLabq+Olp/n0mBgTiVPsSf3HgFMQr1FHrudW17qggIpXJMlwHcU51bBBZNRTPjzgaHKOPlSGKxTk4tZ7bShX3LlPPdv/ic3pXHH9i0S+lmlHWazu/kZrS+usC1S/P/dP4YvcmhWXcx47iYALEmwwi7IgHWVJw0OUuwUC0sxfB0/a96IHS1XZX7MsNHUW1S1Yeil6PbSrFzVAPXD2UtbWisU1KjWhDa/aXDKVaOV4NBae3FpfnmX+TP14HSMceLcOW7+yn9pPiu+mp4Bk1WasQkCaJQUHyvQZaEUClpoAIuGQJDn7SoTNr1y7YDnTVMTJiCEyZQByKy11q+I1co7ThUNABCeX76eSeB5026z3Ov52c3q8PyaYxMSp7Xh7OUX/rtdVWM+bzd4aix7h1CgdsN1ATYY5aDZxj6VjwCKWP8AAJ7qAQBHgATdHgA5AjLQhiIcjF/YhGQ/YSID1xhPQiy6Z7wvOU8DmYxMRE1c7BZtV1l+plrcIEKr9aGhi5Bwz7rIZSlQAF6u3jTm5oMmBIkLJ13v3bNY0jY1wNhdNA8k7mz6KmSu0C1tXv6h/FrcXf3Hlj2vL6idmLN825CmOYyQLG+3EP5AjG3IPkSpM/sS+ckcl5tOS3DYza9UPpY9jpd9KjSbXu584V0y6b9yXNvkT1V/44bPWOHBFoVUE+DQt1b7i3U95V2p6MfpmEptX15C0s7bWhZTy7VVIzIFBjD42pU2NDadDQwuC0JwFr5HJVfydoCOwJJlAoS04w2Ea+krnxMReqDeMv9Nu6deN3eA4Ww0AEw2Ke5ZLo69AkNtfSqBpgKTnu9UBMcNRRG3CV8VfbVV9pcgSTDIUCwyvSHoK7626Orz5TEAI2EkaKEcaRZHipbub3qw/k6v1SVMKNHunRgsKvXWc4zf2AMjErXWUAFmg+li1uY52TBuMt/OJ7qwHFEz7K+5vU0+c78KNY+q+EeSxMEpUmYPGgA0MgUXZKTZlqgbW0sakIl9Sru3Su6yll3+Wkm25tAW2+zf51llSO1drxhcX9/9U7x/kQAyGOWIWO2akijjgrTEvP+Nfen0rGNrEgDgaCABewCcLzDAbaTNYKEevpW1cEwxxBfE5LVuDseNnxt5G5o+fQAAIEF4yOxSEOnaj9mEUBwMjvuYv0Hg4lJmOrn9GUQ8MI7SrJlT4cNrG+9+WJN5KMmEbH8+nu50aZE33wsNXTuhpqMSi8lKqZWdjpR14UBZjqcwMXZIeMMlK1xZLYKjXzGSsHiSRHOHP70fDxtNATquN3uoDXvAHOaMdhUBYN9J7JnwrBj7DW3V3KqeA0hEYxY2f2YQ1mSFrVy/4rD7cnvXj4ePXxVDBU4hLi6X6BgWHdtbXNKq+SDZyQb8MQtlgBTKj3MNruJpgBkRvMOwlcVA3uTCqBLTUGIU3aLJWsUsz6/njwEUOn3ME8nrP8qvX3QFMAbmTrhMhHLo6Avd9N5ulOInLpmq8OaWHFSYBAwuvQUJvNF5cRRH05c1Gj4d+5Sz1dHzqWFqv/j1f7m77+pJ68WDZkn+15qPi35NJhNhvhcB9EWLS4J2z9ztRY6+1NeqtktQEA8zNsHFKibkNujp9yvzI+PkWa26bLTEocnAVHdhL7O0HZujUVNEkjUA2icNIDfy2Xwulp6WUrLc953maR/H1oedqwT79b4JAEcNJGCFiQzM1U/+AMZIsauQYOD13JkINji7VU3P0jBePW5H5fVydZlNKHCQY2k1r5XEpAnVcse0BdWKVY1RlRij+vTBmbfZp2yj4SBVm/zuA29HJ8xMxOP04Y8Xx88b/x+bVgRKHrmgfGtQ92lQ3Flbv5jzuHWaymkH+csisLtHHwu1BlCptFcMhDCZkgGArLXW88aqsY8DIADXdZOsAwBT8eA3+Yeg6UtAPA4kwPLvL7y4sCBlc2xKUzKhW1QvtOfn2fLyBZyWX36hAD4ppcaFfrgImCXm/SwLXVcAAOBYANQA/QrwUS7IwK1GmmQBtDwPICAhkUTNwEutfxNP3J3G2tuqkBRzPZwCAFikzcqXUzyiVNi3lpZWIeoTkyidlYi7NiYPWouSsqBLNknm/38vtX6ONBRJ9oSY/M/36uW0FWlb1XZZt/DUBSs9cnpbRNNhpU0ZmCbzlALvtJIwZ4NDyySL6qjFgr9YrcsOKampOzFAzjXmbC/EFsA1PMgO/YswAQdcrJAYYADoW2Pbmun8/WgCGmvqglc3yr1OCaZ23jD42jDMdDd/dIleiKXdgQ2HEiLoLeLNeF9rDPRTL7ElTJYYhcBVSgVkUtYKd3/VkeduZLQ+n0UQAHBUQBXQrwA3wADf6cvg6yBJQ2qtKHpUc6HRH8e3MEHE1OcXGlwXAHjWw//WnEKjquqBKTcWCRUFXcwAoYSU8OXcrZFWJIQ21Gs49PjB+jPRL47xoBH13kD7amtitxtKdH68tUMlSzeHxyaJ8XVa+EaSkkZ5dVVPilwh8l4YdgC7RphZ0TD4PHC/ckqLLBC4rcYbSNZqvhia4SRjiLaXoAAYl4SaYDNM9ksNWcY49FnclZ3iHcG/XHMgtFDXutqbA1VkZmSgwuGazjrpbJkmu3X2wUEgstvZwUp3tpcCTDIB8Ywnf3ONKS0SqxwWoaNBl1DFDJZ88DEZ1FzlJLVeu2tIC292eyuWgNjeARQufTKI5p9uwhdbG5ZAuMbjtz/HxS28e/SFJhtJnTMv/5rX5bUWWDJT7AZPZ2dTAABAcgkAAAAAANldUTsoAAAARQYwLS0tLS4sKzM3OjgsMS0rLjY4NjU06/L56/YtLCo2NfwtKispODg2Kiw0OPP57eUcLn0miC3ebrFQl6s4agBxQAXLgm9Rxh0ZbUsNX+x1PZaTs89uaSs5mYoyqwwcMkUhiK2zVRz3JlZRzwBcxdrnLSmXVo7XY05qtTeJR1lT+8ILQWNoLeu5UgA8MvXEcyIcf4ofgjo/q+gEk66XFBePvExCFiNpavTtXrO/orA/E64SRX0Ldx4AFDYLTQDbO0rcKIxoba4yEbyE3//8IeemLhm5phK3J7OkJnrz+2vZwde2PQP8MQtcsI9R+wIjOvVa4EG8te2rqea2ui2XzWah0BkSPM9QHGxkJLPVEakJDD41EswYjZ947s9rrTTZ0VEchpWN+xzg8eH1KIte57zJYj6z5QaVudU+1LfXh5rDVekAFCo9OwM8TPMFbn2BmbOmSgCV2M4T00y0cXF4rMXEemOjm8i2btypk6kzTMX0KRdk1baB/7ZLAAxCfaXBj513mGjPMBVXt8ptUOgdPcpp7RntEo56zJtMpLWHtRJxaY9bhXcDdzny8PyBWuR3IKZDNQAUOgt0CbbNt73iRqGmtVDB5DsUX/5zak/Wibgf1xL09p1WwVNr4BpZ+4eyzOBie/W51yuY0QRqAAQyy6PBRfp2r4FCqrUsOUQkcPmv7qnR1j9HE/f71kCSxkPuEnz5v4u2c10ANDaLqKBScrafeqDMemvbJR3xIIg/jnyh69aMyh9GvL1mID22dQbj17REvD8jT7y7Eyw6BV1CnkL7Bk6s1tYqIgAEF11C429OJUidHK9RLcrERLvkanvlIUOR71dyAzQ2vTAI690uEV83X9EL4sKUUJjdsNw4Ed1ja4jdt3RQleqz3mFMu1kPtAH0LX100K757w6nmlzVqAQTcTCDB3oWqCpLcGOht8gBcdEEnob7BHDPuUDDut0BTDJF49GMZRdyStqu0zaYiIdzTORXMm1XgV+Y1lD6It/IujN/YdTvRU49N3rx/VyJ1kz9qyQFFDZFEDyMfu0XOHGuHq46CjDp8dBDivf8uhvHKzzeIStxHJQcxwtI/uSdvXvcXRzxcsGxSzO+RQwkPkU0QbL93qW2Yey7bC2t05DJJ/YP1W5f1+8mZvdktJfPyrj9flnuibtqiWYqO1DSg58LpQIsLjUYSO6UW1RpuFlVN0FDJhb0vmAiubSFNbd6sGk7bVo8HxY81HHWms4bms4Q56HqaPZwAAQ+PSSXNP/dLQolXq+xAJiZXHl9IhkpdI8Zw2ExXkQ3JMl/1Ltvnd7ETfLjLSe7e9dwahMaKOWkKS5nKL+qcXEZqCTu/eJ2VAxd3k2rClyTBgDMCmAPgKcABgA/GDcQhkmltaYwf/JaWRidPcfPk94N3bDeezI7N+OqsoYSybRPjEQz5IE40iOAtcXAH/Dnl8RWltKrMVzNb5qV8fDd5LTH4OHg+hXjwc3zmcnmwH0ZOeKsSgJKhZyuKE7qTG7xIZazamSoVLjs/2VIftUGDEGBllp96iDrEZGvWE8ogAyMp2yRw2TICrbYrj2eyff5T2rDaedXQyaAYvF8FGhTiwprwPOgMBw0nrvlZSZzQvI8wSryi/yvgqsRBsQNgpoOHinVzET2yRJUAaWk9JFWI3oK//onANCOAuqAPQCeEzADQ6QdYAkyAE0GoLFEBh6MjKrHvjK/Ir36S01axQ4WhsTMStF5HPz7sbwkToKq9KIqWICWVZr3oOpUkiIBXvMGcuKikqKQjVOrEPEPWYvlfieSFyeHvs7vNjnUwqIA7sKPRVRVBhahE8FRCEIldYg81t0aUhYXzFz1iV7gCH+khP9Uj75wfTvfLo7U4/FnKpnNGbgrZs4rjxAxoO2C0vinkl6QwLWq/DoWSBUEVop4w0RLs5FNnkpzgnXJb4Ji3ykZStfpdxfiETKZwBZoSjNhMwE+KTXet2NrZQ0yhiSn/acDWD4WAAAHEIC9AHUJzOC2LUxm2A46T6oVWgEx9yGzEud99ZU+070eO1knAaBQ438Lk5YIDjTDuqA+HQBVQSTioGLVGb4Pg4AC6tMQccvXmxJx3rata0G+XqWG58nF0HP1B92m64uorOsQxmsNS+GREdqMU2I7S3ZmZzdL2bf7oQeaXyhhqOmxOE4HNJoENVMaftNuTMWTBLVGa2xEnUAKACbE1b+IgUMZ1EOGOBrsU7kHa0n0O+MEIDDujs5Pju5LUjNOYL+GYKHDUUs7dlPmZWkDHKl0vYIS6286h6pdwPm67NqQgq4MagC+KY3ah+mooKK4+6W8WS4TACBTBfQrwO8EDuiglKYbUIZDwnpGaKZ4YXn9/QH5vOVkPb+Svx9zv14EAM9CBz2nGI1zKaFWEUWKSfDcU1k42bIJ6QGvgMa0QXz0pOaKn2cb8gWrzQUc/OL5zdSfOcYYGj2vj8uNy8jm2VIovZm6IemTAXdJV9tOwrZ4VuCOqMbhmbgNteZ6vauCSkJFN7Y8dgJy8xhl+YqUwpC48Wu9QctglAfvQ9cceIW04RYYst/FVWYfAGy6xWui7VYdaFyuqDeRCgjbSg4TREplxP7XoqAuttrYtpPSa0AD1hclaeqXfSqPJqFIcdg/6XVSzOrTzCQXAICjgRpgD4BbAWRAUBludjSBQGM1A193RolhyYn9Mkoavl5qEasMAMhOwttqUkgH92C/7k3XQYGhobiU1tqOnNxsJpmESCJNfTjGNtzr9jDGiorlUu09Sf5XqzGw/eE6hcdmWfpUk2WrRPstIVzDcme4tyasbuQHGCNOZyxw6txwqZQrQQhy6PxGJRLLBEIjyKTpLSSJnBGT9qBxe7ZEqarAIDEjbPtBsczBNz/a+1GS9EIVqUZCRBWWJsPlrF8axbDc+cRPfUT1O7PuGnth60QWjMzW6kOEeZPfqyABJDJ1LkHdwrTGQb/lKnoBRJRxmjdUitYY40BzjZOem2jUvunaXF0TgdU5PxoFBDb1MoEnhztQbC69RlmCwgws4ZNzUfeWj+9NojlhQEUyNc7UMOVKFznhKgYkMvXOs95ie2Ou8Rdzg4gklxgk9az8dtjG0XQb6ZqeKo6yin1kZP0TIAlUJqHxYPQnAhGvrTMKMJEuLsLmjjhK9ZttZgiH1sbL0HX8M/GbZFC5uf+UXMKaqWcGZ/WeLwFkNqXxDGPRER3j5ol7gRJoUFy9oOr3zN4ItKZTppiE2TalKyFZvlGwfd4cW6oGM/UOHp5ZYFIYJWCPmcoaRJy24tv/7x1R1n2MUvcCACDTAAsYGr3MAwZoaF2io7YUsQPTPfO5Q99nvZMV/vHUsVUFAF/kj6DjIqHrKCYgtIQx59ztc6Yq/n6LOlpSiDhFwO+8/281MXPKWdWsm291aONwcSrqMA7b3qZchpLpPsVC0hOKmXsW+9GEVqGXnrW9lyJ9YkGx5ePzcOvxCP1zedM0IsiV+hlNU7baC+CRYKKkABbZWnBExYKarrbtfNVzDauctmTbnZCmR02iq09fl6OR0OFEW7MKWL4V0LGooB5sENMklPTwRwXo+11zJMcbTtO4hb3WMiACzJwpx2efKPKnDiwuRef52kc+x4n6cU23AegMW/k9bYloOm6PoelKbVXMsgKnhnbX0gkipzEiACQuteCJ5jM9cCJww1VEASaMgUfjKYZxQlQiujqXgKUcfhXeLK/AbeLbKjQ69dXzmsKykIY3L/oADZrkGTs0QclSYtH7G0/VIJWIe0y0+PXOnywC/AH8MQtiwtliv8W64YtN4JJazY3uS/jnzI33srU3Yt2ZlCDD3pFl1OJJAEw2sQpk6y4fEtgruCrVoKFDYg0Ln6J4GKe7jLZkh9OWodknG/KWaA7mj9GeTEIl08zvni1rfQIBVCax9ewafIMiShlkVZpBR7o2t2VsmZGRXw6GaAzD5VFdLuiRiulOBJf+6bHWU3YlbJDgQYzubAAcLmmVCOM1n/gRvbhhnCiADnos76uTta1s7BJvloRrjbuHWrXvqsoouphCPcJn1DvXCeKaFQA0LmkTNFucLpTNo4r6VhSMhLnWrdorH6OPVeqMIxmIJ7IvdHH9t9ZeRgA8LhFmjzXzCRy8XGMVCAUhJTIF+Y5VQvx89Fhdze4Ml39SWVlQoEtb732nBCQmaWXHkFJBWWeGB0wvXeQllibxKHmzydz5O5ZlexCg/dcqttFmQwr53xir7BzC9/oyuwAkKjEJ0mL2FbhifdjGzYOSRgk0aI4xwzmpfKUaFWMgmXjCJdWI2flbUlUXRfnlwc2qBAX9XIt/EToIRcRYmOnGZxPQWor7+4W5rukvNnTAcwGADMA8DI1pKo0HAygsANLEV0zxYD6s96x8T+6fqvrPVG3c1FTw8rTeG3ZRIhHHzHGBiZqhEIRGNc9WtU1709PJUTXSofbujyauSbyj0DUke38SPUagaFRVK/kuJLbGoGCoGzIhjgHvFRCDd61Na+3zkw1wtAbLWywpyKVf2qeME7iSn8/MPscAQ3t0rPLM7Uu/Xjaur95hDNeH+lZPasL4QSZlPfV3dKZdO2edPMO9DTM+poKQOMBrLso6Krhv22f3wKgJBw1TONaV5l2dV8pera7CWWX8KBoAPB75dHQM4UggiblfijgnCADI1ADSPwBAODkH8OAgARpdMEBrNAMvz+Z8ef3p/tN86cP1s8V+2lwNAJjpXsGUDkGCuwA8AYLEb7yoPaoQR1tn75Dn2uJm05BgSBRiQqOgE0TcCZWE9wrUYid0BFoS1F3N47XZnillsd6UkKn1Z+PigYq2Y2qabQwph9z3SJIJIYOoGndDhvu0r7ohViDIqrmvgJzAEPtuuvFayUtQJCHv6Y+zkQVrRagO9jSgxIVaAaumNmIr70cHTMJDW/DA9HiyNywoe4LiH5lQ71UC7JwiNYflsB4NRiJbXkQaDORR6b0g/tQEpZfTBn74lEQPLUEHzP0S+tolAIChAPYEuBVAuG/gQboBpAsANgy8WXjx/mXej8GP00+WGcPO0z0CgL29GPEYPGghMgQllIBe2V6mdJSQZMBXb21SsgZVykuhIaL6HgDsmgHlJMRpLa61FA2ZmFXcKEUwui086DhjVpapXM+eLkvUFpMrRcdhgTPfHGgiJonhtttd2LH1lE0CiopZb7rSMLeBpQAtHvoM4NAT2ZBzpdrA/iaXgPSo1h9zAkgMQG+U9x6kC6tgtlIETgGSp8N8KgrtlaM6Y877qrJ3rG9LW48fiCs4QpVQN2PTBX683L5gA/7o1HQM5QCw9gutkQAAMg2wB8BrAVQ6IGCFQBLwtWPgq/T8y8GDtx+uKZ09Hpzsu32ABIDpJpSuWrlWA0Jlpbe2fJ2RoZcSmNrkcW7PN1ah4J6q6oTNglPT7Lv8N42MHUXqRka2UQrenSqXx7BCbRDz152rl/qFnVmQVhY4WFqSSPv8zYGJqAUBRCiHkZTPozYPt2LXpJPHVEdjYCx9uCuIPQdGKCMFw+EnoanaqvctWYqxqhze+8cAclRMaoI/HlxLyfgeuyUWiOyozCWcCGH5aThAXbIrCoDiM4dFzlx1+U/zHgBPZ2dTAADAvAkAAAAAANldUTspAAAAT/ysFxfrKDU1ODXw3+jd3N3k0+DX2OTV3NjV1LbXRFwfhAPA3n/KuPN0nbU+EgAAQwD2BPgbgFRlENDlA4n2FCBoOvlbnV5retsHDc/nn1xX9wAA5ubW2qKh4r2VVOmEoARGfcK2SK0s6d3DyQwq4q0Csek13swKk2yPVpWJFWdH1HTUGaBQSCgZRvMnu5YVbBwT8qGrzGqxCPP97GjpSJiPCPdGUIJTEnE8ClDnp7gB3DWWFt3vZDkfEtrAidTHn5nQWgLUhO1/br5OygDLbr8abs+lJXs/AjvZWCeJlHHy2g6MR+fKZqDIsKLd8FolC2kKeH0Z1F6rZnpt/+dOg2shsV5EgwfkHb0hYU9WPYiMfUMrGAPbzauenIzye4A0C0Wvg3hlmuqHoLuHMTt1TA4l87wPpro4wM+YQbp2cPVgw3aW+a0qr8LfvAjqHS52uI7ef5K3u0biTPv+noRskNgkRR0MIgXneU9mLMSGtB2gIwsblmBJzWblcNWTpsey0hgn+Tv5i9TdLmuHDYG8mreo9owLtopfAQwOAQvQ9ARi0Q7Q4cbUrgYhjhrTnE/ib7tCprqdHD9Tcrsn36Zyrb+9nbKfiVvfnNYz9iWZZ20ALB6J88xHMyrSh3FVRgE60tVbZ4eZou8Xb7YTZjT/SPEfGXWln7P5VeiMhyqluznVHlgbKTA6yESwl/kk43UETBL3KybOMsYnuyHhmgHAALAnwC2ASjIISEpKa60p1icxAycrMz/dAmOT7nx8sP/4b24qquZqlaPG4AiPJWVSUxrBa9QIAaWKob1zM5UjICho4/lsKS2gxJHU2C2v3rQhifjmRnNi7tWexgMGPzfqwCrTr9sdHwpM0HbJGV2sB+KVRbar43TJ7idkDCD0x9L9WLePEsODFLV/B0kxiGEeaQreNvLzzCDpSBMl32r/bDJWmka9b4kVqCq3So5cx3p9VyOqFNkIaTK0mVv+8tGDqwkUQRupvD2JCP2yZSFEgNLXChlspQgeufS6xpQCSOL2S3yhJACAdE+AowDSyiAglWUjDFO8pfqHPw/09E1h66bpZX7tZr8EAAMoBSNW8WkrQUqxKiiSV6ZGdzB4ZXayVgphZbxp7wBh8zt9MXLZFA/JvBVqbK2sZGuMvGy92HUgOwCY+dST9UO09QZPj+Ry99kqFG8Nweh19rSBIwlJQSfkBNkEUbrbz1rxXIK+IWDIlnxtnDjCCGy2swnzOs2izErThS9Agx4RTMJkM/1Ay5KoDJFVHex3/VGv+Zhg8hNlr0I8lAnbmwtL5g8cW8osHgqSfl46nqikYgyTQcaW1y8DKngBAFB7AR5A9WUAWpMkbBXFg7P/vdz2lm0f2UseHQetXZ1OAoALCSGieFjGoOOslNKa+r6dQcSFsJQ6J9IyUxrtlmUlZ7x6YoxO8Cz3KUWjovhzE/CRqNGrjJX9pRO8Gyq9uasvoZXLjZLVI1QRnaqfXFtycrI+4rTgFVVOnTHk91S9KGKCrMQe4xZVARjxBV20q8eGRC46Uq+50fGuso1nEnKxnuOUqaBcG1g8aaKFxhePY7fOd7nrTQllmVa6z/t7t/kehdeSSkmZm8PX48KgE9/xRNjHFD7DGV6oxLSFZgDw9j/RQAAAAN2eAE8CSfkBkzilHGMxXD8Auz9oXOz//jmMDbweCACgKBQlfmfkaSqRFF+7e0aJXs7PxIc2vqmc1KNw15TbTcBfhcxS8CtxUaGX8Qq9tlu4eolldiLsnMl3U+1mgTbj/RSBHI5d4Gkts8mt0ysVviVE4aA0vz9B1yZR25ZA575zvsEaiwR12nL2wRct0n1TW4h8xoh4MTFafmOU6qkQPjrj7MiqsozCcJ2DfzVtFurG4GLOVmNgds0WSm3e5tF6ZmvmtxJCMdAdRHoEHQIAHon0riZrCABfv6h8mw4AQLvCMFRVo4wSSjMO2V4/sjEzlZE+6/kkzYtZe+wLAAJVDcndT+2R2Bb59ovh+oGhpKprpy0VU47POSxKZ7ZOwqUxdgWWOWBBML7x3UguAFnqqF5nZ+xq3zR6WNX0+ccqFWVLvnLA8b1asGnsd/jpM9E1qWXihTngw30rJnkDvIz1CLFccSYzwldpr7BR6nGU1MvdXmwSfaypMu4v0/vVbf4FrILTDDstEUvbodarzMF1wGc+RIG0YuZ2/6FVzbSPzSKAIky+Qidnszd0AJ54lLSGYgD4dnV6Cj59TQCY7AlwAdI2kJDaKS0o8m7Zv32nPJj/kids/ve8T7VW4RaHU6k1sU0bAykSSyTgpOOzUgSVnrcw1HMJniQ465ykWHbV49VSeQ8NAusHf6qd5svPdrizZ5hnlpLKAxnX4ZCQuTFHxeb7cBUg8NVpM+mpRbAfaM31o4+UobZfQCqAQpCR60hXkiyn8Zb3+ybabvIQf6WzvmL9WwM6LmseJOwRmi7mRHYJPasRqrXw5VsS3Gs6aHUWFsJuuHUayIiSIGierxQIG4zpaefdZuoAPmmssgQYAF6/lHMPAIDpAgqSmAEoV0StLeNXHf27f/v1/20/nmL20s2ergCAKV9yCsy2y4q3ViXifWKvQiLSq2sp0H3sfOe1THFJVSF8FGd9JKczmU4OG8ax/saWYlllaG3iTKiv9MODaSiX2MQnTWpTa3hYEaKe+qhnAafIvOIjyxyt4HWIpz5OE4yX4VLGPS5No0wJtsIwGjll+4x2hSq4uHzqtSlTk0Oz+QeHvmtthx4DSxc7rHhsd0LkFEwVBrCyLtb61O1GaEk3+vLzsDkgIyWz4QbbVLSXb+gH5xwFAcQDXln0sYUiUIBv191BP18GAMYVOqKTShLPE8oqnAalmZN98vvMcu/drUpzcT2uLbBHSTVLwSm9i/YCaxBywkJ1Iwg20upT20yDCe1+mB2d9/3x02eqo4Ja+8gkROOJA8UYbVhhHqlm5NSb9ysHh3P/JkkLgT3H3CrOYkkS9dKopUp8UCuy54FtQpm5WWMnSijIajUN2PXSXXYnCWyvUVu5h9taGTOuhnuYtQ2pZFtdF2yCPD/9XiHtfwJF0cgsrhRhr6xbF04w8SQyw2xpAY9K78AaCj5JTDoB8QMJfLvKFYpirg4JMK7Q0CaVeEYrxwqvf6f958WR1Sa7+t52E5++6H7Ozo2GAkFY9XhfL7pIk7PA0jdpUqDNjuk+mMsPp+ZeK4uVDgtqNxwJHBQKwC/dlMpeHr7hNTrrmVsmFILqOasR/5gx30DGSeKxIGXM9u2Rs4CGel+I41vuYA1XJ4wLliEtBdnF4fVO1tga7FKOGeavq0OPOB/NN7dGSumLNB27FDklMKpqN3UUjA8gxCzCz8eqQVsm1rdXG3kJIPLgGxdlX5y3UsGvdPW5K/ByFXg7YJwGvliUtIaOAPDv2hN6YyoB0K7QUFXOk1kIpejh1zbf6fnMT3OJaT4/+F5GQ89nBeuTFs/akHqiwiqxRkIcnEtYgtDeGUGYR0pdFquJxwu6r46MsCforKPwkVmwSVDakP5mp8uigDg+vNHi26pXW/7QR2Zgyy7JDQXWaeiEznoqBmuJJH8Fe+2CJJC0KfCDSRYjIwlmIDOcV+SOHtlBfR7rZ/pmONMZScZjkKASUZFD21Nw2OvETKCjz4iC5FgzccMZcXh5F+F6Wyxn0x9typWyLK8RwiAIwAQeSXS6h4IA8K5oLb5YmUBVl92U0UopRelmfb7xITf+2S7Z988nh79f/J+7ln+bkeZW/skTdtH8+UdL+ymaQRyj5iJKTVhHtwAu1p/GIG4t0oUBubc5+pbDZ3t3xensGU5K0NExxA8skmGti1IdSZTN26/9f6kWbnWYeBqpcf//tKblOpJkVwe1zwuqRoTyLzp1izQ1jXaF3prTkDx48sCM80ujlR8XYbsM8kiIVfaFwUUb7NuYqvLToAZVMa4rOX8Y97r4F44mWjwJ6b2nG9uDtUODPuqvgQceSfSuhSCQgHdeZ4mo67ACtNWYSoystbD09tSl2UfNvt3nH61zN1mSc9XO+GryZNCloS5RZBlYx9DRMN8q61IE36aelQMHh5XsnnT5T1Ob2otiVcN08RNc4OZqIV4270qmwK+prHCudUFI7fl1ko11Hi8X6xwOwlNlp79TzUg3dVvFGsyijGJlSPEg1CSpeOy/2e0oG4plgq/IvGo7U+ZF6ym5ZsWHayfVGt6rqTWh3hnnpcUcyjKaeavYVBsuhW75XKyLpYboJyhZrCaYL6jluUU5zTuhGMnogHJxhm/HkkcBHgC+WJSyhUYA8J0sct/0YkJVW35pp0hSMQ79/Ofhv7vrVyy/ph7as9gPvn19A4abB/YPnvXIZymt2jlETNokOu0srrqf6FpxA5LJOCzSWTEfwZT5m5RMeDECq7cIWyGa9Zzx1bUJv/RVwzWCdo/u0KAa7fdvTi+DXyb2yV4xrxbMP8Tjc+n6xERqCqAafJdF/CSlokTrf6BhllwA833ijFk6Eyr0LGWNttj52ITl/P7yuXEXq7oS56LmjeKUd5W8MJg59/ZtxWlYRwl6T7G6/n0OKHlBmAB+SDSgBCAAfDdgroJCC2AsqaSqIqm1ZuTu7v33+Hq+s43bFxgeWObf/5qMn59p3JJalnGdRuKtG0JNU2dEWBTdJ6d5Kzh3njANLgkzZaJOTdvXzeB9dTjp+1JqVsws5aglIExzdCT1sh65V06koJx7VZGdlVgoIJiZeiGbUwSvgM4OnQoslbSbpKcLgstewsrMnypizGHpbXud1EkM3Ql0SUCxxw9Ljvwg27NvS8pcneumuYB58IMR74i5XkjLhYT9DuYsoUeAlW3KASktEffif2YZdmmQCSqmZCcAXljUoAYgAHzvoZNAQgOEx2pKTkorwZTe5QyaF8Z74bL53UhraDyebVwT6dyfNsgbRtVEIbPw0UpJX48Up29w1g4We9clKI9+g5muyn1Lz9JFDsYKcIb+jDDcRaqCfLqJMf95tjw13RB+IqB/mwhb89TJap2tQGyT4reWtkV4fb4XUhY9h6QYiZkRmO/WU3BFaoTjImRcfCzb5NFQ0uAOvgclFC9omljFrM0VjvZCu/8MIQlGDkeAG5Vvj11KKu9s9Ra6Emt/K9b23UKptlzNetpTrt1ly8AGfliUtAUQAP7zbVQmDTAmMcrR+UYLzfQ0N/XgzbbPH/8+mbVFtxJTjm7O+1ynLUc3sxuNkF3czyHBMlRQgudcrWxbmLd3bqADlvFUJWNbFRk+1eEiOCL3lfQYtbrNyvb6htzeSUJy6lV75Gax7DCEv7N5S7yldREOfPewme2p/r3urlhp/utyVMpNGBg0l9YrF5p5OPKFkh/4+rWoA+rCXnRF/0iJce21uaJUsTOu1y3X0mKUanV3KDAPLq6IxsTFe8uA0V/fBgEkJlDwNvgjvpgFOrABPllsuoLkB4D/UvSrSkwYY8WwMYlmVkwP+YEv+jrvwc0/t8Xz6cHvRdO525aMfK93c74qx5EpYvaaE5bVMB6p1QslPxFB3GcJWiH9Dc3HLw4I40h4XOtOAiphWd1jxsnNPIun9dSMQC+7tCCxQSnfhcF6wsmIbtpzJsR5yZalR5Ip//Z/ez+XlW/53V8FR5Z6ddvq2Ed4enOBZODfEFZs1I9JbZW4+DKLIhdFlDltfCbcLur2rq+9+GNKYM1eK61AtjmhTbwzPlRyMduh2X7grwAFnABPZ2dTAADACAoAAAAAANldUTsqAAAAe4QEsRPf1s/f09Tc4NbR2tnb29zb3tPPPln0bgwBQQG+a2JwGDQ6qqu2ZC0LZS3TL9L4+dd3X8btFpsvb9lmE3LkZvtE6sDq9ZBXwWCsf0t9vUqGDPMctfQFMDIGshIrSsKaJeCbOSRgOVlEjojeN3JpjVRdNjSKb30g7PT8BR3X+rkwV7NUsfTVVEfFYCqsSQtv8UsV5RkenYAbvsIb4btGhpbLYauFiem3OuaV453aTFLnI9sZTOkxcR5gObWmvhIClqua+0XBHzQy7xsK0QzFDiB3WeeyzW0k4QnZT0uyMqdeM44L3ypuBT7XD6ZfXd8HAROYAN5I9LICfADwn7zBspcd0JZccsmJ0MwUh+e+8tC97x9521ItX43XvpKc9eB+5n6cTp1uuZTNfuUaz/kL65FdlNDW1BasOS8uPYeNQv9AOB6H73WZTCV2di8z25rVKtQjvwqKWjAMxl9M4UKZknpPhDPamaQAagyWkPfeGXiMLDbcrkeeSGnGVptqjxYKGWlzqMPI0oVRFBUyBxDFkptbsNuNYaYo0bzZuQXESkWFNNtotXEKxsi3XRfM7czpsTUBg3ceIErrjK/PLyvOqk2breIO401uUwEeWMSghkAQQfQv2wnEWGnrktJGCcXYHXv3e1viVh+mfHzrBzcO6B/hp+5cxHvfbk4eFxIcG1NpEmTNrwNoaza5SsVQXsanVn9ltiWVpH7jLJ8/noagmW55slfZQWxUMfFNHzf8KVWy1E3PD44CP3vNaOLeLyBHHtlChf2ygcjnh31atssBiq6c4NTcHfJZMA7QwSva8P6+6wm88ZYGIfx/bYUkPJnceAC0H/aMrjl+XRygjWjaLddQ3Rc60mDWIIKNdZfl68fGVPa4VuNOoAt+SNQ4RSEGgHeG6a1RbQpMUtkvp8torZnOlv/v/bz8ODdj/e7iu/n02/+lfRcutp8pmRxti7SZbmJXNuuMWZcF2zIJopVn385WZ6ky2mBJbSKx8/MMLLGS8s4IompdLUejwlJXjQeZFUlIjFpWUxrAmwnToVGSMU8i8vPuCsLhdq/+vRxdp09UZ34ouc5FBFPeosnJwTjGslaV4XhFmsBEpnv1BQpS6vHIUyTxDEaa8Kse9I1dQEYeaKYcCaFQxR+a5ZqeDzz++hlFzvBT5dTLVPMxYhxQYaVnG4IpAA0AXlgUoAYgAPzvcVgE4ABtVeInOtHKscKVYKewXRBvYpvpKh8b2ge+wyQ9DnvW51NyN3FDPwnT20q3Tu86ahzBGsl6p/RLpD1gAnpjkuVBwhyVDrkPDysdUYkQ7Ju9EHW0csHNoP2UhOBNpWqPqWNKUiEGQ9g1M+tl6Havktiu5rQh6YXOh3P8Vw0IXo0+63nlBrlvduvWFPQEEi9etg2SZolU+lS126yMdnRwKnV+nRKK8Bb+Xf2Vranc0bKtUxCqTFwGv77oVEOL3SqaxCGX5QIKAN5YdLoGCAD+c0VpPGD0/arWi8YawRh84V37nr1Ztuwf2aVvPO9v79/O77MOaW6RHJ6Pma2tVKpFatdllVZIUoWaWBBgtb+WY1Ph44OSCdQLKzOPO3kGbfB1cfPfW1+keLt6C6G9ZhA3G9N7EnsYnQ7uaSZ5OBI1G3s7lNJX3yTTkPC3q9SbKOvJYLJXK2bOWh0d4tRz6rZ0IhpMLcNn0qMbXQ3Zbug4j3FFTi1ubptScWjzZWf7D57lggG7MB90vtXFq0Mt9ZFFUcrKcVhug3ZrJhIAflhkrEUUM0hY807YJecaqKoy0chOK8PY9PWg5OT+pjt2K/vVzznv/ts9Cf98GoerXKZt5kaq7O6sYgJCur/x0DPwmf50hdb5tTAMaJZvG/Y1G4Lx37zpMM3n/KfS0xNRK8e+C0zW1IuW77hJ++1BmBsXHV9DGmGZXlec82+7Lv+tqzCQbIYIs6qttRxUGfUtWRC0cqojXOmRp6QXdky91DDys+aYIBVK9JKWNTrnb62ucU+YtePcz+hr+TaITWrEBgPxKCypcrWqZXznUpYtjKUamncFp01f72kyAX5YlLTGHUECvrvrW7eFAWBSbVUoaiO0Zfr109v/p537YvBuefg3u5/R/vrFiw+m1kGsZ34sL/lMfOPuk/RcXkxbywhKuqu4Zx1tNtuRTlFxT5hL9uptupkOQPW5Ruyae2UEbPB7fYJB46gwc/n9XWXEcl16lPaptZjJTAuU7Uind1NaU822oLuTH44zlxNiCa7KsI/IYtDY59FFEevhV/R31V/qqN88cRlbxZg3sihhBZdWyWo4t3X3bcyiVe7Czi4C3oZqS3lGSY5gKOvrqGSwcELrzCqtSRvja5WvAOgA/liMusZCNADftaKMxyo0UFVlqkJahZgxlblxCheubpzNeXzAuPh/q7f9Ozf9VhvuDS+u8yZ+c5d2iNthetqHDiOBjnOXlYjU77BOdZqISkHhKiM5nZ3P4p8gKoFDOutrg8XPurx1+8VNtKV/t82ItiKeD9gUfHzdNUivno89/VOOw8doo74zByYGi26BQSe3Q9i4PFSXAAjd7NMFHrS0wmfGIuyWiiU3j1oyYKzdMVgqj/OlJBU6aNHduiVKBaMejBgxtra9XjNAbdpz23Lg5pZqQW+JDj5YlCAFCAC+V27M0CxMwKQqMZ6cGMXK0nq6/fJdS0e/5vM1nWjHq+3L2YY1ze9kztgQouj5s3F5YOIvkBJfuA+y7wo0WpfOV4yTqFnwkKZ+QVe6qNEgfUY7GTq9su0NkG20VJLHitcXG87GjVHmVR+RxT0ljYblWId9Tb+k+8YOWsOCjErN0zAlx1xoaZhFnq2HzMBPZbMtUbi1HzYv3YZ5A+ClEDuzxmOtDJ/pY7rucgVQuUBKs+knv3tLabCiMCDtQEXVV2+4VMp512gTwAUAnlg0ugYQAL4r6LO5okUwJlFX3mu10Mri3Y3lz/fM8Qfs8w8feL8nrv+ebc6Uj3I3v+2EHR3CLmq8tx2KLmH5Kk6jyWPFluIceTWl3fN9xOW37xjLlSqTKEQL7AFUWiE3nv1FyfAu31Vx+jL+tb1ftSWYzeCBtpQJSJIR3WZrPttI8luNe1cqUeTjw+vvWz5Fw8I7ox+E/MmYlVseIBvZvV/dJzIpTEBqDbfKRJ1YReVHhE/szjWnPX16igkjhFRX9QazSmlGxlJHUGHUOmCS+GulVUrW4yB3dAA+WSymAP4BQHvRlUVMQFXiquTE04IpcjZbH7x79/tYyNSneVvXKWbi9vp5blld+iRWM08q84q4GvDEyDHXRt7tLkPEbS7NRC6XplnVO2PP6EKdrgfRd6xYEq/LWmtjWmQPq7j3JIeVc3d1uIZBHuS3hK0tgdWBwr8RCBVqcY7aHVI0ep4PQ4lr+IwoegO6wECyk92d+s1WdpRcgUVeuw1Bz7LP41DPKK5R5kcpC26zw0HvthxAO2SXoazTqcQXHBtBOK/rx4XOPa54w/b3WfsWKvvkSInFx8AGvlh00kcU0QB812sUCsBYFaMfSLQ2rOjW/F//92DUF9uOPj75V9e3fn+etbvwQvb8nxDjhh7URPLy+8plawNpwiIxqsYlexnw38SKGT8SUOQ1Z3AOgdqAPM4oO31CvYCtP5WXnuJMYKiKoLHu971VKUXabbYSgcq51IVziE70dSidWJjQGnSERdKiBvCvXujmvMJOgU8yKZAdhyzrrUvkyuHyrjTpoRDe8iEt7omTzmqrTMekrbYyw0aRoSw2IlecpgqJrjrBQmgJk5zvwJlrq2FgAwg51mKDCZgAvlg0soRCGgX4r9IMag0d1Oi3iVeyFsxMK/lR7DdPp/2YvXv87ou3lAMZs65umpvmyLzBng8vrkZOVlbR6m8AzUgVVBpqPLEH2A0qaXOtMbmiHkEGYM9Y28KD7vrZKyNYTY29V0HSQTEtjd0zIx2RsSRjYqBfYwZx76devNB7wmxPcBp8H5CmpWef27IcsHlGMB6aRNPu5TJSl2WKY8jVUvVJ33s7q8VTogRXMlOl/vtB/cpDzq+oNuNjpfOeDitbO7RoxMXs2eat5ZjcZjhfeoXoGvqxsVxXwIYJ/lh0pkU0ZJKA73LGkEIDGNN0TELOKC2UwouwPvZqctb/Tz3/z2fj1N8/Wx+23uir72fO8y6msF7aTfUa4IbsBWCDWwd/gMfILtgxphQbCVM9vt9drSbJlZ3P7GV/qDOEbabwpah8E66vBV3KQhlmbjozrXmU/QAH0EnNliCckggGBIy2Ky1tXqsPFtKZvUNm4spofz8/0wOf/CwNrofg5cLG32xAoEO3iGEXArEJF6WKjH7ezfVbGAXotBYW1uFX3Sz9rV80lDDpIgNqRBZgKufqM8YxV5e/MESZAD5YNKAEEAC+q9aWlkY7wJjIoXxVGacV44phtbuwff7lnesVrbfem1cuJvs/LXP/QOOUKZYJ5kOzPO8o111Jvfjd7al8jVPpc8WQxzp07UQwu5+7wIovmku+wx92u2ciO5LitefS/GqHN2cCebHllawiWGuRQQtbcWtjcfpwy2zerzbrEf6Q2PBRr/T6Fgc9B1FMvYTgIg5Zll7UYyQT1Db0H0hPF2J2XoIRldcWoNau/kySI+x66Z7xINCYdGVTBCSszj94uDeoZC/C7koZBHzXmX7tovNX7VIN6J5YlKInOjIAfJfTdnxHwlhVvpNLG60VLhkp/+Wbznc3czjQE2+X03mRL5fxzO6eOd1qJuul5VmmCmvmVtbykrR3KKnJFGL8F7rrGYC1q0pjnjeehidVgT4oYXoQUvOoKqbDjimU9ptvXbNLi8idAGYFcd1esxdGpCNnOtUfyh1TZhW0A0NYyRudS/Oz5cybG0nbuP1eCvUODMF3kqDMq1wWWz+dzNPFjJx4XV2cgIvWQ296fQFxGv6EwJ49+7gSh2sP4qu04K8gVEGge0dZDCs1VsHktA/A2jwrjAsSNj5ITKWEiQDw3jgTegUNQNpWW9E3SmimeAyY4mgUXBrNcIs9Yx+V7/N6mD2YOz9sTJdEpkTgz52BytJdIyNE53Q4ElUjh4mUTjLiVsDdwWnVRH8U1U5wwS2J4i75ZkMSia57r0CC1vZJgMkLmP5i5+7gRyIzFemf1T2fUOISWc+u6nTzUelBC1mcgT+hhibNvzN9vxgigR8HNWpVwJ3/Rj4PKSNhsn7xygqCMdIgiwMpz6IfNVuDrcbXocRmxpFzKJRswggVDsk8z/l7d0vzZ95t7gX+V0w1hi4ATHe5ZNBbevVJmrZjXrOnWVFc/X3l6EHrjweepZU/9358Wv/3yGePV71a8FxOFkSTA3A0GhTU2RmwJ1JFaU/fIEKiLPqe2DY3QeqSxDHLHXdfQmjjVRWy5hGqsj56YtsQYYoDPCrlgnpAhpQzXAnTv4ceLdAGkryJDpVAvRrUDhhG+6ZhghcrxImEDSJIfa9KVKHBMKe+asXaJbsL0lq81EDFnBozqX6Ic/sBJAWtxiugCtzu+or8j54VQq7fGYoCq99j3SR7iwZPZ2dTAABASwoAAAAAANldUTsrAAAA+OQipyPV0NfO39UoKjQy5M/VKiYoJzE1Nv7y8ScuKi0sKysxMzz3735X1LKFiQDwXmF1L7AAVIVjGm10RrMCz7StbcwZLDvjvHWT27uakmgDtlIpNTKpsR9NtInFGaJlNQcNsmR87S9hL+FB0jLM/WHyXYIQ78vATz/QvuNbV2gacXTgh+kYY5qSUrVyKSk/IbLvl+9JWLlhkeXRmuucvr9kjhZGrLGWZJNmh+ylYTJURlLSGaa84Qjns+bZ1+3LYPQaOvHGzAudtg5VRpZ/KOeWKVpjAydct0LhMJ0h11PbQm4f5L4VzeMfy8NoLuwuqqqaq8JAQxoXNpIRAP5XjLGGxqAB700JyEUHgEpTneadFUIpxmkkNI2L0WHBsEl89XLe/0gO7Hpy4/x3F0kOc1OKfXRDzxivjIw6Px69FVEZuda8pXtzTiFg76rqqFEJFC0kzI/teM8sqrezRkTLngUaSSO+7jXaUde+WPZ9EgDd8SrTnUss5XstwuSF78qkbMLJ0pHSPlPqX0ow7PSqHSPYR11S192rYU+jxOGQ8ur+8EFEGI9hv80jZM/qRQtTsC2rmoEi9+gF0pveM6JrEcxUgKKONDk02mbTEAB+RzS+RjQCgPvOSthEAxqMbSWVLTynFTPiPF7fx/zMRWRUfp3ePtV3+WQ+u/XdobqYSKZMWvc93jdP069pB5LS8MOSaTxPEbq4YJjajgtVlZssxVZfhRGd4+wldKH3Xo5wOwcWVYg6ka8Ey8BDZxrAAOQdswIZOShYMGTQm5Ps8JTTBhytzsl148JsBCp6NX3oxYddsq2dBS27gFbY/tWUfqkzaQ33KM48kGDymGKwzs0FfgrM3xtaYbD66QLGFKeAeWWq7G3s5b7isl2aWrlRrDmTuiU0AH5IbKWFSQBwbynNUwBjmjYVnRZGK8b7sws2Z7mHM/vdLw/8FX/5dDrlzNfZNM9UhkkjV3/XOjmQXMQGjQW3w11R3FT4ACbNcXKSuCmARKSqvciWx7y4Oan1vNLlNQjrgdZYG+ZnUEJJoqXf25o7aji2Exg+XTj7XbpqZPJ1jNv+rT/bJ/HRMzNSylwZu2m2CpWGLmgE28gIKIasvFv9r7FhLz/NGOPOTiXCav06FKZ3A0cDia8dLF2lgGfgvVlXNVRYPwl/xBp67/iAKmwAPlgstYbJAPBuQ1kOg4BwTfK9qKMlCkXx9c30xi7/7FcHXz9ltK/zbP63//j3fPMB25renstOJu1HXmt++PqMaAGrB60VDn2YJs6XNx3EL7GaM+NDzRfrLb4tRkJudG+MSScP5DFlTzfNPHGCgBZ0eDl4zvspinW6yq3mfKKXNYWAaYg0LFMbDetxnU3n9kTsgkiO49t5jjOLpV0LaCKZaRkKPElo6EOppg0tqjyFbcZIu3l7bcyVZpkZczzScvbnkcTz8T1jQbkrSlNw21q1oIXsRCtGFYse5cLaNv1VA3ZX9DEF0ATgvT8NdQz9mkMPGV3bWjyMWps0z845xQx+7Yh/PydefP7PXVwdmfotdwbP/Xq4+vwYL0/2JuifFgrewimohnq3rs9hqm1lpBv8RVlf7lerNuF0TxNLFZrIiRTexWAtHvqTzuAM7UTB4sb3UH8gNJnHsrvDgrRFjWtTa0s20v3QCkqwjxdykyASormbuQefGFTKJZFYRqzYA9X3ocHq3q1lKAeh5ysiwYFu629LR4XJVrhW/qXgDbOcBfGVub/Mgc7i3Wv77O08ulj+cNvYAOzpHEIODVQE4mcFgJdkfmsPlhCqyM6pwf517677kjq7QVp9bDnBNAHM9dDMDWqxHSmJN3ezgQtq1DfKIkV1ZD546r/UZo70OlWHm6sr4DqtpwT09ZQDkKVA2P49gDJa33G+uA6OdqiDYDHdBZNpNblL7m1ddxxtxHKv3/z30JZssneeeiQA/PEwU1OGr1pT/zmBdCHI66dxrq5fQluajCXlWb3iIkVHC3ISr5Lkj+ohSh7087q/MgAaV5S+VJoAwP0BAOizPIxVSVA0MWpPUeye12qxMoVe8Thote3/vfF+97s5WqI7H3dA29OF8uyfdsj9Q6s8V8hD35umk2I+WaWH2EyvGCTqKbdwS2m7xdfpaY6eFahSUkFJwQ9Yn8RRVwvXeHOfppMMDZ63EzpAJ+RO0C4sl/QZ9y0u7+lbAQr6OYfr5prM0taydhPCSO6fZpd7YKFy3XRcarqfyTna5BGu/G8SgUgt3HScvqhPbe7DSwLIg/nCKIg4VGYudghNrXLn5kFAPbPKVwOWqWlv0eurJYJysWyMKwN6VQD+V0wthiZAwnzfa9KgsU4DY7VJG60iSa0o6gtZ8llLjqXJT++bxmjd/teW4d0wieH6+luG023bMyPwI6cCt2TaIyn6kfYQDMN3mUbRBwqdH+7HHpIzaR9K0wt+WLzN90G9tMOe5E0j+xjbZ06q1AuUDU90W60NdjuI1uALlzwTMtbjfaye0Fgx8G3nY0ZVCvDIbhhXamsxwaAWoXSvnBeFZfxCv+u7udZ/1buzafCxu8aBKljS9NVyno5zVYZyJUdtACv2oSC4DoiLRoU2aQC2VqQmJXUGLUDy/QAAbJJgUmkMRFJp5hBjOEPGYGkhU74ZOb9SatzKNXni4tOtdy5MW7c0puOPOvX317Lkj4O7vbzR1BoVUtnCvQwW+bviEkzJJhL8sfy1GhLsT2n8PJWJad137jI2TL7nZXWoPZ4jiSYVinatkA7pM+8NaZojD2U7s1fc49JG1DSuKpC6TYrWA6z0SsO33C36KXi5fqPM+kpVGtae07SqLrIhwlZcEiHezSxM3bOEHVrFj1fWU5d6WcuKFWxsybAsw5Jaxr42mi0o0AHE/ShlisXlKiD6G4BRcZ8GOv8is5QKB/Vjfy22sf+2S2JflZfR67xMRAf8/YwxAVSwc18AXsWG1ti+kMZxAFk0nycj/rgmZgG7huWPYjnfBNz1iJLLZD2LXoi1TdyAUVGexdRlHWqfawqG1XKVYmjiICVpGW9foQPE9YABSun4zBSzAFfxx3RkyifKJz918fFuFbbsvlxmGZ1K8iL2TADE/ShCgnu7jdXUh4h0vnrNOjMxhnv9tLgjC0Z+doy7OwFnuH9wBsIVHTt1JT95Uc4B7Bl3FAQxEFkaVB37hieV4v3D/+2MdW75Yu9RvqgT9FsZ8IIXbyeDTqOxR8T/+1N+EGdKQAAEMndoHoPlaDr94DpwmQUuzOwIXhC7HZbqTPf1rMn+Jdel+spqbchrt17sDtJjEoa2mjFavQ5a5xwu0DsP43p49TV0v2STLbiq7gcAoBRQzQBTZcC6Shr4MBodKgnlCEdZrpKWmXSpNeHp0e/0cfb9wz49mR7vzsmfjIpHYpwcTsZDr21CEM2u5qcO7j3+dzROIAKwTA6u8jdp6gn696rPOdd22lb6bX+Lg40XyuWPrW9hFV8cXGQFXxKrvuGr4sprLzRZPgBQ72prUwzQcIBjqqroXvvjMx2al9RWUvKMtrioYeBbQ7YixF52HKqpbPuZCAm0Wy33ikB4TZQvKVmvYmjjAHxJCdZVoBRsgfynCNiJw9gXqrdQAEBaBjAMU2Xv9bnAPtqwnz9eWAXKra48jaARCX7HtEmdUDOsOktyH1v9/wAAAMly5Q5gAbCTQyADhiQYNCbBAEQVFGCmuAJgFd18DtLaz7YdYhSeazgNzBkRVN5QVg3fiylaDwCyBuZA3IvlrsY4vf6Y+Lsp0dShuRiGhM0fLKctZrKX6OL96cdRFeDKQV36vvNZNVWkPWG/k1huB3KpdTk6dGMJXxw12eVoF8M0fiIpExhOiudQLVH4aZPnwGBwVkqxXjhedAeQsPCYdrmY55NTdLe0YIvw0mws406w6GjTHhzqOf77oa3N3sgGU0uzKPhw5sWfqJzrIJ0MAE5LvdBrO8spmUNtjClguBEe1ra0LbFUpIaoE5wt3g8AYDD1flwAiArkAX61QzBAmjpdEoKB3gy2XMm6tJzynjs53bA+v+1+KFz+POATjSilFAnITLfLtxSV1G1pDHP8ODfFA6gqBvuXv3xyd6bp6+b9T9zfO+7U3nves+4ldvvxDzdhjflw2wobuokDl1GGBMA2GfXXhT6wNKyVTHrECSzAtKddA4UAfVFYHAWQNqT+FCMFOFRn+sNxCVzvty+WL1US8O1rZHjg3OOs30Z1KmUvXhFubWGwbErZQQLE6V3+c0sV/FrO01bXEMxbvA8RDQEA7OrvcTsXzmxfBLF5TicdDTwe/dZw1EkT1q1dAhoOLv/MJ4YbeYZ6DtXXyE/4/4uF2Mo/P97PEZQRX2Uen3rFCZy8USFXmZUAswFJ4wYt1yfkCO0bylISeWtGmeIi4sofb4UzkQAsFn1MWjZnfwyuEFeXIA2sXgiukZK2cc3I/U7DopWb6TIlMTUudmw3SwMUFouN1lPali9UFd8fCRrQsf6gWSppjwu2C6d8tQFx+pl3mbIezlAP53FqCAAsFj1KW7tYzClf64QrzwHM1MF6rp7LSNqkLkZDbZhTlSUFjkNghSh4pdrgG0waUW7X90mdLnChSZMXaNdBz6XRgQL3cL7ibFzbxycoON4ngS4Q/5KTdhkMEouDYaZ4cz9QNT7uAuiC4HginGItOy3IWGRbXeesSq1QWc5D9NsvLy46FCI9zLMqhcjQSHYvM0Amx1d6Rpbsl29tkcvXD2l0uVufxo7KbxRvzdBdFicb9/iGBAwid1D2oqhWrBuoI19ugCzee6S1JL7V1uNU+vSzgvWzeuriVgK/CKy3nJ93jJ8VWGOaAKw5X4FBaYuaT0WEq3bcXLlqNKDoJh1NMX1l9EQTcs7UMCaEORfd2ciFpcaYRPShfMcZYJiZ7B9K4fgKALrnzGF5mlZO/7vfrz569Q+y300T3w8AAKAMwL5WwVhdVpEEepKKgmwDJFPsOq5Og4VLXa7z3OYxzEympw9Ox2Q8+Or8a9lWreEkNcv3WxZicjz8958Psw99n17JNmglVcZw9ezooaMzftxtr/v9dW2oaRZLUmvfrrmru2i0tqA9PalOHy/C4OJwkTmNfOB+aUaPbp1KkhrQW7V0hIU9eTLE+DUCPNFEPzautdZ5SRBDDiWy+DmuAbENECHKNolT/EVZF6x1OTNZivIyOxgDJHy6tlLi0I+nBh8o8u0gfIh98TjPNaQRADu3FsbhAAOMzL5XofA+rgXex+QIXbZo00NV9Tnq/QEAgOhKlgMAvgu6LABivbkawdDHRRogamIQM1AXAAUPnyDzwOKmsbvsK3sD+1fEjAIs4EkZyTb6uLQOqpwy5SS+fsgJJExYq6mT2Vfz/bjF81e9R+ca+4j5/UPw5p9zwRE+lwYuR1yG9uuQiI1u+CtvJ8ILmX6CnTa5HwBa3+idGAR+Tn09PNIZS/vFriGSQdsy9qmahkqw4KqP4AD3XXn/SQA6V7Ai5OCkSzJygVJx6NQxEeWAuDp3YWG0tLhx+7ZrfyuAQnAAL/1QtZxjcmMAAFjJknlErmcFrAOlVJ9JB09nZ1MAAACGCgAAAAAA2V1ROywAAAB6HVcwM/EqLCkqKSszNTbx6CYnMjMxMjMzLy4pKikoNTU0Ky01N/f39SkqLTI1N/Hr+issKigoNlbHVJW4mk/Das2LvlCymH4AAAkkA2cNrKqVHoD2PSMYeqMbfSFLCAZ2YhB6AL1j3u/1lPOplApTFXbPqdcmr6y7gnbWy8+bVQgAZS1M+SxTN0lhPUgw6HU6fnPk8mncWuTU6GX7/mg45uMp66QPqX3iepnQB6PTJQnDrpkIxLPk2/1Iw1Wze5/brPyUIc79wUz4181FU+AZ7EVkIAC2YX61fwJ03BqbfY/w5pbQWvvk78YRDwD4rGCUqfeiSPd0AK3sNPgT+kpqOBJrriCm0faRPufqamMlgPj91MgMtKQCBnKXZ871aZHG4qqa4/QDjQAsJr1WWcVvuGV8hb5xAfQGONfRUmC572ltDYive7eIpamxjMAEnUod1QG0Ga9JHkf9thk4L2ivsVoBQI8IixvOHFqaozoUZ/cHzkwrlGCTI7P13cptCiwiC5NxejQemXnV2geYEQPG5n5TpbYSPOceUxivC5Fuf0JIpIUdFq8BRCJFpeUhM0xfcNvxAjaOjjL4Y3kdpsR1w/9Xxkj/5fCutNporxs5tXUBVCK1BLZkq8iwPcz9ABoTjV+ZcNpZ0qdgE4WcE2Zs7Y+aDsrJIraihQc8Jj3Jdg3xeBZZ9LDpu0Rv4Mmy7SxqmNHMXGK6N+IQkkGkagyoUGscuc0A9CX90e4Yt718DZXfyqOERc8OfMuAslJQa5x3Y73LqQtheN2SRtNCXISbL71HKItsXpUTFDZL/J7tElN/3AIRrw9Eg55waXg/ZZ2cH45rw9YvHHz4Heq7oshbOJ32TwtQjhj/4e8ZKQ0MMkt1CfYF9xJJsfGtshNAFxTZxRm/lkjukx9slswYF8xE1FuvCZQgpcxOMNHc3W+kaX0xWAFatwwUvqfxGr//0p/qFMpTc323YUjZOxS2IH9oeDOAGUBlNEAaHEKlUtZMsTKUiTof4sZcbgdrg7J7eOHI1k9Hjx48mFUi745pLiyr4NoQid1OiK7g0NpZ5sA0zI1cyzZZL4uUOM2jOZ2Mcd94PkkfxulobFvXZ11VRYmWICD3j9U2DczzCpOwHA/M/srWqsWf1W0jtDKsCEabOC/4M+fvyt4UkF0BXATS5wrh7dPvQZakLpk7aBBir7nGuiGLi2h+W0A/IVy6fvRgZ8kTBlsDpFH8G6DVlJ3B2cjvRpmA4l08G8+9lWpJW7zCnn+WRmACllYMbbYSwfrQR47I+fsBANBAO2ogwNZ6AyhIA5CG7x1LkkQhFMV7d8BJB2GNgxNHwrQmc3lVsY9fZ6LkHkyV6rhHWF01dUGLIMGfhLwYaciqJrm9J8NA8MinKFHRPtw8ODh7ExF5e7fLt/nn5Kn3+PGT/fVX9y9S/NSzPav+me2iBQMQezkof+7hMgEABhuv+2WsGhBAWZzdBcQU7i+pPmDrLCvaHRyIpXm+ItCwjzOTXfOaZpYFe9Fa8a/rdnBndivhlSNFpSO42yE6YTkhaZZQxsTiF7/lMlRNi/sqjE+cCzXrwmPTAiwS9VyCo4rmv/IBQiq444u1fNBeGA739nSWkZ/90iREUPbC1gsNPBIBKlHW4Mg+PuUMGAm9zfw1D8Or+cYIz3pPI3H9oZaebnj0CkFYJBo1Y0OsQRlZrsoDwGwwcsYKhL06MXRybbKpNNrIKfOCjDfmDlo9Io+u5Cm8fnMpxZRcJqGVB1f6knn7s5SgAcd+Yqic8mwuLV96ssxtUYSrktPiFd36weYznvJbrxfwot2qIwU0LhFpbBbxcd9YEyQsRJPjwZZip+Qu2zBcqjplHKgPKv2vgg7hsSp7Qhv0zkyWSY8HLAppbhjNXskN275wiCTXU+nL00Xu8Kl+snacy/lbLLdPle3tlMyCZtrwLCT0XK7tzAZMCgkgZOLyZqiz/sxFIx1Lmup2bKVQvfM/ZvudaxXepvUqFzuU/81aWv2ujjhvbX9k3gtUIjFjxiT0pVD2v+7WAGRir4sF7bAKDnSa267jtiJdYXx6bI7/pX16RzSKntRBtLSRShVEBjGtDUXY/yDRHndVDAEgDqaKTz+mKzwwKzytXOGDJITRqzatbfL2amQ831cgASQSdRRbzJdRRiBQ///JAjQgMJNmnbsUUYQUkfqeqYGoUbtr3ci1Q6ytZtaQFQIcAv1AKmrKP4267bsMENH4FujjA1gHmW+zsacFyfmagAyZqw5TxpNTmSwOBZrdiWsqQ8O/tkk3gM7QMG4tuwrta7sQ8eGh+T8fUkqyjTm2SoKrBkwaKQVQ9ZIrw7bJB2AkW4fYnFNgkplNyijmSEu8IZaU+Ot9Vm64UUsANA41pWEt//COL2YgeI0ni/ntNQnNoByJ78VQRs19F62hnqqO3dc1AOzt/Ng4GIc55UsWflogXbSumQ7uCdt/PXIuGufSlg8I7+WvtpIqXFtuze2eKE0Z0ujXdRkANCZ9BdLTgLiZ4lZ8tAkqSvfIQ1+Vji6PmNSNlAoZy9T8iL9KMmyhrl4A4PSfUvTn/MR3qwD0KUt9DYAkvYf27Vf0ggazMMd2R2HlNXIxnbXfnnqIYFV6DU3b9nQ+KoWB5OIwA94xi2cABB69/uDnD6138d8WrgkSQFTw6/AONU+pX2OeisGr3wq4xN9wulINy9IoCfwpyxBPgzDUkyK498a9qRUgJaO0yWpbUjbpAfLLuDyGw2JdPDjQ2LcfvH7QAPQli5GgIUvx43/VWtiGJ57EsbTxzvmKyeA6a2NLLN6mt/XGrfztKVAifEAk/TMpK6P9/3AsNBZp2rMxSXGn2KKXv58gQaaIKYy/xlmRv0WCa7dNl2m9gLDxyLn6Bv+QtR6weUUbfiu2+OW7A1pXtHlWJIv4XQ5cIvJ+fwCA+aX6AAAHAHQzcPgZDZAeoNbjhBw7wcooTJh7jLUGkmAWSj/HstZXVUlq7lppjNP2Z621VuCtXSiY9C4lUvNmR5wGxMjk+mxpCfe9+dYkNgRQl1Mu9SU5F6Y/D0KKKtlX32v1fnhvp+kBLKvpbauKQhHVx++ryxcHZC+l1U9qn57z9wd8cSJNBcFncINRW809feYuIY9p4RU4AZyV9lGrXlm+u2KXS9c5b+JW4G2RmaGXV845J2vknEK16mketA+8zT+am7a/EMu9NL/G0+k2nSxQX9VKqB/HWLalXY+ENZaHO2DSC0ueKKSAAfqAollHcPJ2o2bOMwGA1zgGAGDQDPSQAZAGIA2+4YwhhZYjrHHOg/PfXLlgyfu5zWdm++WxUaNOqcGyTdIORUPLl/ZyoxEKmIxiaIhG4Z5DPQAgRVVPaw03nIQa8Vhv9oPNIprnn2O5UZLUgBQRF6njU5t2H6cyzeCchuZjSWew5Z8d/9wLmhV256le0xGGEh+lRbDGqCO1BmJNJJI3XVuzbKtDGGiihT/a1pWdt/eS8WZ61G2PoPchVA94NMHfYHQEuV0iZ9jh7QYQXdcqbK7FC5ZrUW+wm/XLVC0r2EGLN6RCAdsDhXzAXoSeb/OioiUrtifEBAWZHjx0CUG7797XK20+T6kPWytg2FEHwNgGLCf3sgDo+ilBjoXQOira8IT7rOboInfHjm7no03v3Pz9cymvys6YtoLNFtVu3WQEHFyTjGWEto6jgA9/XPGJ4BB67QOHvhNKpCZl/MFvVLxgrp5KCwKo2YJT/i96KdTKX31BRD5YwuPPSY3HL09lYF7q/nBdxMktmx7ZANiFfkp5ph+SWgEQINhx95/lod+lzUFWQcsVDr9bAQ4u64/1YpjiMud33LEtTqbF+RqMgJO1uG2HCcqJTtGyD+ZdiTe0yU43wI/7ROojtD1rhe4Itmi58nP/7ABU8qBUnyXLIm2xhjEALoTRWK5qrUyk801QDtqc/aIQDzOp7CvkhNmHBAzydAxIWd4Qb1PlASICO9+6Mq4c/D+iaSPSjwnpffMBF6Lpn2XRPt0DAAz29FB6Qq5nxUpKfhYgNXRlzuQwoOBlhAdbzKncWq8N0ROsE+3Qd0xOIZU+AfT1vF7jw6p8UC36hsKGsAczsmfTTA23L1MdvKjYTv3fT1AHQ9PR+4imD4Gqm1x6Ez8A9C2vFey2DlakL0lvjRqAGBT7m5MBN+GP2nRuytC3bWkCXXkxNzRsr8XcWrK+I6QkanlOHgH0MXfCYF82qenhkrvw1iibxZuxQFIktRYvb9RJzkfHTF5YtSiTFiS5VESRhyrw4D+j5tG05U4AmufciGjllSlHCeVOdfbfPwAAAT0GzEaAXjCA1GThAEkwEdLKCopTdjaic7CsIdC7uZtkc7fPX6MIiKWBJ1PLAKRasyharcnZpiuXLFx7+OCD5cfj/fzWJQuUFxBFKcNcPE2roNVurHtTePaSlyZ2L4/MzxEdG1ZtixUjVFVVxcmNZc0MY1jvwAwgq+KqWkSYfiU3Ei9h4JdHawHUGqyZ73a/ixw+RzyL9nUBBFRao7jMiv0VFKRujcPiWT3mtAHIpBPR+btFcLsupTS1JoHAnrJ28/wMZWISeKNsdPLmHftHsi2Vns5K+u9iWwib4OkJAF5otFgMoUieOJu8fd+zCdupqxAsmILVjycAgBlAMNiwhhiUk6yE5siY5QYhp4Hcv5mRc8ozZ9fX7hMlzWNdy06wLvqomg2porCwCCmgUD2g4uMrY43fFDXGpxwcHjdu9bkjhv3++mcCAABzzZlmNjoSZrKnsLHTXMbDbsouRafW0eH4bmdDHYqOtaRtYwLGUqKXkQDUgrizHwGAh+lYvj3AiNFjBbjM13pfVaxvVigAaPGK/T7HTb+uDyh/6OQma15MweGChTbRiRbRBoOyDZGmgXvVVXBHZ7mpb7nRYbzr/L2rfb+zaDp2JQAWOCSFgyx9qGaj7HvPFeOhs6/sf72wkqQcDWwGTZclgPXRaCQ3kqDDKiFkha3h57+G6IEc1/7JPZ9eb2/cejqV+dg1Xzg4O+jWMQh7906lRQUvn/70LsXQIAKyvLczgmQlinsJ1x3+bBZ1MYkuummz+c/r53GEqNZg7Naytz8PgJmK4fR3UZ6bkUHhzICQnBGnMzM+gSXGYwysz/IOWDlGSF8AN+A6yuT/ir3sqD9rMyzlbN7kXtYAmUxXDooe4vtJ1+hxfTTEjiLn4qqddfbVrQXj6tHFgoEqqu6yWZ2iirgKUAcHFztI6pWteW46Q+I/ozajbUasnnUBFPZKA9VPMp3by1z1GMBbye/KG5LEjfHaEJbDfNHOF22WyD59C0usQhmpAPTxdgRqltwOlVy3YjIAoSC27pj3pWSkr5lq1Nekr3kfNBxr576ITAO6+oQb/PXKomRfonS6amqtVoAeMpB6f1Abjq08dO1gtvmA3nGTgGz+CqpDAnMNLPb0EmWRphLr+WMKuGATN0Ia20QaZ8g8f8E/Qqxzbsyi7uSm/TbABBzyCiJNr4EuC3H30wCEBBmnTThpmWij2FG/FPwO/oIY9Er+qWFrmwAU/vzJKCYhBbpT3q/KBfDl2lBMkKPL6HCSKbtkMA5UIShdl5ocYNW0Zy/LfRt2gz41NePUIQBPZ2dTAADAvwoAAAAAANldUTstAAAAShiOWzM5Njk27SgrKCosLDY08SsrKSsrKjY6OP8A7/YuKystLC0zODv8/wb9ListLSwsNDg17Pws8jyASJc53BK91lp9EtO62XbXl3kGzFuPjU1qZD6OM1ZzXZuyG4tNeT2DKVsLBr9evfToRYBJDADkLa+ntbYU0cn99NZ0BtBj4Iob/ogf73C6ZdkNNrh5nw10lg8XuYpWnvUj284xn9S38kCWsQIELq+ghnbZck6gWtJmHanQYF/xAJtvtQbmtVjqWW1OMPnK7Rl35joQU51F8OMTZc7TSs0X+Iv5RgAcPndyT/bY9IrR6UrlrywE6GasoOiTmzrtCvXFkEErqYf+Ri/RoM7sC5WWx3d2B4pSbThiEwAyx9wYrXZAmrD9C73+Arp0f9/3uO7O7Gv74+ybYITZOoE0A0YvdgsfQBpM5DyjmIJzev4/t8JbuF6dbCRPF6bJmduHJwenPz58PSurKsn8baelXXs1DIpq7Yll7ZXYP9XZA4PjmLq8v5rNSkEJAtmI16Xhg5krb+BU22o6jLgbAMtoWyQXPpziYJALbJll+A+m1Toe1oAiAPTry3ImA1CJVxBzy8ovvoaNXpsGAGvbt2JNe8UBm9a3qOcEgI/tBxisHddazRjB6HYtn/qRWwxIEgewAMTq5f9hWZC9JADIi/ybxqbQ6IYX0ggULgAcAnemJWY1c1TzTxgAK/gRjPih1Sk10gLbioRsrxwQmCi8hhULuT0ADP522FMvS5foOqJXHoDVgVg71aSj1MbwEim+6nwVH9aBkFv2OeYhvFlEAfQBd6Wly147sRDjeQNcgpjPtJQjjTTKUGDuu1bIhZKBNdttb+Eccwf8/cpZJv/sOMbSndZpAZxLWP0fcZgRj4RoLML6p6nAsgZXrbnqy0kVtFgk+gotXa/kvSzX4vMcsIK7uaaUdVGkbWiCaBUaNQK1NCVTPmdV9Hi6avF7Agz2CuVF1pOo0tJL3jcMUcHpLe1u6abefNuJctU+QCcNi2MA7q9djwCDaxQNDPL0XEmXQaqU9JFWWQP4GKYziHM4WcLTpMRd9pG6sD0Sgz+Zo2nHt5hHNzWj+NS76DYSsaIAVB6hkTgGMeW76K0JB4CrENYZco1jya632shZOf+/Q17OrMUPycD6tdzbOWhbZxWd0HJbHvJWzHMxAkPnTpyF/Pt+AAAkcFRBBwQOAH4bJL8LSUIEcpaFVtgdmS30ti71GObmmOtlfurFxA9rHUoitfwzjjgKqvp6/olHj9Wqap0SjHqXVCaBCBBBEJGh6dlPmweu2J7WuXI/9N721+uvbA5LB9U9c9f79asRlps8o3Var3LKGWpQ9N3gJawNzO4lSm63cXWGwPBCwsUsfUb0+b5Xp5OaC9QlgME5pV7PcF3Y2ofgA3zWZmVZdhZGtabexbbPh2a3obh+D7O/TqsSKDIJruK6CS4CtHHWV53aCwbqhX2d2XyIBWvEPQWsS+2VqYdgKgAkAgsjNUuIKm1qYVwVNYCZgrWfQjEow7JjGA21bpSsxCwtzVDHYUWLgyJ0PAa9VrY/TV505Pw1lwC6lYyRJqVeqsS9d5PlODGrV6PnVFZoryLzp4IRADzyPNJVLtoqXWHwcwHocAxjhNV4pGz6lmB7HN3h3j2Ys1dILnB336kJBPaKM+wiqeiBYbeKEsB0yYvnIJKWoowmpyGeoqRXp/GT5MXhA0EP4qUKADT6fIHLo5dLkqOW8pgCFpHvyb47sgzRHQ9o/IN29tmrkg1F22b7afwhegEc9kriwlKxUwB5q0sAE1nQfF9p4pIhsl/RgFWm+Hd/JIJLidGO2UrP0AEU7gq84NjxImjsWwmkPgq7O3993Lh1yU9fXx8TQqB/+1qgdZDZ06uXJrDW+q5/sVgE1bgtBQAUNouKjLusyQuZode6tdoFhZjE1bc//9MXe0su7/xsKGZYZTPSxC4ju5ItCBqSHq1ap23guQMndysA/DnL9PZDZslIilmL2a3KSCCIHVJhL42DfZpyWnhcsQomqfYVfNL/XrgdXwXYFA69NHcDzQk+PwyaJ80KeF75ZW12T6q2l3r/AgAAABxhBARIuwQCk5UGNkCVsCSflWSKzBy7Wdj1A7AbAC65sm91Js2IUqs4Qo0s841RMbJ1sAZf2WQ0Qb1cWc/Lev4hi0NBeSTpMcaIx3hQZ4z/Nuk4dvz0l/Svvv/se8c75zu69m34eHwndqa6XBxCcRktJBO/GMZdqLYaf5wy1V3xtdawmpyyKLFefyh6D56EIgFgQWvt/vsAr0/ILsqTj2pE3c3VVIzgkg/NBJj5/NNPkQTIGA12pPICZtEXgPhZrwPYyMfL08kVTR1lCjBndk4Kl1ixJdslZ3BblLQnvdKBJgawYMpSXVAESAD+J+UIXSR9yJ6JtIrD/rVA2PIfFgyAHYwAlAB2AMoMAAgsYDzxNgCp0pakQOOceZ1ZTrDPrxJz7jOQ+wOgyD9eFV1unqc40A6UhWhFLRhpsVBZdT3ZIRQKNOTRZ2vKSDhKHZVWr6LONM5/y/4cowKt0R1AJJE6+PUHsc3NbVCK6ZW+bWccpMZtMtySNKzlxsJjlbPAUElXEz66QzuFL+AEFFrh4r5fTh4/P5VMowQPiV3CWCkA8nZ0EosEMYj0MvkZehiE2hZItfGH3ZOxxLLsvlo16moBA01m8IHjw/CWZhj/W9B8OLv3hbVSkO0ZB5YnDXDahhq5+Bb2DMAvAAAAwAEgYAfgBQDIgEI7bsB3OR+tR4Go3wItYh6UJaxTEoBQafsNwhWbEqAPJwRP/JvrHcLW3nvs2KGldLp2d2+mKhADpQANKlFCURTFz8wou6jqUIC2jReWx42Gy72zM91ql49ba7oiE1YMVGLs9p3dWvZqy+hawscBIegEwfktAqfRAn2/aZkZDroYetTE2VyJvvtMG1FtBOQm+rsRDaaI6acdoNRGwiaVXmgBLCSdwz2NAZgqWf/9xBhSQRhe08oLk9zupu/u2Wak/JlbpNApJpOpv2ynElv8hByeJYROlRwTQqopDcw9d6XE5lTbezlbr7y+pE5AhwbHNs/KdHPPSZvQIihvStM+jo8XG/GhzaQuLQH0PUtlMB3yx++j//IIUDiI6ulTokoZ+n1XGsfSlIxJl+FXbGzG70U04dsBDDZLnOdcbLyEQ7a2mgj0kl8/mGopPxl4nkgTS4wzpsh5KklxyR4UIVsNANQxy8nE/VB7IzN0bpqFDi1gQsKlyV9T45v6MVNQ5ebore+cY8gr+vGsgUtJAfw1C0wCQjcvuhEu3ZpVJHpJ8+KA0b1siddMxEw6SywDukciFbVu+aYKnS0A1DV31EQcrV4/3Sjrl7sg4CC5MhBVdEybHZ8wUiXIVd1G8g3ECQWtS3BSMHgAFDZ9aDAh1Y/SyK81oABl4cj+zFDbR/FfNjk/YCleRRxd8rTK+5GuNTRs/o/29PWCqjkBFC5L/Z7GY+81TDfr063VgiD2SWGb4/fAOJ+0yHh0gmlk60hCkWEY51ndycYeJniPgDtiKJSUGwfsQXdr9sNtFAttLL53batiXqDRmrgkuT54x21H3rzvvkyWTCV7SnRj+szNcVojkm/N5nwJu/e4KFgkABootQVcW7nGtX0Tw6br7ndvcYzi2pb29AcFzP+BBuBpoEsACRkLAP4CCjYKOEA1AYS5mCOZomkxNG7/dQ7zYn4eBadCBtXUeWR60MClUqksoF6lDCTkx3JY6VJRRVjacCYCfjCdcPb+bXYyGWMyKqhWoxZpfnlj9qwkxImG+G9vgqNAdEWJ6jHukl/2bbljiWmdJKN6BAB8ma1ZeA6CgD6lZ14Y3q1TiakESxVZDLNz5/F5ujqrgbXDDetguHso6XFcBCR1mqd+jEsKYIY5kiSYDEA5PPzgGFMoFQNAIG41sn0Rz23w8UVa+L3nkbKOh/E5zsbii/JgRNdXAZ44pUKXQxT98GTbVmagyfoLAAAAsDusE6AAkp0DXBcA6DbYMLRLoCwNBohCaEUREmDlvwv6F5AgNdDto7j+u0XQ0qRkYKUeAfXwA14CP9bRcRCqhd7ZD7LOVRg5B0YWu5SrmhWuDBjXZlxFeyGCQ8heNo4s5UpxbQBtUlW4j184b83l3bGJMcfyRJ2MGkEwDf/CT4uMDulpbADoTIXPQ/USJYA/6lFTFgxhfybgm0KteU7tai3NRJwPEwFUBld/rLdnYDY6aAMBnXKzrwbA9xxR2JF6gCA/caOYTHBbHXK8P+OGbTTaYqV6K1YB0XGdbXdQw0WyhLArbzq8JTdsU7WTKAraBPZH5ag/r+lnvrZvEvrDYsLxVX4RmU/UNRt/KGF/3QDcAZCwI4HXAgB0G0jaDfidRNMoj4GC9xVMkrLYHdL23UTCRl+cFpqeDGQ0GpKIUorDs6US0N8nQwRYa/XK3UsJAak0TnC/lU8VLW2KVnjPG0pEK0oKK5IgqOAxmizhvt3oOTCQUnVnNA8/ut0nfgTYC9DbJyFsNdPALSr9QA5oP2xay7Dl7scK6vKyMytMecjg8+G941DfhwNkbQAcp1GjGNTfr/C8JrFzJhLMqec3ZQWtaSqDpzIS7gDEq1cPjZ4xigAIFWte12Tm3VwCt5SevONr+rA/dDPqElFgowAUOousZ1zCfuiG7UqvIx8AJeGps1VS916GyrAwiaUfgY11FZ8lJ65oV3l6FKUB/D3LrOdUIT+mS7eq7gUEAQdEcupfStqKrXGQSyf2c6sDbeUybrzyEtxoAgw+y3JQPWa6UxjPt9cMrBMm+PDErgV2yYuDx9PWqC4vRngWAXAjdm2HtV40AOxBi1XiLFG+jw61BX7rKook4CDhw9ZXo5jfUsxb6ZPGv0nQksvaHnTR2fBoJwQ2C13CqMK8j276b/VtTQJAQj/wj5HUaLN8d/DolA8bSvrXm6IyyjV+XQkDHDaLm11/Ff6KzDR8zAUIQwj8LX402BGDXEXzgPNW61tyuTZLepJ5j+/0YQD8Qb0wURVK9E8pSMYa9YAlsA6j8o0hwmuVmDxnlA19nFy7zQ/dbSFaY6vy7FN2PEsJ2rwB/DWv0MEy27KnoGwLzuaFGbJ3pOKjcNvXJXN2e5CPO2PdNpsDP2MOp0Ohk9namUqcELg2r3U/OADUMa+Hng9VIv48rf2frJtWUYZNv4cKlbBiqbr6rvH9jfjzWHNbr6OE3GkZskW9HuLTV1JtAHoHzTAxruWP/mHXy9fHPX8xV++OdYXN+y2gvwJvYAaQAViBLmubAXCSVSKY4ndSjPN2uZ99ry7+dc/E9ez69PWPI0Qp8ajmnMakjgc/aoPWWoOMTUlVan6+Zf4JihSCglTLzv8lUkhSyGpLvjcVL8oz58ShcIB1WMo2D7lZyG8Sqw2OS6GRMDZeLh+qVv97g7knWU5Maz8H8uaECv7p4W4wAJqKvEChv1tEn525AEABNLebyoJ3pRlShTiYvSeavTwBolVUqbypXTgGAPCHJ2P/3fQffDdxcykU7XutZbjA85wXbpWzKKkKngcAvrjUmhbbtErshMRnONp/AAAc9wv6ljhCAxKydAMA8nOwaifQ+QMdWM8pCoCGN1DJ7Az1WKTJvuyzyjOcjraR2skKSShZUO+bMlWaeKf19DHHRDoAib7Ubars7+6qJ8OvrWkrrHQMO5KbM9/vLs4/U9u9el9joaK9t2+WjZeYk775TbD271dApgfVGCgCn468BWFsf89yk5BQGb0YPxpXElG+Rh5PJabjCTLrTLIN0i/x4R93OvZwVENHLBog9VNCCkCQlzfOX7VmdAp4OHKpgK18pv3VrqZ0NwbCifNXmEKNxbMChD+RM4GZ7KnRjCCvdBlQTUmYlWXM02wBT2dnUwAAQP4KAAAAAADZXVE7LgAAAMNc+R0w+CorKysqKyszNvPq8SctKSsrKSo1OPfv8isrKi0sLCc2NTv07fMqLCwrKiwoMzfqdqckgeuDbXSK3juQzusvAAAAwJEAATsArwEgkJ/0VsBzKeEUxZqvGt1J/CUhagALcOv0hUY9HQ1QgrfgUR6+WL2qtLxKn2aIMBEcUdbjlAZgpEV32GArslDgHulkf27a//iZs0+XLOp1/e3mH24id89+Pjr+4MTaS0QSk347tnckPmvGyaMf1VdYxhnvp8rbYLdEXR7+DnWcBFDfnctWe7Bxxa7vp3oaAKNvoquYUJQOC9yMCNyCa5O/FdBs7Mq6xFxoXzgwIyTpJ70YTCq+1K3hqeAK9Fx6ym1pN+bOVsELdzjWYiOMlkfcPyZGt4+fWV3CmfQakzoUGsuirV6Uc6ZLPVEmyCCQUz8cUdOm75xVNW2ukM50vhnOYBNXgTxCJAAUGouTPZORQevSrmIDQNMh4TtKDynpMrEyDNaRbivlTXL3lIG0y5IK76cEDBpLsmdcRMno8HZpXtQJXMWD0xyR4JBp9sGYyf9kgKVxnh8Jps8aKGUEE+QhS10CBMzFr9dr2gEkHhheGr+9bsfSGcCNJs7FT0YuHTsg/M+I4YWoZgbUHUtCQgRrOrdE6L65kJL/Pm6VUtH8+yjzk1OodUuuinduTKYzEVSmwQP0IQuVPZXbg8zYK/0uHjSXvKhRtitfoVNN3M/+gXCS5jMniwdVSyjKLlwA/CHLkudMjU7rzfZlhQ6GNlYjrIhZTdtbVVe2PsYzyP62LYFmuJ7CONS7DTQm9ahnovFRP25BHX2x4cn7Tw6uJzHMCr6nPVgl0E+amvFtlLbXfy2nnz2CYJogdUO7Avwhr0UCZEmKnKaP9uUC1QDf9Pu+IrlaUL4H9KILgu3H5ammH4+pXXIspd16YYJOJP14B2O9AboHDSCxXeZLX02d19qx35fj05tbPYvS9v/G4AR6YjhrACADsAJrC8hJWLKQQzmtKDZWRg8mmzfm1Z/Dvqq4OKyr/t36HHFWRqQ5CFwb+a+FVDoRdNoh6pjkWra1WmXnm49jJMJk2vt3vmoC1ZoAPj393/TEFaIf/Dz4Vg2EyjZLBL2vFmbhUQWNEmtQAIoGrZgzF5B/hu2fFr9er89iAsDG7g5M5LWeCWBjg/lyyPEj4ozvcN0AUGdjMjXB6xkA4AHR2SHEYYECWFz8+59k84MTMGTK6XgqGKvHVjGRrxy5rIIFk3OzX4i73NoiXB98vOOYAP6oLALWYQxyT+y8FozE/P4AANg/BPYNHAnQ4AAOkD0Pq04qQBLGVliKBEh81EQQM7NCgDLOXXCw5bUpoyktlGpk8bD0vrqcgkYcL28MB7zhKpCFfj0RuniH5agR+wSqzUtNhv/nHcm3EUOtiXXae/SSu9+ZUlybtTMkYAxmXul+q3gVWj1581oAo1kwUTsStXGYMcTz0uoEEWcLhMpU8RWQZCU1RNPRjqsr1I4AHQz44u/KqWdrV2SI/1nK9RburyEbgSP+npbTVDr2/VTnC3ueHWIqEe5XYQXFubR96eEoCvmu2JgOuZcVAPanZKToea4IAp6N902L78OBlPlLKqC/gQGOABiE4QF9CxDIxT2lhGNc9psYXzy/Tp8unv5d9N/t9PVkzLeHdV8sq58sQ2vRS+y6ck7oZFXFi7yNf1KjRAdY598kUmO5P/vwtK+QqlJniWfpP09KSfX99XqnAQMmANrlZuXP+w6HaciTQU9QaY1h7Cd5FokGm2ubdQSNECsLE6cjoakYQiGy+POnmQu7jU1tr9Uw7NqKDiGQ/QojlaZwiNxpTv26i7SAd8sQRimnFlILMq8yB5eIvrkNrEcph0y5vdlIFPUVoc1h+8rw5tgqoGj3dl4gSgIsEguyTZ0gb79uNFuJiIBnm7+MORlT2hWXqPw80PIw6UbmJJQw7zocEouD/TVFOo4sVD3OgTiHIE79fwaB9VH1TU5IZCZUHMCymSsF+c3LEtj4IB4MFouMHZ3QRazNZla0OB0Sth79SZS3Vr2Ju2SDmf6zyupHzy6pLiQbERQSC5w9bg4L6sbjBcg4QBPhpViBMQTedoAmryQFSfqdSXq0tS4jMpyeKQAsEv2NMUqtv/xvAb8REA3ibdAOe5Ho1swv2iHvLWSYUtfnlMP7YjIo3ekCRAq1qCGsMbDFfV89pBK3HphOWZgY2YikVJDuU5pS+KYaHrXubJGpTQA8En1dYzJWJcmlXxwBQoHYOm5lE0wYYzHsKfn6+iEHT96u2eNfHS1ZYgIkDv2ivWhu618Rwd6nmyDDMbdj0nHMvn70MBZ3Czrm6yJPp9Ne+/v7jYHj88t5er7Cf70XABw2yxCtNL0Ig+roNeoE6NEWJmCTepRttOKMbUzeJU4Oj11baOcpkUGF4TIR/7t3Mb1PYS7bVQwAutfMAKJaD6f78Hj0HpipHG77AwBAFcY7AKCBK0nOgF0gNADcSowhopVMCkFxidmKZYU1TlW2mw5nRjRrlc2mlHF7OpkkbnbVGPAmvzK7oJBkJCnF+mDnKgv49GT6y6/z1gf+3zSfJSAOQBWwVy0DLFFJdoXfjtr+5ebjplN1CuNvb+tnTPzPWuK3jmGeabNWUhWCJSzHHRUMpazycyiqkgjz/TJkQNMeqEA/m+O/WxiNLyJgWX6f4DjVDtJF+OpEB5HHzJzUAG41AdpGE0x4Cu7LyLyU5g53dux3u/5fI85DgQFGI7VpRtOAWcXaMXNKBmREAH39DJ64xLysnTLDQ9a5xf9Ik+47AIKYbz9gMoDOo4AGNqsB1BigrBaJhG8kOsEUdOpz8jYaH8NYfO3vHA1T+GW0VKUR0gjSMOmx6knQ0hSUaon5hV78f446u7f5iExi5jB56dvy+dYgnEKLecbnq0Hb8h4cVlCMdcLEyfQMzgZ5gvvjfEcAwO0WfY/KANiWO9KPS3I+rFPpz6VATXuBo+AXlGHWJgaBmZD4qyUAqz9yNPhDY6v92PE0upF+bYcvAFW7dw953LD++L+kxrRDxGnGUQ42AAEAye8r/i2uDm2ABjC2WYPuLGtAi34zi03qgOIGlrckAz1UqK3TVw5dlN+7XqeDFzaI4bhfEsoRoBBsFvwAaXA7BjAiTwoJUgjNGPjjzihT+f/yfXx+8jiw9mHwzXg8JMYn0qdN/7kplsjr2tEWi8j0TUQo+1SR4c3Po7Z59T6FCR2Km8S4knKClrF36IL1et5GB2DiHu4Onjn8f6V6eqW2yt494sIjyqVsq5Cw8NXfXEnBzyFF17loYtj+fbQj1enrwzI4N0eL9+Yj7DnpavWKHlj/L76SwQLyuIHTyOC79Vmzi50yb6TLdbuzp93Q+EdE2YdnGt6yb54/RoAzOeWWJBcjXB7BSzS08zj3FAAsIgsisF5zyXPV+Q4QwkG8AvH3KZQZI0ZCjx1t+ym3zzmDmFPA0FIxojQQJCYLm93Cf5uc22m3dgkE0+DaMOhqrLWBTBXDa3N+v8CRCx3OlWijmtcqAOwRdyYj2WWXF57WBAkwXYma60alpDWrhE7wTOEJCWsXmSC2pPUrRH6FABwWS6LdlOHW0emLkdWXJXqNf2bNimuvgxpNZ9vuRH9g4gR7mKNEjyQdWmuvABwKC5LGFu6qPNR+6gRRyavBv0RKOk3JYQOtZomfOGP6TijhIcufRh/3QFwBXBI9TUL4W0X3QQOAZjgHggQWE531Fsqs6lV956L0OHaRLSay7MUrdrYEmgAkJguHbUmzZJw6dbMOjAH5vJkE8X3nRt3Ado+x++OOT27jcqhkcQTcDUujPTJ6OpwDsqYKgJkNiFhev2PL+ruxl92QSm6ahBLpP8ubnnqBVrqha2Gi+yqTXZf/sQEMCot0Hmng+A3UefrQgUfUBxbrVMKynJ93difa5znt/7Pmk6xXsZ6gZlN9OYcL/mWeuG6EAbQxX0U8b83b2C+obtoBMLtOCw1YQ4C4kW2Gfw8jMncZ9mTQUZt+TtMqrcPIJd3Jc8ZSYq3fIwml+WAAeuccUvColU59uPrOAy9uE6Pk/86fmHPuUup45rMgAfqWM2AtQOgA8zy/dEMS+JpKJGIR2TK2y57VzHnfxf1k1fhrc7b4xqlyF1yAicSNPL618wIQNcbJTNJmU9a6qpobzxgfRGXK30FdgTrE/cOTtPcfuGI097JyDIShu9/jNDClrydLy+o64+f6fRBwu6HagJOF9vZyfDidkIUluzgIHn9ceBFg+fcXXlzk8PL7AuTAiISGdvs8HatQTUlJKTQBYHn1DAUhJ+FBKL+kBIBZPLJgtQ4C23dG21e8loLMQnvAWY3+dN0UCtPnnJBcmHuv71kSAB7I5JAvK8rIvayT3df2twkS1xbf/xQCwJX9GADgzawdYLxvMtA2hVQJUnInmOI0KvJDDrpaA5e6eOz7tdZ1yQOxIx32yPYukpg4ALx2KJToWq5FqRXT601vQ2N66oGuDu6qLLfalod2V8c0ykhCCR2SJ+DcLVMACfrKLbwOZqSs1pGakzoAUG4ZWaBEeBlctCIMf/RNYrM3SdKovYSRSbYsDWRcCoqzZeXi2LOEDiZwFTGE6Qbi0jr7VS9EmuIsN8b4DX6zV8YfYuuOAQCo4RgACPjq2bn/i3HkAaODR3GHlE1LVRlsu6xQsgMbABbHVEM5mq9RFxVnuXT/AADQxNpglg8AOlIqPQDm80QGrFZoPKLvk4IpbPXEADrHwdl/9JM+KEvZentNN17N31ek1qINKSaZvzMBCwtWTMIil2/EfaQSuNQ8ffnn8S3//f2nQdvazpe0M7uv7R9xhOfABrvfVcfOAR1VOUW0TsBQ3F1lBXrSUl5Q/eEguwHXSRE11XyJnvs8SThuILyoQ2eScI33v6icQfU9ufJNCbcTMczAXNgobA3yKKIWVvqR5Q4jDYmV29R28kWvZXuGhUZtAtlV/5wlvYs2x1gP/mjiDUJr5JcTFr1aoNbHsWRFAjbwADwiC7LhxS/dnKrzuwKEdLAeW6gJLNVFlmTW/0/yV6NVuwzYQIoY+4MGBrQVr1a7O6yxyoyK/qpdwIYbaD1uEMuSruRA3HB8B+fPkKbK7jOI9TIYN8GcLBr9yX6ZeJsyvqpWZQdAD5Js+tUzbKk6XpVA5HUpj1aJeEnqabT3SLRVogIsHv1Ouayfmeiaq8eVPwJgBkmgnlzRUjZKiCuJbuflJ742hhL/81MO9icADBILjbEO2d3CJ4yvQETy+iWqVyzx8SP5tI/mbK/0hs3zPfOvCIIm10oDNCK9WatjLI8/qFPM/J0gjomhtod36EDWxBjtOi0mr3gzx5SqBdOtWOaGNgH0EUuDfbf+aaKL530bE52A9Pvkkkiq0AjJjv7O0ypPlM3Oim7E5RQP9A3Lez26RGQo8uybE+vY1l9u+gFLVj8I8vSloyd50if94Zw18sRTtaFbn/RJb5NKll4EJEI9pR7bM2+e4uR3rYXDRGMaJdvtv7WfInl7r20kfDltGKPMx/A2KKlsK9ZZWTC9wGe4LBXNCZrnDJVwmDa9Xy9R1DY2YPr/vtR9u+2tB930yY4BwNEAUOwJ4JagMkAijJRtKBEEFD3x/4/96/idufnPbeml518fIbcdpHouVRpJA+Kn+Uv5MrMNVPCTdGkNhlK1SpipVQAU0H76vRzI6opCasm2bDt7MX9l1ofpZARfxHLv6Wm67yEKXNLqhMglu3piCdUP1D0Mgvzwp3N6yPV6vf74tQi2uDCHYcItOOHGcRaHxZTfNtozAPkYv15EoHDXpxlFzKqyq0AHDf/+woN/fyiwNchQQNUG4YEENstbjpZw/euZkB0SP24957E+AE9nZ1MAAEA8CwAAAAAA2V1ROy8AAABg8bFgKO75KiwrKykqKzU66O7xKSkuKiwrKzQ1OfXv7S0pKygqKjQzN/H29vQ+6MQ8Lpqu+/HQyTKycLK/Ixug097ruQcAbUcBC4A+wwKGiAw0ZMBKInSAJwCamLcJyYB5TuaJeBLoWrVf+Py+8DWq7bKV1UCcOPHcyY3nrM8NdyDC/DOoh6yHACEqIiWA16gv7a+M1mpUky7zLfeu/q6t9BhWiVYLfpPMPv8nVLIE6ESrP/qMmFb1FM2Ui+Z0hZ0fw4W0kqWomupAs7EJVfp3Fn8TdHMBmvZhBIgQ6kPsNT3brO+uOrbrM05EDaiNxqGf3wb0W5rCisBdxO3srTK2tfBlVAqplqFWMHRTIX+jT1yZg0tLxqkEj6IUttfkSLHox3xcVlwhEMy/AAAAADNgAyuMMQOdAQxMGeiB5yeJ0xSou80RAwFplbEbANwP3rRar179+HUCOIThva/+tEUgob16X0LPf9btZznCkPKJ6V+mnm24pS3VW3Fw+M8PsY97MRfqr3ew6at0WD1+4uSbTLHaJ7o3H+1xjEllqVmlJn3JIewF+3XfI7MZA2iAPDIdmu80+E7PF0HM8J6BAhswKtH6ggrRNmjBNDnH7WIO2AC2JOmrlWQCc29YWtwxEy6xHv3muEZWAOEfDU4mFGjyRzl0aeo4akTgnO16RtU0wgAlLvXqIy8QxR2rtFCUdnnZE1cbLDK90DN2uflLHI27UzQQLmF+98dlQYJ/1XjYgyY14+s17XVQ7epF4b8yPB4FxD7vk+aTNL7Z2icQF4rk62cPmGtk3+3RFtQsISf+vVVdRHDLlRyRMDYMOnVUIp7F4ge/7ZuCOJg62PTsQUk458SewINdRrjpbJfHoOfOIuP4GXsN9CHLTPBdYnlBD5tPN0ADko/2PS5FonHp8zifGycfN/QRWg0etFfT8XrhAdwly1iiOmbsH5bNliQOKMErw29dORMJqxD5Nqq+6h215541C+81d3YH9D11SC7j+f9MSvt235KkBg8/fqFW15+bosw7Mmmu0FhU50ffLAhGqEMaFBq9xNN6yqe923lxRYA4KIJ9iw9mxdKM0FfKd4eKOjBS8PRSZfah+z3YAAwmiwuCuy4/0xeLZ1/ohk0+OXBwg3XO9v27a6fT6Yh+5eaeZEGaYIsHj9CkCTY96ZNKbM4TBD7LCj0fNydf4q0It7XQCTS6korLb0f0vHfL9+FkZattcDYcVPHpo6J7T1HY+5AHQ4bdX1bQunkTALr3tIhwiZg9H+gVoiuYEg7p/ps4z6/B0N3Z+vPLvNUCgAMAmj0AFEBlAIikUVlZkBS3x/+VOKNapn6f8+nBQv4L73+a4enSk3HNOsa1bJNbc2eiRhRGc0xGFSa4T9aDC4VzztV+fhrG/bqiABBjjJODM/ePX2pSnOc4H3WLJVdWQMNP24PlgAuXV+dWBTJYMr5cje2oCBv72Z792ZXuOfh4ovkxia8ksIWzsMuU3/a0ZwA/4fPqCqhkmC8FtNt1MefZfHm/XM7u90sUVGFv5ZRVhnLVa9UNakGucJL3XHlMAyLwhwkxwwFe+JQQdiGO/VgtJGgDkvMfACD//gEA2JEAAJ7qbLBVTIPBrMhg3eHZLqRJBlgAkorAH9IkRpQWM2Yl69avEthPSyFarTsXyBBYAqkAgaigwEu33TIvhUjIhVT30b2/Zqz+zz9mR1q4/WzWu4Gtl9jQxqocd7VJTc6MkT5X67QpchawzGKNCKYZ2U4aVNp5xaUlUWYKb9OdFAbHQHV/+dYNw39CmezXpGc7zWyALfz6QlRQLv0UOF68gmmFKcuXasIy8p4FgHZ1AZVIm1iJq5vVKN8zWuVPs40NmNgix4DNnpGNXW1BmvLY7Go3BagC9vekBB0bLe1VLUhfeH973D0vmkUez2UnAgA7CgCAmMweAM8AjAOMloQBSmIEO9aKItPHG17m3NO+4/nF04LWImEaC/o0YkaMZ9biYgZ1qDPvgeCIgxEAWZHERSkq95LjQGEBAjvQyGadRZnFEswSPthv/H+erq5TASPFSD9bX9PVEkupfCIYuXVh44ltUxh5857Rpgnh35IG91K7EwoJ3iKvf1tbj2YlamwjdOBCslAA7yXuK+a+WWZKJWuCopza3QpDWb92MtbwnOwjICIeasDcTX/LYasrP+5QoHVZevn+Z2eDWJfoBd3gby9niTs0AOQtS2AQWz8qjstOhRnEwZQQzOSJEwJWApWNfeCZhcjKphnq0dgb2FcMHCo9IIHveuHDm82WJA6mhAfmrszR5IJMhxTlMSVTxiF37C0NdBVCEyosQo2vR0OQ9r9k/3v3NHRcJhov1n69gchRk5SB4mfc1KBxahZd6LZNNFLs+6QBDC4LuQdD6Be0X7sXcwHiAkGuFTKVRb25TCsX7EhB2RYchnVtWS6SnhoBFD49MIE/Zfz/cPt94epENK7tH9JbStaipGsERKxWmbgXrl0vO8g4is6+KxvsQf0kEc+y5Qsc/P6UShBuoHe7JzuGan8Dcm29apcNR2//XIIi5BxWoisA9CULSLDu4+ve+h7ZZrAQFxiYubtlOCJr0UwVVmn3nm4fpRbuaQjP7aCnMBRORZs4j5TvR3uyay0JJhpwvu1dlo1WNpNrrGLqpbMefW6FpyZv9lzOSIJaCdcEx61wXAAcJgvKBWhy/KEYMvuSOpHE0r/+Yu0HBk+OvkOcrH/rNB3d8XlqT39df+my2SJZ/GtSxtt/BixCfcWBYec3F9KdiyfNKg8AGrTETh936TGI8HFOdlzWt0IY56dZPrjkAesduUUNk7rdpqrlO4YHABo45YTdL3o7r8uH5toCkklv//w9vR3XENjwJADADGj2AngJUDOwjSFIa+srYSlWk83FjYXWVk18QUu/8m6ZAABKGgpStH/mpCYVBADGUxvt2VotcIS2zGfns6s/2x7+ORfE+mXwxOzcSJTLXb1lX/gV77GqVZfuxoDtAiAZpcbGF0enH6IAu/A1c6m2CkwVUPg7qQ9umiFyrzXIaM7HUGvGBFdcVQCpXq4xlg+X4RQjWwYAlEGI8dR4wTOEqWHIHpv7+ZkMf3g5blcasPw87+gnfwfxmx4c3vN8uwG/QYy0L26/wdFBLpWM7KlPmAlAMPXbTUMHnhj1Ao3E8f7VW5Fagv05aA2EqA4A8FlKAADA0+wJcEtgBRiALsN6lyBFPhpBAaOT2P/V15ogN6A1rtg65XgNAFBXoEcnOiRBqqjovZd7oAhKXDl+hHKAgixlzQ8jilLbFwx3pEnMHwcpwzNZtTXqxx+Oe9t7ENWW8s/mxc460QNmktTHVUm6ZQopFUJSpYBuuM8+TXgoHfyCYaH2O8sqAxm29EnmzpbfQm+nsNa05H4nJH50A1oVDAMoT6kFCgBGyEcmEFvXWTKLIGzUWEUnE+kfPqD1NY/Rw5jCe30l7X+WOkTcTDuLydIFgUw/0gC2V2UE3C71Z/8ePSh1cEXwVY5uZZmirus66npdJwCwOxUAACpYYSisADOwYQzQwJ7nC0GBl11zzOQs5+R1/19/+B9+zLzZxdl6vV6vFymVGtQPz041A2lOgWtEKVI4a+FHe2OtCAD1/EIwoxl60h20rwyvYH8+LTCsJURTZ/IyZyxGdvEizrwuiY8H5rA/7N6I/PND7HaGPKSTJ+icL2lmgKG4HSK4Fx6MeIAkNVdHtj/WMoctUdcBXlDB4a0tvsLLbOQPPW3FR18eDADuamaUyHzQJgQpr/wSVnKBZlA7mWOYrUzG5Cu9wCiU4gHkQUtwQnb5yF9g7FrW7nWWoEGX8G1yq3vQoq+1gTU9g2wZfwL17u2dSIpRLQv0Of1oQlrMn/nfKtSgIw66gJamJjGgiFLb0CUfYkSmG5J/G684U4P6EdRJS5BcZd9niv619SVBHB0l+Pz2W6bRiYGZ3rjJ2hoHlEbiOdcqzG2srQL0OX0wcfa9hpiWfbWSiATbTT/6iTqf0pFRzyO7rDqXzhA6Q7HrkiABLEJF7Lk/ZeRvQvt9L54GqdG95KMDyliPvUTb3EpNGYft+5EwYUU49k8FFEY9PAGPbPpjaLf72AKEq+AzL1fjgKypZG8rLXcblZhVMfw4EvVOalNt3EkpmBgPt/gjRTzZVrX9wE406IalCrChWEtUvZivm83zh+DTm3XHvZxjB5dfFzYzm8cxAAQyC0uCSegvFLPeKrcEkEmZ25f4SRjf+5RS3afkkNNCT3cL3pgneVJqrOnznFNvo7TdBAxCC4o8lWeOLtH8Z3kIFDTYpaLnsZAII9To+9LSzipM9dP+IyF+lr4pHO6qmemz1bjF7LT9gwDaJ1VYWOR++/wFfkOXDInS7xcAAABgSRXsBVACNYB1IsyUTTzBFGfO6DEg1qpYQwEA09OHt1HVEKgxCUil9M3NbGbKARYAAJPUu2kSMUannnrOn9NR89U75ul21f7hsiGlrz8+4FDXSyEzE2xbKd2dKY2B+dGlCgJkZsyM6rzFQ4UqkPuomvJHCVKrLczkALu31iagPG9Kmf2GE6oqrlcfxbH+WAv3KR5ECSgKGox7ZjyNSxc7AwJMfnDhRfBpxfXROQauD7u6+kDN+Qefafnhz7ZgHRAmIKNq1nRI4Ai3fPlrpirc5/YM5e4zOkDD13QAviiNmIjVtR+LhUqqksnen9C9C55PAAC7LgAAXFP2AsQYGDNgYcjgA8p5VmhNEX+43Z8f/mw8iBzqyoM3x70AQLbXgVffqEKqWg+iIjmQkBaqgxgGAACAs7vQ1I04h7XRYejj7trB/NeSIVeCnm8Z/LZ/Y+iigjX9Trcx1QgTOVoJqStBfJoMWbQaY4wtmEyUWCq5A5Iil3iB/t/56hVck6zAeCitbz9giIRTvV67AZp1Wq1C0VzeL1lFZdrGnIZImeOcUwg8y6g93pGHYwn+HCyOm950AfPwrkMH+LwZag8ODmztf+2h26naqrcumIBqcfA+AQIAXhgtFCUX0/nV+4XUEtMfAMDvXwQAn6QEAAD0ib0A1wxMZmB5M8AgcsomwlggAUDvzqkf850OCQI4DBN0mEhLTBsSVgsHvw7xToJKamX3RmcBAKBIpgdyAgkrZmJJHPQQZNbAr4Pj6KveVmfBeOWfL1bJUJ6dyRoduU4etWcfwRgpFs8GkWaR5puMX2D2SQ1R26p7zpTLLIXvKf9P3IVAIwZcT56p8scrbPoYV48iNS3pIvGzOMAgZB5bAtkQhUe9FXbuy8asrz5nyhUWR+GiTjs+PfHwTSi4qQhAS38qhT+UGmG3rrV3dAKJa1w3ms3H3zwUUDoNHiktBI6KNqxWKqmF9/42sDS4fgkDgB0NAICq7AkwjIBJBvLI4LZ94DE3HBUF155p1teShrNvMZSy+VqWJwDIFmTOuleE7oQTRMwyKCmxEGeN+JQAAMF87Z0wpSPOKG9McXbsQns+GYpkRZZXbAenXp5jyzJuiOYe6/jdwgqmYgkr1g8I9y8DfAL9DMpFywZ8hKbCCAMtojWiBvJO4t1e/7CGiwEudYKdBk5UQj8JbLIUkycmW66YlGrX1oo7w9pUV+oxHxfDTmjxAjCV7i3GhL1NoZydleKmYiFqSnkZVxcNpoPwc2xvIwOukPwcG6H4swISAE9nZ1MAAMCACwAAAAAA2V1ROzAAAACULhcnG/n6/CksLCkqKTE0Mvb/A/8A8fH39PHu8vHk6D5INZQm+Wd/RktOUitq3zRAAK/3+vslAGi7aQIAeAYWsC3oMgADJnQbwADQaMNA5iFcMz5OUm5Rd9TmCSMTGesYUCAApXvpe56aOzBWF0V9woTIBio1FNb5w2sKASCc/uzZGbEpVo8i5TH+3Li8SWIok8jUljsXtjaLpzat3oXWFOi/pVq01xlUwSkA1hG/fUPz2MAjL/2P9WyidkY99CQqZK1VDCTMC6f9WTEOhqNEYMwEWcIoDQAA/bk6vL+iJwBhZbIh/+pFvFNu8rsRGpnn2O1Q26JZYtH8di4ekRX9BVzBtuL2CkyfHcVBCNzu7V2qx4otbg0JAH4ojZCWVtf4uFyCdkEolffXBGkG80QAADsKQAPsROwB8HUGNoAMGJHBQyDgeUJWQFOhqnO7Rk0vcaVLFB66DAUAbKrwbKZJeSnucUzlKwWXSAtSNfMAAIT6kemLk15SEl3mDwLVliD22hL7WRGTSerA8J5NFnct4cDk2CuHN9aViXhO/ty9VAhjKAcj+/umxdv7XsQC0YNWc/n1aC2Cjxi4I6/CLnpVr8sFRDYwJ3lKCgBYXKLXLSyAmow6Vn0wDKGaDd6hWU/8dGCWRc1rKDhZ8WOWwmlW7pO5OHgV2TfpNeyVyssHb2QABVhog2q1SrXe8k02HDDlFQB2N8WWO2U846NaBVlbUvrN4+equ0c1dM/6vQDAbkoAAD2ZDbYPG2gEg+UcBDiJbgXwNgBhGBguuGNUi8Ro63Fn5+85mvTQt0jRW4gaBuCw+lCYWPIsuJeAe0KprhEDEClqGNZRBVwIN3f64qUaMFyJ5bxLWe87rBUvmjmc2noZd5RvCZ4YJEpsZWg2JGpbmHnN0yard28OLnS89L0HgZrroCqeCTgzNnkMXdQCwusPz5cT7kdSEHJCrbGgJPPP8v8NAADIUyp7m2oEIYsN8zRihzFC0/0+bvUeTgK0jmHyBwMkmbORh2C9U43Y1C4tyxSF3AX3Mv6GLEMAdAAMRgWVi/zw45/H6kUfIFzjU/uZGgHGpdJ3FHYynQsaSo/13RjkKUbxHtQx/Sbx/izPXinOMa6myDEwGsWdBYNk6FSF+KHfu5lLZjaRemkUgYKIeikTxDmLYmK6hWKl2KFVeiqNQINmuKXxzAGwRnedogtz1ET1mlyjk6L1uGGPQwDkRQttLnXM4buBjl1fWiMFfNz/2KbRvF0b7A3NLTTGSzj1eiOMJiqlbBQyPSZB36d6QYVuhic6w4t3nuVyJfNVJ54+T6frf0R1UYOyFHNYyi8KACxGUeY5u8h88NhWPg3ABUzn6zIuce12oYsh8XUddcqcMnwnUznDU2YBREaxCfSnVPwfbvdyA2QQzzMmWkZLmrUKjenZLr7VKlP3bs7GVHE1mSN1oLVt1CMrACwmKWNnRj9xf1DWJD0A0jG3kWtHKVr2z7y3NzbN0tRPmZEDOo4jfuU2jd+k3jWO0u/bYgAsQhXrEUEc92NqL/NyEzojNO0v5OqieHg5N+utlyrL/aSVlymOla9GrhbbYaAXdTNLAjoYdaSM9XR/Zp+S2AFRsr9ffVGKLqcbc9htzwUAdgcAgJ6yF+BKYBJuA13nHMkU3OVqezTer3D9S+vH89nUFHPW39+7mZ+llCirofIrxncWmnTp0iJdC09QQqZ6N901E0sAAKogQlWdKGqcmOq1ern87IHxnACbVrmpKaFa03jeK7bLrWaB+SWYcFiCYfQj/rexs8EVi7i3nVsrAELwynPazYaHEZfcylMiA0l935q+YROQ1EH1/gZw4qdibotouQSI4Ea3wHApTwBbI2mtfSy0O/ZapkKyDQmWFkG2gruig7PYJb3lwEbmdNlsWumzFqaO0QY6AB4Y9cw3WUznI1glwxL8AgAAAOweAADXiQfw0QDAgQkIekcIcAkbBLpu0wHSMjADALutmgEAGs96t8nGpMcixBgSHHgkAIjsfrMAAEBMC/+oihNQiuoU9lLnQu/UynBBmM4Z4zXX8vIgZmB8fdGqIejPtPhZalNoIELF59m0k8EHJ266uoPXD98sAAB9s6gHICHldNxyohS3diY5WfZUWkz9icq9hZ2Mj5QEoJ0/iwMrekcBCyEnSkprq329jBgKgPeovsBfwADgMAZEHgzAmQE4Yr8CyOuYjgfQeT/aZRjAAWAmvywQSDAor4xvWzi4lYcZRCv4gx55Y7mx2Vbvmg0UAL4nNWQspR77SvqiQoKvImqIBv3W7z86AKBfTgEAAHsBsgAOTEASPg8g4SABsAFNYAOwjoGHwmNvtNrdPplutKAPvepWEJtQUApHgQ90i9lOZ+VoFEZ1AFABAGAtyZ1bSSoKImFDFrRRa5ton1CVxUdBQap5eBRBhfXeH8TxEEiOMnx/1saE4DsAgNXsKx1ACxywj/CE0IsCIQlI1bvCC9lOgUZfi0APtChlDAwk3q8VAIlFskMIvOj6/T/WPyDgcXPXlv4/2z8aCMFNGuws+Ua9IeUjG5dRXsezzRKgt7nzvy4hAVRvd1E6my//9+ETDLUZlorf8ifBxsteN26aAB4YdbSURqf9GS0YidgfVjMDOwEAIEsAeAb2APgOYAYQDHCeBBImXtcJzUDM5ibns7zIikgSKaPXHPdJAOhQlYVlrISy5TYFIAGoA2FDhThAQcCDsjpGqD5W8IoVtV0zkEhB37PCxAYAqFhaJB/OnDeFOCE74fk6TCQFhCiYkVH9ZyCi2xpJlgTlvmd8VOnERtQSyD+RXArqhVDrnCppGeCk6+q/Mjc0BkA+p0P4s05LeObIVa+QkwIPW5cT+ARCKlTDoiZKEABHQGb9E0YxNxKgsz87SjBTu2N++QU1sUKtBuuA+GYb8AyVaGXblpZlAwXe50wwxooyP7IHxpj2HwhqYCcCANgBAMBWZ0+ArwlsoNEdCfiEDSWwAPA2ACEzMFAK+buvuR8nCtaXRpXL6SQA9FvK4YEIi4O3MVBl6WQbkqCaGTEAACntaDHuaUlBKI1UBbjhwgEBmLdDl4/gAHTR5X34/sZE6QlHUf9RSQQBB8CkKPgoAMs2AKGqiCiOfVoLSjAIDNUCctgQXN0TBTBLO/t3kO2Sk5TP3jOz+CXjmSqf/ZRQAF56P1Fh5V8QglMir9Q+3vDOg9ytV/sNwaBcQu6bLJkgqLRk79gsPr1FjEKwQlkILUnmlrQZtQEPc8MG3td0oIRKY2Glgml/pYAQcL0AAPQDAHoyewDMJXCgAZIB4EgB/mAG0HQLAEUyRY/h9uB0ynRwYZ4Hr0azXu8EAFAJkUVpQSw0QxwAFABwfVBoM4BtsSRXrXu9Sxm2jkSP2sBYHlCqpuWb3qTRB0JT0FK5Y6cala44Wr2jk5u/5imEspY6aHM7h1sAoD4IiDkIRKpHpZBaRCAYY8BT6vPCQgU4DQkLGBvO0rfGveIr3eEkyJYkQFz+7et/ObkYKUgHAqN/bIaWPHrf7eXArshZyEDnicg7TCiBFcUrJdEG6ogV54ttt0y0eeywTOM8+ZaiUn6aYEMHAB7IrDIm9zBf1YXUTL8AAAQA9AMAroM9AD4SONABwQAd5wAebJDwupwlGWgAoCLqBAA4axNqGQpQrB9RKwEAsl3QbwxPICO6jtEj+jhj3R4cxTvikFdVbKqhAvQ+CBHQqLqyIuNzYgel9y5tnDo3vHLlVXjhxPlZSQqUxwWcqfzuay40Pr8ypaf+enFLnY0LBgHGSHINFlzbWRPOrTUOLMcEC78H9FCSIO69rUVioPx5D+HfQcfxf8TUnn3JSRQzuWpWMty3VMFjRJTIgccQLJ1vU2pCuQMc5p1okk6FIta1xbeTF6WHInzN799Kk7X1vxSfAQDex4w4RUbaj6AHwfQVR0IBPHf86x8BgH4AQFdNewD8OoADHYDuHAk+YIPAAiDJK80Uwj5tYHhJTbltTiiWa5/x8lsAWPhQEiuPrbMIRQkGAGb5JhQAALQ5wyESClI0z6pItZx9TSQgUQWN+HayyETKT9lYaqcAFaBavZkHogNNI9WVenrpOM0BFYCAK/g7JXqP0B8pC2tvyNJsPusqLVNfqitX8o8VGa8CpHz8E2IA8HW+xYeSjgqRoYKCCun1A2oxffP0z08H2KRfjq0hE7Ly9NV9LCCXRnhFGZyNnB/TrR8FgNzeHrxfMYt2BHPaHTAB/qeMIHWPdD9YqJ6Y9tcLXQOmAABZAsAzgb0AWQAHOgBSB4CADcCTFwBaSwf8PmxdP3e/L42rWIb191q9TwIApBiAvIKCQN9gAQCwwOqdpSMC1lmN7gHY21pGroNLqOqsPwaKzAh37ZzTFOIokQC1WnfPQjdyTqHF9+6FxBKloOyhaAq9KYrP3LklCGFLmRb2SkqB+An0oI6hGNIW79nsv61kTG954bsg4OW4rQACQWQ9+HsMyP/PxkSA4KJU74efmnnyWFxb+amMHKHkZmUhqSk9mZ0KbnfpGVwUZZrNqL89wnLMwiOpBbpsueW0cv6njDRVUW4+ggUEe/8GgQZ9AgDoBwDsiD0BfgTQpQcBBCwgsQBoonZMYRKtMcqKbd5p9iCSonnY5VQAAK8I0IGElR81hlAAFigfY0ATS8RQYcMuEOwFwZtA0O6LXTgzyrUXiJecUjOILgIFSnAAfiwQTaj2YGQWotuSCCV8IL9eD8rUShD0Zp/vu8HQl+YFPXHZ+3HcfeQLBnfn/yeRUbKmLWUf6UPIDwvYc1g3I/DjQ4onAi05EsIgwOLJkQW/jt5LZwTTnCL5YwnZ+s5D11mvd8A2G+4vC5kwJq2h1r45m3fs0taxxKGKFd6OnxO9lwAbvpdMIJYe5r6yhdNoINj7T5voGdgBAGBHAwCgCnsBvhM4AIDkPADQGimPraK4vJrRGlWv2+xgp8aUtMfDKQBAMXifOQ+OlJrQqrKwkhBQbPxyQAAAmLTMhbKEtER3id3F30rzWLQrok4xF+3BUpE3S2dnpRxltQjKWz5TWIdYSnRzPi0yGKWN0JWxYt8AXuvkNwvZPEYHj5ExOfMAuBVN6gbz+X8zK8AI5Fd8xD20PM+PVBlFzDBQxCD1Wibx1aWMVCAjsmWHHn5zXEtadaILLqVShoyTgd3FZl+7x5bm7RIb5/hyNns3LUpYy9BPRW/AAz54bC5GotILwN2fP9ISgAoAgB0AAHw87AEwVwIBsuuaapRWFD3x0fQNEbvmcsH126gYvX8AQCNbHzS6t9ZKQ4lOeamp+VJV8nDDewLEAYLMkFKphRJ7lBJLGUUmKqcMjmiY85avrSkjcK/J1gM8SRcRBjzstjRD+Qr0saJI9i8bkWQf2cL2KP/qBxDirKHSyCvfoiMtGwIejoEzphWrrBUSZX6qWW1Xb20nqv1kGZH1EKV+1fxUZAbFIUpSpdkuFbL1pyDYum8EBLX6+oBOC8n1grJdRgyqjVQ4isO5WmV2FOOQAJ54XJlpUHHwoEy+++sBSYB+BQDIAgB0Sb8CXAmsAIEDAMiHPOEEM4ZMjFFlBn6Eg4kNuG3pw1sAYD0lqUwl9U4WSxaAlQASQaqUJRBXLtGVwt82kxXTMc+sOuYyBJq6l0rFW9vH6IAaXLtyvVglREq9rTAhmm2/In8h47a6rmf2hUT0m6oCkd7ZcTMDqnSG4eq/t4QVk8DPMgFq3jvlI09UEgB17Q56jAXQwiEzIjK+MQ97ah24h0RT8ewafvK0ujrKuDaBhwl0eFGq/dnkNEw4uQtO7+voFtsjsxCAjz4Hjt2Yz5voAgBPZ2dTAADAygsAAAAAANldUTsxAAAAAqoVXh3j3t3p1NfS4CgmJyYwMzDk2MjN39DTKCc0Njrz4t6IXLSrMdXu6amkFrz95yU0wBgAoB8AsGP2APgI4MAEIJ0k2gnhMUXvpHlaG33IRDWaBDU3O6drEwAcCCoXWkuAdM9KAABoPGIqUkqhmiQhu45UMs1+h6UhVcugqtmlyOJUv891Cqxy5FcrskUlTDqUbbQqSB9oirphAetNAvYuHK7bWCwZ0H4QDPNsWiUB62Rml+7mpiuyD9x7W5cmHB7dAfkMDssijcQUmTXlKzqEpqNb+y3AwuC9AoeA4vahNxGWgq9vkGbtylYhx8nDw+Q1OAZdsR0GVU97/xAbq9yC+6cGHkj0OpUx2X0BuN/5GN2AHfn+MgAwAKvaE2AogEnStDb6LAQF+9Y9E19fWbfQYXqx9U2mV7nSajh2JKZF3VqChlxMQEE7l3KOIg7YIy5BIC30ka80VINkpZHH7G8p+W6k2wxvGAznfXGOZNHzYiOPyZCzMacYeFdjxA+qGVWsMxTljyGmVo8P8iXS5i0aNrQ0iY6FDSATP03kkLQ4rkWaKytbaqUNdVhPYrPRKFz9NPLha8ywOoRzzvh20S0wONR+PR/ntKRENV+hKG39c0k0HVyA5qeLJWS+AHXu5pkNPkgcpS4FrK0Z4PaLWhZsDQDQDwBQQb8CPAF4PIZcorVQjEFffD1/LEsuIb93T9M+nesyFADAFit4nVhADEYBpLIShJSmHGITgMwc1ioJCBUnkS2hFAtEl6nfNpMF0NNmCvnQMXiVmGDtJzMZ2P/U5Rt/daH0py2NbcnjhqA1dzPoICaNpXOFamAm5j2Bx9h0kXoIvVe3nVvz48YupgBHWi7V6qi06bBeqfeBm2OHPDRyJKqVa/oyS0YnC7E8o+FHFBMON+Sg2mtkKxhkVqfRZKMMVsJuXbRdZivrqgA+WByFKQXiKVuHSiukvv1DJhwDUAIADECxF+ABVD47EZ4sjKJICmqMoS/+/HecDRtzUt3xegBgDInWq0klxZ/8R/AeFCCjWw/rQDFyhwLuRbrJq68UR1FVcyVy5GHy3PZSX2Fzqs/UTzAXNr0cEwWZTL7J3pP4z0vwUmKTStAiK6sKk3ymhUZUClT3RXBNzKbDW423FQ2yj1AI2oPHZSzlrQqoZlTemloLb/jTAITEeyWvkmvmSTL4NtYdjechjnaoxhevtOOnkN0jrG6YsoVNG+tqixYdQRLqlPJgm6qUOLlwmp/zbYV0Ar5HNKbElbh6HZVE6v1+rdE2Evh8CABkAErK+Z4JaSEUxelbEJ4jbD8tmpRtOW69fRsdFbKeq9cSP45zJfRmxo4IHudqVPZh8mS6Y146/DYiZt0nidqBkgulrinf0Dxn0vJvXYqA/k2dDofVddGnZ4ahVha9boC/jcxW6FddZ5rRWvm8ZIFPz2cs7NbP5Z0ZQDNWYFCxSarkxrcx6Qo9Rpx5uoXXWB0sg/aWp7dblXIaF6tR5r6L5gg14XotUa65jN+o7bd2kJ0IUrzZaTak/bkhcCUBvkicag0QANx+GQBhCQBAuG1j5VVUWlvG77vZI5ceH8idvaVbjL3ZWV1NANj+THGDUpy+WtVojDrzTfGHuWahZI+/dBU10VZAVDwLyIPuNG34o6s6QXw0f2teU9CeCZyp8p208Ao9FHJmiVKI2uYYWSTM9TkB8Y2EUHRSGym/b1NWIFFN9uzzfGw9izVjKpB3ouxRuo6CGln9xpevaRtll4aBSeT4FRqIvr+kBLGgpvJ5jZMYXg05iydz0bbYXFIiuQQ80IN6NyLIMINRfJD8VG4ly2yVQAdeWKyuppwRQSbg7aIOdr7vBQDTSl1FjkYrprD//KnPurwf7v04JU/j5g9zNwwMLsziiJR6XMMymiqBVjGy2DI0o+qSOhuGpmLteO2yjotbqqu1lnSZWJigpnsp74DjzZ8D5p0HdUOqv2RTHM+6iVh2Xy3ADbzhiA7SYTTesFtmvBYJsCk9ox2XrGduxtbUtgpX3FW2yS5nn6ko4QJArCfab/yGCW13uwNj6NIPnUaC1bdkhF2tdcjEK8qNhd0QueDs33iUtur8iqsZ5x/TrjBgqzf2RmQ+VQtrnxngfq/5EZ/y2oxOanakAZAmoys/Gqe0YpiPm8XjqOb+2jZXZrmRafhz7U+Q05ZxUQMtLX5QnY15NWTSlfql7B2Xft1SbmjgeTAl9uCNHQ+V2+tRMCbCzGXzrhXCUVfB3g8M4n7pFuIu/es0X0VefQt0u0TLbfSAj1yI327lvS1WlXT4UzNlgCq24xmhG+rCLGy9/SgB8bvV4JMeuBdNhyqbZx3X9WHsGeLj5w6KoV2FixB2VnvyjqK7RI+2I2sn5zLhNpz/8zfTXwmxQojm0N8l0z7I3I+pAKz5dM5YjyQDMj/nArhg/+q59yTj7rDkdMRMl2ZFgg9W9sppuVqYWwCM+TzGgxBUsHOqExgVk/c5VpWl3Va0IzMpodVr0thBpfnoGO0mC5T1/M4mukN1g8xMkEAnmdk/InQJOdR/a/ZBOxnRLTTdsJD/mTUoD7T1KKMAx8E0WxG45CtfGPtD7ZTv/0SsFQds6pKSUEwDt1zpZ5wA3PlwAqEAjJ+QgHXsy3jOMFuP9x6D5UvNtydT4bfOucP87E/Hul3N/rXbZ2zR+20A7A0RAwKAY3YAd3EAwH1atfYZp1hTzWPzP8Z3/fZpmnNU4YrK1M6C7UJFpc9WkUQt5hoAzP1oZcMpXW69jxMox4znbtd0G/Y9NxlcT2O65UE65qbVrTnV4X+KcbXg0w70Egxbeld03ieThKplVu777i2i7HnIoXWL1hUAYJKOftIY7VgrxsLLR54w39COQX5Oy3HzqT02aPbRXVEU9VBacAPjhF7OYnp6GsHkonZZXqBV8p6N7DhdZsN5i0g1P5nhTeGolMzmGrB3n7ZpYiKnY021dnHQ9KwuX4gsMZgxVEGGwsNXNOdDhUv3m+Pz7rpSKjN2i+wGt+cAgVpXsoyoUm4oMnmsXhGdaDQxQzuRkaG0gsgW7hol/1mk+pcyIuRmLbPtUtZ3+bb3MvRfGSIgTkeJLhhb1Z8i0QcXqibzVXfRLo99UwNIvkgspSUcwQDuxSTJ5Q3oKhxKo5MFa2Uhma/bDB6cy0uTcn73e20Yn/PNeo5pbt0w1p7YxMK96nrXryIo+D5CAhQ2flquthGmg8j/KSSTU6GjyFSBIBK+e0xlROh7kdY3dIcJutQBe5cpKU4wzMpj97LbfFr1E+AI//OImqWXdIx+kRWBsymqXIE4CF92apSWkPOrGdFnvjSFhu/pnL1l6n78PhVw+oZH/88SM28zfSKskuwQ34fuZiyU2f8cCEe5EPKvEhBDBEB5cdG6d7EcX1r/5Yy2AgoAPlgsMUVhAHg3xAI/LQVGXTFVygilFMV983SgX7n/pTXf45R57/2Fty+e/Dwglribj6t5Px0MXN/Oai/aFsHO5n55AWE0Z4l7pc5v9IghsbL7vOahbac+WRzO/paZmB4K2U84WB2Tw61eAN41F8AE0jxG/ujly3KoomzNusUHkqzExSk2czhnvxgh8OW+8kiQVyGUwpVoWyqsmkuxoEgsde7pfi/2miwgV16kcOZhRs1fuqDaBn5bZDmfQYgwFp3xiaDE6nofAwCeSGw9xp1Bg3dvFCBlA10bjuWxVqwVY87P63u5Nrl+ce9Ff5awbvwNdpk3ldibWnRZrx63PGf5XZcK+vcA3K4wJgqNbO+GYxmrGYdGhMLszhzBV6crSU5yzvVGu2KttQqTjEHYGqTTZ+G0yCgL2/ukH6HAB1iIL3rO1/n0I/nQSMPefH+9cAj5lU06UMt8C1xYaps+8MVZpc72gQ6XSIWo1LYjcoMju7ErfcCA/7meltTk1aZLJcwyleqDVOUDWmsEo63bylb5RZjsUjYA/kf0pQZnEIB7cnsKegBjTZMq7QulHUXu5l76zRdTD+c+Pt7MNqeyi33aPKaMvdkH2ipz3SaqQnT9DVtqTRBkCWsxXVhg+zOdwZcUbSR/w+8Iu2Yhzp0HWSWt1bZesRf0HvXQWSm6bDosYsh9KRSPdBfat44zyl33sYeb3rb2TUhLrn/Qu50/o0VcMWHpCEHKAoWNhCk8aOuAyZQqJ5S0pLkQp2ZNhemq1TqCpCf1luNxrr/9N1RxVJ8uBffDIYFWr5zm1nm4RcaXaxG1TRuolxMxVTcQerNZDJFqvZZhA/5HNKUGJ9CA+8poTYI4JGBsq/zo+YqVpchGv81NI5JjUDMHCHPYB7atkvX4EXMdLTJUyzM66X2BhZeFcDBHBtEqYqn+w8RHgxB53zEhzCXO03dthdFJhI0W+7X2WCuRE28osuFFrDg9wtybg+JovDFgLS8RiGt0to+UvNXYY6blro+nH1YKCXPfGH4h3F3ZBp0ndpQ1SctwZ/XwXboGOWgCNgXronBO/LbSWmYgXU/2XF2aYVvc2QMq9T5Qh8oXEKU0WQwhfGUo7RDexAp9wzo2RzTGB4EgYpz3qh0m98AR3ULn8AmMVa585xlWzCgwifxyPrrnxpETdnvmi3zabTpybh1ebBv8S1jCqgETfo/jO78pATKbh+e1lbCWD4Qh9Z6agvwLvt+sVza/H7mD+8wRpwVz0mV9UeU5E+LR/ryWbflrpWLHZgiImNosVGUVykItgfMvhYA62w/Ux9PVQyaGRjCCyip7d3NmuIDaBT6JW4yFE+5u7puFYEeLcstBOwSS/UhN0W25G+4YrGmVCPUncdz3sfIUmnlorVeW1rp2ZgIAxPUoI6cubDhAAZ3KBFzwf3urWCGQ+4Ybn7X93XI8lnse8rnz8nsqAMT1UAmcJGPL7FQeAF4yZmXqVErf6e3JzB71T7+8JolPJWVWbIIqBdTtvCWG/WA4ILL4vYAsbGZ9w9VZpnH014mn/uz4usp2zhNv+9Gp1DrWC/E+9wW11owK/gCsNV8vBEbJHJny0NPlqpAQkB34wfupZ1K5a3pm0OnvrMxHL/N7VMLOz8y7byrUXJeWbwBX9AL0NXdrxkdzSc1qulHsNa0hvjXEoPguwz7d6PE/g+3rkvOMpOG98ZbcbVspI5XU26op1rvmXxjYLG8AevccxCBjuLt/eeXew9EJi6r3AwCQQJsBH8EK0AsGSKJfbUoIMcU1czA7LIF1Odid6ekY589fmc822oWHtLVqIgW1yiZff5ndJH/nempUqNsrEVprrbW2yk5d+5VG4dlbV/96rsglf2WhKOp/fPnQwQxUWe1VyPqgBAKw/0cMMcjq6dx41+Usi5LYwuU/ce1VdYLtCGwwllIWihW4BMYxc9vo1cIgbdPRNynCfm/L00LfWTQ7d3pVtkVdAQYoOmXeW0wMa1ZCGQAIDUDP8WBNexvniWrnBADvEj4sdf/V8Sn20zQwgFC5GaIoEgCa3gVREugAvsckeZkpw8wfYlyrT/NDFvcDABAEFmbXAADwYFAFuqDUET3PkAwwQ89gPu1RGX2VOfB3cCaqk+vrsDTXpaRERu2Wbh0oEh2eLY81Nz3uLfW/4b57xYgRulCw5S5OnnE6omDXCGES9jtktggBwKHdiysTGK6T0/R7A9r0Uq76kVDdIxXh2z4FgNkMZKq/xPfwdcBrd3zKBB4Fu2H+fscGML8QVUlRi5moCUZDj+3Kbnwi4ddLOkBGsZNrpGreFwpZS1qRKw6MV7j3370GGgCgej1PKszMALBt8BZ8c9EvAB12Ak9nZ1MAAEAJDAAAAAAA2V1ROzIAAAAR3mF3MOsoLCkpKSgvNDjx6fMpKi4qKSgxNTg17eX1KS0qLCopMjvx4espKikrKywrMjg68BbHhCraZGrt8eFTZ5dJ3jfJHZ+67l9eLepPPyExrwoARDBAMHgy4Ekt6fdSwUD/YGznfL8YWW1/bLw0577/vrqx+WpdIVtFTdj2SggSMEqCqaVjrkqiUqV9efr3WLrsHXzNWKNV6MsgRnNDgJ3t7P1BnzqxCtwU8T492d2SCkYUDjV/A/wqv2TdkjHvjnMLvsNTfiL6uu04qdyuzH8PRwqAnDWkVDuVZqe2ugfzQld4tONFWaiLoql359QkjGH20QRDANnz5d2QAGuWvcOvsTQDSG3aw6Oz0+WSjmoNJKAJQAPdKSMGAQaQoAAsGkWilWah8O7HHwkbUUFfKfBa+E6aEuVYAesotyY/U79/r5XHH2QFRBpFoohm1rw4PV3PcBGIBxq8DRsVhYTmuGta8Pzdn0/VXh+Al8hPGe/qowc0FkViFABdeLtZ7YgZUQZf34tlL25X73wepev5E5AhjcSZWVUknzSaAxQaRejBw1dyYBlaNwtEfCrB+Z1Ewl70XfDEBVcNz2FUesjnKx+GH/g6DBr9zlPahVaPU1032xqENBgn5jAr/qkbrxtb4RMxrq0O9aP14GXJfzUUGouiwSS/wTfv+l4DGB3EvtG2GTAOTGsppcIYY5wuDsow/JNSPAUADB5FxDgOIBb2Jv8M1otTBUw20LhahTRi/NktdajWmZnYTdoDLajZ13VuccKdOgD8Fa/Q9jujJ7GS51XfKhpo0HnQPlzM9fo/55WRnl1pDFLhwNWPjkfG7H+NFxtOECJoXF4C5DGv4Z63JJI4ubpaZZ2SgOrYkfwK5gTWNluXw/T2fcQN91G/v2aevjJssaoY+yZC0WdWwirALgA618xiMazJ3tVc8XI+L+Tw/QAATmC8AwAAVwreZg0IBjukgZJSJSWCSMEUJ2MRjkPAuhR+m7FOiZ8WnU6usvNd5prRY0xORwXYpSollaISNO3Vq4377KG8DzMdoFrClCZx1GasyQ37kr2y6YLgMcZJ3J+x/vtghkjs2Tj1hoPnXv6ZWcoo9W1vbC7Sewr4zbc2q19pRh6tEIkSACIXOKmksZiRpvzfm7a7aEad7lcJNxgcoUU/BJvd3OD73jDAarb7ihknL488gNZmzHgyFMgxbxm9hx0QkkBRRq8q4+xMBuA1+tRoLI1w/mjdnEUHAGMAPtgUwNSlZedflmutXGV5knL/AQCAluAqdwEAgOsNklSAGYA02K0WXU62QSQzAOgCeH3/VuJqVXglTVjqnP3Ke0hQGemuJN2YAZICJQFD1LLkvabzm19fZwITcGIjscJ1nfgZBqfsRZgGWhU63t/Id0Hmp79okD75QP+op9bEjBA+92QbT9q1nRMKAAlSqZpaXYB9llpAHkF+n44lQ9CEpIiqaADs0/fCPxsYxE0sx5Hx2uwAoFz46xnLJKshtJsw8rkJlWgA4lXquQI2DOdQdbNOOwO9k2Ffo+ABACDueXE2jnmY12niBgBW16SK3CKt3X/4rVvsgmn6AQBoNJSrA4CSwQDBKJ4MuLoZQNeyZDYMrLlAuxVgcL0P+U0eJ8NlynANeunGQqfHCVQrmZQkh6aDuwzHW5mvbzHl80bO7NpZVW7lxhLHIOi37ewb209rIkBdUIx3/ZBmSNiMVi2t0kIAnHsbR3CWHp5zhMsPyztx8hrzd3QPIDBIT+u4fitc+tB4xYeyvDMltN/+jTYi4pat6lXTvxhAAJAZwr7NRC3O/N1haQA7fE68CrAAv2uOR7FmRQMZy28rqyXQ5HLT/U8mAwo0e+Uu85+wMIssM7KT1IcjQwFt7Jea/gBEJilnYLO00tdpV18BDUZwnquXQshjKTO0qHONpyGtZ5ZE6zLepFf8BhQi/daD4hbzZXwJXTerC0KC27dwlqRe1jttun6nnCIe9JdIGFlcZRqkARQmfcGG1FkprpN7UM/oCIjUePocc6BTCAeqKv0g0N+ehkMgzbWz6Nq8tTH/GwAsJinnIZ98LUg9u2k2Bm5g9b/1SVR5T3TU8Nppne1N4z1tvaKmVd8zKSn0IYuiB5t/6TmF9cQ3EDHQMBuzz8B+MixtGwbrcKApvW0XmPhljkPwAfwhi5J9Mt6xb6b1i28QqQRJEH2osRAqTVPXWuC4OHGGjMGOzf4U8w0kJgVuR7PsLSutdo+XhK6k1hSvApvy9eBxOH245v9s48UzDMpctI6soyhc3MnaXlsA3C13+TzfCSn+3GKrehFAA8WW+ktQ1PDfNM8Se707a21bnWQTNMfwbsdMnXxsEXuERmbD3w/MMXd6gp52lr8pLjIVYhVKUDoNxsXbvl7bknrmWWja9f6iZ2nMYT3JpNfUL+aBUmcc/TyjDilgHBwyvZ6Ez57r6zf5RXprJIBJFb8ejVV/QtRMJjYJ1TwaHeK6POptV4ClY+7Q8Pjxr2MAZRwAGqe0A1ivrtqw+HVgdH3vj80zMb6BoXI9QmOjgSVAeKZgEgyjpSmg5QqRTJGzL+5s7Qi1s+be/s3tlr/Ddk+vZs5nW7V7M+rCIqs0d6dUAMfsm4p24YXddIXeiLgGXWYi4BNji1aJHzVhdf7n06DBW9M0mORaa8VZiRBmIWWiijb1P9qNyql+UL+RjrRlGLLzhJDsI80YACeXXvL8SyLFJ4vkyauYV2BqcG9SrrZc3LeMEGEoQ+XB3NutkUUFVxUj+bo6F3NgBajg0wYxGB4WOIgYAggmChavccFaDm6o8Gbp6DuSpypga4ok2IAG/lekELZZnqaXNcD73sSRdLslPHdV0TgKADYLBgjKgEMa3kLhCc+zWlFwcjk8cnDUHzOl2yS07eTM/ellKlUndeCLrItMj7FdmFYmhbdEmYZLULrnVOIqc6QbKhFEGf3z9EqWOoUoCIK1M2k9TA1DzZ5UePXvQBZX32fsmTTFcVPzMMnWHcHN9uc6Pgi25Jq3thWWf6HCz7KwDkuHO5GxQkjrwWJ/bAmHngJq2HsgoSkWj2nPagxpARI8DQhMQ3b+ycj3Tg7qVufXQEwFj5oYhbSBfGUVPCik7+SY1m6oovRxscgBADZX5DBLLtuOH/rCFKT3DwDASqCAHQ0AQJ84AoBZkQGTARSkoQcck5Y9zbjjeUH0GDe7wlyjpNcHz1oNE7cNB0RMmXz00fO0L73BRlcrqegpAbCSjDM1oiBW1hHDDXeoK+lNvASdTvw8JBW0a4iHR5ayi+plQ5QYgrfTzy8nCiuz9+Rwf9DVsHe5WtOvO9Xuu9rNfYPbrq2OWsZqXUyKBW2tdSzDNmjQ70et/4Y7IxBQP7lSKQZACNlmtAJgs2tq3nZEtt//pV53GHidFZaZRlwc/u8097XRiimmbsngtGjPtd6xyoASsoivVN4XOkhBycs80CcADPY8iGFIev0Rcm+KAQhXwafjRHek7Mz+LJDGxNwBo9epTVFkKdC24AEU+jyIcRA039NYhPFpBmgwNbZuRJK6AyvDXFK95iiMepa04VDCVU6go9qgFxL89XSI/bjR9aHr6vKPAHHQBLXzsVOMt2UZVRLfDw9DlD1n/Kx6mO0Q5Ajk+XTAs6fN4jeyY2vDYRIR/HfemMlrOkxotOBmw1OEjqciw1+Yshu47Vh/AOz99MQz08h8rUwrsG/qGBXXryXySxJrc0TBrfu4MHuclDpKT6aomf9+Awz2RMTwSLy+IeXPDy+AC8Zk0Jy1MG/soXGq0HOrew5RDD3mlJ7shbAEzPlKfIEml5nkYseY0SZIJ9aa4kzGGip6lf5vL0z9gdbbZ5rCHvc2nFJSlfZ7/x/cQgekMa/1BO8S+AKy7Y236sl8GrSOjg2vJCzTmza1Dbtxl+s+o7c9UbL31kP5srE/iObNHTvaVcFooDWDAPrGHMBWvWaf9Hj5OKyjkLw/AID+aQYWrHYNHAeAQpYGkIEOiUjmQ0JQXNMp17ZzC8jsU2vfAgInqnFac7BS7es5WQOnGsu8AGdb/j/84OFeTYh4jK5E11V7s6bHiU6nzUKjSYfWWqvW2urSpVdeXzVDoXGvTwfWOGQdO6C4KdNGeXpy77ODHFASgWqMiHG/vtXXi6w0fzCuOGBlV3HDFutSUlJialw/FAAA1n6/OjRYguABvv6rhrtgMgXfHntmTdAB6zr3dKwCkLVWfqaC52c3y8LfHc+qi4u1bqRA9F10bFADuekYLNIvTaNSJrhuBwAeV+RIXOZZkD90IP6+jQKP8xJ2pO8FbMBRANAdHQCNHwwQDAqRNDYkmGFoHIQdsSaGuVWZMGtHV4Ufocb2WpqcrItS0b64NS9r5yMVdc8b1fC+YOC+ymZR5ceFV51EUlsSiN6lWg1bieVQIiecvVZQ6k1aFSDLqnn6F4MztjxJ2+FjVeugaDsbEiZ17uJA4xvrP4vP5iiWVOj+Kjpdg5QADRA/0us5AIf8vAsDWeP6uWPDNKwIDVQ7z9sVYM5W/X3TABY+VmdvIrsAohSnPh4Cfnm7hV2rmzFZQ6VeNKUzAgAWR+SwyGgSLz2ynHq/53p0vuSnM6n1wxMBTApHA8DOEQDs0QNAMJZmJ8fOY1lRXDz1XhHe7tAbt4H53trQjL6eYqO5npQrehoAGGVq8APnpb2rslGmUiJigAQOfG2CSk0HgiakBMAwBR4x6/aBh0OuXZukKija3GPBj1OmjDu733a1nw25bCWE1xpMNKpB9tkPIAFoWa+wn519AQUOD+AFRBSgALQB4NKLXx6valewdCRiHFb1CqM7/ciqAXxEAGFnsM9vjyU56Nm7douD5eoreNNvkaMaZ+FXo/BwYzD9TlxPTvkGu4qKVRgD7PWKmG2UvF40yu77TCKCxz/OunjjxINI0SAbBalAfjKJPW67zGG9ZwLc+XyUbbeZ+S//mqq+1kQEz62b9t6QpgVWTdaM+w8qtIgq9xcknsmMSADM9Xwe++ftmcnSLv6LCzCC+NHWOgqJMjdhyXJXWecuycPYZRMhtZvlAdT9ChHbs0Tjj66r4i8DiINu2LwWFrKio9KiKJ4XpH2AU1oRjB+wZbefGDr0+TzQft/4/OR2fGUEiIOiUXs8zDNT4lp2isDzdWf8gzfOV7pUmLURUmoK3PH0lGe7keaf/GbSNo4AKWn8HS3MtSTeQv7dCHkoqMH7mtMjnPm4RQJRtQTs9fzctrPIX5iOF7BznIBU8XnjtaeyoI7ymC0+T6Io8Y3TFC8iEXVMMQkbDPq8omEDvHB/fduj9Ipn+8dP+35e6mA7QQfvbugFHedYBJTt5A/q3rdMBeW16Egv0wGkLX8IetYmI/qgtvBblQD0GIqz07ujrWMgzWWNy0kmN72REHk+r/ShVUTbT8NLXHjzI/3IgQZ3A/wxr0BPw/GYMx2WD3WnNXwK7GMJZ/LLd9ui9vlxWg7lyg/YeLKFGpXZhmreflxfUzqHf02le4y7NgAa19yYLP0qLSEExyJH5Pn9AQBkglsC5wNsHUCXAatbfX662gHSAEIhpRi4XZwa0KH3DWNuwa53FRkV7uTmK6oQyx9I9wgoxAq5g4NkaQ3iRE+hAI9ek2Sc+/TK+lk25jvlmz3ORFdKQKNEIqZhxmsGANPmOGbXkToPtdrNu/x9Tq2ly/NO/it9c2BtrTUB1Ky3Gh4dt7zXBSgpKcELcDjy7Aow/Z2iZWdaXKx5TInCcAhIAGqHo3jYb6wBlGIVlwyIB9zblQxtsimfgAVXQ4fKJzzRv0MALfZExzWObByojm6xJwBkT/gMw3GBXE0A7AJPZ2dTAACARgwAAAAAANldUTszAAAA+/tKxCzj5ikqKysqLCoxOPb07ioqKykqKyk2O/8D8vQtLTAuLC8tMzo4/wf87i4wL95WHOJckicpe0bq1+r3fkeD5mNKQG0yS8ABACEDEq/nEdZYwUyhLbwAamfJspYjHvIuOqv5Z+WhLq23vJylHtj7xxKcUCruwSZo4auHTekSat4pGu6uCK4r+/GMgkl6C33djsy27betgjyMqFA4AKDq/W8L+ORQjoJkF+z0uen8FC7Yx0eC9ysEamUlVhINzPo+/UZxsnmeFgeDTJhd9wB280MTVc0Q+fv+3+pRQlIaoOkY/XVfQmbipnv4Kr7EfaMQcd7EenZ50e2VkUeiAgB27nml05Xqm9c0ZjHzSv+sc0sT1lbMcC4ZgQgqvPdmOpkIV/bvd9NCtTMbBhgABiBowhppHMiFWAtG37Ow91LYv+a+9i2bF4OD66u38ja6XtyU/b4Rd154L6O0BPfdSgDBtQfHH1rGVQGF6Zr4vvSgffeAivv363uWnj3DvcL0s88XWjKA+zEwi7rY0VIHCN9iJ4i0MBQha9AgeVSML+/QG9dEWhGANZ6L9eoM4KJ8VFkMWIUhFBI5g18cyl53pSUwv5w6ImKnRfqj7DnJWvZME8k0P4c0aAbnUO6vMAMUmLOtJzgVRKiNVfKYO1yp9W6xgOscPKO2QQEE/kqsxiR0SbNj3BjQS5YbaiqVLBtjzMD0sbGT16SHAp/frdDQ0M3qAJz1rjMeWlUzZbme3g8QgClBtedTH2etujbK03DRnnRc0Wz4NP/hsLe6CeQBdwbFVk6XJ73cdwOsii3XiYCRXJXM72T8mq/R+mRhjaFT5bs35FLlGAQE8oqVJo/Wj1wM+r6NcMmPGyl5EWs3lXbn5D251P1OKkqHumKVKasKaS5J9PlKosHedtplbL6OC0BHFtz442gry0VE8ho+l6VpJ9IO4Lt7etY2Y9wDzP3KGVt5PXwy9X3V3wCmXrK4ljYkJVU598GKvxa8JXVuo/bxr1pWpg3tHRrU9XZaxRxJHJn0mT66AL3kQHmliiMRsfEyub6FaLJHRgOd727BF6UzKgAUAsujAC+T08c9XgHrGOqTkSQ5menBg360z1Pf/+v3uP2BRh5fzvfyGfuM4cxUSfUQ7ClfIYbtZydEXJKrt6t6CMA6FihORVZ3aXyWTjOd4az+S83KBpWYzZasfgzKxulqfc1qyO/MNQk659wYLQ5AmZztnS6nKm/fm6dToaPPMIkhE4bCziVQAgAzoCB0ADu/zODHlSECiZATWlHEHmXH3JPT8qJn+/f+Ned+9rhvxuThj3OuX9rSEGq1nCzEGCPQd+nLZ9nLKlA4p1IKOAquCsn7/6MzgEy7qfH4WbzPNeqPIpOheXnv+qZsa6INALk/DEMGMWBL/609u0sBNhw1+h2go5xEyD87TUmrxWhFRYxhf16a4/YmrJF1KQVXJl27OtQ0qvneXwEA0Bbvq2WSFVxfo3PL9k5oeWpq4r+fPYTbCDE1meJSGABAk+zx6xlYCCER1SCyGVAZV0NFozeeV8zRFpXOyH506tvxvj8AACVoEXAUsDpABggZEJjJnB0gCSAXSbaMqQko6jIi4B5JhtEOXibDdcBA2dNX7CXrDhDiLt9LDc7oRdWiWt0VkY5B23TdF4B92zATRkn76gZ3c08q78FNQKNLeafmg0bJ9+nt1Zmsgx5bMG5rs4ptHyipHnZ/0Wp3BFt/u90dwdTfEY5QWhkdHdNw1h6gXe11tebSUVZiIE2u3T+Dtg4QZXZarkaentoejVGjtbXqBjBMy59qCLjVqnmvJosQkHxPWGAxjRzz2Gmqqlo2W7N/pb3dauMO+7ra/8i1bVD2UeM2HUkAtlYcIHqQDp6tw/1+AACg4aiBgYAB4A4ALoTSBYAkEOSEYEXxYo4MUN8357j4dyfedNavtLd/UvuSmGf3fl0oKOvWftlPJCFlRMSx1cLFXRsinhs0Vs/9NMEjTJCIUHhxbmavHuT9dStO9V/SEaDhgpqjxpcZ2Ve3XT0rqVB4veP2nzz7fuyQ+7cdXGP2nvP8op167KQUIP1UOXY5yrCNZPQ5uqCF+joPyPj+CdCXtcyx7+zZoQ/wlBUDMbn6XQE6PxlglV4LePTr1nl0+8prqEJPiszywla+ZP/tHpVvTZ+3Mj0QrZStB7tEj/7NFyz+9FaUSUYnddDXPAFwuOT6D9G5I4iq+oNqv2kxZ6lA8rXRR8mUBwc8G/T5SpRIn1IvwplrqwHACnZOpbk4EUsPtSF8G7lTPmkQI/8sBy7GlwHWAAz2SiO4qAxpWgbkTwMQA40DE40wHUlSEKmVXdJGHewLbHe4fTjGMmUpMwA8BgvyLsdIh7tcOQVAr4I+cTqtSsZpSUbRhyvP0vbiSaFF8XnDhT1OACT6ipLgZ+c3pcv8MAYCQLCKipoklhHt3EFivjQsDXk2Rj51S9Wpyj7/G/T5ioMh/exFhxrsW8NKbr74PG6UjXrjx4ntV1rQ2uAJYNg3Vc2aK/0PKAAcAosya44UXYbrx8oxgO4CMg0VJ54w9oS+BYLVFJ36ogqgrq/KyLjIDRz+imiQWbMIDVB9wxGwiiCxL167bOTGjf5r82cDPHTXR1DDdcrEk9JI0ZrA+Hykfht66mwhANwtr3jt6MS1FIu5qT3FKhqBRgsE8UAxad1SrpCNT93oQs1syirjnMGQ3G5myuKCiin559MSg2snujwA2ifdIOpz25tl+3e6UNuuhuP7AwCw3/9RALCEHbLAXQAgPTu/vAGAPEcHG+jb3MogQwxZAZwxxIqIFW4NhbS3Ue+0gakHskjMQU/Qhi3EybvM1kakHX7lplmpqJJKKUXI9Us3TPiBK8caHZJGv5t89VWDPkaPRbXWWmu1Ws3/uX7kwR/T9zyaUvdqp047/1jvjxOGLytjsy/hCWDGHvEETeR6CvLyUfFzs+3z1CtMuGW5sXBNELcel2rcRuZHpR0OCGpCA4DTcP0v/3VVXLR9ta4iAACAMkyN525gbt0A3Ea+yLD49YBSBgC3o/kuLSwDEpebxbCn4xR7AzdNW+6nFxoAHkhVjM9WR7rkOUgxIPsPARS9kwEBwEYYJDIHyPgKkOcAlkAX1HkhwcBtzFNQ3qS+qdMwTSSfIB4HAMSkHo3wWImi2/rMz/N8IqFHarqXVjXPPrHVXMv9G/NrXLLw+M+6uuSImo3BxeimCm31znxirtKNiVt2e420rauKi5Em8wdNc3o1k1NZ4H2uoNBD1P0b6ag08FZkJI7yViTJgllos1Mq3bZVK8vVWPlCS1s6DECwN8C7/JWw3FdrK5IY4AIAxKH0CFB+vhxn2Z8uhgRlxPcdhwWwyntPgxRsyuMe+kD14YXtVbbwB2WJu7yEigFgKgB2Rx0Q07PpI6/tX2M2I/ALAAAAMAPI0hYAIJhGw2Q94OoJCJKQsoqBMS0ssZ5vgGoAkDC9xCOVxj0MNC0Kmzka0pUgxLESHv9V74brOBneOTBUFMfNTq/mL+9lHLqT4j0PcaKWN+Bhov/+/zVuw7dFdnh/54Gd1dVVVf27nHYqfXpNgxUsIlUI/A3WUjS0twB8BS09mCFfFgzWDs6+REYAxrUXQ63Zsa+ymvfBwVteJVvtesshaLrKbHg7Ih2g8NF7IiQBjXkxukc7DvQbRbfscAEiDLObEmSYlomdSJmwhWjO3pyim8wxBDPCJccX2wWNAhQABD4Lkgdd+lbgBEEhuDVBAQSu4ticxxfrlkq77tHPGz11bOFzLjZRcxXZY1oS/EULZDCX5C9aMGCH7F5mgoAJDbgxd7xiytr6zyJUhKlfJK7blsgZKyiNlJsq7EGLXRBHWVcgWjL6dvhfaQZIuQeQUOXMeLJqpbglsIBIfOwh4VMPZ2Mz4ZWgrE0ABD51ODFqDf6jBaPvGXZV5gAkNgjQYKIpSyfFt1VVNoYHVGfyGjjBMvmxyRZtC/xBS2IQP1u/0c3g8l7pAQECA9O3j0VU1CVzqcBhcru3hJJKVz9jjBoy/uAH7EHLNY90M3VBK9+asB/ggwCBEufTQFINFbmxab2WzGqDDJjWkLrmaa5siw+pDACsQXeEXNKZOQmXv6rtBwhioMHCaLckqUj7LVtRjNT6nQlOT5rzHsm2g02kZwH0PYvQxKjghrOtVysEXJCQfGVQ9ItTIf5zvPWufb3CP4M9CHb/O3JWA9pxOn253WrjtAvkLUu8wQ/JaEZrlnM7jtZCJZLYOrCKfGsy26BwWuqVM6n8W25eyVqozZ0qs+8nAxyqSNkICbiqYpIB1DnLa3bPspQXWrOYKteqOJZEEbEPiswX7GjASesTcZENa7+QJ3USK82cXw83ZOmkuM/xAnKKSQKaF807cV3zSd/cs27/FrYdAifrLwAAAMAGDdLjTQBAsNVVQTLHQHDAhm+DAARjGBBVVkMA9CrOvZD9rlKgT5sAGNJYtdZuDY5aKVEn2dzFwDU44iwD64LDD/+2eTPPLIFoxSMVD8eUVy9lQ2/CqsWSak1qPtvGQePdf+0PP2zVCzRXaA5sOTz2+flBX0ynAgIXiPWSVY2oUsf57PRdrqa3vJZkL40vWzkcxkS+5XBYbKIRTft9zxjEtyzblxIgt25fKCz5X6E77tMJsb73l9GLuVhYANjIn6PvGl2uqPynPYFeB/EgxP2ia5poiwAAwB7Xvl9WdTICoAE/vzKi32cLIIbV1YEN3le1TcvFfHTHl3W7Mdz5BQCAAXAwcoBuMIHB1YGZp4EDI3MBQDCAZDLnUaAAQKWB8X0BoDB7atT1KZlS/mjVPdNVKI+LeJsxSbx4emUxUMdz1CjVjh2dsejFhXjYFML0wuOnIE4j+mqUKvdai4+T/UGPD72W5r8YM/fzluYRbVQzthgVJ8e/GK0OAp0+fadmowiJZrn5s1V/qcWAYuLT52JehbAdOInTlHP2K01Cw/Uo5QpvJDXgagwN0mVsHPjd7vYlEuPOGcsSMsBb+rGtkiO0LjHb8pUcU7OG4Pd4g8Wt+jYYUN5I2qeD0H7B+8bKzW6lWdGzSkgz7GgmllfljXcHaB89swSTiSDxLwAAAMASwiF0rjIBIBh0vKwHLGxLgESAtCQFDOYQBjpefgCXH2sAQDBwXs9cNZ+0WhrpJmwpKYDEGSwF2x8Ht0/sdSVpn2N0AWI57pV9yNPYPSBMxTjxCVQE5vx3dagXdy+wddiWloSf+6m0H0XLfv+3bYteb1mWQpS7IoCQuaqm7y+2ck7LRnJqLyWr9GW9ji2sm3k2BvDae+bsmHf1WU3aeU6zsGjbtJ6lwwm/5xV/SGtU5VKE/d9sRs1DFlgA74axNaXbFhqvZRTgYpqnGuOY6G5W6reK5CG4oF0nAORBi0wucD7voNi5crcW60CAQMKh7LZVzAX39/mTWu+U46kCJhkiNsmQGZSCpwP0PQttIu0qKxGAbpyqu9aAClJDyj0BBBNjT+WptMa1JHIzxaQlACr6XDUyTAK2QxL0RT0yMRZbv8BowYpvz9salqBYCVuuPc80JSmy3BXlR7feS6bH/aoAkICr8P2aBk9nZ1MAAMCBDAAAAAAA2V1ROzQAAABVFdUHLS4tLC0zOO7l9CosKSsrKioyN/fs/CwsKikqKSYxMzfl9fQpKyktLCczNjj049xBi20CPmP+AocWLPyxFwUQICWBEpzszPLdEkorbYOLIUwnYVTjOyTf/qch7wHkPYtjYiyqB93IraNaWQXUFEi4/fqPhJpGx/80yrikYZDgXVJJfNBAI/QuEAGsQXfEXHJJ/UWH2s71p2ZgBdxeFYt25MVptAOoR3lLpyXXlz4gIwR78Z3dAKQ9d7hcSZM8FzK4h3SrVJEEgITHFw8FBpsjOqDOap6MNIJ7absxh6x0qQ8VA+Q5y8EAkkwadguiyU/DA6zz/rVWotOTsxAjT+fh9KR121Blnv9fakp+3Gr7j36MrzKjANwpr8fBthsNqZ2VLvyX0RB9ogUT3I3+aRXB9XFTiIYlOvoxV5KHvKLRE5AqxFkLAizj/aKA0+0BGvccIJkL0E5J1Lx8hkPi/gEA0AfYAs4DGEFGgyK/gjVtBjwkGfPMFPsoaBlSekTQqN7/0VngXLUhzCqlYtQPwWHYqHam1ahG27soWVlaK+LsW/mMoIgnP1/NEVpRq9YuuWWts1U0OlKtZHXhlXtbso0f/yTOsbPQpRcsvMDlP+339dpwqRQ3eEClSciKser161gXV/BPYICBWli6CFMjT39GwhIAHlVJCdYABAPa16uXyjTFrTaRfydcMFtUsH4ys8fJ323xBQBTLCl5VDSRj1FwPwsGGatfhM5Mx5MpALhNW+9K6aNQ82CCuYYNAL6n5AlXsQtm6j3Bun9CHmBL4WwJAOBkQKIGB/AJdAtQJ05FMABbxcB7dZUVfbHd3kFrgecTrCdghPBmN3PZIzdlwrydNHeyxvFRVCNRRWF3DSSoKAXnF3RfpJdTA69Ib1SFJrV1YsxOw8VVFGOMfbk2VkqSVgGvsXqy8nbb5DiolNm+IUFZRTsnrHtFJeDEAPfOIEonTGr9I+3mXYAtptdxi7Ux2DiIMwtgTCu/6zZmbpVtv8muCvAqn7DEHUONDA32zb8kKi3MlWsnGgL8/HzqsjhpuH442mRSCpXKkg7jTpUfQADWlgyVuA9yeSRT5ykR8PoHAEC/AQKOxEGB4RJo+hWAKzXJCmAlW0sqit1OGlba3DHkZHoWksMw9FL9lnWrGO3NEtjNUuSXrYKgG9ZZ7pFmqGdf5LOgrQS9PEi7QFJ4Ij++Xr4D+trOAjRCBefuz7NsUFd2eshljUtmnVSvOqzX2eE5ofx5wpwgVu50BrR8Hbyf9SDDD+O0fxdBHyaslhFhZaO9mryocOUH6MFA1Va8AfJL/pWDSe6ZYRqwVu5CDHDAerSWkQE+9EtWXQ6YJ1B029JF2rnyCY4SYQGzyW1uKLHYV23sujHxRplCOMOFZGBPnYIHLBILk0aVasf7RLPhCdKBOOvfB0JgbRE/fuJ85WSYumlh3MAVRWJSHkYBLBKLqsGP4r6T4FQTxWLFQAmqxT6b+iXh5yKu0a+e8Qkt8IW5uaY2v4Td4gEEFsvP9nwaDqtVXA0gEgSDXxE4O9ZR+8i5y3Mc2FhXz50E8lfXUFhhAwweC5M9005k5nCvOBY0EIj6Wgt02WZDBrG7h9r6C3Pmr85FskInNZM71BIMHoujja5ohq7cKp4GEAnEhq1rWckryDgwUgFXLNJSmOskm+T3WhHmn3UABB6Lq+fuyuykSzcLV8cNP9gfqR3RePjDlo8OdWwIc+UyFdLsFegIzY8AJB6Lqh2XbVbeaVvDKoArMX7+6UudVgF7Xw+pL7hDOI1RlEXfI25LIRUAFB4LKM94DQNQUKbWdBOAjcCKO3GJfTdOfE9q2az+pKmp/zl9fjln08jjy5cORujptQAMMndh+yHYYucMFPzJpxGQHRJb/+afhtAy/l+tghrmaPNzU2v9Y/0YZQ0Qj2c+OP/l5gfhwywAOvfMA+wOkB0lLmZ4ed31BHNq/wAAyKpgb3AAKJABiqwL3NLtaGdghyPGlhl43WFghY3x6xJU2iKYca6aGjjbziqK1F5anWiEiCaSUX0kPp+LEqdjdHplqyFtXvZ+pkeHGKcPH/57ZFD6p2tZFY9JUYFa/rHfgseuxyYfvD3dMrLOxNmHaRk/2VWRi9rFQ1DUkoE0hxvTPP3bB1dDR5BwTeX2IKHdjyEBprYwEuBeKSUmuM3LlWWYVSA4DP/jYWjueEEDlnsoe3EJQctH3U+aCnKAiZ0Y49mmUMrUVCIDDbLWr6gVU0sqEB4OAKy1YwBgeXJ+OQaQAB6XVBVdB9nkqOm9Tm2Cvb+qIkFJfKkBAMBRAAocCSQwWWH5MvJSIhiAHcnA9lX+nzrWDLRD/b1w6JTABGAOQPqTdEQqH1CDo6OeTP3/TF1aaSsR6aJajyFAdMI/GYupGAaT8fWmIrRJUF79fODMNsMyjJpczhL7x5fbG0xmKEGyW76UwISnRxhKGJkGkC2Diir68rEaTFC/qdUUAHMnJoIpBtkE/Po9T0Iq4/CKtlCuW1TRtJfcXm1e4XaFkdcAbyc5QWGIxw28zgjFzFgYWnkG89mwn7sAB4FTN0qu5YdFqE2P9oEIfR80o6EDFpfkLLlZ0+hFfHiwfu8pvR7Llkce91s90O+CreGo4aHBcIAVHHsAdI5n8Lr8gIAAW6ZYqxsxK6t1Rp4+n218Rh4GcuLt0xq11q78xz2xQrz19bpQaWjMegkYU1PXqwpVluXC/QiFVH/1y9Bbg44io5VTzJ/poBaVlLx3Q7Bh5rextJSp04NpH/QLu7C+kMSdf//KFAgy+zJSyArEGSAZZ9fIxg13dDBW5NSzGhrmMPH8SMNKCQ9C3y4IXpoK9Zt+GgEJ8G4A2sC3zcvJR42AvPhiLo3WNJ1fBjzWO0BCfncBYKyPJl+qJtJ5Ow2sdhi55Fz/pg82tyQuwGwPJBKLhi1PKYckOdRPD5BBXL++D3US56fHitwkAtogoZXXr9h7fqJ+AEyl5hscFkua3eykqIQOXV/4VMKC2JYrU81/4JCOfs3ZekOOxF8OzDhzx0dUgDUFCvwRyyV7JkMldLJTdoBIIEbtqmKCNHiX/J9kqHZmlLSU8Gh/PMMg+11RAAQKS5qBqRkhXc45+SNBqsDo3iQp2hEkv+1ClN81B5lN53qSVPNDSAU1PA49AVRGBq/PekwXZBDcDa6UPdir9Ds+EmxnRWkd/pg52Zf691UCJVUFJBI91R6AGHD4faHghlu//KxrDNM0/wUJ8RUtYinY2t5wvA7glVHa6gQcEv3ZTh3Exq0nyhmkEvD+XpwGbTW0k6ZuUxtaYl4N2pq5vO2cAiwatWxHZuaR7aZvJUrPp69/9jy5bXNNoboWI5e7XXVcc1m/HqXzoFprSV18T0dT/QY0Fr2Ckb3ala7Qsl/UgLew/QDN67Ojoq8XBXpsA1b7BOBBTnLa5V2Q53j8Kj22m+q2a00ENndxj3FwCbu+cCG8q2jQaF2nBQ8YNec2aip3MtHVvvL+qopvbT6G7o1xqn09eR9BlUiWnGtJGtcc4OnIq8xl9blcrvlXvwTfDwAADYZ4wARMkqUxQVDqjJWsWFEMLay1LMJyuYyHVZMPrzZlW1tVnb1u31rVlSYCHb93xUIBDM0YJ1Ef2JZt86v53QPpE2W1n1TlixFW39DvcYy3KdEBzeI784+xSGFSbI9IXTkziDXJ6E60JijLuwXajEUAANyX95FNj0ZVaFIOxZKpaQLydjvvxBhFwLTITIdbw3q2sBYA7+qVbC03N1wg8T79/OFdcicARR4R1ZgcM1BbdWe/piwyUCufyn4eBQG2X0wWa6s+AJyg91TiWKBoAF63tCxThq8SO9WiJ3ji/QcAwJ4DeGJH4gNIsNPQ9QN7A0A/AGKeWrKPJJ2UJQkHLgC0gQkmsNeF2SxS+mXwGICRZbFxNFacaOwCB1iZlwWj5HK9KCGeFrwZi5Xz1Z7CMoSISxApGreXRmsc+XdL28HZwtrpOVpjps/asOtljcQGJ/XXxroyAS0dRcHMSD2csp7QcUUbgAQkf3moaj0MUQ2dqzMWwsyE2wzH/96szs0wph+gWhmf+UMYWf9K4lnC+WlxG4It+Q2lRu7oCAAA6vdN1U8enLzf7KvWUbiAXfYPDx7pccBYfTmFHG6d/bBIMi+2iCAAtrbMBfWiBegr40nT+8bx4m2qaz0bfvXfAy8AOOChRhcMjoEAS4A0b2oAsCRTzPUMGDfjhI3UP86T2Bzuzv/0ykOd9ZSiyWLCbVSbBVodXa9TPLh7kC81diVlf5OOmV3dFBX6WvaaR7fbfDVvL2ldZ28CqgoA+O0vAwrVpJI5MnOfh1Ytb8mlKOAfFLkNFy/c7+D5FoxNCpt0ZIxK1NhMuQK9ACaBTIgosUoTWRLGO4b1UnAPRRUVlIyrxwB49odDSMEwGekDCL1F6hWNU2pfF/q6DAwoxHM1a/kI4KamobayM9DK2L4gM0crXqZkYtKDXdgEG/wVd2SPIyxz45+ahU6M4aV3g3O9jXl9rysdRPxwGlKML+aIc642JlECBBp3VAPSkRNZ1lnjExAJxMHtWSJKOS5390+xydL6MM303naJcQxqO/xGAEQaPcFwpC6XLA8fNyDIcPhgi7AKA4bayZ7N9c8V0v08xal8SSvfugo0DA7LdWMX1lDxB9+cOkADhh+vr2CKpSfr9q7iNi+n1OlZV2tMnFAk0++AfWAAJBILs5JtmKKQ9dXVjDOAkfxuGXKUKavoXzJrYO+LsTJkS33/Jw/V96oF3xLkEXd3Gza7y7LT4uURwAXQ+0AkiewaNZa19zyyYofD/SgS+fl3ZnYULgtWI6iyo9N6wDx/BOhgOfcHVmQ70TKZbCc0Yz1acFKFa7+do8Zf7i3T3o0V+NHANQAcFosQOyRRlVxo7b58gGywEOzsOeuKE2nWAPL0odfGQrz5GmRuX7oTTxXb64/9wxOLmmXn4gLsLXcwu6dRLSKU9YVQrjLAQgzZ0XgiuNxzFdt4IjfsfG/dRYmMVxqiEk7tHuP1TUpu/tfNSBirAHrXzJB4k1G9c/Tb1Xvg5Olj0v0AAKSEecAO0FMaQIbVTxNJAFIhaQAqyAimOB/lPIfMXtb55MwcOmtlGLWab/OXUmYlY4wxxhgjMR5XW6BoWdpqvsnGkRnI1iJ4Od/7VbLa1GO+f489HOGh6RgjAG114VrIXdjUxjiaPKP+ZBsF0rn19AG5/LMfb7VMfvBhvIddSaamZBR58oR586zh8O5y/DjHkA/zFD8/E8CA6J/xBlhc7evFRZCBxqVhuZEMctEnjMl4SoZ49kJP8eWq4HN2wEP3NjYekcICNhp6q/MS0UDYZtpVi0m2fQEA2rzcBzT4jQ4eyESKTm9rxNXSdWl7TgnOifgbGg0G8f1LQwCIcgdIAOhxajNUQTColj7RAfY9QQHhYeyk4fdbLNniXvPbUzTxRB/y3sjJa249KbyvkKxpN+ijlnyam4SkANYDysLR71Xl5E75Un2TYVZXyihqVWY/bbXaPn0+e3nYAAKBvgyysorSl3UXDoeZAAHvmAdyhJeEhf60QcmeNon51LWEJwCYPoOZCVpZpMDNAw9arQD40gacaRFa40iUBLnFDr7mp1pNQ4/nGbYs+95fHRQs9R4BuqlWSYrUCgV4xb7OX3ANgNdME09nZ1MAAAC+DAAAAAAA2V1ROzUAAABuYZ9HMOcpKSwsKSgyNDXu8PUoKS0sLCwrNTU27+fmLS4sKi0tMjc5+O3/AyosLSwrLCs0NjbXzAR9633aOl2sKmUpzT8AAE2CAy6BqRcMMMA3BgBLtBKWpMCBqw0YBKEHjzp4/XnqGd1SYbdbbqY2smTJBMZRw9Smga6Faj3pRWPruX1Co2xsW3YTsza97TlAqzP6snrogezENaLEQr5b9armpfttW6v4j8NLG97dxdx0+di7J/cJkov/kRkV5ckYafrba0ZbupnA85e9Cgn0c+8RAFcmh0knZ+7SKL4e1h4QibBW9zq3df5KujgwLEDBomRLhAbjA4PYFLPc7UvYnJ+3n372hAATwH8nb0K+07DJfhRcM7yyX9bZD0QmCzu5ctjuwqDVxOcAEQlGH3zCTZETdN/27SBIERc6OTie0uu21Z0AFBpLmzaNm6oI4TrHVFwBgjQQFliEXnbn3rpdfrJ4vEjJqEOC3BzczQccJou6dhU3tVxEqM49xVCAiEZMc3lkik6ifoyMnrfjQvDwPCEPBJrLp9IlABQii2Yj0lFVREMJU784AnRQQTVg4qxIGYVtRexzw2z4prpRsg3rGSsR3s1JRCILqzSFT1y9rF8+ngARybnILFRKUhq8M/4SU108MIxOSqL7QtwewgMMHks6GeqUCXXkevlvw2IaAd32a2knrl1o1JUMiD7H5aXtjSwx9PsCNCo9iwFpsfD3sF3xJIBKnhrFlKRSeckFSy4kPkLYAxLf3E5ME/JLUxiJTEX+UlB16wAUHgvKPHy4aqHU+6eboJw3TJ4NV9J0+++RrKfFYrEI0h48WAQasOB45A3XndR5fLVJ7C4LBEpLfJ4/9l6zguVnW6OkoaNbqvHMOLCzqdtf7NSQ6b+BlAprUwQRoDg7TMQ/Qa5IfdsMOgF61xyk5LWZq71WD9lV8SfxfzHfZdiUPUxKpedKAJgFYIUdMmB1Vb0M/BCRsKEQK6b4/iSbP810Z/j58zi+87ZTBnYnmyqV6r260qVu71RjWYB21hFoQrvwLPNIplcLprvW/KZLNW/58fQ/694EkGau5l+bdfP6pvnWfLmM/NsnLgIYyV8BfFSkTi8awke9DKIlQE2De4kltXPF+/wZE1DILWtfr5fjE4JupJTrDgUaALXWrLf4CsC0YOnWcrdcnCCZznJxUboaztBaL1B/QIQCq7s609yndJtWUwfXPz8/KxqEH8ocXt3Jpo0+ACgAvudUbV30tYaqXlzULbnuP0sANFsDAByBl2C5DQZiIKgSGPiNh0AgaaxiIKeZe8vL1mNvGdLwc8gIrCkAQKsvX8y0IDh1q/fFgsPb7QqldyxZHFqDlc2PZM8SFU0+XpeeDbnXcusSEXFHrXnnT54khwJW+0E6jLcSZbBLfk+cKtBFpsnz9WTlFF+iHLQGpUoH3/y7rbxqC4ZB6KM3vQbSYy45f9Hz3Eq5CGAM1WzWti9iFRSE6fnk+qBWDpUk2DhFreEJLmzshkWtWkcBcH3D81E7dqsOBJXZtT6io24Kq4CXPqDmnqDEFxzfb7bmMCwA9udUCD30lPJBlhBO3R8AwPVmAWhHHQTo+hWwD2AgWFJMgzGgwPjWMskUe3IwKELoJDLm8CV2cTaaWCVRTvN9JtQR16YIMm/yN9c7dMBrOJ1UaikA/zCVP9JFKVmPj2pvl5zup+sXz9yUxdHvJ9v/f7qXN+0mS17FJbvt76zbVufRh6UWdrv0ImReVyp40wuo5Hs4t57FbQIAIh9t2bZv5KkbIwQQBpG5yORz7gdOb9fnYBHWPAH3SN4hB4r4SyUaoLB+rbOB5KzFmhlYrB4XYPkeyuCyJePH4zB3asQtulsa0GexcOGGgKjxVJuU/WqaXZG6nRo8Kn3GgxTJH7VCvOwEQRJ6jCsvSpb+/gaaif4MZXeN2+4TS3OHj60ABCZLiOc1xfYP3XTfVIigfLNedQ2mbCqSl40vtCMABdE8dLPiK0a9GRbMJXeQADYe/3Sdj5ddgLhQDBtIAWO9LqVonafZVGhz0o8btUbfwpcUjqZfHgDUIXcwz5ERt4DRsW4tdKMzg9doTWZorGRJWta45kszrXfVpPeLUlgsm61LAEQeKabVwW0P0vf2I5UgDpqkxtSILUtFlpF18d68RJEB0dSXDPi0JkIViVUAVDZR6VE3P26x/t1XbIMGTfDy6IyIpZNNu4e255eTJcF7CW3oCMmfKfTb3AA8InXGoyc/MyW7W78QIA6ahI+BKY0vGesSqk7v6qKSTdR2hVX91vZdUSfp7DELTII55LS/ANdmtyY7wESG8Sqbo4slT4zzyazk9p5Ks+lKi1Xh9MNPqyN2WDJl3jrJVgn8LYtKE9JJ8UMboyuQnE+WoCxvXjthvbFkT5dHbJancw/aIfu3L2EAau0c5opeE2uk9RMWARRKiz32T5uLSyzcelVEATq9YxbTsFDMpCw5z57Ni2eDT84rqVMm63QslKOLBFgDPlLxSqIMANoHzUq0cW4eCFzcZenbLuj73rysmI0l1bZ0PTMAHGAmYIPNgTRQkMjALYCEySfaMJDe6y13bcJEBrZbZxYNnc1c5qnprInjHVQ2zagY44z9ptYaArp3LN9SgDFGaL+6Uq08+sJ8vt+bWmug0SfJ+zOHj/575cImlSQxmsb09NdXly9mTycj0LgM5BdAe72mXBckrkQaOAD+np5ohKaVWyHCEqCbl7+BcQCtCdqOG9wAhzWt5y1bzrQaPRCb7nr1W/dmuOgKuZ88LsIUKTKk6JCcZxij7mRSoX76vK0GQ1LCGBN5joPEo2Oxxa1tWpsAnvgEWofefGRpoe1NSff+FALNU5UAADgCVAB7AT4vEAwa6cCtPAIBzzHJQBS/f+CSQD8i7k5NT20b90sAIIox66hJEYSThyupAPnnOzB/DKcAQ6TVHG2ZJEVbUlUZTQQ1vvw0RTNiQftw/f4N91aLSGWGf+Tcl0J0k7FpnKfaYE0DeHNoLLISowosIgKYK/T3/qaI/pPCc8LwqZV8Z4yAcVaL86sWAVQAsHTW/N0GAHlYkwVoAgBCcvECffNG+dUXdYlF2Ktqv1rkPNCBKzSsPSR9+n6MN9ROS25WCgbtjKeXS1iBadAGdvcMoBvmucJvQVy5LBtg+n79q7pmj83jvwPr+ZIGIB0JEnQLGAq9fDCnwSNJIzwKPG4+5LvP2Z7BOQ7bY2bXz3/fvzY6cUYBIYpr0FPOevVmxEOnTr2m0gQXMhVxGZ9aAYX1xqvfCcusYDSJEO+ujn99aDHOlswG9ViDM51uLvTMEjJq+gsXWHYHpR69FlkU+QBAprMSsfYw94UGaWymLvbe910Tha9NgQIE4Rc9GTTmXyvlBDc0T5kq9qlsSaQG79n4TUAZ9hDDJ5QE2nYx2wJUiqs7NSSkmRrVVCY32xdR7sldig0cLv0sKHZ9RQNFR22sIgJARAW/0+susKJfMpoHDXasN34arX45LA4sem7+8AMUMgthQFtPViz3N1tLamBGg+DBtF9LEsPwgano6DXp6UafSqfFh6/kWDCqlXkD9DGLoOeUXkm1UP/9F0oQF5rGs75PNbIcqVhi1YfU0acGsq7wT2OTyJLkoAYMLguUZzT/douFmnl5NEglxohKxhG4y04bYzzOLLJNBSecCQWfjKRpZx0MMn3QI3Z9DQMXersrowJA8A6FhywnjAcYt0fXVY+VbJtdqrcTOg/iINNzIAb8LQu45zm59EMC+9LLbcFEHFABf6rRkq5Ix2xvQhgwIr7zt+ru821xp8UzygbMQX0ylww++RPWFvutTclk6h3+WR1Vc2ftSzKZXCA/Fz7zGXyUIiKXKmuF01LQuc6DFPQtS4oTsH0Mhbj+jdZWVDik5afZ/+MHPEz9k6JTtd6QU6Dp30d2EsI5KvLtyW9VTwvxPu84lwX8UYsL7J+efgsDN/EtzVVEAQo6RsW1+bjtJ4y+XJyU4asHWBJjaz0t6VRSzNv0ZCmJJlqrl+ilJR1aF81L/trOqf1+WfriZj8/yabdHwDAxwsAOGrQA7AXwBjIgB3+gG1uYyAJwORClsjAVeE8gT7uwUtreNEQVEFZq9WqWgKqvbBmZgsAWV6/O/RqLSxN8EkTpFJUqt6byJGyUAgo90lyJk50/f5KtrfMs/lV9tdXxz/PvppFAABao63OBrLwUcLs/7QOOpB4yKpXjm9osaam3Q9AO0Q0cr0psIoS6AOBuTCXwYvgRARKTFBsgsppAw3aq99A9ThAyf79rF6JC9B0Q5qR1PTti9itVrFYPrdmOowX2UEWdhZFGcqdGxTWVDpVF7iuLnf445BbpbmHg7cOAP4X5ZmOOdf4SNKDl3bKnn8BAAAAdiQ4BQCwB0CUwAw00gw2LQ06kkysYSAiAVYFer8EIEgLmz+dWYQCYstpYwEg0QDETh84C1hWgS7RtxCVgnBQYmp57FMP3ElDBZK03Pf7qTnXN9rgfLSjBmuLKxdbhXyLNi0uQsMc31CL8IkIoolMfGA9BSn7V2YVzQqjLwOpfUgGwP2olG7p8OdVw6A1biiGhiF/0r/6ARkQ8QKMIAHI5KttJuy51ua+bABOnpL7luERWGIAelHVMCUMDXej1CsHqzNS5SUF1ad9CA1h+lSDvR3y/OuYqwMCALYntZDf5fOTfjVhCdFf7wYaQP0mlzcceRzH9xieL2sA0uk1MAxMewH9scABgCcvDZfoggFSox0Dpw2avrf/gU+jx43hg6I/PW0++crLaBgpEkLacwQZ546X13QKCOHKtg3tvVchkg0ORNFCas4ehnrKEGBqqlRgLkF3oqM2AZaYHb6z/7w50bDkkAuvbryaatfzWGqlEQBxj46/maSgDHHFZXM2YAioL8+Xy61PK/WY8ay5477WUvCSsOVLHIAvS6Ak4Xn+oXu4Xfyl55bgxu52aozheD/pDBuRa2ypPu9BXoBPQkHbViJMlycQynPsLefOtrtMrSXcOaJMIe516FsEABQyC2WA9L8TarK1lQHEQVNRP9xIHE2/eWSpnL+jYNduxzWswuJxfCtWEwQyC3gQpauRXC9bq10D4qDjIJnmrixuy85egxn7hi6xoS3Vsk14+yTxStcS7DULQTDt/8bAFaal/65SiQRx0AWs3R+xcQgw2pst9mWa8nLP2RbzbR/J4rYGFDILsec9/aNjUqnr1rYVJj3cwHQiT3Nl1bLRHoR1QliOZ8yC2Ie6ZfxhhAUcMn3Sw7co/QMH/ZvPKEBEMDLSmJmSxfNRLl1N0jJh5D3Tf3io7VSzGxcAJDY9ykDzpRcJLF7eKj8/oCFigPMpoY8U3g6FEsRiLFuzTmXZNdwSDJqUCjn8MYulZwwZ+0OCer9X5ZYAjABNT1a5UrQnu3mkGCTWVVatEEX1EF+abDMBBEK9LgjbaYgyN/fCb21bhU5vUPT8bbOdccmQlkjISuT4oiFgNQ2j6jWmQLlTrK1x4IJmAfQ1i8oFkVTzR4e4wI59RgEqFXEyyyseOrn4q9wNd7F8kFl9f755gcvx9mNTBka0f/OHGB8SBU9nZ1MAAMAADQAAAAAA2V1ROzYAAADmWv4TFTn/Afb0/P8B/ffz+vX8+Pz/Bef6+ARK/UWJHqMzTLH8s8UNC510CbJBScWLf5/V254tFb9YiWC1cVzKCLUdL7h2Nm0hPirjpKf0jScCANonzWiiZ2eeIIp9co9KtT2Rk+87oqhH3XLevzX2mZAAcIxgJmABy5Ng6I1AMLf6q51IAlKo5gG0FAO/0ZP8k9nRwWiXueBPj6ceGx4H+ntzc6WulK1MqeJnWzZvaq0AbuZcOpU4TVRj1DOI0auVy8G8B2ZidIXWVtkXly79b7fbv79GYozx5X//fbHtXlJj9BhjVKKC+5wZjSF7unbBsiCItgZ0ZsCCce0/kLolOgD0O638Dsjbe2XavQGtNWo2C23mbjtPnh0M3oNpKikrqOnDkBpAsMRqrAW5CTFD9AZBZDOHRADFR6ZXbgMw6vl0G6xn96sJgOeYR08rzLZAmgC+GKVGlrYf5YNEomvVitP+8UpYnuoAAPjgAsAIALAX4GsDA9h2bA2Q4VbrExeQyFaagYbbyI6MMrzdN6CtUZTxcAoAQJVMexlDLJUAaDxiaimscgQUY5YCQKhs2/A5Kyw1UlICK8tQOeuv2PQQ0z+oS3XrVIVI5+KK4ISt67PXBh+KG94oHeFwK32wyhC63i7SBmOxN22wgy3ogLP/SxBGf0oMwaP6cL9LCuh0TqX7QYln8gagLqd7AGBeCwUAsIA0i7NNd2NxRdU4AQN44F50DtOtpRmbZPwRaf5iGyxvuf09GqNY8eMFhWGHidfcnYT8FQlGGwAeSZVJ17T+mR9JEbVblbVfAAAAgA+eBKAMWNDJHgDnJRAMhA0gGB8INCYnNAMAUA69fwCAFaW2r4WASgtYV96bAqBXBNbKL7MCAM+qQGxplhGSSEULLuM6Pjdtjl7vxigAZSDE5DJnMVaB9drnPyyTlHxNGgvVObFNXD9nIruDlTO5BoIusmoDKS8Be9ljgf4EwzBrfrRAjY57KvKrT0DbANpII5rDNsJPsRuPkvWYADCDv8lXAYAAmb72KXPAgb7O88wp8K3mPOYhyQ2GcTIpnkhjaA2Sa1XSZv5ennFokFYytU/HrIatyOtCSLcmnOti6goA/jflmFv2/GlrE0n0boWivH8SwgK/JwUAwI4xeAEA7Anwu2xA6ABslpCdwfJtD6kmsAFoIgOvuiDfMJej1VL52mJkqQ9vAZBaxemPn7KtEChfus0AkfcEAJ5yLAVkImk5eLLWqiQFcSC2ZLi0caePA4Z4s9H3n956efGIndQSGdIHxNDVSnxdDVKl9SQQnCQCNgjkVFEAj8EbVxMN8aCyw5iArUeykFyP8sglvIhXR95KqOXmLF8emLQDVgIw6P+vNbElkMWwfRdXE4cbXsPzlYKZ5XhmEVo+GZKmNgyw9wFtBgB05RFFWIkp9Z9g2G2ZkuNAtWvmQ9jtSUwA3jclWEzWPvNVEFytr6D+AgAwANhRAR8AWOwJ8PsDGMCYyQDDIA0EBzQAwR3QsKBAAvC0wbh/AhDQMlKXVSg61GTXbluARvOIhe03EQEoZ11g+J5wIFkCVFZV2tvb09+n5XJYIKR+eiLNZmsQdweg6FLp61MScBX6CFnkDXMUSsTLtdGlvmVvEDgYSoGGcfa1S5Wz41aPSxXbj2dkTHD5dY9A0EswlisJi2kigl08zEgIadGDKXiFpTlXn1AzNjPZi/74aiTyYNBmkvcwSTI8JBC7QtgMfURuyj0J9RL7OAlEdhECHf4vVjGsMY+rFJ2D9/lXf5dou/tjeyhX/aC3Br5HJWCMPZ/2GtJa7Kd86i8AAADAjoHgBwAWD2AoAgAMABmAcwA2DIIBumCASc5QwEqArsDrnQIAJKbe5GKBACSzc1SUZMYCluxMKABvneLiQ5BEMQ6koP8JoAwz8Z4gFKbH2oXpQfO6YvmZtAIi4JytLZbGoygoXZoZx0hbVjc/Zm4101sFAMELfK4RI/XupVd0zMLBcf/2RHkqqbEPFa1Sh++oFSqHstwZMF6A1E7JJ73AIUEyWLAgSW7uKEa1VLkxajwMloWcvhRpgAYD+IB/y2Km+Zkotdp+ZURgpIbVZoAIBEkFACz+qQoMCgYHFk0sjDaUqmFfFq8DRQBeOIW6Vbs/7XNoXfCJBtB+AQAAAHbUwCihQWNPgO8IMAPDSQc8pAcUAMETsOlATlAgAVgVuJw2AADxi1OvUaURiNJfAADvFEDCEQKwI6gqwD/z7T0IqRbQcY3mv2fM+Ebsgnx/D74/NfzWpBgQgnq5UYpjgEMWp4E/Nr4tNAXcAEAg4hsxN6EjFiBcOCtv0/iuK0uh3Fd5rxlkWO9/7UaQUYdA9yFAJC0BTu3yb1WCEiMLYBEynR4uoDeoXGtvqhkkwN2I8hlA0uqULHbavtH2OBp1YKCvXGRDHPGHigYgvhDDxZAAiH8TwGCyOTE4e/JAKLRITv8FvicFtCRrz/hsEo5Xif33Wg389y4AAHZUwYQAoLEHwP9OwAA7JAMfE14TvAg4E+ABawoMsBtyLm+Tb3Bv9FWBOJ49AEDFGN7JHxGqI64/LIW1hwxA5SwLAIGCk293LQzj4AC4Cn729XVf7fULUZr/+iruTR6aLA383QMKuC1ABCAeEqsCsXcYhQp6gzRnCGA6ttcOlFMAYpjIU1JgbfbZoZDOE+gooKmV0pTS+ldXv+aGKXA6ksjTUYGx25Rd1nEWttYhgHdYVAAkvSnh/IjEVWz4sKs2VcDL/Z3doQwmfZcBew7sipE+2YxL/fESiSfizzUA3icl2Fjac4zPoQi+paL8VUQuEn8ngt//ZAKQdhTwAoDFHgDTqkAGrtDOUINuA5rgEWADyCsK5Ap7HtOdXiPY14PeKJDkIREAcFEEoGlNRYgZPYqUOtCGWglgORQgcpMHSLRZi4Pi8oglKTxxJcjKGJ+++v+/d82+M1XLSDlgM7BeRMaKigKrcuhhcW7NoNASoKgqIAM1OkUwFZ3Q/EoK3W71c838FLL9ayBradQYAEGUfP67amIcMN7hA/WvCiRwWOrGmTkD+SOlQBNmS/R/Tg/DwODy7/wTLAmOT2sCYF8ywpWRGLy9mwkMAyn68SHxgTNs4GTZVWsJAr4HRWIqs7nKx5awqsgvAAADgCx8BsBiL8A/VwID/Jj0PMA1GEChCe6ANOcosAPAKodtSgJAsOYhkhQEwC0lgEoI6Cg92nQGwAJHaUr23syLmN10YajLe4OiytJRyhBpq8fE+s5BM7e4gACUUOfeUcgJ0DqAA6vqtMRvFrnae32377RpA+6drSLAiiDQe5DfuadfvaZFDKB/CATdlJaRhIYgIVdvoiV8ZNf8Oq6t/VdY2rBJR9R+JUDUloEEAFVDnhOCag6+HKpANOenmgb/kx02UgltxnCU0lIp474kq/+MTsZMnjc7xO0lopGQdjfyvTGQ7xc8HhiVbKypprYOGYckwf61kPiYFAAAO4A/AwD6HQBABqaQngc4MIDGBiC1AThNgTQdap3OmgqYjn6Saovw5TkACKr1yXZGXQBlGTohsKIlxFrEQwqApwCqFEmUypHNhwYNJ4dbX4Y5ALXgUdA2NuPKq/QUTZVGb6BIGXhsKBSABy2F9wGnVg/HhhRkgVYaneewACcAeyGQkYWJGi8ZnEMpQgiEJIqXmFFpDCnqdB+yt3qtULBvt8W5Ns+JMhm0IdJS3gF2HgAYoBQC3tC+S8JI4kPgrzcJpUUDJB1v01f71rgVwBBe9J6OkQ1hDMqSM/cMydsjsg86FK8zQ5gAfvck2dJmp7SP28BRKw6/AAAAAFmeA6CxB8DdKgEysNvp6QFwCQMobACSADYd8AQD9QA8bTBPCQBoMLaQEEFByShOCTAikHH6yWmlBACgSfFJNrZhfskbNOnLM3tCCZZIUUIg9cmB9bBV7IK7KpQG55kJAKCMgNbPBvvbwaEjCLTSJhfHXgqBUnaqO2v61fty6y6L7LND0hD+b6CKNCGHkQQ64bS5/0MyyZlG3IGnoBxsiPO2jcap6ok9gDGoPcwXDSlsaVhCUk1y/SaxGEYAkPHwaKPN2x3b9g9k1rlowPJbBeWWxS/taxzIPmDPfFTpUqqxQn/toQF+50R0L9Oe0sdmYavM/lIAXGcHAMAOoAwAYA+A/6wABlgjcCTgwAaJDUDSBJwJ8KBVFJiNp42Dm+muUrnbSy7g5hoAQK2Tdwd6xV6oEF/5kkBSQgCEgSTUAoA6sEwNBIR6l0Vo1f67fzudshpFGjsgej6qKEPxdiH/x31L0uxRtTAA1E5xmgtQVGwugWs5iWOGF9ToDqVKJNq4QoPZHsoMXXJ1C3VCb00x01+YDDC+EYaSGlyk8xc2+yJJKknKLCzZNa+ZqGHIv2FiBiJvpOakPcr8R2XSoGtODBHbU6Y5DYwKQCz5gGEMrhk2B1EeT8ElXZFU5mqUsT29FQC+1wRsj5nBxzZxZMVp/yTMUsNODACAHRUwBcCi3wEADNDHZADOAVwmMgALoJBKG80UpnjpL4h/hO14VPGXr1M31wKAKhKvDkFljII242hQUAdZEVwBAKyfN8BQkKZx2ci0W/Uln3zA8HKFWHhoVmRTWhOX4NJRmoSmjx27pbm6QnO6lHi9FyoUCNDFS/Q8qpo/dWonWEY1YLB6I0iFiNTVLqdWtxUBoNTyqWF5LZMtIV3jU9XifEM7Lvo6thH9hB4BlSX9zgSqjVcoBt9TtZ6oGeKwLZdFLYPLOq1Me+Ge2f6IJcYeJ2pkvgsnXvZERfoUFVWheFUoLQb0vk0Xc2oNgTsgAZ7HhHJp03TpY0g4suK0/5GJxN8xAAB2JLgBAPoV4E1VICg9ByBBGmjkJDrHFLg0RA+l8bW5BvEzuIKENZ0AwNqTdpkrVRRwZ3OgIKWFVchwCSATiK4sRWFWUgDuOxKMLYYNVHDtgE/vhqOLCq44qBrKre4OYe8DamBCShpjSIHzYJTvVzXUgxqMjgBoo95l/9Un5o6lddidkaVTfiT+TWkUCh0TJBzkLT1LykqSdzCKapA6v4LSaMsJd/+mgDRKoDfD8QOdsgAk91x+i02BkYx0QT1tzfrBbCOCdzfXpBk5V3I8rj6JCd63lGKOmSo9GjgQpXX/ubAkvqsDAGAH8A0A2APQ/1wJzOB3ZB5wLgASgkFhDkAqKUWBRXejPyb2Lxk3r0ybufB6CwBM5cazjN7oiCBI00gkgLcEUDcaCxBpqSSvc70RB1gUazMErfGrtJ+bGPN6E0fcpNAShvF8ib9tEdO1l5eUuGr4cXvyzmy4NgegRLQeES8EVzxQUL8o7S1ewzIghYwkJgGQm1RIFhHLjTU80dbCrBM5lDnzOWbL+SNv1X3nnPUhuSvthFj/xjK+o6EwUbKvAvOvI8PhDO6W3hdVK/WNyCf9FTJgAHoSlStqG0KFnrzD1br24qyWEQB+t8RsKc005ZEEHEty3f+uGSCqAQEAWZ4DAPodAMAAE5MjAA8kgUYuGKBzzBQb8t4f5BYLi3Gjy1wzS8y1AQC5vRTWgVJLUNcQAHwYAKyWcDBmU5pd/AjZDS1/aQXG5GYARKVqN53tq9QOKK5QLah8FI0uNVBSQk6hg+BrzSeDH+wqkEFUi++w6ChLdh0hWMDHsrk6wmUOEwhAXkdKysjq19DMKMVZv+3AmolvwGc/gCGhL4Usr0QdhhRf8rBUyMoFjfxbla0vYd8tWt5olmlAewcqgNCREuUJM2QrWZXhDYrHiMtNqU0VfjTZP7k7VLF/U+77vnWACU9nZ1MAAMBMDQAAAAAA2V1ROzcAAABCg/9hE+jl4ubj29bk1tnU2czS08vKy9Del6Ruac1U7aMpJDqKwvq1hMQ1WfL7jwwAhjpgD4C7VYBweh4AkMpJtVEwxc3quN5/3VvAFpl2XCCA7DGN8RpQvgeIT2Dm89LgUbQ4K4VSJylF2xtrpLVACP1uNjoq6oCWNPoPG90TynHypvZ2xKJha5B355AqCf0o4htPwe6rAquNGDuRsgsH5Z2pvyZJztD+IS6hDYBH2y3Z08bdagVyYJ+TCdQU2CToMzqxRK0vkIfmys3xdfwIqKqSbUO+oUhCRw6zY/qxyZ0Xk/agpEiHAzbFBPFWTFIVRXoNa3ZoA8YYf2iiYwYAHojUcSrtFO0zSLiWVnLvXw3w+wAAQD+KBAD2APjPCqCXbh4wee0nmimEvIZwVcOb8k3CA+oJ47gPAJgWANKXLAjFVUIshYMIvPVPCAgscs4tRzUQPZZjEj6rMwhkGtPkJaQbiv+rcpARYGooLnK579w9rZaTp/dqSUXwyVuPuWV5MNhCNk2XK8KvaPnopizAkhTiuwGDJLF1eA+FlrgQPB17Mwi42L8a5BkOEbLSBUtfjZp19EAoVuXvhMIyqsiI4xRdgn5atcf7bQQGGu+la/1mrZAUZODInajAPob4fhQFk8DTAb53pHKMOMJFwaxw9xdm6KQrAQCQqQL6PQCAcDoReVKbEFMo4+vPaJmZEnDF8CxSJy6nkwAQEx0dqnoPPikE4BUgP9mWJG3bVtdIWiFlB0IlAycXdkGzEVEgPE6wGBACMA8Qn8GD4fS6d/hVSaJsXzQ6SG9QxUNy0oV6nTufiYaKCAXboPXvWHIi7gnhVjmIyCWhX8GdpJI4+K2eDO3bnbqCmFFT6xBxJEarcANqQIyLf0kd73Att6K/IHIFje7Yx30dO0UJnL77sLeZc/fSA4l1kG7CDltfn6KJA3Xic2MEIAE+Z8R6LE0nPig4tsT7KqSAtRPDf/8QAMjyBQDQrwBvKoGqVCovVxSCIu9uvsmUuTX4W3orsjK0WxccwloZnThXpIFoXIJ4BUlIVRZFQFkHIPEhZT0oELPyiaQGpSvJVlINdN68F1p5cd5G8JpVr8/vONt1NuR3RlrlB0Pg+AHwYvxJ9xZ6fCGoHUMWjUw/URTIhBEXpJISZ04IN/RDUw6z6lEO8OGeniYKRGrufzR0g5Sc5nXJh5BgzEejoDY+HDQXvoRcIpfpMvhZX5SOw/h1XmpARnmpC5byHF1a2orbg5BerIrwAP5XjK6GItYI2pbE2x8aEs8AAgCyvAAAewJ8KoHyZgBSVuedYIr36rw9fjX+yRMnRiUtLQcIAOjkUkLiznqaeCJBibISVCar/Ai1IHZN4aOdRAW0VWiwbrwJDhthCRVUq/s9Hl7xv6YJkohOy7s2kjyAHfSbzmVIHPfOwXBUOhu+W4Zppcqrwj9TrafMsg3nH9bMtNQTMelBsZlmTcASNO/TMJxYe/S8M3sGEVQppj7RGnI5/i20EZEn5JJ5AM8RwphiCPZYpYZOvwg9vNXlbfflqwAWatvI18mXdgyDsg2pPM51fkisLTVmsbIScaXD/VJA4gn41x8DgFkdsBfg3wDhOJKWdSKYsXof8XP1+ADLdoI1TRbx8M0oodAEVKk4v01X+dyXRIKuMcTyIh7EA1d/PRQAEHbjvTOHuowToD0VKsKld8WTgctIiQ4PEofuuglzit6JNDa+lTiKaUMCuewtVRy6akLd9QMaIZJNcxm6WVFoCGSrUM5f2QbW3tIXTfn6JW95iG36WaE1ZypjVY5O0egl+KAJWDRJNR05cUidTIiSzJ2KOLW8vbdqXeOUDs2CxahgN/h7Dj1JzTMBvleMLkV05gIIf/vRTbIKAAAMAehXgFsBlD+Slp1jRRFx52dz09YsVjszrzUn9T4JAGnsK9AhBJYYUUcRB/E4zmOsSIhNf3ZlEkW2rYx549DLjONt5RNyVlUfJdTF7fr0j5nfDmbRpzaYY53LFkjoaclEn/7dI4OaWJiE7uxSN7OMCSCOSZOOFCi7OiYApFZfy24+fMBJUMWRl9FBxXMyEpSiV87VyrG/2uxIlzKU7eMaplCAu7x9/Fr3KTxp4YIlXN9HWnvbXeS0ivxfUR1QypDofDskAL5XlGJsY7EhCLic5e0fAwkBAIBMAvYEeC2AqhiKRstKMdjR+sxKVF9Dh6ir5oiBdTkVADyUCI0Wah2k1iE0eFDQsr4TrSEUFE9pH7MaFCV9uqzbGBq91y2x5jdrDQqaRg9w9D0cVkgiQJerctD0CU6x+70nXLhJLW8RT0F+lyKt00hU7+L5uSCrHcETB/TT6yBANhIpiypMj0dzIhLTh/UHSkOnComAisq4nDhDhKfOxbWCoedfsTXEQS+WP/TvTPiKHbV7WnkxeWvTt4x9eLJxQHF9L1HylD+wkQ10ZO6W2sR8AH5XlHJMdEEBuN+kAhJN8vdOBADSFUYYK+SiYCeY0TvjVvhmExMaLsx6FcPNd4f72AkBSSpn8IyflCgu60PXJYmAm/+IkzNHxcJvMoFcmnYBp42nextEhjYgGRtOgYrr367CvzOuz7BGpOBphsEDdVjSmO6K3PbWKRD1cgjfe1XPez3a11kbQOB8598ZEfUvoQ6FKinAk8BcsmkGG309vWVSxnY/3jaUA39W277MyrFzXUwKPWWtCOu1Co/33pbv/XsLlVvkQ0l6Zb1fSQ7vbbEb9cHXeQCeR/RxDCoggnT3Sy3b2GUCAGwAbZsmftROa2Z8ecDy+K79SbM7m112YqwoBwDZQA1UJaMbC9ro8nKtyaq2qlWyS43GiFL5A7VUrsKdN5YY6tq/tQqNbSkOHLbUbeoQtJvQ2ffzCZM8cjXlktuPWyboj9NQfNMTfjitFUNh+A8PCeWYVnREJbcxmOQhd8VJxVaIGdKsujW1nifiMOqlPtvsaPMQklU8VgXmuK6ZW9gVnujWtVaFJMjnqru9lEY5W3CSrWGO8KMeW8IR6/yFk2+CEtM4HGZH0/EAfleMqQcVAER7VzFR/f7VLwCAqio/0VpEWVFsPW1+YnPMnJkO1+SfkPfh63I4Z84USibmmoyrxu37eYYpNtemI7QvVYdlCu43uZfstZo3luDN+WA9vauWS1QryVwAx5vRZzg/Dr6bDtll9UU7XaNqj7AXlX3cc565UJk101ya8QwYlawQXpp5OY04UBV5gN30YyUXbRhPEuLMAJFxbvgcAVyKIAome/smlMUDo/8nkDHMxSKzZmSlUIX/GsvAdkmDHe0eSu9oytyXN7633ZtRoUVroQ5+V/RximiKrKAlYu+qTBb6XWcHAGmbxlZHZ0jFjFfmzppKTKfJmPS3+OvHoHd+dydiUG3SDi3KnszY+XOqj4u0KgirjwB6K/615NYoy6Jak4uIXE/SO/kg9/3CQ0M6hxt5Wk1h65vokk9lis1B9ft1VtPMQwaWeQp1tOeGWyN5KOfWkvSE3kSwbaKn5zNU41klxuPSXUQP5rWXhXS9sYuyQKmTal9GXN90Ws9L68Z9174F3U7SDZ3Hy7S4sIfEuDPhdCqnIctR4kpWpvpZ/6uBf5vJQEcdvwkAHlf0ZgolIGEW7K8MkNCNHQOAXn6s0ZAqxMyMm0js6mNvVzvhxPrDopWmq5fGoivrHSn3jEf63jiou6MsWWaUKTWluZnedChrZl6gP766g2vvqXF1XOCAttrTbOqbbDwDpj8Z8JXKmMeEcHq4p0bIOSy3OiG1aoQ5zRnI8XsdD0nRPe27lkR3uR9CJm/PSGnWlQpx3MlwbM0E9uuqDpK6vmOoPAsMIQHrpbGVnAml8pI7XKut9EHzQLJp1lWukF0pt3Flbs8wAwHwkSABvlaMckwLQQVYb1PBR26pAGlNY5XRWltmnO3/r19mrc+f3v38djmk2f+8YdUXSsq89cxHQw1H4Y5Nzv5D9gQanWDHmV258rKhHduCystiRNyJ1WGtzvYMtCE1XOKYbnL9wYMzdQcQc9hkfU2EyJ3OZqNGyf8yI+vEf6+a1ZGuauo6lwim2Mc4eZXh62gYxWAoIfkKtKjMNylIvfYwXLE6y8uGDObobvBhTWPDDv9EGEQUIxHtIoBOlFg2nUCmQDUNGNqHF/a2SnoGp3GTSdIECTQAPlfs45w8BBRg/aYAbCytAADVttXGKITWzDju2eltrP4/i1HxbvQt2Z80VUxvvc3W6ozislJxf9V+EQSa2kV5Qy65yIl0Es/jKG4ie0Vc6sAP6/6hpWUFXBLfzLd6pDrE6BsiDoU5dHDl2C+oTHS0y6Defd0NSaZ+VV8rN0rFmy4m4vg3eF20otAkGlLVu0+Acn0hK2xWTtSkLjKXdWbFL0rMA54FpHZZNIeF0vthVmuteytjZ10s0cTX8g1O/gkZIrs4FalMEti/1BplthLsRtMBEr5W7LWXKQwVYL7BRL/WFw6oJq1GK2almOL/vGfJJXXr5k3v9/8f+OfBwacDT159ZWVoYmm74rHiV6iWESqEVB5xfYyZj1lIcEZpsLp/viqaGT/2jBHfoCz8t85JdcposaqIl+xaol7oL5ar1+HFTknhNJnZwaCIjGm/iwbtKFUMes2NtxwtCMMar59Qm6QSyRs8TwvsKPu8nWxTc0pbiTV7cDZ+I0/Dx4iWW99v2awg2sn5/pl5kZX0Ufam9Hu5/6LCRUw55Yv+z9wE/lac+hRKAWC+SDcpBKi2qpzWimWm+Dno2DjezP8+OEfl4XbZ/uZqzB1fPP46sWzJJXNPe191qKcevY0FPZE4MOgGM9+E6Lk//4rDRBUFTEJvCn3PiHrY0SEzlu78Bu1TvlTUC+aUg/ZqWIaUCn1mFyJikF8nC4CbsWY6iHOcaWPTj4rGwF8aLcYRTYq5awxlldBaBoV6q+3j0JrJBNMbrhklknkJT0WothkDwUrISRGzfyzfvVZk1iNC7ORTo0jcET7nigstGAEwAT5GrGUOoaAAw9VJlymBsdqqqDQLpyjuHhz+DjevzF6sN/8Ptj2WbrfKyP9nly/z8lm/laad8bBZTcI2mMWUxqSwssCq+ScRz9imWwlC3j7b8VY2wtcts5JACeX6C83euIJrbSQdRYSJXrRu3Ja7RksaOLgt3vlBwQgkLAnDoBP1wGguEl2HOucZWGTKQxkLQTAQMlooz+Vy5tzaESKyoF7EAwuFXYx3jAymqEwLvbLnvF5B1CxsGHC4gh3kQV/7YQvXEwXzxZVd6mAD/mWc2pxyx2UA3HDIHCyAqrZazyihy1KkPvT70sQ3jh/ON3B0sO2/r75+9dbfH2c3eC45WR70SZ022ybdYh1c9CBQUodc7uqoRzaXJyRK0aZql3t5UFKGWx9cLT7G3sRutMBMsqNHmXQA7OKVsCIfvtf5hBT15qQ4ck7SfXgbrazlR/DtEwJj0ff+nXa9GZieWl1IMbmRcKovl0ocSJfp/CisG+dXEY3BM+wlwXe5MGCcXkahZo0/pKvtpjOD9x+YzlSjZP2gJj1aGZ+zGToJAE9nZ1MAAMCKDQAAAAAA2V1ROzgAAAA/L/0dL9HH1ScmMDI27uLvKzE4MyolKzA2Nvfm6SotLCorKzI5NzcpJzQyNikpKyo2Ne/oXkUca93oDJQD082ksUoBaKtiVmccV4iBnZ3dxbPvl7l3m/f3Jgd+P31w87+DwgG32qZqPz81f+FMjp2QecbWZ8UyZe42w7l9vfQ3WHE3ueOnSghECPIvxZpym2prkm934h6TB6qKr839YWTnVk1DA/8Gv//a//9nRsr2/qJsjQ1m9CMpUr32fwAAiF41VrFD9VansRsGKT3x32fKdzw6I0f3nqmn53u6p8tqHyivIg5D1EnArXp80uNUIroGEZM7DgjpJDfTw1yU//oPWmH6DgBeRozUh5ZAOhyS0tUnUgJkV0yL5ZDSmnCKNKn+2syRsFn/LrOu8lr/u7HeulUTMjyQONfyKuUQdlg7WhdAk139vF/akgu1FMdVzDKQ9MoktJtm/z2/2Xfmf+F2xDvuGUEnYImb7ln//g8YwYCBftQ/GgxxUmBwLw+7mhmE9pt93fFXNiw7cXeRhr9E468LkmAMb93q7eJ1S8LKHGNfWnN4ZXfUhrZes7Re6Tn6RwaSBPj/lM3CUSIoQXU9PuREwHp4CBPUlwgA1lWEIia1ZIEBifmN6qzrGHVt7g0mYKwKJ9bXTjimaNgO+Kwy/EZHVobUcI9+Lc31bN6scDgxFc6mVofCZu1OnbKl4SiG4d2T5YjEK8yz4T/fjkef4SOMteTkYz8uytgextCK/HORqGTonvduMq8p0vgjZAo2zUjNxf5cJu7zhSMyczOMYB/8sBmdn82fuAdm4G77cUF5Bl2R3jf3Rff2Seu9lGNGOPpXtv1HIeK9Qnkixi39T5dEm7Kbu2oXzIJwvMxt/I8uNAHUIectnINljtQRCdBNpP2gkVRA1jFvnGpiQZAAzv5mRoK1P/S4JIqwn+8kB2Ekem+bMtsGxP2gA0bWiqHdaqoLYAQDQaTRs7as9erNnuBsjsJXK3Xehw5m7wHEBXEAXToHf0/FFwVQzq/FIdFP6nrYw3zy/gj0JWfFNDQJxpsXy3JVWEqs3Y8P0gGs/XwYWP3hdIXw/T4BZJQfvxPZk3GnvcUxC74+IsBx3um8nJji4tgmRrP36t+jApBQTMz9fAr70iCIlPWF63zrnQCLXnFhBC/DrEErkr7c2E8S314niLvn28T052eMdnqzgekn9ybZALpG5LDfxAylfnq9On1O+RD3VxbPHHEbatHr+aQB4IkBWMnKAsAwDCVIgvZIKKImaqMouKrscv5HJ9MrnJmk4380hyb9SaafuySyrdLVg23i3UPORUrK/JQEhZ5Vd1lBVO4yCJwEaK3NfzH/z9uL/zInrUmt137Z4Poewl40IlGQpi1LR0TG9XHT2HFYDUOyaxwnt3jIqltAmFoz7/fjnwBi1Jub8OL6y+GqB4IvFhfa6UgZLcLhBu6LWwPkEBeb+zpPvTlm/+rVgJA9CZ6hk6Q/gQBpwdoye9pWhGGz4CL3bJxHpVDblffS045sMRPeR9QgAf6CWpEc3yNrIKW6ALRMFWxWGTAOQb7RTrPWCtmbgUsX7zY8nAiuW9jI64V5mRpsiJlGhwy3Zhi/QuHC0DXCfXe8xjExqvlyKo29U9x+saXJLuFpXqL7CM9pw3lDL2w6k5v8Lr6kkDQnjHDuD3qXxpMBIRvDuj+3/0t5FL3veNS2g/M8aUtTv/C5nOPori96tJtRBL1/oi349DiZBauhT43oQbtydX52yY4QG+ndZMVswJ3INPkHJxYzK2VlZDezcpytwBZiQ7FBzFZgF8QWYkOxoUxzFbKtwFYUIyYEdkeEuCCifbYq9xyT4HsTXuoY+nphN/WZBsgAU5oBkyA/r0NaaK3oVEyr8Wc2rr1tytlli9z/t+194GXamt5coZBt919UOb1ioeGmWbvhQQJJQjLflajUQPzhLeoTD2/boCs7yEluuMYGpgvrpPFJBn+tsjA6UZuzroOOucYA9OiWnz24ueXCZV1XVoqQfHRBWoiOOtanynAymqY/6fchMgIZj5+iQtTSpLo9azozm8pUJKdSzDvq78nXx0d/uQaz+CuhtRwgH1KEpvExRqxopGl0Nt0cIbSMLsrsgoaQj/ZePF+SL6WtPmbIjyImEgD88eggVclNLnOD5XcjgTH800+y0GnHaLTMVNl7rIIF/dFUpMMCTOjt+QsA5PmAtUM6u8rZX286AXo5H6Y5PEpz3yW7okkdJfr+B+ha5XtrlET/eecw/UrXKo5dABTqQGBDqaHLdQSvMw1AudwomDZLjthgbcknWuO1qbByS4Kii0YonMKyOjxa6atXr0aa/j79fWww5PmEplF8zTl6Iq5RAxC1WO52W6/v5UrsB7vo9OsQ/EDn+kQMv1+XH01FfAkvjwgQMmcB5PU8A5ex9ooTI3/pAKnxboNL9Lr0BaNqL5UOilK2VkvJCvErj6LnyLwW7PG0CLAGBbetKAUYwfSLyRcpcaheBN8ZOb15MdFHBIW+xO56AOzttGBAejeI6AsJXIprvv3AUGRSslXDk9L+Kbgpyc0ESVL7O7osfJnAIAA0+qQFgiLwKjPOgE3Xcjj/LJFTDx8f9RWVeBwPda4r+ABFrXo0QagkfDpakS/qNADEAUuxkcG1UylTIbyrSgCY1WCQ827HnHHhp3U1WYs+fQ1t7vPre4yrqkb81F0sUb2tPibQdQAEEj3KOJRGxvQNVPbWVtCxvJskQ4ZlI4U6nl6TTcheTrhp9NHy1zRXUssRk2mxGo1fz2F51QD6R4RCDBMQD/kRnI8Si8T/Vb9ut26RYtP5iwaAl8hCAsANX3oAO89vAtKgQEoEA2gRhbBYvZTv2Zz+8n6qZzW/av62PxepfdqPUdwz7ug8jFMqKZWSynR1dhkbENhahQMms5vknQfOAcQY49/pafH7X6ZH1Ynq+/RkMo5RXRsTWmGf7mu/dRg61y/eu2E3GDSXZqGyJdkdwH5+JgNAyDVPrXVFbBqwWmO3c2N1UVia8apkj9KhQKHXM4OkkG1jFV7QzPNa1su08G5DddW79gTPd1+T8j8uTovPMMZAo3/bu66XYPmZYZ+O3m+KiZ9DUoummD4BJycSnjj0wAC6gw4DvqcmABgXQD8CAKZUBvpAMnCrjKecMEppBZOXegv7LNfK2JnRrbo8/2nJNL6yy2R6PrkEeZYMWVDlLFEZIssNK1aQ02np/mw1/XMGpwsxG5A0u22WUVZjfhAd3Gm9bSIZWhBbyTsB/XVKmrYb2Gbt2OQbmvs6Q7j7NV0XJXgh8EemtM7b40OrURtWe2tFD483y2lyTz/ElHGgmV2EIcOfcODdC6N0FnoQdjrTFKxxDHoyfH28DNhMtVEPKrSpqXAQORw+NINbpG+VMNsVcqq3XVeR05HE6Rvr8w+OwgPWN0QwIWi3AcB7uX+4MuaI7RbmO6sADECRZEAnAxDQQmsthKWZK82BnHnPCH++yJD/Pnrt4vDAadZkcrYfQs1XP+riooIMqflXcn2yiFdc1QHjiLFJguD7C8W0HLFYtqer7VXUiCheuKtgbGgi610rb06azhZ6bw/SD9IBBtdeqvAjgwTUfIhPf9FWda2iUC/q8PEGMO0QrSSgwUjj6fl1Mv6tx8yNMNyLNG9lo/RgVnnRwsCyyItZ1A8sA1gXLWah5DwXyvM2DLacROvOaiP+SfFe0Lxejj0xw3stGqlkATffpJxy2nyDDRz2tKYs4R2FF8TUFxvABc8E9ZLxYi4NaNL20uqKsVlZzyjaki6WVBKlAez9vNFAJlMCQlflBiymS/GzyW32kmlDrEi3o1ddevtkYJ7EIykP0bJP1B41ANzx/NGA1YvLxYC8mgdwiS61Rb4O0sMbXyR+P/RdwpVyRE9JPT2RjU1sF0EDRArRCoxZMv5wu6a7AEKS4cZLSiXJigkJsgOYqC5LMx8R3aGRaVib5VMHDP700QBysnIXffsTncSmZo6MOup8Nhc67WP90fVoe+To0fkKsaS7hJ7QAQzy9ElD9SLkDTQLnaQS+jnTsh+iDl9fnL3BRH+UyU7FCnrUkMe3/ftcaQUs9nACTlKxxWhfBcpFyubU1IS1W6/VtjjQq27UfgFsfaIT+kd1lSKqDq67YBV9Md8oABT+vB52k6T8G9J29m8b6Gip3f8toifgBm0vq2s+254PmhRe14DJ2uDn6ZOxIG2B+NRkqyI1NfVIACwCac34LJHyViPa4q9xA1ueRhglNh+ZKactN/Mm7FbEbJ/8z7ioLVsmH/fa9jgm5PJrRdJnTQG8BUtQj91AuQOrZbGw16AEjgYSUz2E0bIGdzqSOzll7cvWXFv+tOdqmc+N79l3Z8bo+jcwAm8B7AH9LDAkNk0d32NfSGCUqK8dnUyjLZ3+gBG83Lb3obTlzgnjQdk9UgIMAlHU8/2ekLeF9wkCRAS8Z07HlaUy/4jhRXuaYge2sDR44UFyBRM0/hiz7RuL8zJ9eQAd5+Kzp17TFbesXf64cPYj+LWchWWEMh2l1rdmQgLB1v94lo5eWQcBLP4IttsXicqNt98WaMDVjwbTTOg1jIT7eE1+Xx/lD90qypZXpHrvFv79VQcD4bWVlJAE9gC0PbNMdFVI6X5rG+DRCFyRae/7exuVS3w2E9OmlX6TmqiKN1/+BlkhdE7pPv1iNgdOknEU+kRlwBBauWYmSxC8xv5Tc11pSHnjqRcJW5ZgTE8rH06My3mZZR5uALzxSoxhL2ErN03+QwmMihPRpAqUGEdICyTUrbrNrlsS01Ojuu/ilC0A/PH0StkBKiRkVQbwiIOiUf7lTGUVlHygo6GRrXwG33mFYtfzAksdlzKzT+T1/MaDIqfOTUp8Lw3EAcneqTfmXVrHMNmCun37jOtmuSStuFRanZBJABzm6CC1KgkYYqzzBqCMcbOLy3Zq1/ytW5o/Bpof/QT9/vZs8ySO1jLaVpX8Le41e3AC7XfSCSz2MGOaaxUa6bB/NJBuzhd52X0HXPFv8MnzYbmpl8yv1TRKRTUb4AT5TmlOc7GwvmXW/wIAeijEMqIqjrEsCma+V5yf9nlbJ7UwbDeh9Q4ATIIBggEkOyKpldaKfh6u9bcM7K5qOZNmzdD78HraTZtr+3czU9iZuXZWYLSmLkr/eYoewF1CrdqmY91EC1BCb/LrgjviqWfSkJYNvwf3gPNkcMpl0ml7m1KMBrKNGM+f75wf0AyV7tZD00FVFkk4qxWauRH06tsfNEPWqUirS0QzqZcyE6x425k1DM8PLxf0j7dfbb2mADLzTEHbdPLdKpTlEWL5phBk8wwh98tjFh/JFF4mjJOXpolss2HChjCpzPPVZCrcClP+18WQ8Gtk5je7AAD2VwQwxijEAvC//2atbe6meWNwwAB0G0BQTxpsEBhltNMeQ/gYvjyf6gbzy0Fff33l7e+cD2dvHw7FZCVkF27i8wo+aTkRpbzCSCDbF9YSpQe7lXr1ViuMj68NSp8klFHK9+ta6A8dJQ/gKsKj/h7m6h6rR6eDU0kskcnzI2YS6WYwG2MiXu7IzMDXge+rDSRsuuCkY8SYriwoD5UHnfd6e0uY2/AbMXgG45tZe3VOvrDNfU51h9rsZ+xvUBlPdruG1ajuNGdgGNrPtNRLEcWWZZYZNpZV8h2nW6KxwekqXRpbfNsrAQIAT2dnUwAAwMcNAAAAAADZXVE7OQAAAKHcZX4uJygxMzT2KS00NTHi3yYqMTg199jkKignKSkoMDg18N7cJykoKSgnKjY5OP8D4hz2xEQ2VAy4M56BlBziC7Idxvtz+fy1Xr1n3jFV9JB799owNklVmCzyUAOkSoU0a7YB4sIMglf+Ps2tsroSd0fV5qNNtzvUohB4r8qZS8Xk/VDHPCsoVRHSezUBupy5A+FEozNHzUVE1PSNL9vCKXtKG0xk6nkJm25ji6hbaTEBHPJ0HttuXCWNxYfsQ6GSKR8unm9EI3ddRS+EV0f/hbHv8mvBZOV0XWgCcSkN4o6KjhIA5A09+sDTsNWaiknYq0FHLx77nL6XzQ1b9sdhWp3W92/177KDCmAsS+UtGdChXKFqeLL+CbJH5KXIkLn2+ZuyOSYrcfLeaXjNPD8Nw9ypuYSzUQUb0IUPMNWAYLyG86Ni2TEa15m33LOWzP4zSjDznzEctX312rNMyxIlGaefn6JqnL42LAFxYguUSMSX1bX5C5uuuzpCIR4FyU7dzLqpKWtSo05rMBu4rFi1Z1seuJR9P7DSldy35IDMrRPlBADQWlBv8bXqcEF4LtWz8kYc60w4ny1jGGHKCpfjVgKwZSU2FmVneRlpsFeb3Rp/zaeO96b89cJHA6gpW9sbZFXxbwLq+mdhzsDcxWZnl0x4wJ4FhmRtI4HJgy+D97k+sOxdPZSo7cpCrYgHAFwS0QSUko1h/3IG4mAK3qvOyrRVoozpWrLYoENkQ81cdtUXHr3OZEsFzPH8shJy1nRjfNoBHhEVhwJ4vxhSfbpbMadN2hY2QxWIa8lhJ6+bnbsRhq8BFPYk87A7pwVtWuMGJB3dYtVc46lN5HvoGV30NOl6JdFI2OrWVpChmU/89HzMwj+TcSkWACwKCWcLgBn4WQGkm4fduz3DBDkrt0gTbSwOdFvT1HNYRf/w2Gb7jvFnSbsrjf4hySzR+gYAJAJxZDchSRdk9h8LpGNHgabMleOUzh9PZVeZu+ph+RoPeZTiuPBMKBa9fO/udL8GAlpXtIgUikBJkPhfnGbHS/3EoiPnBOUIAHQzsKNSIik8p4RWyN4uvN2Q2azGpCsbj7d/Xut5KT9SYvpqlFNi45AmOm47XyGGpoqzKko0hxEkkFZMV0dKadq/tpF1S82AUTI5ov8tsdvBPlYBV812nOI0SXdHzEMZoJO2rm9SdW0L4mkGPherVsMb7mIa70I1i+TWFeuKddjc8Ht9+4x99+7UMuTuLGHl5tZ9DkZXBLnAYFWr8u31/bDHJSsEUkQucBZtZbfx5grzTnlLt7et0RcasSA/DAoaCq3ftsJ7OHf8BAB2R+RASiYhFsD1/0blICr6ZfsAl0wA6CaVBsNuM16UcywUY7FpHq8X/VdJzIXhW8DN+Yne4MUaNVCmP4D3vyJClcnq5vbv+7ZNAlv/gwpD71VQunALh2kZITDSco59StZddGecCQDl7Fzs/lATzyQJOAttDy/il/EwCC8+7vgq8NenU0YdO8PCjl2kOHjU863PTzZst3QvXq703QoVDXBcHj+y4/L7EmbVI/+GblEiJyXLcdOrUGqYyL5ox3rjIupd63tFJCuF7hT+S5hmqBtxHyQEC0Bweca2x+C80dgAFPo0q+ACxzEzGRAu+blxPsWxhLvzEe9CeUuzwnd+ypDmB0UkNgoE+nTOWJwRRsSGUz0SuBJ/wg3JJyJrxdFfWT5aWMY8o+LBrUZ2qsUS9QY8AhURzwRjlT+clwXS0SpacFVl7NVdrhqbtz12T6kVqyTfDXsii2T1wVdXVFdgUCIAxBmvKtZ0c7tCgzqj1rSWgBnDZj0L/nmCuNhnjcNPNsNPu/xVkWXLbRXOa1M2hRMS7wbd8Yg2lhLkJXcGWzlsObJzr8dVDQHosWSM53DLsSGQMeNKzq/Mkow7yYbXv0FkvZ0aHJWhrflSYV0tDxpnHA5Stk5IxsrZzrT2vdvH21fPMezO9WAVGgaAyoCEmCwAwuU7UlYQ5Pfs9GcWLuPelL5/nA9s21RfR49xYD5rGHLG+0uZRYVQYGxUVtWTPokHDx+9feT8tSutJWi/8ingEIQq/bpdGRkUsiZWgblX2gw/hGHTa8bRLhs2d5rEQIJasedSHHi1iVN6H6wep0d00iMQ6oj6FV7i6veTfoibVgUbKZHS1+ODIu2Gj+zTsO/kA4DJYkw2g3iKp5rzmiyLzUFb4DMtOf1GGTRGbbZHC7h8Cmjt8veVaL6fXayDq8ghhKasAtYbb5Q+n74cBxkNlosPigd+SOSBDyAAtLfKq8DW4SNMjG3qR7kSJZRTyH8K2yvVJlONF583W1/eka/m9s0mfncgJRHljS13lY22wpSZRWVjDLSIvZKrrMpiFvApBs1E14fIm1Bg6IkOF4D5RmdyrQ/R325T3eUJBaPSkVLqFkLnKpk0L4abrETA84aq2LI7Vlr623MwlQjxawoJaL52X5Oyl/L8oHtkWxFBTewjXov52NrrFDeXNpQYJr5c6WD/D/pCX/fdXdCyTH1L3aLKGKNiCOZBjL3WfMysMOxdrTqEIFpHCyPQdQDWV7RIPzAEJtC9a757XfUGGdEOE5j0/CS6NEZjhaLi5SN79DlbuDRZGN/Otgd+ffJE/qPZx4tzAonJ34CAp+9oM2dyWfK/QedJdqZwwzycuLaQl74UYeFjj82AEKn2meBeiwlvxLMEwVcPDqcV2WIdQtsNAlvUVwNdI0n5tiDvyUFkcjLoE7aqcpmJgu6tGfc6cc/StC8aMuXCz6Gqu+eRa87AeQHnG6HhaHsSOaQhEYZ3cKieIcdOw7+pYIVtZQPrLI5vz9Mc5QhjBj8+KOQglnSgH4TaW6BIrXAHt4PfpoM81AEE7gqUEcFTxgmyZgiBS17ZPdw2uubOVfzoFwz0uAmy9lfEi4hSnsg4K23M9Uq4HW6oCtPHuUAnmf17SRVCKo11ndN69mGcLsxlKqlHMMMo29AA/O2KHXBRAP8VGSCYhLn0KS3GreO3OeItrrk8xoqYZ68PcTfhrk0AFPZoYI/DhsTJm2ks0Ety2vddDSuqLEEFFrkuWKQHQ/EVbHvlM3jHNwD8CXXYhpTLgrDfAVxyN2Bpz7n1Q8DBl9Ls6TTfm5UZR9HB/vUZCF8WAAzuPNJWQ8tiBK9Z+MQN7F0avAq6Lg6aFu5f/4GJRKsoRBsB2xJHBAEk/lCl7QAxYfrkBMqyd3+k6QZkfeNeTD9M7rLHbJ1NtKtsa7P6TlzWpjQbrzUOewEkDouIZF6p/JxA6b5bWwP7FmBQj9ncmJdzy0tMYzoROH1lat24xX8nezmrfmBBsxUWuWwObUedAvwpy/j7Rntzy7py4a8XgHcxvHOr8ShfjfqTZW3c9jptm+OF+NEvjFxDaX+Cm17l6nXuqlk+WnfMgpjLpDjuitr3v6HoT1l2HPO8SbxmGA6gASoDfZs14XSeGghrbQQzvr6XN1PGr2K3vjIddYXfOn52912tnlx4KJoxaR/M0pMdJb050PrwkCmKi5fXUJiPmE1i9Ef7V7i7rWXjdEw9uCXzQqOXlDoPYZ0c2X7ldRqMf71wre7v6wQpCezseGQpqCGeARmR67aNVp0pczseHsXAjEbDjKzVkLdPGZU5ctSoqeMfxEUKYLgv+ygXco54iKrILEhpAR+U5h+CkCmY1iqxb/CAgAuq5HKfftitTZrVNkAA58LyJWDg3OokwRyjXe9bJl0CHljkQAwoAHy3YYrcUsazUDA0gFQGTEpuUs1CK4V/3w8+eGbub/5qzqe9J7/nj30eePpEGvvXd/mTZmzLV/ulQnkbvapEoHrrS9wwNr7KjitcD+8a0e99IsEyLZl/pZMTXEjsv66wX1cyniddoGrkLD0NPtglTh3tgpxC0Qqvrdl02RNdESMwItUlKosABkO1qd9r/dxrp8IdDrprBLKnbNBqfkcHVWK5KJ2PnY4F2Pq46DVlii+FdOvLU/RFQ7EMv12bgHshI1oC1rUPgeSOFZzIXDJbfkP7CpS+0g4AtldUidKRIiGB+r/z4bTns9QdofP3oWEGkAYqJgGl2Simn71jHz3ue7mqOudTMmrn9l7MuFoPDDdnbJCpxvT77lFcPSE1KlH4EFjqjXdrRE9Y4Y+fhiMYK3JUsuOR9/eeMnqLtushbQmYXS635Qm+EcpIKzhiMCcJtPC9/couqpojyWkIQv2SVm1rvg8csatHGmQKFPyhIkQan/hBMYpUcUtG5q/1AYECypep/pfcloIPCmp7jxHx4j75K2vYRCpdFCI6MSQVGv6rgAkoLhVQ+R5+D4MsZi8DDWBDB/zx9FwZlRAVotdsG0IS5FXLuiUjRx2+98wPjxaRjW2EpVsPKMFmDBzyBAWsWiolbldF2QB0KvLnznqSADKJkVUkY+NucbGSb2nPiMnACD8A9PG8wUBWRID7N5vAcVy9rvliSRiRVW7hK/LJuLeeNsjRKKtK5RodDwTy9IpJATEhpH8bCfSSj1cNtitF1VmqTMN95AddRh239Ls/NWtMw54CBPIKKhB6CkSjmeECXEWlIppAI4qrKkhq1VtNMYqRWIzg/x3QoL3PBjz2KAcqcBibbYFLHj3w0MCUm0t34AHLnNvZVqiacXIqH/pIQziYALz1vNVjb5lkgZrGzXQBl8wXfpWhk6NgIQ4p2FFOEB7GS3GnThIHTiXTCsT5/IiBDG6489bwAsTAKg5ffx5utvbh2dOYsXe24eYXmZdziNPhk7b8Qg6eVdEPFimJjd4GANwRy4t28khp9kgSuO62Vq+jEJtB8dIfe5sxY52iF79FVjUZZrqr6YKfGwd6y6NRs2qrjrOTgS2zDvQRS2jbsCRT0ZIBW/DWvRYIYh8U5wwDPpl2xCLzljaVKi3T2hgn7dtjtHctgRCoW299CzutBDABuqe0gUxqq13JRJsxU/y+e+5e1J2jbMcww34A4GB1AMhcAu0CLhkP+G1sAEkokKt5MLFM8X/A00nj/cNpS//dfczu29F02XCc7U3Ljko7cbadRzCtjl56tSfdvRGj+8HtvQSUmkz7/H9XNjUoabh3j7jrqNUfOnwYodEaTao1778+fLQe2zTf2qq1ak1AiB7j5KDtlUWaAIA6EZzPh0KLJFfXAqDyItjFecijrJFnlTe0lAkODbTUBdK+zPS7PnbqX1maszmAQhYhowCKVn27nEpAAu+uWBO1EYxuZe4YwS+XAjmhiVbhCsAKMmQR9sMBpeEXN9aMPsyV+2M8gbgpuKInnpikIAUcAO5udQ+bSP2PADBDBTKzCkjNwyM2spfXTlH659kFCXemrBkfjNtXzpOZBzP2467WFO8NpByD0GT+poJtcggN8NR/7Da32KkmJeJFYOwxxPSdranSYJ14hDXYLA+G47sQWItVAAtL4S0RV5WKEGMcfalLGqRmco2ZpUXO9iCHDsBEeOnjaZeawr9IQ+zkULVo3TtknSDU83JtGQAiZC2pses5mjPnolIRKobZbxeVPitNCTKENrDVxNPY6EsBXr+GshHBdLKbu4uV+NRuCZ/ASBjvJdjJ0pdA4wvQAU9nZ1MAAEAGDgAAAAAA2V1ROzoAAAD3REucMeQtLS0oKygyOTr/Ce7zKSoqLi4rMzc27d/qKConJSooKTQ57ujoJygoKCUqJi84OPh2d1RgKQZhIAH3e909XmtHdBrOrXV8GQAySJC2A6R98gEkQLiohaIwifcaXdCBXNdkUrxYUKsNd/ydyzVR261UV0TbrRrq/semu7QlSbfZfLPCo5SodEMLUK9O6bp/mbOmZEguRlVVzXmBsX4VFJy7NIQnPwTUaoTPCIFuyWcZALDKvqrSG0dRcqv4wxKyASlt69FqWMpy3YZ3BRcbNqXJRqjVjPW9ilf6XSeBTVbmoWVNXmCqpENsspaFE0NcK2TJwbQixPpSODVZraWrWaLJ6qJFGaV0KEhoHEsGsNdMfTJGowPcAcuUh1fZnJRn+00bQAAIqAjgXyUVJ3yifKXKipWU4TaQtW7/sWM4JTtYqgQMBnXKEyrSkjP1AtvGmyBgQvJ5+zFxojSEARtKIrRPRo22O5ZIUDal8TtQUwDcBUuSZzGpzZsOS4Px01hgBWM381jJdKRMdTa2c71dlaJYBWUzNPndKmm8oQMEAr1Ro1PZ0SHzftUXiErIWogWKQ/jg0CHaSZXaVT6o8lVC5WLYtIFBAILs71XUB+Sb53ZBZIAUGLMsOgCUhKPmR5dSz8aKrjWxKr+kt8QNWcvAfz9vMkehRSs1wcW9JL/pmyZ0B4XtHvjjrafpW9zUZwClI0R7WL9rQn0CX0sILLKt4R+xtYyQDmPvfJ6M8xN1vHZACmsZ3IJ7vFUp6E+sdY5hnjk2dv99e0CCdQdd1JGPkO60c3boV1TAQApWxcgBuw7j+aHho6X4UOjzJNsGDSNU0/I4QFxeue5pOoaQ2s2autvHbwZdyPadkvmRksmaYNaLwCNuKHDFhDJPtNvtizIwnqzX4Q8eUTkQGy9q3sGdCQcCWOx6mu0uLrMwAQapxwALnY2ghtjNgT5fgEAAAAOdgDIAuMEgFrA1PQdYBu3ESAJI9B6DozxFcV++jz1IigGrGEAgDLjyTj7ZkCqFV2g5u2y6o3WqaThft0AqXQlIVPlQxcAI8zaduWrK6sWNQLQVjI7Fw9v1s+vXJq/MJ9tLStCoxC87q8uNGmtSak4RC/n96EA2rbB9NO831EztvzJVIlVLq6xM+F5alt11onIiikz3u5gnn+yQSMvCWmQ55Qb0BE9xFPZkJtlpyVMinPv+v3MfdcxkpIAOIrGDl8K68Cpvs1Uu0wexryLW8goYbVEJgoe1ZhrrxxOc8C3DT9oIXXsCUgorBbTYTnre5nuahoGrAN+qNTABA0AG6W3v0ACzAkA4ABQh8wNA9rstpMEYKzTTLEVS1c+gjUYquvGSHg2tVgTAGAs4w4x++1rCTy6KLjqvSa9IUG5+f1gGhEFwct1QkGtXrtmVE+IoFeWf3z+OKvWhBpS2SObq3PKTzkDAmZyOXqwBOrjJ6IGgShGQa+gEDuWjUWb/Xef/0cSBEZkJt7kkqajdgoGAHCmAJtBgzxTAFVijde/319FceSdmZGA0MCqTj9jiii5DqdECzzYzfvg8n1fo6hTj83VUyo86B0Tgbh3/1IzpfPp3gUXlapG6uVi6V2stlmp+Y+0HJ4C1peE2vcr4SBHWnHnu3+L75cjOzetjwYAcNCBgOEDqAWAWwKT1lEbRTGzO0w8k7TUnP54chrVuOg9AYAuwbVX7mZ75aiKHltrctcsgZqSqu1PrCOl0Z0iqnSCl8T3qTP76oq6FutCdeNsmMn8zW5UnwxJGoRfVsrU7JQ9LY8Q/fiIvO54MuIsfe2fShSkWgL5Sqd9+7fa+79HuiRJyQa3tdpsodS+vzp6HJHghARgCFpUuHRigLOUtecshOrZ4QyPLNNrlJyx2IAkFe6e66LdysUoxPxW6RSE6JTZmrveawMNR2gYI4P49TLxNsBBE77MMgsNHA69we5eoB8O8bEaBICEwcZjoiFx4ttmdwSh/d44E//1EBXWpSjIyAAMAvXMHtXFDbFdJwkEVkXDVE1LqOW4RxfRcFWvJKh/RcQYxKKsAVKu5QPsBYucBzfkQTeKbVY50Guc9e9GXtCn4dLoXe23n+yG81WBUiyptuvqWwcEBgu7/Vu5qVsJbWuxiiQA8Dyb889QfZWHt0jOcNLtS5XV54F6wUsBnZsaxhcA3AmLU/Cl5FWf1gBsNrRG7CBZnx4+J45m+CeqM8obLq4sGiqLVIJwewGsbvfcCQz6CpL9WkwcNmqrugYCi8j907yRFVcRK3+T0Ny9NxsCizA7Ws1S5Y6xTADkCX3BPnfKHBjPtSryAeDJp7XVInERk2z8GcocxhueY5XcbHTS8OqxqTePRCa50PXxcw/sBXdLe3NsJq886xPbHw1aD4UGaDg+iWvsp0Ee1omvZNJWj0YjUnLYLmrnoHmxfSck2ZPkdK4C5CWvRg/zGlr+8rlM+b9Lstkhyv/u7J+zcZPly5it0UwiyNXpnxAzWV+Yhby9XrmlO5KH+6QD+mZUedhcjWXG3kzVS/ll3vsBAKACKrwCl3PwSFNLFEpWjAPMYSC3CHpjPnvhtVvTVK3+fDGTjNEBoKKeVfbxUJSS1tp8VlKuzCemo/ZfNl9zbuFnqxydvKTlt6WnV5juJsRu6E/8/rS4+EyWlFAQ629zx4/wgY5VVmcAFdfZ2pbM1ij6EpMJ5MG8u2OinIKlQEmOa+yL07XWhGoAk2F4nD8jCaqZprY3p2utxdRbnjW64Q7Yq6vVTJQ2e7qpBumr9jGU1TCVlFJC0QHRjZmX36Y9AqCbxlu9HpQDmwFFQsfSwpe5u+zxh6V/pkYC/lg02idBAPDfMK6MtokhgiMBxpA5QN88ROAHlJRVpGZ8z/nx69LNtu9L+4O33/r6QI5Fv1qnRW6vcq9knb6ukJsjUZAimD7ORipZt/NJiB61qfyfQaL3gluyr0HbUpJAp9I/bp03TEBfuXOHLMmuBgCipq0/2l1CSA0dR3n2xbsFRaqNyNVb9aPaqkFEb2K6MoqDjMVXhXgoebAyPF1ziFxvh0eLufR/N+hvUOQGBNGRhXYoaNFAhqggZY2sLL0P5jkUUi1eXSe7t6B5We2Q4etZpSisshCeRqAu+MMHBZZH5FHJEKyJUuRqYUfvvVdltPKqe8mhZlbBgAazB2Qd/fJ9bYRl/Jfxs5bsPH+xL5p3xPtcXs7Y/N9PGTUxpY/ZYLZExGvqc6YD4i51HiweAsi+OWZV3NUiHnWFJCyxb0w5B/dMroEOMCtK86Uc2SegttvFWRXKZkALf6hakenx+BrFkkN8GCM5uRnMsLXfIKLEgQ5pQ2NALIifRTzQl90Ar6462hXpghOYoRo+ZB6X/96IacEO/R1Zv+BMA9JGU8Ffg8uC3Yi0oLZyiLYlvWQjg6H0Wf+d3W7KwgSHf3y0gqEomB+SM/q2Aez1BBlAtapbGPtmuORM5ovDagShQ1XHh8xqhZvrl8OdOzYJcWPmaz8M8uhgj5SkcuMy07lBCuZ1vyWHDaVYWocwUglsqkDTQUVjeqQES62Z0QDs8fzJgALAm88NGIn9Hb4f8CVhbT6n3VD6getGfPRvyFXAYDS6EgPU8QqdLQWokE0zKhgJ2xPXYtOdK9F1oqrYKByg35Jrn0tzstpOvPVKsz1BipArbjMK9Cr+evm/xQyV4JZcRf1jhQPmjGzpdHpeG1VMWkwA9PV8wYgwRYXYmzMauIr9eVFdSSt2fuDs3FporO23Oijn9ms/Ewm+AuQJfdVeAsRh3ABcsBbgqsgFGikRlCvi/rWn6sZV7qTMIZB7C3qF778BxPkKiKcwounG/X6SWwPrip+by7HtLvVgIhG381OGantch4fjOG+ttf+mKTVgdCPueXikGuwVd0qD7cY4AXnQJ3+NMwHdUgLQKLAwJ6pHi57FakuqHI/YP+fiZVlZVn/SDoGViD19JNXiZ329AJp35AnZL2wQF63vvc6eQunee9unl8wh5q1TnQh2zDCGAXxNs8KvUyoJPCwltGaK4YMcNGTK2/5OfmbyZsgeejq1ssQc4+Tz9Uvz80X0OB48z1BVdfA2ZQWQWOtZDxqtAGmrC5eyXx3871jU6NFba7BaZR+aJCMEvIJmcXMQhzxnfkeruYMeLRNSgG+Vent5087vPHGxQLjVCQV0ZRQWFoFpf+0oP+MrjIk21ZG9t6ZSDTC02rxbQ4ULTUFevvVjQa01q6e5vDLh55dCAMwgZDchOFdGJED5EabQ2WfKMBL4n5nmPCuqQnbHoB8zagFeWMQgBQSUAIfvfTTUJG4UWB1ZAncBhOcB5gH8gAtyTNQMNF83udhvsiPIGbm9oGz5krv/kzlp2R/ns7M6BDyl0AoMILCOsREXRcIYx53+2ISh6qjrnMMPjJpJfOjtlBZBwlIyUl5PHQoaYCuBA+TIjy4ZHP6DzFMKaOuzy3iVzx/qQzCRHdrfkAQz5jmYMP5sxq6kod+h3/sXJ4lQ9TZG3WrZXMaKYAbmv4fxfRkI1y5C4co23FBAn0oHrSgKa48wOo3P4Tizvq/VFQ1F5VLv7ujF7SRNG3/7rgWx8J0JTx2s4/X6FOYDtlckWM0AIis48Pjfm9iXPDm6rtX/pfQCDgA1GB7Q9lVp2VPKUcjWmDi/u6PT1n5Vd+b1M7EMyvh3YhyViefCtDQWH5SNELy8B+3ZFnxqbnUteunY7iTEQXGfFkVcM8Nc8JEstgIg2K16vIkPt2/yPCVpCXypAQe5ytXWXy0rbD877sbXXzeg69GdlWv/yl67h6ggdgmKaJO2jRDc2nYH+wkbkFZCT+E4AQeU3Ed3+hD6yVmzOXoifBg2KhgXOPiTWDtxzMPtOGDJk7dC79++XkO2jANaPWJvd0ga6qbYTjHOM1qOZKWMAOztijPIelOIzXwE4JIta0GHYxN29oPttsJCsuGmOE2IewsBo4/1GgzyvNm+TkhWgvjzNLSQ4E1koDH1r9DNceo2P+qiVsIPqAPot8ShrgD88Qoq6LwJiGyzNVyJP1Yzw4TsjE6Fjwk8c7jtQ7s/CoLGidZcZWcDJO70lcydNIJm5pmBiGR+brZBJ14bOmJnjKYIzTkDM/FS5cv4CeBlAdzxyjXwkwiwM74Al+yWQtHirWpW0+7atxFc2qbFWo44w4dSEwAM8goqK7NIFR03ajMaAqTk9p4vxuHoWk8xnLcoNTeJPHOLtnVBTQOTMgHk8YpniQAS3CleE7hk7K1ESTp0pz35Yi1fbAsiInfXDoySjMk+DtT5iohNwMmbs/7TCTzpvElNF1fJW+qx4C+smj3/F3wSdCadSGsL3o+8GVop3LcB5BlLmG0Y/R6xZ9msve4dwGJ2T4MN4c/fukaT2AeNyWlp7Z9i905M6211Qdn+3GpdWRE7Z56IHAAELv3Sk03ufZ2/horX2grRcY1JB+6n6Vtt/WxuasVK+NPpqIyxj2bFINXSM1RsLAnr34KzBtYoAJp3VAlXo0xbf4lXds3iogInvq9vp/rqXXIuir1IADyRBQBwS2HpAaz5zQzCJKsMGihpAEIpxqQztEtOXw+/yvbNdLQ9ms0VjO+vT/JQI06OCqZrzkqIG0QpJPWGHGudczXiqgGT881Oi3PSK1vtXkBUCAUryV7a1Lgwf61KGlLp6Gtcm3JgDGzUyn1BR3OI5gbjV9TATGQzdhXXrWFUAMisWp8donS8KaAG/XZvwL7H8V65nxUyFuTGwqRM7Xth771qiVaVZwgh73V14wKlyT6rkmA0iPvqio+hW5ny1wCLHdWcQg+7nvO6LUAkW9reG9JooVpoagIAT2dnUwAAgEYOAAAAAADZXVE7OwAAALBFWPYp6uUrJy0pKCoqNTf05O4oLCgpKygoMTj29vEoLiwrKSsqNTjy4ujuMTceWESgBhcA+J4EmtAmbbNB60eDBKakGegLhBl8IXox+loLxjfxV/G8LXI2fVEoWBfYPUvyWKKFu5IpnVPK5B2wlDYwUoLabSqCtDUk/uHYEfsRYamhCDt94OePc4kVZ3V3OrmYjGjfJQVaatLMO1U+EhKWXAE2R4Pe+sESxGxcyHbCahfwDsQikgkXZRKm7aPbEnursNNJBLS5eaWXPVN6fkeHzjDpXaD2w8mG7nmkDWUJdY8Eava/4E5s43VfRnNyed/iLiU1LR+RxBeu5udCAYh1lQbmQm+rWkWRvk4xUYe8iMuCdj7AOQCWR1SUWtXZxADeO88inrp+GaLD9mlRATMERUk+ALDHN0ITFSumSTjmCj9+7oaKF/nhZhh+yvdz6i+cyqhlfTqw+alQrW01Heo0jrHFHCYY9W6YizRKC0w0NeQd2c2H7PiI9c4u/WAUjLbAnI6qdmPaQBBrGNLFlAWHMOn1ywIM0DR/W+lzUQnNlvVluufSLUkj/+FTcM/XNf4D1yG4bXEPIOyyTTU8OMd7+/bpy6VEJ/5Tp1VnLMNKkUt9/SJojvZd3U7UUkFp9H3IXDonf4lyQGhTxdIPJFDufB8fb6pjED0REmAC/PUKqnGFap2eGnZrVCfAdBwPXi8apU+VUasVtGu4sn5/Rgv1i+6lQZOLAiz6tApSo6CcIv2oE7hkRvNcwrMV60zQ8zb/otu1JOPdKwvz3YHUO8wBy5p2Ge8Q6PJBtwMEGSg/Ah57F0SxULKYWDjlarhHdnzUA5/XPAwdn6KTAOztym0grJaI5CBT0YBLxg7k9qjSZl+VCzqM+GggSt0crFW89zkF28oE5PEKgs2FnAKX0pU7D+CCk1EgM5YpZ8sYMVSuHzMX41UXC82B7ihTJBTyPLOEy0hZR00uc8oAesmV6P4e4jqqstBsZvnkQyDfmLR6jFeBY6neN3zxrkb71EVyZLTxA4QEawXYa9QzrbdSRtNdSaTEj5S9VRqGSjefdEs9AeT99LSdP1lkj1mdZwfwZGUB2be09ZWonn06l3qxmPp3/+//g09K47+0NQG4/rxfSoytZtcCBCILglZG1+jD16IEvtYpA6BXG7CTiQMLI8f+pK6zK9ebIrASpPGF8vlzY3pH2/DaFhnhQ5YGJJqHVAgT7Un/8vHRyR2WD3C/c/Xnq83EEdvPAoAnZsBlETpAD8PdnCEJ1AY0YkgSgJIcEoriWdB6NDw9vq+9l89P8+3868BEO87WmELobJqbnKWFCEaMRI2WY6okVWl/73+OPRptLlQOQCOeN/Dwf1f/fkoAHuPHklXLNhFqJ4TGWesiqiASDJaAFuyc2JEWX3086Ow3I1e3QKjIu27HiTnYsm/aIgvPf+nReSmmkhKTVlJiern2rVR3R1KjTGXLkwQA0C7csaLKGg+Xs2rvAwCEQPQV0legi0GO2dnUL3LcROHMb00NlPsECyG7WLI+vpsmNAB+WKQgBWcQQPC/GQIIMaEDbQZsrZUG4wUJBttKQMorWQtB6csat4+ZDrc4v/v1pPvb/jnXWr99l8MIef7Ezu4VqFHTAyKxfmtAKrYeU0+2/fDKpyIsUPIoeRv31trn95lcBTnaeqB0y6TTwdc12je+dfI93UjMnQL/1HkVa0d/VqcjMJp/dGE3yWQKUvZvi43BfvaWp9EMIgKD+4Qwh6eUGiqSGhwbK8+cxHgFlUN1iUMwzoqjVbNhI+DwegwzlQORIURnKUS8a4sVWj+Luzk7unq44dB0fKEMX5Q0Btk2W9M6JgBWV+SJVKIsADbS/wcAwLKgkwGmyoAkA69C1lLa0ywYlYKeYwsiWUNk3vrvpFNnQ+sSH06ZoJ9HSo0s7upTm0w84pUcLqfMObYPO5PqqqguZ7fX6X+3MdUh97mLMve8Ot29WbrTDulrnr4gMlDNrkKBkpYA89lJF3wwqXN/U5pbkuaDm1ocFRocJoyfiK2KD1ss10FcvVqamfh4yR7riyIlUsm1hOoyxYh9FOoBOquQfBeAwcyWDb13C5ChZC+DP8UYY/0pHnv6S+tE0qE9EviGUIzfHfqQORCbTmjh8j749WS5mOkKziQs3Jj1MZ8A5PHKZiNTHVWWg6/PICUcP08mDJF9uA4Mz8k5iBZ0Hpw20sFFz74wD+T1fNWANJN6DTHfGkcACDIcFJ6aQzH1S7mpcdyG8txc3a979EMNd3cVJmUC1PWKhl0u/g/l8D49ArgK1H1zFNFJwC2JcDk320MFJeMCgvr2v+YKvhT2xGikhfvADdfWNgAYySebz7sZuPGFGnafa04zqlqdfXUIjhWjeKUAFPqErtFUKeV6Gsh9s32ICNpemzsmHavL98Jit5w/AcQuh9SbE9E/Syu7aPz1CifgchHE0OsbE53gP//M2slQmyS9Bk9npFtnL95MwMoMcZkligK88YqjHVYWjhsjM0klCJLwpf2TDGW7BZp+Nhom31WPVZ+oah7ESbcABPq8ehCl/KBAiPuiTpDO3GlKw2KknncPAq2vTdNiEdTnOd4952Dq42YCBY4MqF71AAwi9SXSOHjNP0NAGl8Uu0YfwEQWvwQde2CAcdiyjONhPYgb+iL/WTGlnLomBXD9dclLv950AnMN+oa0La6atVydLpJsBpluX3dWf8yxUujVbwHAUQAwrbBOZgCSJQFIAygVChmmmPxuR5N+3mFTwYVJpj93uhZ/PClqfE9Zs6KvaZjyuBx+sJLgIMOwZzqmGCKyWmVaku6iVBSe57s3nYzoxJHpg1p++t4SepM2Pz9/IftiU9j/+uj9ZAkAgOLv81arRgHFyB/hW2W9om7Q5CENCwkqwZQ/e15ocWXtX7XhKw+Xkg+4N0pQMChCvmjyk6Zp09eLVTUgwQJeFwZdrUyg7pUSLKlzXj+Vla9p8NXRJyoM0i9tEQpqkTkayLWacw9VXTG/kvg0+MopkJ0O/oiU2sdOR0SQQJC4+2kNdMhqAQCOBoBpT4AtgWkGJNJQLcgAlNbKKYqzpoaYzxmhpLrgjdU09FgTAYD2yIdZw6IiwT1akdhq4oHi+0ERQmAlUC38gHgwlspcaEysA/lmleokaWqFD5lbL36P7lC4O45SxnEUT8eSdFrydKhWSlFaka4mFP2CVEl4bGQBNF0zPqK18IQwIrOdqXenCjroIUZ0Xt5xYNMaNLmAPvK9UntjEhBjR4SQClHDVqEkA2iuOoVcfl8seNCKydQ7kxm7CL3U/FwAvyQwf7NkoMv3YzOE4l9QC6LCW/TlsO7dumHwDWhcZEcCdmfkke+bzuIrWZCq0PeIf/Rj7ui6h7XxBZgBTTsDjRks6ykYvwjHzimtKHbGLQ3ovezUvnkzw2XTU8WBwQ8Z43CYz5gxl4TPu7tJlSrLwakUw6OMQ/V9VbtMT4SoWMqL8ffPTZcv3c1tjEnB2rD7uO0NCopcrk5WmVvpdCuZkOitnfqydQG8MeDpv16RLTVSv4qIoFAG5IeTvqQtyShE098W26dP7kquRi4mBCBhbs8beaoVIswWx0TfW+NSdcIgTLXqghFh7/2cAsRhKuvURoiGmQDcV1ssaGpPi6oMOpPqBnnxgX//qU2yPArdPglzASQWAfHELpYf0WsWg4jkz8xmSUQe/3UgdEKi0RdGj3iJ0r2ViIs9Ex3k8TyUxj4Zn+yUJ2tCPGAijo5h1MMK6YJ23AaZKt0vahDcyiTj/OnzsO1Ae8sGDAJ9zp7kLxdGyrp9e0mDYnhpzpBFoym992LzUpFM8W0imJ5wlAzBCu8dqwHkCb3SntEnj6yk3Sq+G0ADkpqnI5cQTJWJaTiDiEslYbvmpdY6kNg+CsoD9PH0wJ7k8itApvVMM1SQksNwUXMrdulDNpOMWA1USO5oBGmPncF2IgKsBctZz7RErEQcw5syTiAOSIjOXrMkQsJ1xQpBBq0W+xi7cQnBtMb+axgD3PUKlGckV7ogSX5JEAcTx9n4vaJU1sLC0GlpWGumDkp1fZGkIQpxMtASBPr0XjuENf4C04pP+VMEsI4N5krRLGqWp+epNQsWt3n+Ouv+0rV2tNb2f7cz3GcYVcnHEgDsJf2Fxt3o1j9dUfw17gDQ6HopolZi1Zojwc+36MmDMYaNKVuPeWlNya2chY5o3lQ25SQ0EUgDALqHJAFX7Snl+vAplbLmOcTk/wZ36vI5jp1zCF34eADApF8BTIF2BiAJv42BVMJtyDDF14mMXr3ty8lo5776bw/o6jTTVAa2oo2ahOisDjhUtVpthi9a5Sxp1TQSJ18eND17ad5wrdaenR44PPvfTdkYm8/m/38sCiAQDvw0KCg2an2JaFxZGTU7Rjf3rzwMNVWSCs2CR0UfdvstGuBsQFbucbxH2QmkuYEiDwCQAH8e3dsBwQMlJTkYQH3mL0unM7oesJdvHQTKWhPX+vdYiVXSBI0VNBgeW2zS4Yjio+PW5OSDgtC660tzONjWwOwzwewCfoiEIMa7YwUlXr/Mg9sMANAPAFCwwqpIB7iJND6GQYpk7bGieD2N9cX3/ODvhHXTg+c/Lm83VgCABrCiZ6GsRbw5EHE63TU3cE+JWtbVHuVUvn83ZURqfiWuenN5zzZlE4pK+e6vE+YkTG+hTBm72N9Atdopjd2RsNpNgjLi4wfE4xvGEktX0FbRAPn+l92yoXXkDh5x0c9OmLRQ9TRRVS11WA0AgXTe1IjyfMsdAxdeZl6DPXQ4Did4wkf1UCuaRYXsOgs/icrStyuWS4AsLA4uFbS108yvBKGBsJZRN1vBA754lNSEFgYASfvJtJkL7NhzXwAwAzbbE+BZoGbgQjDmSuA8F4WyFEo02V0uCJJe2U0zdtd4P8s+eNh5mxOhjOOWZP00ChWoPrnnmRSSSpvQ6xPIsRiI7IYg0i+c7f2deyI0oQ9nUpdDL9OjAgSF/i0bEKQ2ru2wgubc9GVBNhL/z2knESikbDbiLJfwGrNLiYB3hmME9xjwU3QlmE1qbI+YJkw9X0xDVGqMKFYPoTN2VeqeS2nGLT4DJioK6SFgnc4R2O6PFLtwqMIi/esiMNJaPRV43zAPUnkzVnJPLvU0cZmdLZbo9Ad2Z+RwzFhqPwB8fwAAz0gA4CgAGFthWJIGg1EgdMC6mYHxtFJaU5zdPLeI7Fis8DeGgVjJmNeVlAMMSojxF8SGZws/CUgSBTx5dtn0jVI0wEG12axngkdxlawlf8okbf7pSrWyqCjfZPqn4WEvIe1x/09ayrG+3Xf515e9/oqjc4b3zsJVdBIeoSXRIP9JIHPcBy2+0HqOIEfa6qzRQubooG95ZOwKofhluHiwM5sKMAEcWw83TwnUnoYBvGUrcoM10bGiCPt59ZnfyZMKZcdJMfi1VmYVh7U+lYRT6syxcKsNPYuN3CjcSJM3e+oA3AkLtABJ2ANF3L5QgU1uf62FZX0+aX1Z55dzq7Y9/+VyfvZGkKx12tSfzVNTKw79KgQqvV6PcR+mP6LFzF1nJOhoME4aXf8gwzrDesaIOfp8mMzPdZ4MnW194Aa1jpiE8o7rt+dUTgBPZ2dTAABAjQ4AAAAAANldUTs8AAAA6jn4bRrx7+wqLCspKCktNDn34ODf1tvj4+Pf19HW1trHRJjrw3rKr1UfsjYohZTmb2z3znEMKe1meoYEgCMBMLKArzENkgSXSCQqqzYMDG6Z/jY95VWdHn324bplPGXefWb1pC0TKXXPqqhMJ7bkW6RDhbiMdO0eu2hvU1YDWuGrkjtb3m+aXzVhMplMkjdffvnvQzPTrERgy3N69dxfZ0mwfE2mAWgjrEuP5S0yW3ESZTYo/quqjCur/llHt9IIq8D4f40RAACo/RtkraWYnkEamvc9uOxngJKNkM2lQFSPcQ+dR+juzj7fh8cpoL+en7Vy6faeLy4WoFdy6/5CwdVOFd/64i5nqZlN+XmWDgV+uGTQFfQU0FE0ktj7Y2VDBFwAADtqAAAUrDCIdAZfCIaBIB3ROcUU87fGO/v+eH/12xqds2dGLhMAQNOavwvSYnUiZcWJpIoQeC+PuGbpihbsT++b00DvbVW6ap6X+eyVn6tOEKJ5cPuPOdbZ47CosqKNlnUsRzplyjkMwjEzqcPpc5U6Uol+gkN2HvcbvErjzOPiV1KGdbCmuc0Xqzne5L6sFu1hCWYZtkBwVv3pOVC0NN7AyhBlBKHsIG0JM6npBSqEq8FTWjzXXTDZWdoBJry2dI+fH8h2YEGpvImLckn77NnrS5lzb/3/WaihAPanpMB0G2HIVkozd/+9ZR/jmNPQ2XoyAMDRALC1FSbaDNinYPQ9SCGhlMwUJwcH993c2bhq/do6zJzd6LMDgOrL5GN0rZ1WVHfPqXUpQgCj3+1aqgrE41fGGFsoX5U2L5Jh7hdHhmbs4Gfr7y83f7JvfaWl4bFGv9imVq2kJGpUZPtCd0auOhvFKc/kM51RwnfJMD5XaFNGyUXuUiMDuY5E33qyiGT2VVw4Yil0MgpLil7uFGMsCkV0RZxxmCfoLQdggF+TbEWB1rS1YbLMl0RYpepOXy91q0Sbkn5AqHx9TBfpAbhyaokNggIA9A293HOanx9CETXVdoKIihvJl80AbFWZK+iNaaHxvC6lXUb4wojlVz0AzP28SDCbjy8AlG5bw5OOBl3CP+Z7qzZ9gn1p0Na0eRaeJsH/fjRG1lsrsmocDjXiqVt/rgmd875dhTggIe2n3xWTcZyIROVsAGud/OKx5qV+UrfjKAkB/An1xnNNYekbeTdFzyAlW+pPCOH1lJTHZuu0EYHO8JC9foREPoB+gwD8+fTcE8lrDsE0JYmjKyr4+OyJriqsGlxX/9ZRKQYnqcm+qYROspADFA5R5nl+JIcOL5sthTgoEr56/dWJdx020Wnlu2pdd8ccfuCs0Ry8PQjcCT3Sk45e5oK/AcRBMawIECprUR7ttTSopxKHVLq8O/4BcSjvqZYI6ZkhXgLkDQsKAtkeKiiK/aheUMnv73zLxDUc/XU/HadTZ9NioXF8ful4WlDHpvP4lNBPUqWYGZ4A7CV9BXbj4Jb/wBWVYtWsaZZgMxq0DszPY4t6ECdnb6uhVm6e09581XAnRnTzN65Pc9g53hwIcCEAeqfkSSX5vNpHtKSibUoYp+/3Jo55OPZu6MZhxwDgwQsAgGJPAGNgHEAiCUASQOmQMQpgVor9J4HxSv+o4XcK98nZgjPOTVWS+uwBUhBSBmVnrGsoLAipyCIImgX11DwQUUqlsmlulsOVVkrgpZHo748+9HG2NbY2Pz8/v+nHP5cuESfTEQAA4Nvi00nyQaOABSjjbB+VoH09MW1rqD8u/MCDJXI/GLXGq9buTT9qHrXriutr0SmlpDbhoxoAxpeL5EUJKYBoUmlGVWDgwj3x/EOnwyw62nb4PQfs+8o9ME5vW5zpKC7xiQduZCMz8UpFCaIsVMdeAL6Y1MCElqDHxP0gaWDHftwBAEcVAGMrbIca4BrBKGNIsXFKK4qN/m2xDzf/b7mhClShkZ1qKj+mMmybuFHdleHYqWvmuq+CgXjDREp7K3Uxnr9QodNwwo/9y42lNBl32lG3PN69/9mDGVXb1KzNqRdeca8O75mA2VS7I/MBdTmvSPdjIJ27kZ47+FDkSqqHXamIaGZfb9sHQWrSQiQMEDAPfDzgMWCZbjTNCt2cEeOPuFU4raLA6iLQPFH7Ch2lATewxhxZL+/j4kydvyF3mgugHCE/F0dZgT4Mf6vbnmgB3njU1IcyBYC7n5B6acwVAAA7AABQssIytBmwhGC8wOaEZU1SzMQjBTFGH6s/mGGQtLdFGQDYp7eHcn3VAQPDlbOwugMLT20ORSya030yN7Eaqji1G1Uw16u021peqwkih8eJG3sP5ylSrdxsTNJc5ZW2hq+3ZTH7u4gojhOzTa3AdCOnSOC3UBdik7SLIZrsRtu6r6lk6VtnK46oZWmXv/u8qmJJPgDwDlC1dHLoK1aSyDaBgwSvV9NcUiyverxSM/kVA0rJn/YUuZcKr5Ve4Ne6YNj9AIUFlBiqwYp68QBeiGTAhTKQMfN2WcSlDfP7KwHADGhW6KgMSIIx3pbAYyFYK4qU8xeJiz+u6m59ITmMe89qwrtiaRqaixxt2qc1e+kEUKTCtH8ZTV+gnHGrDKTpKDEUndp0cJNd5iNtRIPKhcdZ+2nWLbW0JPH0k4D7uu3ZyD7OlAHpiIXysVo8b9WrysHcoYni7jqdX6GETAhflmyWC2682cMF5hyFZgBLLH5G2dvPlNNZoYfKnfoaQ4KYDtJFV1n6t5AMLCqBlrZ19015yTyA6M5BdKFgLVVK66PrzKvWYDy/e7ZrS2gAPniEIIVmAPC+0jZorLJv1QKAGdAtoKEyQJKGCexIzZopnfB33/bh7E/6YWZqD3797eS/cYa3FkyoRiRZfTRxzGpERNqvKJ3uop6smpNPgsbIKA5xuGzJ986ueTlak/Sv2ra2tar3yCpaW1uTyC2LiLftcDX+2oWjsnBnWzGihOiyUEaPiBjdCJ+sJP/51VJYgzC50nvAymrNVQAt/lV57MHECsYjeuMj1R2chPnSwpeZH2z6UUQwPfqbqr31NjB1BPREQUXOjdhaPpiXnss9wVyne4WJDt5oNLQGCAC+XdlDrHgmXgCYAd0KDaaTht0I2lgXNVNEvXNv1nr1dybTfvj6s9OTmmi0mtNjyLpO2CsZs9jFyZEgUWYfN8IiAIHlQG6jdaNJubYrF8LcO/aTWGHSt7anSt2TbNizEWvlRA0ru1o0xTZ3/5ItwDFCeWAOSCJYSddM+gACPl58/mGysd797GZoUaNjpiS6JjXC9W5TAwbVoIhdnZhQKTwD9WDVWf5fzqo9Q5PtOkrEnSpBOPYrANmvY3aYQxbKQGe/UAyTY6OztmUMFvvghBw3pQlXAP5I1KKECUHFLPTv2hfCZi8jADADihUmwhnQkOyU0Uxaxs2z5198p8m7yOeHn/iOrwZjC6ZUXKqRhkZY30XoS/SoTYZej48SUVovl/mUHCKCisax6owDbzY7UyoaW1bH2KgVPFO9kx/cTT9tyJTw6z5kWevDHHM3USv2o1Gq5QB9PJmYJQoVaiHw/pZIwhrLPoGiwGaltDtVBYaENo7p73x6sWBDNIN9S4O1M3IxssRedcoH9JxWUxC6sZEVKKD4VhS7+Hrdtgdj79oMX7fOajWyvCWhMa/cMzCqWFv6I1aiBAEA/ljUslUKAkC7iyykbcuuYgEwANMKBZVKgwLnEbUmFUNW//37wubS5LC5bZW///P+PmqOuQmKmnJS1Qz14iT0JaKyctWaGN0nUkANv3ch20RLBYTsK49n84sX6Mp/gHbjjqzmCJkSevKh6Ao6xJTyORN+ZDrimz3KYoP75FOe+df7PnEexlrW0++pWoCET68oYYGPvIQQq3DPg6x7v6w3Y70Cw7oxDZX0wEIqM3Z3G/8VUBney+i87JyeE28BouQvQX6stErkIPxARXH+/3m+rPX5mqZ0KizsjQsqXDPeTDwyeAD+SHSydoAA8O/aFtIv1F6PRgJmAAuAKsnK6MRprbB/5eaLV56o2FVNb76lL7vHQ+zoEMyQky6V0zKU+GiCZMPydC5KWCrC+LayVHBhpTPbFshQEqOzGtZVv0JKdzOzVfsZe2jqBCBJmvaNs1buh8tTdq+CZtkUty2TxCg173GbTFnbJDd8H0NqUNt2eWz9vixqrcz1Kx0ULJci9jVQ9/0rEHEeRlzazXlumOs/hSziolmgp6H9Q3AiESPrWkUijJPEo5QduMv1rcpKsGlda40SxLbsLTWnYSULUc7XSBnJYajTdT5YZCAFJdAB3y6Hg5GhEgFg2naVei7RnlCMSzZHflz9eWn/PP+g+Gp9KjGKJ1M6y0wnq+GqmGoA1cGiOhY6BVWWMzZt5gktt35qIj1y9ZguU0U7umU3r00v7nqyCY7XItMtMw2HHhBhrhY+n/SNk23kzuk7ZKq79emDoTAWQerY2qajJ7Pe+nF20rwZj5CdKaN8wYIv53pxpTjRPfL6Aye1/MGIWy+SlcJa9rxHOUYOBfy9QSM8vN2cU9uyY2Cwokl0FSTQf6wJOWmBYz4H4vyl+oLX2KnVztrY4S0TCgCeSNSgBiAA/JcF+EyQAboVIPUD5aKnjKI4cHo95fnFjZvzQdtzSR6OX1jHzfnEbWefr4ZoV1ddjaYQYtsf2mZVOi3RovETAQn6ZYUq6vFQ8AfLW/U4ULiuH7xlG6Nffw0uTA0t8MmKh+ctuU5y4UF3WjwbHg8tmNvZaC7vkjmq5dtn9WIkyOgeS1hjBERZ4q4srvjcPgvpG9MJEj3EqsGkS6wf8058mOU70czgWbgiRnGHikFbG3WC752sCtOo0qj0HqAD+i0EEtBkg9r/M0Pw9yjaXLKYAH5YZLiEgCYA7Q3jivAVoGurPO2iVqwo7O98iAeePbn+LOrLVze/eDY5/F9i9XEX9pct6GjOqC0uiNWEo0TIGZGXTJrb1V5ZWaFT/nl2uYj5UoeDup/ZcEvQ5PJbtn2TBU103DYLICUvTPbNNbQ9BpSRduXi7moq512pHTTeqgoliYiyRLa1OAHl5xKiQfSEo4yx4O1Ui34mo3dsngFRzw58SrBNozyTqyTnEa9uVXC3CuuNrU+GCUqetvllq1klS/+iK5TdZoCytlc/tsK6pdEDXlhkoAYIAL5dORAUJAA930U51b7TJDMOv9/+dHM0jtj/eOXFdOb9Y1FMq/FDFNVLDovgKC3m6KK1j94z4cxcNqY8LtrIlFQlGefpdBpzfuOCFOYHsbozoELlqAqz73t+X3AY6l66WzdrF7/jTpoW5TqBa+uH0j9WykYlDKPI4UQPKP3GUi0LHG3Zv1XcNddm+na+6TUB/okWyGVZmW9jaGkVVrgTbdw5a2+x2N45ZCu/pwDPMubYSmZoFHzFVh/VzwjZ9npeZ1yHsapym9EtdkxpuTvoAH5oZLSFQgD4XsXKBoJ1dWBs/VH2iL5RTjEa1zWcA43Ril1Hs3GX2V7S783EjaQxdWMu0S3Z/rbpydbknIxsVEcyJ/ynDK6kQqFH8FnD3gkROFvyiJLz/u1T+/VRQVvl3o7EgmDI2CdO6DlqheatBWwkoEcg9LcYgvVSOsekwoMc1FDW5wYnCnk9pNnrtTdfWR+18ScYvelG6P7KnveKT709wh0QC0r3OwZa6riaYXPPnQraoVGRFhhvQuvtXN+Vmp3RO4ghcyVRghhmJxXk1vpBXQBPlgRPZ2dTAADA1A4AAAAAANldUTs9AAAAYc2gribW1cnZJSYoKykpMDIxKCYvLt3a4N7X39fU3tQoKiYlLjQyMjYx5n5YlKAGCAD+y2izUOZSYCxvIpskGie0wpQldfDNr9cz/qy2bRts+3t2YsD4vTGp8dxXmWi+8xxivzc4Yzu2ZFt89+30j3YyMEi8pDjMRlDHAfxtr7rETuOP5yWjyw1ctS6pAbJ3lTdzzMWnoEfT4/uCJavlFfOJIYQET36LslYIk/MhJ/ywqStXkLVFxVdAAdydtfQwNPwlvEHgIu9eb/1Qd7ZdPx4DEHyRqqbteKBoi8dK60OLCl1xUZ3RPE+1JhQceCPFAJ4iPcsrgJFFJsQlZWBb2AC+SJSihYYgAf/5Rm9D3CdQbbU+0cSQNsyYvH813Ln8b8K4kvrqm3kw//RD9/Y/TuWWDMOopm2pzvThby1DX8sa+X09afzIYTQo+3jP4OVJth4RmT/W1SaunaWl8odoPIZ43FvRm6rIjzJ74hoyH2di6q2vpfuD47UQunya7guL5SjUo41RU/Fjvae6rPVX0WDBMwoyCC1356a+is4fT9uSY3eEDj/aip/KZ4FYXHwh7TdFVogtz9n6nGGtxL4Q3wCMrCOIxuTtCh7IMhaU77ZWCzRyAh2eWNSgBhAAvjcmAKAE0EtiK5cxKhGKQjBIT2ONXxsj5Q/nGnrDj6nUe+E0OPXS2WS/Nff2rvBVKrMHiL5dbhIrXWgERnlbqOW8AJkponifkZXkr/CORjlGclesdteCJgGKINWmk8rOKx0NtUgswMJN6PQuQYS0Rjg+b4IDuc07c4vmzz2YkHVzzfF7gTm0GJP0krLxui2t57g8MiTumQrUbOBk2itfuYtGKnxTAQRYXH5LFozsZIkIbkhQvN+3HJYrxO56dtu3oxN2V+RAS1YIAP8ziq7HWW8OYWXXJaqtJO9ro0hnKU0O5wXdYlIsHB/MV8Km6a33bfI8rfdLuaGucrKhvr/Dt6UWxd+oHvzFZG4LdCXf1Wanp6SJzmc+UGCELc4YhubykRUPOIJ+w2EhinhDu5cv7gPa4Zvchr1v/yo2342p60qyoKSFZz1l2k/m/1AIDUJYv0CrH1ba9xDgFtawpzPreCwHKVj58qk0UhxXizkblfJj90W5P2AKxXFPtcT2QgHTFBIT3hza67RMpV19WioDdzw2Je6KSckVDToAzPE8wQDAgN9sCIzkb5uXMadRyzK+HRqraKt/UrV54cdsicoEBRTyhAAyVWfMvGQCg8jk2UjrWK8cnzetLqdVRvvy4bX0QS2GsXYD9PV03Ygg1Mgk/E0VQEr42W7h9cJ7ZWe6oElBR85PyZTdjLBpF+UaBIz1SrOdsG4rX4pz+7Y1dIZvuztmNo5O1QxnmacpNufgU1Cl+vV1kTQoPXT89XQJCAjBus0Cw3EVNzanzPex98rOH3FRvy9MZaCUju6EeTVvRRVhENz9vMaICzpdpBuAkaxtwO2OB2S2QMnGu6ynbM8grbRbQ3Z+CiOpfUgbLApZA1VKktbm+DMBpMXE3DmuVeus+Ky32VzhTni3lO4S1d9yxofsYsr2nkRS+zQAJAJBBJWkAD5eII3MzYnKqukquy1yzmjkH6vRKTzm2Kth47d+0isd1efz5PCNRjc+NgA0DpWVkLqHhMlf7yYNSOfL3CT3Vab26cUaV9sXTE0q/KaiXg4hXier0ogr+HHFLb4ALCrpADJWBXcHMJLVBHSPW51bQSiSFSNzIt2rPbZfSSpRv4yWjbJoAGw2WQWYSA7z+1rgknzBdY9kieNra5ThSDe9ywNmhWuxVafEmjQAdC5t4CMgwPuZASjHTIq8eI5rK62qidbIj5ZRC3xZwSIerWfL3+S9z6j4AfP2tQJ8Rq0FgA7e7wuwjukTZj6pEhush1ZHrTL7c57NZ5ZHI35mIL4tv5S20BUKo00KevmMKSULNEWA70163Ttmum2HFDZGgHTMThvZ14KNY0R/tDSdHEfXcwzDMRnbMLd1YOveoNzVHiU5DoiZjM1judW5Uu6sT/OyEYzG4Hd9xAAL4hneEO8La4Ey3fq8kfasfRcsdbFkDxPlQfaDguFc3HIk+RfZtyhrzQQGJlmmb/4iVmNdwHmLZdONZR4Xo6LJxI4yHVutwwAEUMfnSmj62iWqw8rCfXGRB3FfXJCsTfiBaEOdV3Lc1iDMZGhve/hazfUh++FNJjIDnHvWCjcDPhUBbeCFybh5cV1VAAr+uPS6h3AQgX3DNIo8wDimo0xMW+0JpvgvjX1urtz/ES/9SDGvpn88T6RcvUN8nKp8qwWxNBY26ogir0FMsyVQ9x0PcVJUMhwBK7cFUnoeu+RqLOQQHyvP0w1VmuDV3JtPkvrSE7dmaLogwtjRVpEalYLuyeZPttOvRm8Gri6bYR4UhWm2YfLKaM/Va3olTUR4X2tGh7012AvrIDzyiUwUJr3WCzeIq0YFwUXC3hKtHB3jsTiUluqAGIxl7dXoN3rs/sbbumdZN0pVqxjn2Y+AUpjGFmVS29mBBP5Y9KwGJQD4r51+WtkCGKuq/FhRe4rpuGbrE+u21x/8nn3sw/Jr6s7dvMQi+qxNhodWal84pnHdoo2RYZbWRBDvDi3drH8NFC1NO+gW6mFgP+x36BY3GtZ7eqSoE5BeaFZV1qrQtfhoawdOlGpFik51GKRewodeZM7pa2f5HShYWTNsO98PhdEhACS5BpjxTGD9ppFAAflDZOeyLoOtXDBr7LJB0fpuKCYgb36yC7r6e2KoY46v/wJWVNGCBm80LnRgm0WQwV2GsNIDkktVXICJzGnsC8cHfX4pnUMeDyYAHlk0bgyFAPBd1SxGvT4GjIEquWKSaCGYhpcPHJZ8F4bdMl6X/Hm2Zzb7y+2Dl0ebqRf3XE2ORjc4dylpYqCRUW6JPESs1+SwUkrDi3dqo1XaHlfDVTEt9sds30zlbCecKRDSa6s0RrYoWqJFHHMVeKDxuNpKK3VsWGZh4r2dNWfXh2vCTEElwYjWsEjRPHHLionI8/MfI9iqgv1a42aS6yjMV0um+aRqWPkP0ElaJZqey162THJGX0sdctMc5tBaLeOzumsuUdSNgdpHECN92RJ0Q9rCSUv6Nhg6AA0AflhksoYiUIDvVchuOiBqNDBWxfJMRRZMqd6w1XbeqNboxIbX343C1Hh79W4cHM/mW58Ry/yNisKh9gluSLEtTHdonSi5toKUubSieBM2usvyK89cGYhBZfSrdcHaPC60aZeMjjOJ71kmapHbqlL9VDufJlNTadLb0hhBCKhFzaFKhfMdBtnbPrp+eIw5tXqjMkOwU4sCVp+aM8776sAMs9sk2UkyoF9VhUJZ5sMI/WSKD8F7G7H9SfkWkb0W5uC/1SbTWwitODBjs0u2b2TId2SKaLQGDQCeSGSyh8YA8F3KQh8KoK0afTlWYrVieuhlHPxC/9ZMvq9S/qQ98urzmefZfuiO7M+V+R76rMxvC99KzFrNI968H+mOTYxLujYZCqshq0RiraJhSf/y0Aje2IF3ku7hh1LckHZHQnEYaorSbOQaUE4OzvH+y8QJKrVnDGzl6coi6TlwBDaqqPYaBYkMkta0wqWCgJG1UMhL3aOfwbIW+MQ7xmg9CWNJ5MOfzlvq4Drq79UZHpBQVHO2LDBOl9i5Xo46m07giTkdb5dIGiD7Xwf4Pys1QnsyPoBpRsAL0BoAfliUogYIAP6rck/RhgDCWo5JmjitSMv0n/SPU89vBv739/s/jNNzy6+ML1Kmc3J70+Bs2O/J+HL4If5toyO61geClK1ChrmxD9P6MkJuMj1+EwE/EA7hTkYAxjeVFZOFNwCyysL9e+BafrnHsIsF6oxt0UOkMtsdn6j+pWjPC+yKKGTWbw35OdYT0CzpV7GZUSsEEwcpX3q8V2kK2fm1cNrxXWDqNO/Z1esezSsKQ0UkdHgI/PLX9zU9dOf9br+gjlapddO4rUHyULLa1M8dRoVqRwEBIwB+WBS4hSAA+K6l0rGog0rNKPvGeVYopndzmY/feYkxmz7wfSh3en5o2/Bv0v61OaOaFULmhPZzdD/Hd0dUrlrA75bpPU+/Z88vE3aH0Z/4LJuhAtFx1DZ/SxzuNe3tnrYiT6NbHieMYqsERTpu/Y+iQGxJ9HNWZ9WLSyqGLrAh7FxnaOWh0zOWzJ5Lwy5I7c5xxbui2RM9cdloonHNLOMLnKU+LLJLpzQtDM3x0v1A9NaYowHSBIPduFKbZded60B0OnNeQHRxu5awTu+pM3szrQHQAb5YjKxEQugB/ldKALQhaCA8hsuXPR1ZK0W1OPuenI77f4fZNQ1969vwjXgwzfb982HvbUzlT7yL0fhRExtGWE5/qDlVR2InQjbwV1ZnQ8BiU1W1qQAsxMHBZA6vnSH8CJS0MfcTWjPpFK2W6afBtaphE4Iiku3XqLOPdQbzIKFIYfD7fYn6vvW/RngYVHIb956/thHFOlplKcVT6jt9D7G6hl7CDBGvPyMtAZvmNEwBz78xWwjTmY8jdq3Rmx674sySURI9qB54d4NwYv39R6Pfq75b4AkXI2BuTA10ANZXxLj2DAKA//30WjxWtnPMhgPGxK8kcTHEQjFdSq492D5mmGfXU2tgspNwZDd5GTKFttPdOlVABnf7lgnuYM34hW9HOl0JyWFvlEhZU50BY135f/C79ROwKzpKB4knmUGdoyg0LPy6TQ61OCIHfdGkNwfxrsrzkw3LB50PLienc6swtoyNCLjv+/HsTjlTSZMwORI6CEkc5hIiEXuUvvWALE68h2uoWyAuS0NkLm84UUra6qN5pnURppW9VqSsQ3Ck1FDbWGSamsHE6WLGXgbVDqAD7PEQZz8AAG0mZICUHEpMIyFV0rVvVRPxpNQkBHtifOhedULzZzU8JxQKhSAhHNnxZjrV1oBLrp0Xjbuw7Lfb/ptfNOpwjXCXhEKEVJ1+Fj68DjQKhRlUioI74wiAF7w35EZbKjU6+vG+rDnWe63ebaPSwk/KGO0BDPJoBwAZsjTPJnDBzpamnSWutG6yJPdI6pVXMRSo0yP483epAuz1qKgAqKDN2QHRxGjPfLbRm9Pyq3bUjQtTW4scUR6+0SNK0ni8GLUMzk52sjw0EqFjqaoVVGFNHIBCumAMptGe5WZM4+dadP79SH9pGUekq9yreWlt33I+SuEtY6R5HGMBxPV0ztaC9Cwj7l8GICNK2aYTcxYz7TVkN7mSLn636WnSevWdqW4vd1DbW8a/KAmzoQDs+YRkQ8npiI35f1vAXdQ7rdmK2xU32fNZT3FmftenGQjjtr/qjeQbgiNyDmcOfWkFACz6gFO4WQng401gXbvJFHjfraZtl1EO46lyv+gvvL49p+U+tifvnFb4Ymf2nFb4Jo3qo/olACT6uCNLJrOD/4oZKNfucrzSqN613PpH9tMLATKyfRBv1BL3rFt81WhW88nlOzBtOgASWISyoSJ++sVALf/7aZjO3WaHWbQO0liVyL4ftdaK6csxyU693+0EOcZ5i9v13A3r8Mpkl28ynLhl4Ky3MzfSuR2dIM0E8FgDD5dX8ReQUtSL/AopZxXy9aAovyjvDTHUM/YYPOb3hDRmoxBGfjQKP7kzHL3qBuxDB1vj9qb/Vi19F1BfXKaXZjGp8g9EvJ8A2tjhYYpQl3nac9BH3cZjbja5tKXtX00XtpRacbTzlJCeu2jEjzIpeKFXo5Z/6d4nNI6JpuiWZIjE4ndzl08Z4Z0rJp0d6UZoU3KfV1jqrdgdNBp0AE9nZ1MAAAAKDwAAAAAA2V1ROz4AAABM5vf1RCgmJjMz7eDZ3CkqKSoqJzI1NywvLS4vKDU4MvU2MTMoMzc0JiotKjM1MjU3MC43PDQrKi0rKzcxMjMwLSg1NzIoLCw0/O20wNoqIzoocVYJjpCf/7yW2Hm1/DHu48L9Nr3DWb420nvhJNR8ABTqUAMcBKDZXuB4Tm2f24xJ74FHR7yCOAubg/95iciHdLK3aeoNJPJoCzKXLvftXA3oJPNbVsy6o2Ecm9FlynQyvXb3zaSnQBPCJA8E+jgwUmQp6Jj+Z0C6GI7/iN2angRiNXFsnfR46IViBL0f3w9ekVH7z+/hRGqv9f9/7koc9kACmcDiC4bfSqDcHGfCtozqjsLDZ32p7djbk5rmhz/QNO01Xvjeztni6qGQEgqePQDaWJQuAbWDCLyX15ksxHbIzbVQC2kJY41VVbIRxigY1OdLNu9+3ZnExtzGrNR/L7fsLvpALQds4vQyY/lnQ72CmE+SE1sgk4AD7lAVeSPcKREoiFviRtOmx4N77hCyjFcumcZHsHOCDvUSbPrcqh+Irtc3RuEutfWQOTdRvc92BGtX65w7Q9LVGYmIbGPY8dk9a12/gHtR+dp7DB3AfX8SwmF8Du/v6fpCyeTn8dK2awSdOxwur6PJUxSFGIWIz9V35Jy5PFzuvlBxhSmdcpyvCwLpdIsGrxvv4gI8Vddt4w6fHx1MjesaC18LThO+KWzag+sBGcRvOZfwa2WcVMmJ87TQRtHkj7nP1p4vsfWB8/9ycqn+ufuxCZWqp7BPEfeJ+4TrZkPV2sg3sCzM97/Tr6pL5yjqGcUg6jVxIk4q4aA43YzqrxfEvztGNGhyrsAkSAiJnqN9X30m0iuzp0qiOYksIDuon43+ToglCAMxsJQZDCPL6hi/zjkv9+4gKWd8tNi80Ug4719uial1DcxW4C0Fi8+EwiUT8MX5Hr7OUtfW2amb2SQNizmBqnbZrRSJsmLvNgGzKrWEBkFXzjrLXDdWSYua5KHP3UUDAB6anGICuAHgu+YXvUZ0mCSxWiNrJ7Sz8IOf5nwfuT2Qmw4zE58yD5rW/rqv868n67DbZMnVvMONwtYmIzVgMn9CXCvxVy35InOQ6lL4/PH4NnoNMQo4EwcWMt0h4SupUmf9XJwLhBJfMcnGOgmaCSj4lpmMOJCctFtZuvUBecB1b+tcGmnkpvuL2dv8mQIfN8Vi+rqCK4TV7e9VEAOQyn+4PLNSHY2O0beWl9kYou9uKy00E8DUuqpyrVP1btRstfG0o2Dd5tTAspGJJe/svpB3/J+2za7Y0SfWeDQ6IXJeNwD/e/74kDt9OmEQE5gmsVIXdXTCMXbai8FZ1q7Rv7Obvnztg1+UY5uX8Xb62Ps5NIf6iKV7a2mlYYLbFqGZjxbSM4lUqd437Fr+3jKMNZtxaWVXRL1sEvUUhgpLuDqdxqJptidB27RDo63Ry3bRPMFcjz7qAh+ZAupEr4qpom20UVKJa29RY0g3ahri9VA24bCfTC0Z27SbEpceLgG2NUpIEKyj3vqWNkyKs768rdei0WdY1clAJAm9LYotYnYBgW1pvT91CCbufE7s6n8cO59sZ1EATAKhBMrVeWn0axekxMw3VzSlsptGF3Z9URo4dHfd0+Eeik958C1chQgU9mhrQJABk4wzlcBV2LTJc5mBFwPP1R4hO14o74wh3/K9R7YLQAuO+QA0/rACQkYgqryYATf86WwUo0WJTeqSFJ3rMPAe3Euma2aZzLXjZYKmAQQihcwWhNEjNYp2C8AFawH7Xq8hikVKWivbcyTPk8iyVP48bv99j+1BEwQORQWkDgjB/AlgpOCEG3OrooJDB558xOPu6lJWZi/pf0d/lcvHztJNATQGUQtUBcArG3CJXnHOep1kHBZBBK4zFvO4WpWX1Zs1YCuHiaq+BvTxmOBhNpkK3iddCeWYsG9awAR0alOvm7o2FyetPlxnT4uj03pLXi+u924OHyO8XC0BHP40gdw9WSIbVAjiPwWQcbCw2LZp/LTRpoeqIky/Vr2hmK2uxwT71E67S9IHBnxexSUzEAE0Hiluvz13BmGgul6jBo3ZTRp07p74LX7ix8nxdVPiZJtInxPo73ARWf77HS8ph990rJsjOxUATCJpaWg7R/ajAykEsSZqDTiXPG/UFaXINWpGNfoJvoXvAhlsXR9bvtxeggn8GX3KbrdTRV05cZ3VDoCPAxLKG5CaEgncA99WtNzhX9tHqxjOXvbRc0T72FKHAOwFS622NT0xC1iVDUBjgihWfgSzgURNuYRKHUfUUD8JZYmsl32Bqq3bzOfMAvz5vM5uG9w2OJEDbC1udFKPA5IXH5K9LmFxTaPifrmkMpwofdPCw0XeBVumRRP0CQuD3di8zWfZix8gYtAaC9ByMFGxqiQuWLonJ6Cvo82MyDK+WNotD6fLkGoKAEwiqQqsaqtwXCd98pIICeiGvJwIteNM0bRAP6XG4yt3descZKpEzAn0Celo92zQx/rQw3NVedVozHL1IEr8YA1tG0ebkQ2umPbHZMTx+eYQs6K/cbjp035SfVKcDhT2dNFDZjHYWZb71mhM3Pxrm/dexz7Iu9sNl1iKb59Ovj1cxVEzVJOkyMMPtVCvsW9UT1LU3goAJALppiEI6ZiC/5MlbLmS8Q+jVyx9lLQiav3648zxLpRB2Qyyl4YznXslYsmw44q1HQ3yJ9QkRRi503+4MCZ67xpen9EwHGvt7lCKDgMwhTOgkIFHGg0pa601fb1eXguk/nAxeSG33e2r5+1X871T2tQcbb1cvNR7S2onqur8hc9ElVYiumf1/LMRJ6IU4zh/68VqwnrTe5BlyV3UemEV5wvEVxXALt3/Tc4WGowgW6F+noN0kx7yVjC+L0i4XsduwJsbMtBE5YcEBBTOq9GG5Ewr4+eyVsZDfTJGhJFJHZ7bTpmX+j4362iqKr2VKUzFr0X15fJqAWiLLTIAaH7WagsFXr3cw64V/6vFb2rcJb7hX011a1NLS4BBfp58qP0a+V9FdgMPADT6gFMINUkq1mkBSQNuCt94kwbo5tZeJGX0FJGNQX0JY1XePjBDxrwN/0uYmro5BK6S+JcJADwCcZBUCgnJtDYMUC7ev5KIxpTldqi0Ma6q9Wa+21OxFc824xUvGgW2cwSK1O3GeAIE+tDgiaKngA6qbwNUFPs+mnc4a7M+7esFYharh7aEEpfDInLdTGOgFJvW5nn+rtbXiwD89XTRDoAHwYyKBHqBzrCuY6aeU4iipBsgU1QZjuypNdQMjrKVt0IB/PlQ51mTvMbsVGf+JEGHxLh9ZylHqtgmfW5pSAS611zH+9fEemIysesjDYqembvXZrEALAaBUjhIAjcAVtUagAZcyzkc1LI1ccHKTXKUvUFxcbtQBxYlv5i4Y129plql2tHZOmRLW6w3AAT6YDDYYg1iI1znzADEQK8YaJnqqZS4MS/xfdYQcfzv9h7VZPiFCZ+nwzfwuRp83BrKMgBMApEE0G0FYvzWQJCKUtd0uITUEydjaWqzc1jWxhb4NpFo2rgOBQz+PMNgM6T8QQ79J+oAIR3fU6EmZCSnM82bWV+Ln61oVypzIByvBOMJHtTxdCpA0RNBpOPD52UGtEvm8xuNIqJ81ajZtqZa9BSyGiSxFunR9xcFI2YrAOT9/EEjeYdqGJwdwCWrC8hMcK3iR1SLZNK6XYwbgBVBukFrhfvINEYxARwCQbRHyjJDjG82ooPFPl3Pl90YV8+SvQa0LT76//bI38pPmdBx4KdB9TGwggpxVZCJADz6DGc3gBmAn2bQ6cZhtFeNGHf9H4/YpXU6eouc5mpvs3IG66f07I22ePsFaSpbc1Ty1hQAFPKEaENVHMxHkaBSM32PGWWlO+d5hAgiX32huAXrQ0vvPyakkjEb6fFaTYrHSxUiRA30/fyI/TBwFze4EKpXA8gGq4kDs4N9GnGSilAVvrL227/w+n4m0R6R5Ecd0n4gNgbEiK6sB/wZPbxGtHMGnT/DddSatsZK33UabCPMfGo/NY5MSWVME29/hOGrnZhJqbJ6OM1fEuX1m6pb1wTsGcukcZ9Uc36Vmux3gBiahBoA9aiib3KoRVtNNYXRVT4fATZ/FBgRzppRm3efEQgMFkVeOxgt29HBTA5+3WmLFnoaePtuWmUITeBqCtKuJrZ7M56wA1J1Ueu7sKhR3AF9KmjcOSZyyXXCdUYsYDY6iQ3dmt4WCY3NHF9Xs/XNglx2Ji86e3dUzEmW7ep81WxeK74LABT+gPW8PTkbn0yM9RZY9G6S5ukjqk+IytzbW06kviZootXiD+LPpeZwqpNPW88C1+ypyEKi686w3v4ZAEQKiZOGp7Dk08e4dVsN+EzM8sUO1WjuzZYvxLFuJb+DIF3pktualEp2yoxXnT1qXj1MKAAM/nTWtiWV+BGTrOmsAYIM7LaqQ4ZFruHiQZZ3cP8qEF7OZ+2Nqa9Gh04CDPqEYD9YeWCBmnz7jncVD24eNLEzOEC2JTd7B56CzRU0i7hdyVn2OjYNFPL0TRmk31MKdAfFyDpFAggJCuCLHCJ2lLQigdnT3gBHVkLo7MLu0fT6LGsADO60YMzWZZmcqEHSVznBS866bPejiFZqalBRcGf6BWcz/3QRfl/fbeCFD/TxdMmDYu2MJI6RdeoEmG7AiGOi4Vp30L27qA/MnnkDlalvNCvQBVfJkhcM/lBn2JIY5JxGSfaqNegyWntR2A0lPXO+HaSfPzn2n+sWobZmJnvQr/jGtXI9vaTvNzYkJCoALAIlV9pOhwn4vReQLk7e5S1fcmJj9LHU8/86eop4j9XMMy2gVjtaXWIVH71IU1P8AQzuEGNrg1UYgE/ugC0XqxOjJdezG3ltktayr649PlgrojhkFgJLeugTukBjv7j86QcBFPok0BhlBA7+KwGdbqyu6fClgcyuXFOwHGJ/rtgc1ljZ8CNieAq1cLHkhGz5k/IH5s8APP6Ik3DVdgxe374wM4ynTyy2ze2iHOFdhDTetVqweaC/6d7yosNxRuvitr4lt6YG1PG8zr4J6ro5lGzaqnkCxNOQnLoWViGLj9hupCABkbQXtTN3IjG2vEJP6EABHPpQK21W1grkkLziBQhJnj6gFqGkw6ms5NkeFgcWMcs4KfqBFWC9BiT2mDImK1qZTO79tAnKGBJwKDcCw/sUcRm0KRDXs2CK1ayNQfvnOe/vb+lAryettidNthcBzPE8ynOkEA7h+adM0E1cPN8bRRI2PBIPAxp6ql4HO33sqzCWvuJhWP4d3F8t/o0THXy5IU6rAAz20GiXBZWZa9Z5J4By7LhmrkufaafWAFOd1LDbLrHO6qnMcI29+619ycm69LPRxCEBHP4oa8CaqUIKTXUJUrJprelQLGXpYiT1mTMzKlCuq84a+ZIoeBhBABzm6GhAaYJEuGbhEJJi3+7wOnRzpykNx7jlf6BbzdLcG9XeZhlQ1NojlAoABOK0oBSpN2YWYppRA6mhmzEmvpJoLH198xpNN5WMzQLGNcIHKKyLZrLUFgEEAkGwo+lGYos5r6YDtoOLTS1Ygdc3vC5kiJv5G50wqxjzDcnVrovebhWnWCbU1uz16S4TT2dnUwAAAEEPAAAAAADZXVE7PwAAAFkUzTQ2NjUrKSopMzM2Ojby5OozNCk0NTA1N/crLCoqKjc26ywpJyYoKSwyPDj4NTjt4ikqKigqMjY7NPoksaOZApTCRA7wNwEacLPv5/cIxOy1B71eZYzjDz15qaPhf8nqW7zXv5hjRcX60lpddwIAtPWKoudNmKY/hG9fDLNxhMT8lq3hAnLN2lfP8D6tyHjL4LZ1He1I5zD98QdB0eV8zGYm6AAM9nTOKJrbZmk+nH1+ABfohtFUUgOd4tRZ0CqDnxVMXEOnC1HVV13MR4kEDPZ8FRjTKt4YMvsDCAk0Z4urMw6d8LmuKkR5AmdUeJWDRbetPWd5Jw0U9rRhCCsbOQsx2TybICL5ZJK3lI4aci6NH7bWVIPmnAzmyCNnFslugg4E7jxJK9at+qSYqBkqCRlezjG1oXVBsK/X8d7h2EuUQhZ8whe8RXyaDtz1PCkILFuJkfwkoauw9GgoNYQ4utCsMrSnqogfYTi7uAqNi2oGofH6tg2kctqz2JWmAMwZy/ntBt36gQLR8xWdoCwFZ3ltTT0z3U75n6c+4Zxky9W/ViBzFnSJ777lekUIqjxHABwiRa9n+6c9j9wWr2pVBUB/dnq+3H5y+hG6TyMHvGfJvktRX/gQBTQ2HZbnk62IoT9Eni0vAdwR/YLnz5+r9wlS6LT2AdBgRkS5BJ+z/jrcWbdlypA2vKbQvDmaA46oRZf/+VLQOYrfZrr2b6JZMQAsHiloP+54fChJqvkaK0BDWnTtmsu9aXt2qjO4Z+cntin5it8/pTrrvzuMcM6Vqq0Ec+rxTAmaRyRImGtJTIt+NoMgJ98bnsxnMCojdA7HbTNoHA0AzbFOAIrqghFgPWud0QzZovlP82cWBLHUvt3PmB/OX19fzyxZ1YdJdGWM6JcJvWBUK5FuiIRTzInp0N4moOjObd6Z+7NjVI24VrkWSW3JV80VrZrQrmb+tyX1qGY9iVgAtfVHFChrzI8FJxxXtAlxiZLO8l7/yzcVkWvRKSCuSvARlqdjfqcCYNJPyxfUU7dz7bHwRsj4RG9JF41H7MmKPPh9lsj+GLNdYxo/+dsfGikQKvxEkDpziNxpTQCXbEjYofUQBGa71Wh3oaIbO74rLV7TAb5IlNhFOqRQBYHkpP9qQAJj0DkCAN0MjGl7kmAEHT1WrBmz+vNPCzfVDCxWdzmhOZJ/lfbru66L5n6985CTsx54nmrEjkEL0XsLzEPhjVUuCE9wLZpnf/xnLYmoe9Tk/p3Lp4uTNUJpdh57YzabGIvIhAQmOpl00zsi0G/phLpqS0WQWUrNUN6MtblvNAlGRpb3pTYt2uTiKACDPEkYgq52AjAd6m3pxxAjs6HoK+1PuvpDZKcK1oNeCO3VM/aewdvDfR7rdnvPoIvfUnX/3G3W+16OWzPBBJgWz9S4ch/9M1jqBDZIZNQjDK+ZL4D2vexcx+tY5oytDzoZoDuqAKAyANJgexDGhYQRjPe+/JN+4dTwxjRrD15+v+/8JDE/L/lth+HnoourhmrRcE8UH8+vUvR6kSRZ3iWCk80JoTk+PWgrkZB0OozUayuPQqSbSjjdPZA/5cCQkYvx1iSzoV6pZfFu7Z0cSNDlqJ2y7VjcM5OnwMpuRqGTPjgYYnwP0plM9IQEKJbXYIYHc+56MTdWOVrmhxXQS+Eo5rxPiY4a+Ynp9mYpWC0v5lkxFkigWZ0UO1JWIKHo/VZtq1BlzFWebKU3r7MISh8Vh1D5BUwOmQWCMIIi/N0E0sWVMIe7FbCdqe3foDx5/m2Dtvdysozp6tZ/r+yHWzpxETNd/ro7APwRaamNSeROyrtXzQBZIvctNphUmLy1js7PrXzdZy3seScdMPaFVrNUqDW2EowP2JM8xgQU7gBj9gNCGKUZJWAkNndoPg6sGLfy8/sCV/BaHDvjWK1qRAez2vygACz2oDQ0TK6FBFkvCzjSCuEA2684umEy7edljt7mhXl+/pToPvEngyvqFHgoFYcKkhAZghMsBg1QnixTBYO/Z4EGXDO0fVRFmYMYrgVjva7pCM4wgrQ+MKHFQqpxYvMxrie37Ety1XfwBEwirWikcfMLRt5/HEAmX051YVYnnR6rM7yq9x4mTYe8fju+oWPgoqHfSSkps7OYAOwZC/0eW9qIZAqk418TaPDO9topd2xgK72dMJblzsMnpUVDr7NIuI0nh+neH/Mo4hoOGSIA9A39Ok/Pd+vtgACgBf4rBWiwTvRVOKhW445Icks2YpxW6fE95rnx2n5Zvda6Mb12FdkIb7wEBXJoFBIjrrKXV+c3TeanT76v3e8Vo3ZlGmTqDeBpWGngGANgiJxEMOzg5KiN1gq7i3pveS6+vH5s7c75GJP+87n/qJpz8aDtLXFirZRxU2ZVa00MEg7714dy+GB6jKZGPJaolq/aix+DBvWg5V1Ps2ZO/bVvu8UoIdJfanLolF8c9zFVrfjUvCt3KbsRMUePPnBrJACSq/CWBjPzofYAZ6tCnjhPqU6RpCtfKvf9RFCbpMS6mXTSkdq6sJCfgrlAp7h2SIi4FrGOO9RGx+w2FrHCu7WCjOCyPjaqFWv11LqhD6M2JVD1bHqPy9ngQxdUDWW2pUPzyAMMFlHEboPMi5S3G0C4YA3ACPldaUkHE2gqfDjlz60Bx11j6d1Xo8+XdiYBJBIBZJ411Rxc6np/pwGdivlz3XqR0HY1U+hNywWxrf6Ly61Y+286t0sP2AD89TRm2zeVDt4rOkAcTMmhi9a4xtPSW9OoLbM5K0mblnP4HfaLFlNgIAAM+jRoHKQe5/HSZX8jQUTFvERb6UjErfFlSr1gzRrcVmR2/ryUy9eEJQHU8fzMtrfsXJexIPmEkBAkOJ7NN6lRmZpRUGzvgNvGd42M6FaejLQw1ib87SA0jjsmV7mUwZ+JAA245vOFJj2YjNaTOax4uul3YO/WeuQL9X6pxHWfGsz4uzWDStuyDMUEDPYYtHsaAYB1FwANLs3VVTd6UumJW8/fezbFp7WyrS7+MP42W6cQFRXm82y1vOQrRUXTS4sB8iekzCDHdLBYEKLed/5UhLqzN9qQ0VbQqAHAeNJA4rQQ2mlNX3uT8+cmkw3Bf/bNsOB/H8D492ViWS9nt76MRB+bjFUxSm1sezIU1/Ik54uR93TgT6ved19fVzi4KAlPE7nzOegl33sQ4JTwaKrpIFnz6AdMVlFJL+nZ0amFXStoa7DvL09mO9/jQc3zljV7sd3PImrd61gAlU+biBQHS0xB7fnVChg4b1/VxYpL3yVNs9tSrFRLcZUJ9+DZIt/FYO8j2AVMUr88Mnp2u2i5BRCi5pG02N9gC/IeUbPT6Mcx4j2Cx6KFRQ7hARzyGK2NO5UM1F7nbiSICHH2a2IeKSTnuli6UDUaG56+oy8pYTYX9aJMlBcABPoEaETKVLx5+2oGCXHQBXt+dHMKx2IGpdbTRXSDLkIljr9dDmNvrgIUDiFhdwnc4E6VGogLJORRMWciEUeMEvw1w54Bq7AQUttv19N+/AckDtHEjAAO40yOAOESfvXWg7hPxFhO2mqegpXNNYnYPdunyDkXD+TxCqxxkKZxCOm8LBAxJDBnWZF4HgOdcgU27zKHcm7WNtSYzLWllgDc8fzMhhEzEJSXZnsILNlS2rZ5s4lzHnFlarZc40OGN8rMRCxnUXCuANzl/FjZhGwmNtJ23m0gJNHMUSa6S70seUqlsl0N+73jEHGMebHfErSiT3cAPAo5wm5OchbTMf6RCdKxYxKTOVBYnOh1G7sMcjlRk9/VPCQOdngxEpWVZm0JeWbzhAG8Ea8D5DCJdtPRoKYdAPsWHt21WkCyHajOMtiMnsgc43vT9EY4Op7s59qRlZ5tq0pPhzX2JJOJq0y9XgD8Mcvhnwzt+eIzXJbtukKQnGsBRmFkpq+4lSS57Psp6+dDF+FQ51eKEcvDuyeIzPKrRG19CACyAPKnHBCtX5GYvpkHXrF/+r0n3s7DKCJm3602UccwAWHpATC/zJDTeYCgkNZGMYbbR7lkN5qbx6Z5c6an2fEhcu7Tn7+4lp1vrbVL76zJZDLiMaoGGoULnBzXvoyM13JaKhc0fv5zJdvmBQo4bO3cSMJSAdE2txz/wrH46RMyGNjn0KU/+8A+xbRu2aWer9atAWLJHKppdX6Pi4dKmeXiixQRqzbeAPEZKdjPCP6kAT5+2wBp3j/tqd7bOk6aJiSXXMKa8aqiDyW3prQWzO0SsuPBvePi6nYFSA1EO+OLha1CIiHrS73irtaG+wbKJaw/u11Moo0VhxsAJPJQZY9LFVmPn2ZIDbpr/bnvxrZkyzyJgx2LvSvwke2pPCfOSI8rLJX44177PjVZ2N3PXQkcCvXZIG82OZlGAKvaXIDeMV2cGe6z5C13dEpOVknCgySWVrqzUw145uOYvVqstbViNYtJ9hRuANpYBK4CsYOZkd337tz7Y4YYcloh4FsnE4AZKAygBzlgjDFKaEvfeVHUkP+J6x9tNHfQcHT08lzbfI+Pfq9ubyCV/J2MEURx6cRmqKuiOP59bpYZo6J9KHFiXa6/vqLRdOWozKzGf+4NFvNECJN0q8xT+hmZF8Jb0q6aZSV0c9JoQ21jUVzh8yV9omkK7yHL2osJzyJF/XrPGgyPEfUwjUeYMGQgY05sJliAtOzd2SgDxLFN7Ba6fGDBVVe5ivZe2/7mNWeLbtiVamYUa+fW19fnlyI9qIDkPjruGyjahEHVgMKVMVVVVpflAhB0ADZHDLkanMEp4HvZZU7rniO3ZxnXCAwFEJYGFJ6UDshGaMu4mv0wEdD/h8hQRMybxKP3fry/LPYXzr6cHS5P7wh5tiJGoDAxlolGTOCxrzfyjvtPY+SeXYocVfM88o8/WR/Ip8EDEtXM+DD5r+6Rr7RsnCh5hx3qBUs/KxTHM6v8hgPL04BMuer7K45cE2pDhDOTESlvP+ewVf5hRRABDR2vBEE0Q0A0yTp+WBaFqa2v0PbeQZNuD9pxmQnVZP71dmvhcBKRByiYSqdNfNcMbCVpSD1q+QlR/6uty269b5nMogPs9YqjwlRtSJio5vtwuOD1f18fDr0Fkx0LVL9IzTVmGjH63Pd0JdlDBwTuvAE4lS6IKYp8XACuYsv69uhAOjoDceHSJ1KjbLYoJJRUNiwQXCFiBPTxRM6OQZiQGZH7d0rQSXQ3ngiyIiVbQH4C9Zjz3cwYs0qURN7ka+eJBuzxvIYtlcVxom37tQBGksOVaREBash7xUEypHsZqKWa3THPc3mVoAP08XQcSGqmIKOe8jMLuKRpzmv+Bhwp44AJfQuS9zmCzmdX9oFKcZu20wYc8jQN+N4E1E338QxYx4ayub3heNpPDxYWTEGd82/+//87bq0d515tqKPeDdzY96cvAMwxrxL7FgskX0vprXEAGIwlY6fp6mksM7lSEzUfEr7zbUoSkSvWiGWnECm2CkdGOX7ezW91ABwuS7CHeD29X+wFJenFDUNsAnCKYazntWO3B9eZmZAaagigHo+2ivjLQ0vU9rXTRUG7Y6FX/AN1eQAAT2dnUwAAwHQPAAAAAADZXVE7QAAAAMeFlAs8LSw5OOntJzQ1JyspKDQzNDY4Ozs5/wP06S83MjUzODv/Bjo4Ni4sMCwtNjI2LTs4MSw2Ny0tKywrNzf33BWvUZ70aOLEstxHXGMbgNPjYH6+E0Wk2TbagOqySfj8vfw/6I3Ly5QWz8gENB59SqvTxhvjFCKu11Bo8HoJrPaQktcKweQgNZywvw5/+SfAE77mnFjucQAsEovyA/Usr1iWqKdbr6UAXAxC4u5HJPHlLJfp9Q+DjdR/s9I688MQuIu5bRmZZ6OZ4uv3GEl3kABE/nTVRjUEMbqAsFUWggSxApdX28tGl2j8mcEsg2+LdQkrjRtd2E9csDetklmU1WXW9DzMnwfWANpHzIrWt8E4fgK1ef+9eY/rXbFH5PUk0DGbgDQDPZCIecIEqXRIUd970X97uXGfNa8Y7qKMAqau8n4y/fH17dmluTe7QzHGGE3VSHKE1lotRpDk8n39+My67ZnPX9xgcKbCzrXIVWytLGZac4eEepTn4leDA34LEiAhDrWl96aEb7DzYraPuroCTQrqmkWGpvXJV/2LdhhOCoxQTOJuqkkSXI0AFNb/8+dvvWQ23IXd5jQpNKCY7i8OTQZftKqtz8rmbBXbDKl1e7BYt4WhbQL4Vn4dytT+VoQMnW7p5eGvMK9OB+sbAtAA9lfkaK25JSQnUVTa/s9TH2/m+RBHVCITOAJUAeEMWICqvJRlYZWizb39Jza8yVVpC4nMF1ib1MEzH6bCrbOZCxMjJGI19PLCKtmJDtYHPrm404WqkxFaK8MkZmu0XpiTppdoVHjHj1JIEZUJtEJ+XLusVuggRBgzcUjgs1EKxIjjliQy+t0fXPxQk04wdMEgqfaDjL6//kB4/OVoATKVwiliRVnxZNlXNS/YiUt7aR9PKUEmVMhu283+qx+2w3rCoiVjg5VNaMq5mxMuH2gApyLD+UKW3b+6xRTDqGCUMSF2v6gs4Ou1RCZ0FNAAHOL8DSxFkTWizUJBJxB4WB+0NcVo4X8M1qGb9Ig170EqNSwObhoAFPpEayiVBEzEvuoC7mYyXIsEWXP6/LSLbxY94jly/F/o25Je0SX2q9y9dT1Yt6Xi5p4PAMwF/UEapCxdrsVuOwCuHKtNYN4wog25v3mOy9ZUbapE2vOWFwsqGC3ffAgP8G+a3KsLSpAzHO40x9hOAhA74wOICj6IExqokFhec4v1nNPwly3SCfkke77o3qYCLAYFB7IQWcaRI62zALjAglHr3xolWVEmPnrJH6h9+nR0nSuuK8M7xKxQACz6BAsyGxJi6bc5gJF8F35WI9aT8q1I+Gv88Mvz8dPRf1ah6hTX9G0CLPooBZwVAbH36g3oBMrPa646GmoH6xNmVhZoH+azzfa93g1sR3kaBTwekYSxMwgY16QHAOUi9nkmp+j54TqecktfvxEWQUAWvSMtFMMso9TU1Nvchiekl9//ewEU6uhAbmFAgmN9BICdNVo/Xdd0aKNLN6KRkPb1mNVOODq8rZ3Pn5J3o1ZNw1Q1RbOk6BP8EXXJMFSGDt4O0AIIsXwBc5c+Iy2KTCc1GoMs030yJlbV06hf2ecQoWBaMcsfqWsthlAABCKBZhwbYW5o4NoBAnSKexv4e/3WwwIctmm04rFUjlQG/U3WcZ5yGxoSnK11x2e7PtC6bdAJBCoLNTuyVi/FZjJUnDUZAEjZzoFien8fqEVXa3s/uo6ZsxtUPWCch7k2VYTUhOT8en6ooEQ2mAAkKvV6uyEz76vYzKycbr1AIomt0dEpHv+7EekkMTmdit5PjD8sZq9vj73hk2U7+3z7F9zGOe+bZh4IABwWdahn41L6SgQXg6WVGLbGgkYhhmbUd5gud3RARetiR7VXTPOBeS8ZazBuqhpdF79unwzHL1/V1GoLFCILiMdw3yYVkxXDcL2RQE2JocU6uF0amNJIm4Rw3HB9GScxHywp9mwXA9FKcYQqia7ORGxavbwEOtccRvTImSzFxrk2A7z9/2CSV4g0xyg1AIAxC64EAMEMEUjNUwMHngLIYBhEL6eZQlsM/+xupo88fGxPN306KAOAOjfmWqKgKFKaIEGvTFvtV+dZI6UmaMVkmP56LECrGlLN0ZVH9bObhx80149+KeFaQgAokGpU7o45bfWJRi0PmDfs0PG5JsIKnt5ymalhBrytFhdtSTxQVaPsjC04VEU6vafpjAdEqbI5HE9BujYa9qJVEjIzW+MJdqzACfJkymQGKSrOOwCvQMX+hhhSr+068MixcxxUJ1cYqpgVtloySFz/4ctTYXf7ynZt9IMbHubFrEGuzZSjPhfIvY9Zfx4AHrnEpoVyMCFleP2SV5gZAABj5ieQAZCbA5QaIIMJRlunKH5tv/nx6/DlEA+33O3pq1bktQA42d6eM3GFTtcFuD1+f0djjPpSpguIrXl5VTs9OZB7efHrTHNi6gQXQRBQj+wO2vUogAaFsvu4JXqivLkOE1MYWeFtYLUs4qrkXZI9H4XEBv7WHyexQjkCi4YDjPre67ASzuDL7T6olFu22Q/5KQu6VKIEYy+p2iX5J1L4p5SUvMZ/z8HGOq1VjTtRIwV1wmPH4TcrKHHl7gcxQYEZ3qkpr6ZdBnqpkMf/wWTNOZ7B5aKKrlTM7QLFVGg47w6KBxaoVHBflCqYgUXpfbfR0/XM0FmnAZ7/QAMwyewAAx34dcCAXgCkFoJUFD2R/MukNWuwpy0mU7Wj+5UW4+54eo1QOp3RIW34PKau0dKSuAT10tO+D9K2LgTFI3jzCqp9/7jf+jd7q3WlV7mXO80zRsR1cgxAK+cTAoTvu1IXnZ8Ik1KSgxC3SLcyU3tFHw6vFbswQWbaDvpHqHp2xWzbTxR4PCPlaKK/+bHNisq24Z2ru29IK1wO9MqbznPKhYvoXLKezmAwaNuT/htjUe7EwKl4AFlxIZtUrS7/cA71OZsHsb5AHnDB6hgA7A19znOcyRMdRmro7gABD8EyCzAjFLl2yezju0mlhDaVbLl1g3uIteQ7iLlUNAAEEsUUxG1DkRkp52y9owYKLQDHeuUiq8dzxMTpJ4umaHKtOgg344eDE8i1rd/QQ6nJJgv//2cCLP5Q43muhgUR61wCQUmhj/+IC43caj5jnvFJDVO5tG4p6VueFe2EZmrsx/OzmyaT4QAEIinrAUw9HIdqBxBUouUCyM1fG/pdfaZFn2syUStT6luGzoofY0dunErFng1iy3YH51ohASwaUdqeSthPIHY0Po0EFSURdplqlWUV96v2Z/71hcapB1vU/8NHUGsNprXG8Uh/BLkkE+w5ywmec7R8BReTpbFZb01kgTqxlaQgK585bRNpqOXTwphiW5eWldA7bbn1mhmbhqCoP7qmMg0CFC6LBNvuGM6ruAZDe4o1WYIvEinb3YQstox/VHvBauuWe+nghPhoQuEd70lt77eWbFm1JsXDbgUM5wAS+AyY6ds6LNO+OW+NvO5ify9Z/UqrHqIuwT6fG4ANxiB0TAMAMrZZA4GNBEvwSMJqVSHMHFgjGEhecd50OWx4H3PnDk7yiuVH74R+rXXiUpTtXKeZRmuMY1zblJvnrZVs87QjzgWOEFsFZP7Sp5k7fT+1NBu16ZLd/5hq2ZYFKVGICqjRtX5c+jCL2w+741nL9ov/zE6dTsYYI0BoAgeyyWkzJqIOriNX700zZubz8/N2AwnsNL7411S5XL5eKwzQ4aoV4PfvYjBYNNZefTV4eDa0V+2Aw9ywnTgdB/OOXB2XAwXDZKt5nVgtRmHfStb8Hz5NOaN+3nWLt/TQsMIpqyQW2zhMJqHxjMvu7mhjmiiPu87kAmgRdoFj61G8olxMyzb8R3S9GrRDh/YE8S/TStd3VhxWLTjtV/28k0UAJCbF6ImjeATTxgCU466bC0BshuLq4M8nsr9M15O0WnJwd7bpvPDv6NZJlQa4FM5/ZT+UlJQCSxb0Mf0pmAX9wrRmnBu0W9ugAbEOZ397XuuDq+FkOEdi+Lk0mcrCZH5YvlxqVpkcPQCFV0odeQDsKQtDIqbUD7pJG1Xr0QAlYB3gONDlKRcQpvlVVL9VXtgTOtL/XnIgWucxaRAA/CkLbBBHqncA3cLV6GUcQI8QtrN5DgEVPR864+UO2i8kS4SSvdDWi+qChwKkKXfHhNzCv8CKxRJqY1xyBARhkpFaoy7jVGmlFdouR21+zwu+j4kYZk2M7rgwDgEMIv3BvnbqK4AkMnrfogRqAiJvhD6PdkWc/aRopXq8wOmK6qzfsCn6bztSCQQqC2JAfB6rl2nX4CvHmmwGEpcwGLnio+Zp8wFVPy+arzihGLLY5fijxFTXBhQqhZAYwUQPoJv75FunGIBUyrH+wouMIvxuWB/Tkjbk57MO6P4blNnpEUpsRt+nSpzpZqYXFjwqERMETNRgVVsTW/CBdexIKPBMljv221+H4mmLPbPK+6i/efFyNrpUXYruWxaLU+tFFDK1ECid96PIDFSP644LCGIPy++h74TUNRxLuJApk5S8mkZVQrwAD7cZ8av0iiQ11wrWyFQAFDb9yZ5OXh2tQXSaT7oPiBoKr79tWUk2x78w68ByC8/AxX+1mkQEc6zDfJcbDCpFFbx1ctaUmdZMEsPaASQxcKyaDTS3P2LmLGXNKE0Mced+etvXFQnVWo8Itw2vdD/1zFvWo6VM5wNELhn3TDqhJ5GgyASl7e/roIl9EIYdkqMAX1TW4yBh8dC9p8Yc9dCDyynoih6xGGqMF3S4U2QrAAQm/S6gS9OVCBgtmDZldwCkPlSsCuD3g6gobXLc5hBVCnSpdTYcVm9ZOyyaexPKLgAUJr3GE5PMV+CQBKbMf7IEyJKFfbFaWSREadFCLoNl96mMi5sMtxHatF9HAEQmMfMMZ3KnC7J1RoBrBIBjn6NXNt6W2vHH1yJ6weR/m6ny0G5xE02lT+xREuM/JS/X1546DEQqgQ0wtWuhFbO5eq4JBiCJrcAVkfiZBneaJPSsGfxgqt5+zEpHKfV7mWlCjNWdKt/WeXWwWHIMIv0xKDrNEy2YPIX4r4gZBExIIIumRbGsqGkYBSvF9gPEL1YmoViEBkThfFv8JX3Bczr8Roc9NXTXKC8gCJMwoFnsyoqFKVGUW+GQNSM28it2UHK8huCSHQAMJn3BnsnUK6KbDe9dPCAAJMtZ712GinxQQSvWeCH1C9EPhkcNfr0kzoEEHCa9yXOcnLeA6cxVPRtIrOR7U04qlSSyb9HioJS3LZfxQ1ju6Q4zLceYEQA0KnWzZ1SpV0FaAtSaOoBEj4NilJHDBFLPB3uoLLSlvEXyL2TZSWJG5gEN/DW9VMLYka0G5bbgan5SgwCIMj9yahCL3b6pTw8MDlRfCH18OW/H/+91zrcwjk85aQ0BfHtrBSQyryqbXIYig/KhF15vqcR0OnDboJRszi+sMq0+txMD7U+CcxVbZ7StdNh+ZVyK3IJHyqwGuwY6+AwZG1tfcna61Y94fzN2UbGveI3zoY+hDa/9X2Ai4C5Mhxm4qnlgZ4WtDMIyE3UkFcV1fe2JLkT91OszfR+Fix9HPHJxnB9SVFN/u7m61G05EbQkvn9dFncg0qqdXcnc8mzGlVZSqwuv/D9oszFRWhZuKpOrkXYPzd3dl8ufWiUlskoLS3XGx7JaEiKEZ3fxYwlOi4us0KQ1HpyB4B9iZbnMqipKQlLh2QP7ZS/BBbUdsOSZrl5ajrPAiVqtN4v0sYdnb8ji0CxncjkIqOfn5+cIz+7bYN2LHSg+m6mkZGpKBgDAm5NWmLmo44GBQuMPw3iZgA4AT2dnUwAAQK8PAAAAAADZXVE7QQAAAN69B/o27/UoKiopKCs5ODg35uv4LCsmJycpMTY4ODU5NuspMzIyKSgrMDMyKSorKjI2Myc0NDc679vrPqkU0Fc1YQTu0Nk5vt8MbCbOG/pdsDMcAOpwALsEmgV0yJ2VBuA5jykGC3kx3bz3m4KtcLO34bushfQ3IRLSi7WYifVVRv/oRasSzwlOsVo9PMdUEEo6YfKb0E5LoVSUf1852HWhNdMmK11Q9U7tXns4tqDredX5WFjlbVpWo8JITKoGJ70ElWXZYu04lFjyfG/HrvC0C3JvfvnjRLohRErsqRhsaFtc/N+E9/TG8u7gJxr2tlNHAPOsx9SNjCE04oVvXbJG2p6z5vt8Ss7OdqY2p1BoXUULVuWG4wXRrGMC1udHpSsqUYrTZtymEgA2p7QUl9EqstH4UPJ94z4zPPbYkycnDtgPABwBELADcAEAkxVXCmme5UQLRdF8xA4YEL9aXGaz5aGJEW9Un//byMkwYDRiRrRUYrhdO2vB8MdECE6QqV+DupZS5aYGHeRCAMIkSJzHNQYkhR011RIiwStZ9W3/+KJCOo3ZAG3YPoT41lXC0fUJJI9BWYYDhH7/JpnnNBK07G2IU2YgBZAl1u0kMz16lEHFHcnFtrR8qNmTtivmWO8TRCgqzneuC8f2Gfxskueb685KDJ/ZLOLAk3hgmr3KgtRIqShFFGl4W0+ro9gWi8vS5qHEXOQSoiJLTNgFAOQNy2JAAfpw8L6NDb3grLkbXW3esHFONgrli7WkGgeuye4blW5m2wAsCkuiwpFyxdhb7KsWGhBMe1JvTIyyr+YkR+aI6zjznluS9J31G/2wRwA8Bv3NRmeNYELupwGISt5NjoMUlkcbhPXKcrGbMy76fqIZSUcmM3qJ3BMkCkuHkYuRMDVsNiyISD549qC11akNVazM5ngSDjbP++HyTjfEKoGYABwKy5qNKehE2yoJ6A0f2PbEEljlwrgNjSWO5xLHg8IJJL9kA9DxGBLMCa9rnjFpdFIlbgB6wRoNJA6Fowpp5aUVVZs+px3+jqpzkmR/w1+b0TsATP6EYONiIktfYlvbRpGiS1z+fp92auiVklW202yZJLZoydalfWJP+T7amuEVZ3ybVPT9////vwIABAYLNU8USnjYALHGCUCldnPyFdZtpNo4j/XydZh+1q+1nhaLuwf9gdaUPD0IiAjltZVfAZOBOwAMMq8STzazgw7cwuifHawODagXqKd7xuYq/7fa0NyNNflyJXjnbt5zpbXdXUVpxo4jnxjGZTURACxCr1o7fSWTY6jd1vb2GvSJov37mlQdSDdj9h3/mXq60+NySuReZP8CmULkwl4vs1VVcwPz8gAa6OQocwCkJixCXvz48l+KfN9zqt8WKfeUO/8Hmq+ynDZzYGQBXK7wQUm2hLGNDLzwFzPZ1nWjrl3oPLROkWwa2UlbtdWmT39mJjH61bGCx9h83W+eN6MJDXBtF9bz50eUVqvW5s/mr22/JNNmkgvODckOFb/S0YvS57CSknBKuDpPqwN3tLl1LhoJAEon4SlumEAzl0IJy4mvfKkd3WUryHQzWmhiKHLgSUWKlaXPFg0KtnCr1QSF3s8Lw5R6va5dc+1x1eWBkaM5uaLKZMLnM+soDBjhC0J4vlSO6VaaewrobAEwFP54xMLHYKDkjqT6vtoCKffMQrwDzLAjAPAJQBY8ABJWgBUCgZbDzMYwxvr99Fo7GY5mNpjVcMfMMigcGoeBHx/oMdah7wgPtpKS5ojhlbQ0jA9HeESCKKreewELSyh4Z9PE2Q409xCzH4Z5kySgDVjPHjzZyGlCfYhL7fGMeLleQbwotQpgohrPSTKFZGTRFoLG1UeihQL0E2KR9FGp5x5EIlEQJ+3dhBCtyz6OjXL0NZLw4rYMcmq04vyN/65FuTPQxI0gyyrFXS94e+92P4wWuxiYNzpt4No8pgSWy7l852kMzkQll5kn8AB2h1TsuBAGGp7gfTl6jlvLTLxJyAkAOBpAHWY9MdmAboU+Jm39sGXBFOs136tMrpOLh5X1HPH98v30d+ZrBajV5mSZqk7FyTB11bW6J3tHXTvnoWckBBBfQk26B3C/mdPsJRYKqSHQKnfanJIoqot4bk8GuFjrYMhl3zDzGaOxmy55zu5zmOupHEPhBbJjv6jbpm/ifFVjOW8a9+wdVluUMCAVUvg31AsZivLu/lmVxrHT14RMQuXIAe95I0fRm2oP+3J33bZ9BseVrwmY1q91PNtouKlSjPl9YbzvXi5W56kXzHbWSywKqBuWw1tltKUuW+YBHUqjAwQSy3VD7pJGRk6CafJzJKRG7lwsp233IXmuvw/TKzVV0i1RaphTmcC3qj4bDP7KOdZM6p1bjet0ANCAxvPMdV8Rjt+JjUEmMe1QqwhbVRutxqDXZDgtAUQKiyeJi6Mw79sA4RpkXrywDuwldao5TeimBgITVnmMq1AJ5P5yLApLqoEDJvh94eCSVruHx5zsJ9LOBMkUz2coJOh4XWeQTkyyZgcADApLmh1BaNCdsVktuISZjX9WCdbZsLGfcKvGp0BTeieKro0XUbcBJAp90R6Xk2JXN+JtjxaRcDzzQKpZb9odnjA5r4EhrUbf2P77FK4plgEcCgu6vV2kVeijnDJAZpSX5aUmoOaYD1TTt13hChUDcT22mXjiRxGtFJSNsXjipVYaLAILRaPuxM1O8oXm0ReqkA0WwvwP/uNjwi8LBHn+0GsnXtBx3pkO7voXdLjDs6HPmpWHjX40FCqvMONgTJvuMauanzwAMWihAdmzNyaiy4ttyS7DmkitY8n5u1n+bUKbUiW/5qzv/SJ/nLE2OgNMOj2C/dPDf+wpqwiN675yrjGJYl+t9JdpJJ9m3Y9ULpGdV4gj9Pn6uts5Nhjalw//pysSaHWKASxCi6xng3TtYn9Nz1vDpSHQHZbmt1QnXQwOIp7TD9yn1dNAn93NIJOn6N8NY3Adu2YVQuoAPDa91rMtWaX6w9Qk11po3tHSgcT+nbIctlssPSunn4zWa939t+j6QaEIp+8sWWHoILrQ9AyRjCgCNDYLs+EJ165/A3Xq1tABdJPkr4n986xl3GKVeYt7StrYdNtEmEXEzh9CEi8Jl2Wr4xWjC0UB8re0+bSMmrOslmWRlZomvze8OUVHFCHqrq+XpkFthmQKGkBHEnRUJEOSrcwU8fdb9kfcEubTw2V1FUk+rhfj02rVNrFqy2p7irqq9lmWiqrJt+no3vYefD6/6bv19IAUUC0omdeX3cOxGWRFATZByBTfD869ohmqVQtHLAB504zA3Bxwo9YaCyOgZufYU5K8lDbgxJIglPgN8UvzAjzgahZ4qCK4EKW1CijDrUltDlDLZAbwpLKCARaLC856tbi9lYsBGTGD9b5Fo48jt0syAOegfRfWo6Y1BMCaQrf40nATIYLeNlJ2gvQgOyweSyeJMLfAW11N3gBj2NPHrYW05NCc6/ZvXbYz5aRxfXjSIBw5ghsTbBaFCmS4X8gY+D9dQBW2UY8S0zDY1Ov42PG1ShavH9Cs8hpKHE9wtJrONFPAB3VMf0IHbB7FClyYwE2Ql3WAStE+NyR6lXxTvalNrGbZfo0jUGkxPOsaHpq5cGOWZgwDtOwjZgNcMoVmJGQTuO0kXnUI0HWSvLyQMMlNnhsJV+2z+cMWcjtiSYYQj1lhEtlGt8n/U2ntATweaefB5t65lMlrNiyISH78FHuMupPYIaE6uoubdm9+6Sb2f5oay6AAVB79TaHLctHH3uQTwBj4GVwsnR+Vwxt1Svdwn4L+KS543ceeuERJAUQW/Y2hqlqfc8z/eAHimBh+s+JEkZHoPtqVhmKrnfIptrnwoF6nVKXeVwBMKsVmnKqXhVOnfrwC5SyHYkU2EXdp2UKZ/auBq99ziIUZf5KXtfT9TGSJBJ0LAwBkGulJQ60RQgz5200QAI7duigp1cr3my/J1YYGq54J9tXv+Ia4nS9badK62Ibnk/65tG5MJrVmR4WdAbk69SGTxuOKufkPTOr0fk/XgviEEEF0w2n+kmSd51ahOkfoD/+kjnNIAVQaPRl0uVYDpaH44kqQKrjsCalIVJEy6qgFEMkVhgfRkMHtaE228cYAXBLFCHCLajA1yzcLl8SlY3j2ubT7ssLQ7binZIivUSdsL1sRSFCDZUICNB4LBkt4TThAhQb88BmIKHHKZJRS6rqOzlz0csPW10jHjUa/jGY47KyoAEwivcNIlW2WHYVGbIsLSA1uYnIk65LjraQcUUiUGrpxvMaL6RApp93UATQuddkDTI4/VEJWfbVCzyjvPM9NJNwd1Ml4TX57EY9e3Nr0VFzhFct3CriFAvRdVpYAFBJ9zohRZaCTY4J1UkBDuriazZVMPJ3y0FKqGYNSHOchnooPemhgDau3s8ku+2NY8Xv0U7ECTBrFKoFrWPR19pn8BMhUbN6FJKgfvtfhQxf6qKZ83nPbdqX+I9TnA52LQDlvZw6qCz8AbBb1DVR9cGr13rcvMDh46NrsYrWUEu1gxIr8L5vd9iF1DpbSEs57ZC6pzlqhi7pTRk/dFy9AB+fkl1sVte5JJvEt7k7q1lNjUy2f5Kjti67ZbcrFxqZ/pYnWNjwSCymFZq6QHYVm+YpNkIkdTjXIRHbERT8dn19OJo7P04ltUbdlyvcOyOZ3D56UCKlZEgDsJXfiarhZzbzHrM6+A1THiLuBJDTtG+8qe5+1tCiK+9WgvOZ+6Rd4BSnTVkcj2OrQv5VIKKsOLD6LKLun5pSVkopk+s9HrbEtO9CKJ72cb6PEakX9a1pcT6wTljgOt0nI0P7+moEj/lAB/iEtS+ByALr3DBRdVaOlb15955pmNgNOfO9v8X0N+uXgxO3dBowOeEAXlsa4aiIJJAFZEhqosCUyYLfI1EfUaHNjs/X2xmhI8OnPfE38dS98ejp593K2tVbSsoihqwNLiSNwakXLnsWHZ2Bh873/Zh9OPvguqRFw9Zzowbvv/llblnHUCjL/ztIiUEXN6QCaBYxFs+3CMMXw+RUnqSvTyGMeUqvtzoDpjQ46DkDpvOvcOlHvKdkEPD8vLqxsHAPky5ON6wqwkJZoV1YXZhUEmcRwcVA50nDbF+cm59kZKAC7vuiyGApoHQitzqBeFKA5VszdagEUnthEZMmsJF5y34slqhji/Rqpodav9wsAPHGABDbrwkFSlnRBVjHQvFy/amJ+RlS+mtPPW+OI4Y2/QQIW9DaUtnO6Rpt70/JMjGcZ0EHrrTWbAIRltdd72s3iW5Miz+aQK2BBwMSoowTyhBoFstfdPeaZ/7doaLThuJiOAqMOwst+WnsdrWrBU3oVBAiob1XL6aSgBJ+pdO+AfdQMcGcv2vmoSx6PgQdMmi0ryIqhxKCAh1Ldxl9Cxj7C6Fnebo4E0uh1NShtbqds7PuXs/Fm2XCq5ZwLfCnfkAMUttdUlFhoS21l6RCU7ivrF898LnlrdyJAHCCBqSQHwy9USj2v84VhirujzEb7xXBuqWaHZ1jIvROyibvDA8k4HCuxev/1+7Bjk6NhbAwH25RShTz2sAh3rmw3AQnBV2dznmxcSeQlDMHsjS3O6V+9zIL8j6dJxJRIojdusPLhw3MTZed90BoKhezmhby4X3rLJ/MCdBJ0Sn8xMHTzxHFAC/XcNI8btacPadr6RcNz+YayBlwjIQf06CkhDlIAJms6lj38wRF4nXeUrYjqbpGtsjXLWug6Q/AtcGqx8t8D1uxA/313T5payQk1AU9nZ1MAAIDnDwAAAAAA2V1RO0IAAACmXSw1NTQ4NCsqKjk3OCwvLjU4+uQqNTc5KSksKigpNzjt7yonNjg0+i8zNzfm9i0rKzI2NfIsMzY4JDK1ZF+l1aeLsdD8+mqOu8Yk+eBARg2/sao5LdEcymCpKnkVyvA0dJUhN1j4lx5/25wpEiwidclOjWP1nMiB7QANuKhdAehiN83ehWSqSWWxkxksaI4S7h9rP2TuqFk4T+BYZTZzNHp0ozYAZC7RbESqqcpq+/rLDdgOev5HjCtxJPOiv0usuN3sFCySgtU1e2r8iYq/lHJ0BC88JTUwAUwe/QsQziDkzuTwTv8FXOOakR1bQnsuf9xRG/wvTGLgk+lyjhe57t7jlA9MEsWskfySMBO54V5sgpDk9ydvrBLURXpxxYp0foGqOAUYUT0b4ndIEABEFnXOiDGj4tKA7EdzgiAVD4WMZKkbo5iohW/Yv22KtpyeS2cdN2BP0wHUGQt2BMlRrq8gLfN3ByirKJdg0azuXB6a6/nfIztun+e2CIam0+d5xzbpdtIv5Ulo3PUTAI2XvwIkRv3Fdo+daao4LfW3pg10rkErdgRFQ53w2fOjw97ahW9PJipxNhV0P1Zau8yGuxZY5CMT8F0CPC59Xo9tlw5HXUPXap1L0OnxIAb8uK5ZbTdxbX6lrY1PVSVk2z9p5pqMY48AfznM2G494DmPFgAMIgu9nnajS291DXV9VckaYEYkcFUEWdG63RNUatI2gissXxTCsMa/p4clZCQqS4FnGO82UTvNfRathQsgDpqBjNMVXrjWaO/q3vNpNff+3tZ09o+Hg0UvOzwBRCYpnWfbc3/TxU+d7b7aSTw0A/n9v2Wf7gYqVn039VwVFUzmQCTK1KHyuw1yP0widbQn1D1+nIqfWpWboKGiWE7/hi16PRyj0WOqXy6Sgaz+D91SofPymwVyRfAx7bvb/AcDVCZ13FOSvlRRy3NlrgkCQDyUFAufvaTj9IbTrGqLrOdWkI1cNJdMTthayShFbRCtr08wPd/PaAD6CMVaj7yH8dHLKykJ0/ue1+N43cMSBeGaDAAOoIBpT4DXADLQFyQQjBtCElAxGqsoZoz202ko9t59NBzk5PT23ZGphRNXmYuMCjDxNCr7r2/JNgThVG7j3pWNRhO+D8qoFABpZcHhhQQsWC8py8aSfWL/+dJAtnnUsH77mN1ifzwjJHMU00mpofnx3lmj3H+TRgtLepxbNoRyXE6c5PNd71O/9I7SaYufyP52aTTMcMLMoo9jBsBxelcCJ/XgsIz3MGbax792BI2oLkW9Nbs6l/R4WXebG8A+zowzl2upowbgJRZ06BVBovgKlkUPtfW4WMAcH4cVaxVINvhUYVyphfYrgwyZ+8XL8URmZtYKuE4AoDcPDdIAwmFNBjyOijH1+W55K6OdqGc7MFl7tJ2jj8vPemS2aENFy5tcAwH34aYnT8gpZlXQfUn2cPHf22fNrT03n3IQKdBR/zcGGBrcWvsbCIoTW8Y/bWlmdOiL44ENh/W0Mbwxo61BINKnH33QEbq3tkRQPWkmsbWPTflTxQpz1yY3uQ7EAlB06UrsMnMgcmw/NWCfM/Rg9HphHhMaEgCgsfJsEjZL9buRZ1aqf72Rr+O5frVx6bIDEMoeo8I6lfvZQg4Inm5TNhABPC51zBOjz09gzv/qQydxQAM2HddVxdaVrOq3ZI9zR/b7Nqa6PyMipxgDDDI9PAFjRv4lTr9cRdQAOkbJ6eNPkpRMZj1X3eLzy2hJGvQP9sYmtis3GwfUlPQs3O4QBwBUJlEVoPmJxYkaQuvUAaBSZE/PSXHEpD9uhWTIm5h4oPs21//YrM8TulhzKgPK2+1LptO+tVMCNEZF54mWaUfifMP2AR0d41LU7ATLSDywC1PrLnZt9UOvf9smU8HjDNrm7YoKM0SQl07rIRVg8zIBTCJFac/gZytd0K7b0QAigu+dxRQiI31ANKrbCKutskXAUd8WbOOUPQCELuloqFIng/KzBGhAciAqx+ykRvXYVCg7UxgddDnMPzEs5VIkFaT3A1w+NWUj+dtOzLYdADOwZCUX2LWYw/ADeTreHGwjfLbifUfkqXpo0RwTGrMOtFKVUjR5bR+cvJ+RIMjQcCrToI3MN2g0nf0ddfwdU5ftGTAwmxC5tI9JjGZFB6QlqjizO4CRnAZ8vGifNHZFWNcUgOgjth//Trz8KxtCza7FD7RK6SAtdARIH2eAOJiSVw2HyifUqcfmNDt01sjrmtHY66e0wEZC6yMAjDJJeRuDzsepwPRc1TsBZIqb9x/bzqgkfDjSdDg8sNha8t0jgjPbQNHaFtu5AXOtl8rF36VAAiw+/Z7gYedqVT3QG1yTE+gY4JJ8mXpiI2MtO5k/ax7jqySpO6W+WfMT3HoJh0QkLj8yfMfdczwB2lnFEcfeocnq7xzc9ijy23//GG5lD9mpmZMAgCU1sICCDJAkMpiXeOxCbCyl0mSh27etvT8eumuX9e2/NhkA0OrSFDMa8YJFaOWTGPXHv/9sWkkTqmXb6tL8/Crx5afUSYwxTkbufTXz61CXbOPH05tvziNyZU9Z+mFWjFVuDlirMsZTTXBOilJfZod+v7RfKgRXDAeGmzSCCmztmEvjiwtPSCuZKQUuPk8yIK//q+cNxXFo2ncKoNPJi7YzmZJfAJK0uLHT4uIJA8X1170uCPCX9g2Btd0vTdGZucvZLfUFM4pOmzT6mJ2uCxoAVhhFWF55m3xmESTX70s3/EGIFfXHQbveLAAcVVAHXb8C3CTIAsA6ChiD8QtfxWM/siAcWNjsyEUWq2utLa0PMudnw4R/Mz9dB4Ef+YN4ElCya7NGVxAxHmol1DBiuBEuC1BSilKz7GvkZVkQCkLHGLHF+FbPZTZIGJDxYvJOZV5/xdsCK2pSWNivz2Jb905NOywxEeFyaOBweZGjr3j1C8w9CSJvNNuIpx4nQxU7Y3SOFRQjxZvNqcKGt1gnUOAXaxmYWjFIX/ruxceev7euJ83CrVaRRar+MS0FK/1HtcGYu2XJ4K3nNbJ7tRB+XlBEMgXlGcbv2ZQk/RKv6ARBknL21JMyxaXoSWlfSW3K74I/1VX+GIGyuQBMMgXreS5ue2D+6TYwEnSmXvQl7Di5E31HLFLk8MT0qt4rd0kQMgEEPr0hqCb3cAcEuXq9KqMAE9FivmlHS0fmuM/JC57Uvy21xSVVfqKehaydOSK3LZf7h2bmBQAMKr0uCPzGcA9TpaxTL5hoiOmiqSVMdCcIhzZNNK9mc4A21yeJnsPezaX9QxVla0zaI9H65qgKABQ2PTHI4NpfAVGu66tCCSYy2TXd0CtrxFnbmKMZKiNdHp3dcSFPy5HnpPAGjgO6/2mNowIyCCUJXwxrtUfR4QJXyfl7Y1+idJqD6a59zhsAjgLqgH4FiBLIwLKNzQoQjIX6oPNMIjRT5Bn3YGXgwWwqNL1JOvIt+dysrjudJE3iMkmOKu3MV/Skq6uj8aHMYqX2QnMfBzUsHENEps8Ho1mWwnvIGnmWqfDrtau3d920ulSMiDIhnjPaoSQT4dXn04Nmm7IKIJiIUb2e+elqcVjfdn2GYLES080QmveYtDFFXiQWkCceAC6QMlKwXxYBrp0rfwY2Jm5e0zlwQTPF/zKy9pjZ38vpJlRs2rL962dcwWauOLYyI3fgCwSh6cg1z480lAED9zlygxEbYGMDxDF3sCDsf2VgtaB3cVWjAkxmShqCOQ0qqjwjV83jMQI1bbdiQh8lfytTU4PpgQQMQvUqEe1XENHnrWkvgHjoBRk5TDkj0bCkjWbWXEzjNBNF3x+f+cyb89RFeOQGUMt5hQ0kJr07gjJn68BCRoHDaM0qh3TFp18/vT+VNa/M6j41NbVYaE3vLyf92l6WqeeAg/+bFLZ5eAoATEKFUvvHM0svuv6P1lYx+Y5peXNxL5xNUv3dJnMlk52opomlqwdk42sJziqOqDNJsQopTFucAdo3zSC05FmuTn+xtoH4b/9pnsaRG6mv6QwAwIOrAUjAChskGbD6yZuBCZFVtB4D++ijmzDqthOt/f1h+xdYawIAIBL28p+mgFQSKfva0hyt2ErYRSXGqKIxeXf+q+noClRrbROTuWnie3N6Qoxx5u5zY//37YcOTifLttosq25OB8+SgXH9LRCWsKgi9tXcABYWHJ2YzVSBmNgX9tVmKYrWeB+ym4duzmBULHU/FADg5v/+3xgq9qLzAABDmPhsOA7Hmu4rEXkSelckkmFKVtwI/PYlhNcAmLjNzh0Nku2iwSZA7RYA9hflSD1km7yyiBYsOX139+drjw5Rn4Pryy8AHCNQAfQrwFwCWQLILRLTDGdD4ZESSUgw0GJSUL+ru61NAy4XezuPG32Dt9/RVK+H1NvJJpFRx7e5AdcmgNntyakWKuoTE5UWotRgZhzIKIASOOpLwtqp579BTmDJaC6k/lo9/PGQETfnxIj0J6Y4a/dZU3LVNLXsu3maY3i504Lp9NK9j2ZVIwlg5pR2mwHApety7FBOMHqjgmKkjP7zdiIKGJgfm3dUW/mOKwZflVpX3cn70vZaOFA7Z0els/UglZ3pYouuY9AennsuzFBfFxkHYqegiPmzJQ0AJC69JEG2vvRDTix52VonEDHw4NmLrnvNF/t1FyaXGLoxIlH/3xav6VZQRygWJC51PMFbfOMfcfXZt6KKZvjB5prqjclv1ebFHrEt9MjZj8vvMA7EPzobAcQxd6ogSjq8gWJd3+ZL1YErwX/tUJNIlj4DZ5oQjZbNz9LEln49Tw63FjZcMlHjieJnL7K/zvQCzIgz/tUjqyQaT2Zlc0ENwyVtvI4G2YdtXxtXBbOO1ltj30UpAEwu0exBsoYsBKK/KrNE6ugQwlruSSRuOewq1Ycb7fyOnrsb+texKkVci4CdvJDJD/TbEPXKAWQqMfaEdYsjaFA9WxO2QUeDllijO7L1ku97HNxCQtIkmXjzj/nNNl1c+Sy4LbMWH6AWKVlu8ge1dCw2+3JlFZ9Dcf4FAAAAOIAArDAQWQK0U8IkA5cYkrSsLXCcKg06zEsF1AgACOJZu9ScJktBxPKgbTLppnvsMEZHWWLX3ObvVw5l3Qtiqaux+fJzbsHchXQ9wdLyvfbS/tneWishydYp6s3pwbG+/W7fjvJIjVaZSZuTe9ZRSWDpvX7UPdJGoGDRatIkFhiYND5AorLKzS2dKaIgpaKOIK1QBarYVTbJLO2NkX2xTtcC6KoDY701Qav1MIAAW3n4VmIOni0A7L6AGk6arFj2XN6Z++JL39OqeNPeZU5hGVspa3qTjmKvm21J2MBuUwAcLjUSwPoNN9o1uBrvC9dOxNC8K+vdj2JTUcaN4tKZTPXuX0JBcavFm5C4Axw+ddhzUmeTCJa5f/VRgs5M59FAxpdJNIarqaWabsubNXQ/U4n/9KVzPu3B3BJRv2fDBjQytZ1BjEJ8oqPAV9XaRjzSee/4p+FwOG2sjw4qbRcvu2Ci/18eWJwvPaWpisdOPUcXP/6eBBQ+PYUJx821VWG+duPmssNCCSIOeinSv5FmuWcQrJYlEd2qj10sdXHR3hojp7JVCevuFhmAyEMBT2dnUwAAgCIQAAAAAADZXVE7QwAAAM5ySiYpLy0uLi83NTc3OjU1OPXu9+v2NDU08ygrKyo2ODYqLTY08+vq2+w0NDMMKsv0wS35hoN24blQ2FqtBB8xsPfPb71Vqst0LPXbN2U5kIr9zJ8Ypmx4Ox8LBCw2SxDPi/ENP2Gjnrf2VToX2HD6yn+aW9FIXQnRX5Kq0/WpV6dJwJrs+0K/BxQ2i2CAIdxOoNhR6P7qChAXehB8CzLmGO9IFqQbpjE+KIH6X69CxXTqKUNOCVfsNQvFoP0+Z/yhOqauxatcC9JAAx2LWThcemB5Ila2JNn41+YayPznJCJH7bsE9DVLkaBivfYT6wuV7QATcUBCuSLwbb1UZLZWxRibvTlQ2OFLheU3WKf89Dp38zUUNgU0Ic1/XGgLzQ27q9jWAnoLE4pD7002RCvWaXPBk/W1YLYky4FITEsmbP+rvJEESg+7WgsATC5F7jnJx4VYs0oBoEFP7PNx7PbU7B7nzmfNFLJni5lSlXlUXNV1oWz5TGvybZIq7HNVswz0OX0gcZLXfMg52jZW0QfCCA16UjO7odoylrw9qEn34X8x1CTPU61HnPbqRbe80UBlz0W84wAAFEJROhdl/LdNoPRcYmudJEJHhXHj+1bVJbc8y2/4kElav2nMx9+/TF428o+tP8tSASfr39yuEhQuKZBotCYXKvMUkXaAjgatAayyArSYIM8I/5hew+Tw7abcFPsWm39wTbLGKVKinxMt9lbtOiL2Q0QcPkWWiORsr3gpVLUWukZnNlB8kXi4rLsNy8imHoiba1xlQ10aYB6rZ8BqV3FkzEoW5s2rADQ2dSoY4/e4xWPJYGucdC5D2JPxXC/EvHCz3YcGT/5kq+uG2/n4R9fil/29ykuut1dyiR0AHC71JLgYn7yEDWqbVbkNNtMbTMe26axKk1j5eHtx01j+F9V5wzSWrdvfOlP9IehRFfgqa3qV3wo6OAVY9zQPLwgKKSbz/pd5Wl89avaaFwCAAyiAvQBXAgP8cLpg3AKQagIhQWTgJf/FPFQVfiSTdqR7O1dZkwCQHA1z5s8ktACQeuPJqEbCdIeK4CFVO6VLo7x8q+KQNbYQ5yeTXcjTNAd9VuyVqOS4sklxJsnU6Pmpa2195VjkKWy75NjLMvDtBrTcFmRUa0LaohAZuqKsLpEKr/BOyeuLX2sDkqWbHGcBx2XXMYupuIAMwH0Qd9kGYxJZ5J+44Xamqaevsy03O+yT/cRSQGKApHh6BSukBj4NZoh/tsvj6bVuN0EVa4bnLHlJMGZ4rJpmMSfoAP4olcCFOiBikhz6pcAlAIAjQR3QrwBDBTCATjtg2aNTUo3WDPzc/l/1x9n7d84+br7oSffhMQGAloyHBC1Fyr0/24SjB8XRZniD0qR0CD8/jW9yLCQRpgmmen/98NdfOSsVTn2jLm27cEdl5axMlryBiSnGirRP6N5nuM4kgOYvscxiS1tyUmtIGr0XrPyPjEruto0Pe/aw/GLRrbOUzmruwspBfCJj0gA5E1k+hlCgLfbRLeEWw3gchK+Q37+DCp2JJSPkV69hgSYxk9ssrIusOCIKSlAoZk+h2HPBewlNs0LGiBenrOZauBBMNgC+KBXSz/IeXEmHgfC6v7KGjrRdKQAAHA0EYC/AjwAG2ObGMA7Y3NAYk7BiimN1QHnhQvOFvTngGvOJ43USAISRWchKjFIBebONptZZBK99KUCVg3cHW7UojbQUfWmJQvXD1k+jsTtrZgj6mKlb7s59XmdyFpvv6KhNmQqOuOAH1cYdiyLKvymnx4r2/UgeWi4POqepkKM4B7mZ8eksdvNdoYghPr/QN3ajBdXU5drQWgQJCBxb8x00U5yAWiujoQQM5FTJFaDA4/npyFulk5MLlTJkzw/7Fk4T3H050H3p2ZohNnfnToUPRg0ufnVTKfdxEWHQDmAQnimNIlZZgQCGFHa/ROATA4BZAvYA+BNgAEgHvvck9QLaOQYObs37nTGZvvyaPE6ZqYNwddoEIO0srjDlUEFbFVWWiCoYP1z2VKCORIn06LWbe31WWYZmL/e3j+OD9+83t3SDqh3yqqVt/FFZVmbbOhzblbxvx2B4GSfQrZH8tZme1DyBilVPmVcdfsJ7j6UPLj8QORdAe9ryX1mQfhppw5K5Ngp7XAHqgPhrTSIAMihwEMI+RcheeWAMUYCV4LTIiuNhTOD5BEMOA9s+pN7bM4Hi8UOsBVmOb32qHFziZyRouRoNaNUn2H35BBYYJXHdrtbk9RTQghX4Jr/EEM2Qxw/wnAOgdgSoAfYAmEtgBl9lkuFLQRcINFYxcPog6BiFHcZ4py/mqmyc/f2e2cnLaDTahMSz+IXf1rI9NxzDIQTj+Abekzmg+alwWCBONrQDs7PWg3rvosa6Gp8v5FUlfaG67LZ8/PP0XhxXwa3bq7VJlI61A5lH23DpWSaVZW5OwNw15VrnTxNAh0Rz5wsB6lSeES8FImpXo8PYMCCOE0MLHZ0XIwUSM/XZFb6RRtunB2u9juUs1wt1GMj1L27OJbLlS8n/VBiVN/dXCKpiRhY5g5Y3ZP95f6C7qftSxhU2ACw6aRuoxiv/gRHWkVhFFGAiavnkm3lx2ah0UJ6vR3ZBzWn66EOMzo9aKbKeahHdynxLLQB0Jon10ORHRlRZp14wkSn085cRdcbsaRj7xu2VYQoLtu7uKJXqqdFgq56mtnK5M4pb3xw9AGQ2pfU8dqEvkTGtCRJAg5JYcrii9Fq//b6/tJDp5rJ3ElefHrQtXYO3cQhXulDoAIcraQBSGAWwZuzKNWW0QArv+/eOeRyd08TJ7n6/3w2gZQKwgAXRyxxggIaA84TTimJ22b9wp1Y353hG443D9k1CL4K3dqedFSmB/WYezG/F8eZe6mJW0WjZtu3fTfa5Uqp+Jo2GuLpqhJGA33r/5zRTOVik1bJUPb5HlMf3XSM+2ms3dg0Wm18UWc64TU1QbPnr8+VbmsY13XXTdkiPNP1XaaqU2hKh9XF6MIAUkCSISOFE2RcpqZ5rWGU30SFY+p1Up35YNM8xSi0bLuIHGysqjFuMVGqVjqINPHj0fgQNzbxGJMcR+Kp7RGIoZh4VnwPtTHvgV3QsKvU56Gp+dKQ/vL4wgZEw/O971XfVtwia1dp5U4bCu2EY8InL6jQBLDL1MTCN2062K7GKPgAYw6HfAcpth/ixKxLKBXVsJuzLmF9WBx1Ew8vCBCw6BZlgDj5epMZtNK8wgCDJy6OPXkghfaph8VFKKd32r5yo+13ovaaFzATsMYty4rOFnIHofBUboCM1XmVuGBEsLftEKJHwbNAhdPsYDZ1EHktLGQlUNkEKdHXSEjuWcXNZL1AADYrFni63HK2MWSlkpJ6V5vk4rHkeLfZOfznJ6xF0RjLyJlP4HgQsJgXnWR7i0REftVVtlqCjXOsaHYT+MGVvNrcljlNbSQap0npqA51ruL6r5Xb0JDNUuD6wZAZmDOwxdTExmrcsca4WWxtaKOhoUcXTs1zQp6ax/PLFl2UmtjXZNuoCtoJjjXakIuHmyudLhbnnACQqxWDPPpNmoPjJ/xkVICI5dlZLRoRevjQnxxqlmbXou0xeLWn/SjywAiwqdTGoNz9xEPHWuBdMNGCYF+SKTClSt+kVlm52kazEN917JwBeU2UoNHToAEwmofJsJX9qYESkdcpEmEgXK1OboXWm4mlinkiJp5rfEu2/wYVHIhG9/pgfnuDMlF2JTEmXEgwu9SnhtE6dSB+n1hegoxXvZ1xbKthYvmdXt+72rBLMVUmwzAkVCDdhFyJrhzOCy9wK5zo6CCXZXLPjvAo4ifDe/wvTUeCW8uMAAMBkD4CXEuilAw+WkOiktI0MDC7+32oFr2umRrU94smd3h0AYK2sSlt9TMfoCpQSOtTeXU8iPeIqPemuqF0XtJxlq0YbLjynJ1U0GL9cSsk5J1Nydk2TscP+/zZVXtQQokn5vMcl712rbkS6m4RTOkROebDOH7EkxTFC4Z9M6JXxk/L3VlIHUoIcvAei11QXDGTQ8NL4f0xZNbHGswH/dTN6AijdYfEQU104Gvs6GWLqDhjBzPV5dU6j27a+EkIWTJH+uUnryAu6KzSNs/K4/Mm9vR4wQLGnPZefewIe+TS4RytRJCRJTP1SDhIAQCYAewLUlYDkOPCgSzMAnVEMXF5lvPrsPLy/fJCD69RL9zw9AgDcT3obe+hKkIR7SSnhKEu3DKyowABa591gN1lEy8XtQVDwggZv1x+ST5Yy2VGUEaK0x0j0qRKrMqHwSV/fMdgeFy43u7i4ekvUTJADDLHv0B0/+zapGaGYSdm9U7iCe5mFEaavAmRtOyzN99vI6JD2wNnEW5tgFGpmXULFOglWJkZn6B5vke1l2qeZYRDVXqe0oNDJnE9AYFmDlMqaExqN1ikjoi7JR/4jaoFfO2hUkPtWJB0AvviUsIdIAJj6JWxe+8QAIJOAPQH9rwTSZOBB16QJaRg43OL8jy/O7ZIv/a7tdOplWZ4AcGAKcB3GQEPC0LJWwcmpg3vPOhFIDvHVW3ak9VZodHnXwIrKqeDUgzQhrvomWGPxpMh/KiqGY6FkGCdsXEcu5LCrtUQJlzVbnhoLIXJtFPGFdLiuxa12NCvQCv4N0NloWVmG9WTYZ6fAWDzAlDk5qqkKzXQokPbfBRjF/jpaLUF2HZPxG23xQOdMUHpsgruaDlGVAlMYVlEK8wRjr/2nx+564E7sO9aTG9dCuaCvK7cJejvtRgIA/uiUrIceIABrv9CaBwAg0wB7AnwugDQdELAAaAIeOwa+mm27fN6b/ZbMfP5xJkxPvL1TAPDAGqiVlGs1ICItoUC7VzkWDChKk9NczQwlgkBzAj5uL0CzzB+mpukNETkCxhsUstBV1jw9tHkZnLEXZFl3fsP7Z2qi5Ek+HlfEnPf89aBAuXF+i9xSYPL5KTWVqFpsiO8CLcsEY5YdxcJyCVScQulfSgA1mP2cvG/jgS//81dlFMjZNLF/HYNW5vLomCakqGEI5oDu1j/xIT4JUKQ0WLRF+CV7EzokttfEqBa5O2uQ0QYr7O8kiqcuMnI+BfZ7EkEAyBTAngBHAaSVQUAXA43WDJiY1h4fJvkbdu6Bwwi93b4zMb3NM81Ql6lysjVxeicqZkJlrFZSpQhBkRSPExQQSBH0TlhyIYpQCNPN3374ypx9owHLVikg8YEfymkNiNdcgFwQYX6Uk1ZqJYR5dYflJ7ZtWKfrdrau/6MO4qOHyNzdRf8CmqkJ2qiify0gDSaUgM45sec6oODq2lGo0D/7juCJADVTirXuYUUmmVB6B0bz647qBtbHdaCu7IvowErD1rPmDCEQZ+ZkULR6VLwyIQHkJcWQy1l0vRGt662FqtFRzqeXvzay4YBNuZGM84Zhc4clVO4d5YUcK8PFk/GF3458U38AXA65tT8AEIt1RoKOcm3r/g2aVMMbK7H20CI1n96271DVEb1HBU9M4loLiTSZV5q027c6ATQmifWcwfEbkbpcldsAMrFN/ZSK2TG9uWYm3Wy1rBUEm1pW1RQXa+D4qsa81joaoI0CAE9nZ1MAAMBtEAAAAAAA2V1RO0QAAADwli71FTgz6+PZ1+Dd39vZ29fh1N/f1dvR1kQaFbdn8G4I89KaWAEK3LUPk6ym1Orq+2wZZg8s40Mr+KhdrijnPrHT7dh++zcr9xYssCMSidYBNB5JMDK66YgdV2X9AEjHli9LaJRBvBnkcZOxsbN2i2epxO2Y+zx5p6CNr3w+UPtgm7cYmsh0LPbMCUUPfPtjQo7nocT85BAYABxAAewJcJ5AJRkEJFHKeFpRcIpNcXPWGMb7l+ut/fka+wMAMZTs0mpA3FFZIp662tMIXqNGBaVInNMIzVIhBS2QcZ1WFi2Alm/C0rVXqWYbp4xRaOCiYUUn0lTPTa8/a8hd2wWnQ1H6dbvjTVgRnF/gHpO4CY/EEs3oiIfKbbtqRiAJdDk7zSwgnB3LWvDUIc3mR07wzzA01ZlBSjHFIv9JCyVt+JE9N4EYtyokF4V59EpVIu1tZ6f2d7bHqCuJBtsERPA08STJqx3vm6Z2IHo/H2NTAN64NLKGpgBw+6XywWYAAGYNsCfA5wDSbkBARxqSVEzxJ9U/fGl32v26cEq7V9mE1zsFAB8WaVVL8wreGpUFlXFCEhPdMalMHd0V2bp0dXf15js0Ejt3iVW8ypKjjfS5TG2iFmUuMLCR+UVymbsoFklUeiuiOBMscge+eyRnYXfw6WiEclBjZ6QL5VfmcIPKSL7VireilurYNMgoBctMQNBrV1TGUO8612nw3pVOz4WF1VzvCmT4FQnZvU79x/7C3v5ei8U9ow2ys9cobe+ZwgyESUnYdWuFW2M0Z282ZrK6WvQEnqgUtIUmAPD6ZUBgBgCAyZ4AWQDlAr52HocUxefZR7f7TfLanchrBw89Dc4nAICKJZYQy40KGReBs8WdJNDSKlXsZDmEXOWIoYZmNHfdKmg56EuWUiRwL2B3p0N66RmbHQGubrqykeoW7UtGiAwuQk0vFvzagtaDJVISlHP4tp5dpBnA+RlFU5YzrL5Orv2XB/jML0R1gqbRPWEpUmou/NBngoLN5VxVH08e1XgTF6oLOYYQVN3tHS+DZaMPtulQadvkw2H7wgKXFuyeu6QvM4AFmwsNe3Y+bX6oZKYlKwVAcPc/0cCyGgBAtyfAE0BSfus8x1pQmNZvzrEaPzJYCIfK19LxdAGAlSwSZR2XSxQoyOl9mY7ORPCbivWm2A7pOErAEyTK1zCiDGaVQn8Fl+uoI/WGF3VY8Qd6GHUxImyCkms3Cyq87lVEggUxH3gvme3h6NQeTpy1+YWLye+fOcUnAjySaBEwUhn5xBf2tLQOghf3vBErzDj2pL73xLrwrkNcmNILc5WtPVaW0bkchHraZeNamerngt3udRQqO2MvnfkWuaSdIs1QYHWgP+gA/ojUsodJIAFvp6LT+f1LAEC7J8ADqK4aZ7TRiuJI+tWpzf/+erUfNB/KGHQqUvAY/XYrwmQ6mIRc2yvCwonWt5yWDJUsPfZVDi5gohv9ocXa8hFzwJzfvcCO6qMa5MPby/BZjXbRdExY1QrE4DjEy2Uuo5+7+XiOgALVWbpsbxjmpl2PvNDX9nDfrNfMAye8d6DlFAiSTs+jo3EkO/96YjIiQprFGfNaFuvq0Ugtdw04LsUazGmigBlAZLbxD0TQUPwD/gPgX+wbSGvuzA58vBOORzJCykCRn8u9djbLMAA+eYymhiIA+PulzicFAKBdwDB0bSWe0sow49PQdvL3xWSYb2rw1PrAX8NWBQDSJUCJbS4kIGQ7rLMvox4UGrNkt2jJLUXLJ+LOXbFmJW3lXchYZC4rnJxuRm0zv/L+MwhbWLrHxhkiMQ+cRYTUtZVCmMnZLwpXQ3UWNGcLTOSNfZur6dNWs7jtSCALH9DmmNpOPlAr1PlOW2B1uE5OejuibU8R0QcZNBp6lxsz7FGVo+jKwxlcgrM87DeLut0ySdWNXyoBh93srMPAhE/U1V7R0L9nc/C6vTSz3OgTAD5p9K6HRgDw7crJJI6/lwZAu8IYY2UAynlOKWb8qrsXD04uvLfbXreTp7kfH2eujyKUT3JTLUsV2ERcq4MfOlbBI1Ii3if2KhgRhdPnSrk73UrLVtGC+ZqxpGXNGJ22nx3rSkcNZbIz2/iW2Gvi+dPSDtiFBT1bjtOsVw23SyLPvzqC0teJuta92FIy4+/KXZ66Dn8B7V4c/gptU+7BfceYFTi1pIA6D0dCRfR9CzgMrCIJqWdpLXU2O9jox6xwKMSX2UXn5FfeFj6oWae6tYMR5ZKPpm/U1tscIQpoUwM+WXSuhUZAAl+/dFY6AADGFQqqpEx0jpVlnPKnyVjuXX2Z2G7x2T/TvrfKAABQhsg4ZqopjKucY1tlNTtTTVlWLGPZulbHWralmnRjDdNbLbbXPoz/xqbO4WJQuGdoqoN5R4xD6AmgLVAzd/W80rdVogmkEHyfDY4oCEBt0z3KhL+aVXLxK5m5ouBl6w3vLG/F6VMtTTniuTLrfRLkytMQYNkxU6JfGYZJ9r5/PwCrE20YKvlWpZ/AxmNtOnQ4d5ZlhkChaJavFOHbQBlS0ZWLKrRIv3nOVwc6KQF+WYyuhgZBxJp/5wqFvqYQAF1bie85WZFCEI6vzg//82vKNIzkr6uSPGK7cCiU6rMxX5NOQDSiujf1n9RlrcjIEWQYdKC4htlqSgvg3KjoDIA/Fou7cFsl3HbshLsz38sWtYRC0GLOKmzaDRLdE/fISnDOpfsLUct9JgJNXyd3sIYrUsb7kq77U5ovIqvlpaPZRt8ZYOrm6xqNMNag6JM63TiiMIHBpPcs+kguQ2vj1TT7ADG2VNN2lKJwUvqe0oYwrHkGdVfSyjjSaaW0uo1VoSTUhOUqkJEsvkjUsIaCAPBfYwW5rA7UCg1tVTSlhNOKPvhf7sntxNvrafx9e3ueZupx/Pp6RuJ9TkQTErRJWXJSjYMD2U7XqKwd0orwmAEBuPQR7qudW5zoiw8S75FRiLBllrOrViI857EX88M3UUBFghnfPvMOEc+/MgSq+3lSk0r8lGAYa4kc47SHomu1tjNFS9f61gvWX2LHHNoQKR9VTL8DV9VW2g7QAFe9gy2cIS3okdQL+bmAom1ZffV6JZK7MG1A8twoKAgXUiWM7LCJqkLqFOogGfsIlvEaIUxpD6AD/lg0podAAPiuaBiTAarSKj+xyhplaV7u9/pAv5xmYFi2/6UxZ7/xduvh9F3/NWv+tjwuRtoLspb1MczD+fbOrJqwnFtdu7dR9jTBAPCmueNIpycZYHZM3FD9N0/KIR9DrDuloHudTDSxgOhOISBhHowSS2Rh7HXZ3P6hNnwejzwxXeVYWc48if6Er8B96818Koo2Q5J6DeSxztnGJ7SoZvtRMdiMJGKKL4wohxV9a7/3CC7zTd03qzg6zLrICG9sZChdSeEMudNOc7Zjt27XvbuLtdGBhg3+WIymBRAAvrMFBjCwDYc1AeWXX0kSlWZL3099so95/Dfk9Ono7Ou7U/6vtt/pD9mlfZSxadLnHCgN3taufdITEnXHe6Vr2zMcCpbYkq0uT8mj08O6lzvwRvjB/8Q6KXcJYTfBCJW3GgMz2YcwksS/NRhsIXoIzYn035/s36fzWHWcYDyen2hJMuZwGOc6+nrx/VQNLGJofE3mg69bUJ/txAT1kh+xWIYHj1iAgwVJJrNnOMJXz4orPWiP1YpcSdXYmt4ZVsRKlj8zuMRl58Wk90PpULazm7N+NHzbbAgK2ABeWJSgBggA/vu6NCkBjPlYciVOC1IrPHT/zvT7mPHnwee/MpLt/dQzlrzUtR+an59ONP7onFJcscEYsrzCMVn/RN5WcdcpurPaqj5GsfVkLGgYrUJgOEAra4Z/rNgKU86/1Ik51ujTAiNcAIlI0mH21VjV0rFigVpgzsjTtEjR2NKxjBWwL3hM1nxZC6j37qJMe9BXKqXB4StL8i46UZc3pNaP+hkyO4IJy/nKLq3zhXCgMycHGp2TX8h3lUxZzgfoNEGupqjdQBVmMWTcXuxqfDl6AN5YdLIFRwD4bsBcBpaZILvSqtJRs4kM29ny2rP/sr9Oh+Zc33RmHzdSXqwsaTJXgywxdxrm1+UIkiPsApoSevhbep9l5jXzXjDfG6AEqvLFh3Q7qaLFoShM/Q/RiKjg7FEFhGn1EF9oRZXz7+yssYfE5AsqXB5RxHlIyd0pWPGSwTO+2rEmyWi94A5l/A6kudFXcI8Pr0Si3/qJpDFd9rzP1wO80Ba+2OyeDNIUviKHKjQix/EtTJ/ZKuNqZzHEgNa/7l8JtQhmZYhY3ZxtRwFZIkkdmtVp5QQVx6sizQ5+WDSgBhAAvmuXfQJg2rZJyUkZrTXj8uD7r8zxeLXNyf+xp1r7uwzb3EY0tlVeJdYlYq6OY11Ia1thQV+SyXeEMAeLV3cEbfUURmb4Qo+yFBxMIGe5Skt+0VNSJy0xn27iLvuUaE9N5bq5HJlcsbRhpy5yMUqmRqYqHlNoWxZcJu7QVA+9NRkyssxOb7gK4WWn8SrSxxWQcfGuNXQpWc+Pxj93WGRpIb8g6fjWawlW/4r2wiZPfJdUZZQfm52OlzFpkG9+q64jYXxWWo8IMPkat9KVb56axqgx5NqdpiUAXkiUoAaFIAHfTb1/owPGpGJScmktBMXjnJl/n7009eDXifxL7vvxb54pm6xjbtuQ02L2ZG9dsVHTTzcwWNzGdUf5eXvnBgYHY+w5G82zdoIz/70SA27dmitTJcqaW6LDD3dQNcSYcnV94xK75e1+QknF2+3VsMaO/mGpnH4kR2wHatGJYFgK48VdERqgbs7LSNGX3pGAvm1S/xE+1Bje/cJ2QDQDZi9FDGPZKneFuhd9+oKPbFYQ4i0EQ1T6VIkXNcwY3DTxezl2fVXDKysR2oIfeF0APlkspoZAAPgu1brxFugrGKv6ZG1KFtpReiQc+urz78PpaVN+X/v86V3K+Qu7+UzbOpr3/+DEdHSD1u0sczRRmd4YpaZyu29IIH+gsxvCZ1zmq+SX8AUQD65LnVNJD57ExLrVPWZh0Pr2yq21p6GhYxzk2yuq2K2nViXJ5ZveUXwYjaV/46s/S+kO2gZQKD2F5GLmpdtWx23w6CuEO3FobGS3Boj505qbIIpGLmdOltHzsyjMSav683K1cb1exSBUNNSSLpVllmy8Buzje1KswVQLjkxdme0HJlAAHllMrgYQAL5rojRIJkZPjiVrp5W2in6RMbEen0naha9P71aTRW8/23YkJa8/zmScDfZ1Kjco1U7XLgNt7LBvWSvOR2049L3XA7v1XARHObELUpGPu/0h6/LK2Ji9FTo92xMSnstGrhD0Xf+M5n8240U89wpz1pt5dLxLL/w8KwNu8xAv70cYzVJJVIJl3EbU+bCdRcaPai6WGktHY/7Sno2+sSMTsNpGfkyBIjB9gPanH+miDxLCegs24JOnCrENq5n8Kpnz0Z021noZRwGwgQ7eWHSiQfADQHvyikWVzYCxdFKJMzqkFePg3E0P3Tl1n5P2vWXv5+vm76NPspsvdGNWpjl1eVY9uBkuwaCM5tFzI1BWtNn6AnEZf65uq5W8bs8NNctdejDUa+b0rzIg9W+VvUoWD/6qQX+GPPiDrcZyOwWJFgjHOINKGCOLDVp75MonCdtMwbH5fBZ1kj6T5l56lNbQImlu1eeXiuxXRV1EUXXQan/Vy8q57hhBmc+q1BfDfTOQ7bQoC345k2JFUfkioRxebFSsLSBDKMlsWVZzP9acAKUDT2dnUwAAwLkQAAAAAADZXVE7RQAAAGlaXH8T2OPV2tPU3tXb4drX2dvi18/Y1B5YZKAEIAD8N7pbUhyAsfXSJvG1UyQz3c29c5knt/9uGvxASt737ydX18mPNTSsSU0zNR/l9OQl3YfEswTAdapZWEU2NrkePU++3wrdvxsZ4m0WLe8JOlxQQur19RnLh8G/xbsnZkdULAFMSe7r4wj6mc7SbGmIsMSyJ5AzWC0ed3CnD1pEFLSDgBYrXY2FlbvwUfiJXngFyOfS343PBNRF5VhKeS4cPvt2VXs+zgDKt8rZ6gCjwdXOgyKWKJGnC92WdkkVCcbq0W+gU4S16im1mjIjKAUoAH5Y1CIFwQAGfGcDvZkkMAn7cvmxPK0142h46J+t0/t3R5u/1qmB92jagR9mbbK1tm1x1HhJcRBFScYp9iQeYlkgyeu381BXBxXcH+ehhydxFc2hmWHdZsJYzdGc5oT76smYUlebsSH0qu36jTL/BW1c8xOg1+To6ORvMPmx/grCoV7PdC9pyUc1lkBUV46jYzhr5eCz26YhXTOOY63QNTb0r7Qrhe0m+jWk/tAmq0+1mtIcRSnhB7PdqIFMZohubj13xd9eIDg9XdMTYd68PpmDaWjnzBD1LXx4Yquwcst2RgMN/liMpkQA0QP819pIrSeAtgLlRy9qZVlhzPeleXf7Xki/nG/7kYMZ+uPs+nfWcx+TbWZz4rFN+QJzdFJoNDf6P/5VYlqjseYZibwdrfdZnK3if3NmoRCnihqJtj+Wdx0Z19hladDTnMVMYYYxZFJE3FOHGUVOpsJnNsc6WegpbDUHDW8LVeWz5JymMuhRvnl9ywCNw6sWqOdBRhJs2cYGwj86BbaYIfpUaDUMo80aHK5clc1VCYZtbHHIqtXqXLFtA0pa2xx3NGO3LYpLkTjkcl0WM9kAHkgUIAUIAN5tXDaXRWMtwFg1VuKi7ARTHP30n93dO///8+Dsz3a7yeGD038sqfa6I++kst4tMwv9ASiNsGGS5A+L3C6viyehjTQDbbG33VFjXNtOigz0uRxTs/uK1Vn74ZIt8b2tMR1YqsnzNFtjXSC+asQ4+oljkuNoQ+wOmYOjRGNvxOJNPxgzGeIdpvYPD3oUJ4SD3ly+1NGBvOzZFh8y23pNgx2lCvYYsHLTBLr/xLidzDcmxNBKtwb2y2gGoUsPZuZ8MLMiHmvRi59d+pyub5ourlGD9g1+WGSshSIaCTPfcbvCTwmqquSoSzOTFBe+3pR25u+t/bPw7sx8Ld+763YpT/KtunXMG2wOM/V89yRWhJqr+G9t94jVQWf3/omxpFO1ICiMe91trgZJ33o6KwRZs9phURvMZGvTEwUr/0XyLNIsByY7PzGTu7dQRpzzO2aCaC2qRwgsTREZ6w5RFG9pYooy4jLUmjrCinufZZBFKDKUHF9xh7/fMtC1IexDdisuJfd4tkQLd/hF9XBrUu/1wyjX7IzmqvvdnbXPPdasinBq8Atjm946fljUuMRBBoDvlrG5NUmAMSZJhVw0WitK//2efP11xtlq/0wzreMRmT6cnLYdxvkypturKdnb8qlQqGWY+tAborVZLWh+YzBmm20hkWv7t8I4+CBPcuVfkidgNohQy3XIFm7RgUjMgCQrNtqD1D0kVy+0zZEPM92UTlPtMN5ymjq3Ctgw61hrAzu3fZJWz/2VRBwjyshc9miGZTcgW15VS1PXa4UpVjCtklXaSXcJM5MySsSrocbiBSmoI9XHgFAwW5EulwF0SZdMRJQ53uZ+f8zugQneWDSyhyAA+K4VYyceUFWjqYpROcEI+Wpj6mxtk2/21HO9u3158qFdODzrQnI5P781TLOqH26j2qQal0nxHMMC1HEcCUmyrT0wNjmM2kE4yKsn3lGiQAYcVr9m1xQk19y0NrR8fmfzUmStk3ZO5OUorK7S2BSF1vbD6tBqKr16PpW1vkJZ+UkC6phUEXrnIybXg/MUZqyW7GrhAALEnfYLT9sPH5tbS1H6sbzYvDouOwY+vyv2mqAuYg9Ch1mY24N3zjDoUna/0H1FXhI+GElT7b78HfKiCrwUsf05CQDeSPS6BBgA7iXKJnO5fjD6cvQ9kyRKK6a5n8f+nF/g5bJhd/jIjoG1Mds25eHcd5qb3JSy6m1/MODPdnjcUjejaQnt+jwZi/Doz80uHLBiZDX+/HCePSoiNOpOPZIkG4dEW91O3SKjelS9kVoX/w2vXx+r84ghkx4hFHV0Sb2QsU2FE3+Njy8K6h034RojH19MymzQrKon0n1+S6JKgxJtyZcyQZ34eWFQj9ASItCj+eopBjwPZtcbUCqbQa223fv5E+LNYnPjOkW3fJI921i0+oYGWAeeWDSyBhAAvivflMY2m9KSsSm5ot9oYRTjw03i3X7uYePfF59C3uDkWTg+TG3te/DHQ9tWuhDgOCSJ9PYjGzuJXQNCHgo6pV3mel8IYSmrLfOn3Cuoyf8SPT6uGZgM5DkVkSVrZJD7pLVdaqMkk2/ZT98ya3P5WjphP5BEObmEqnrbgt5TAtXTULsFosgq4pkpDI+17oi3JnO0yUmXlCNSZpDvRfOM+wl2MEzzok6s0rWJCIV+7DLo9oOUIj9+CFGq6g0Goef36pQMkM1l6VuhuSq9pxYzv2KJBwDeWHS6AvGTgJn2BnSlzi8HVI2xdJWzWlNk7dOOk49tasthX2fG1Lfbz5j7bs5w/8GnOcNIUV/oN/psrKscnTW7fbU1Ek5jby518VVpeT3D3WMrV9jOAM+fIgCP4LQFG2RIojUlloi5IfwOyzBEwbS/M4EW61F8ytcN+JEsSOgn1+IcZdlisqH779R/j1hEs6ZykTNoZ4AbBy0nQis7igna/UBnYgykMuNoOIxm+TfNxPZjY292OOgDikhbRjQI6W4l6f0PXKcnrODNQmXsECY7GzuXPqgc2YD2a5V2sfhatQO+WDQmhkIA+K9vJL5Hx8RYFRPfRK0NK5o///9ffU4/fvmideNW1rRuzqUuNU7ZZP2ram1Kzho7HYueMJ4ks2t+BgqqviQpN5jzEwWoAPMpX4iHahVIU2G3uar984jeUVH9qbwMEmXCsiWN0D5odciH2JOmN9M6954yBR/n1GbeoPzmjdVy1QhqJSMc803XepmzluKI7tr1wio348pS3bg7WYURSQjFUEeZRMU9cdJIJW08ruyyn9cRoMpPUdhLiEOkEHQ9+LxtVBB9Oyva2VlrApSQY228pAboAN5Y9DqFQBAw4L8KpXQBibGtil4ZTSpmep78m03dHPrafH5UB76eDv3l/enz/K/OyfG01ncmWkNsS/VmtAUMaj/idzsMNW55yY/4pEdrPJXwPL0PaD7BoRIsGQ/OdPtMf0oFe7GHjmpBBoTAe1Wu+JB1Keml0AlFT39mhZfnv0lN0BXEkqOEi3CJFUVte/XLmKELu5fLgH4edLzq1ebY9a6NjEmLLTX4gwp+76Z+mNdt0AgrbWmybvzVTuSKvc6Zj8Sw58+HN+W/p5Vrt5EvRKGfouIGeOgA/lj0skUL2QC+S61olqLApKrk6BLthLK4FJbPD6yPXk8e+nR6krU7060bY5rd46omU7dyDEfbVrvBNGBPdnDhu3YA3p4ybKxqIsej7kQauVavvaS/JHrX8M7emjQyjj+72V2unR9qhkaLb3Ei46+NwzeRRNCc8d+kOWlVrrmBt7SaFSWVXndnWQdmdcHKLsBpuXy9V/b1EIz6biTtei1dFIdoSY6Ep7mWlGSrqkgUkwi5cDy0ptGqN5qAuHWDFqV/X79o6FT+UG/Mh7oEUtoj8Wso1bEmN29TAN5YNK6HSaAA32lLZ2NgB9QknJ2PJStSGcZ9eWDbwOl27YYJy87O7v6TVbx91Fhvuphru1S1rl6cBxrho/pkG6kiUWNDn0sChHmpbB2vlNZs93usYJpy6HyCDXkdIWzQg1bODsqZtI7ZLlll6IfHW04TyoYFaVIVhZlUvlWs7E2xOO2qL7IMxrNhFzt8jGbebnxCV0gPV1pCMOIQI/QHPBAXWszoHuknH/EJbV2JFiFU29WfGUHlMLtbxmRf1Y8VBp+w1fkXDC7u5KmQrLWWWjb1prO7S07ub00DJp5I1KylGmQC+C6n2ekAY1slR9lobYyiF4zstW03R9JuS/sitKuH/h8e37i1kf+hc82avslazvHS8OisecvhlTKGb0hKbzLn9Q6qL42g1RDpFxLIiPT3VUV9S3reVV1Sh2nYUFVMhx0t7AjsXql80KxUw2QWV966onl2npm/mvPjysJkWbJjp7cpDK97o4LhmDYRMM+jdrMU6o0J6+qSNbf2+LAbLZLXlfsmNcenEwAXrQf/TNGjzWzUqhTa1D1Tz0Io27vLWxF/BWVCSfjdYQ2EsQjVPRjxzoC1eVYoNrA9mABeWEythsMA8G6BdM0OQFqTqkQbrbVgHM2mnB7N1T93Djy13TQ3t7+Rb8bY+kcmNnnzrsKG2o9Yuy19ZnPju4hx2nMigOVdmi+4OudhkSfunCm0o7GwJbPgd/JBdN1oSS0FlzNOUAfHn0KOgbY0rlmGv2Uh0w28DMzvfvZCiUshteJj6fbqkZCB1OuT4Mx38gMF5/1s1G3Q5P81LGY1ORvsLcbvpTsjc0mVqNYx0oBX4J2SfIMXDiNEHhA6UZJu+sg5lAiRJDLYi2ZooxW9MBV+S5acm4kOAB5YLDWGLgAM92KQViTAJK3YRq21EIri6ts1e3PQ+Z9PxvYDN/7O47vwgMXmRN/PXFcu6dlhlxFpGU5gygopMuWqbuU7s2E0hnJFrL0Qb+Bmm3hYyb5TR4h24vnlbYsl7biuAbnnfrHqu+rrzQfqTJIlNocoM9vZWaqIbkSCRKAXSVeqQxK1NONgJi5iWHe1jnh9onlVqwsGqqiytniH0paCuJsFpPoMRjNOO2WW/H9sGBUbRsJWQp5ud31FMnLHn+Ly4qKNgsAyVbayZJJdAJ5XdLqGjgDwXoHuA9EyAIyV9lVU2tOOKUjhcU55cjVmbOS19Su3aJPI+t8p3W34Sld+Cr7sCi5wUEWKizdHJYaM8bW/uP0R8DD63Xj4tyV3N1S9uJWUnM38UKf3uTtH9rmrXFcpE1HwcAyN+8q09I+B6yl4UDKodzeJ5l6XnP9oH0MtYRPzE6Hh55hGtR5Otm+6vKhkES7DHFwnhdHG3FbEtJJ2/oPyXS3vms4tU/Ldgl948XoXaMKnxHq3b2dh2SL1Sf2QE3I6Txhfu15TU6z1d1Qwlj17BL5XdL6GxqAA770hQAZ9ABjbil1eKyGsYmiaWf1aGlf9PVzFvq+x5lemkTT29t5Nac+uEzl1l/MRs24bWzOUSm1hyx8jKtNd+mzgJaIkdObsWhALJied1zjKBt4eyInHfNVR1+qRFxDDPaw5cJIMnilDEQxAT4enusb3FMr3WoRR6TcCSMyG5qfFWe4QTnvCPHhtvzS0sc/J5Ih3XOO/Qe8QM5Z7zsa5iDAek/OWhCX1OJXUr0wGSvoPg3q/a6Se4H61uWglzfdsAE4dwwXrhm6zkXsDT2dnUwAAAPwQAAAAAADZXVE7RgAAAKfDi5wm19Db4CspNDHi1NgpJygnMzQ7+/TsKy4pLC0rKy83OfDt8iosKixeV9SuhCkAcN9ZqVmWBkBaFaoojNNGMUw5Rn+v0fumhlU/8GuSG3t2fTI5HXp3JXugJK/FYP1+OfdlqNxu1AvBzwR6JB25zRLCEGrWfV9sb+qu8ksDKfzuo9yNt4wlHVLtoEdWVBjWuaP72WC8A1ME5CXyrGMsTA/VifAQvXFiGVfVs9U/Oql1w9asQdpmvQgazJZnwS1KQVyUmBirT2hLTTNyxjk2QeX+rYl1bpQ1ctW9tTeYiYC235FnBhUMqPDKfIlOk+qUCR1C1qZ8cdR3YrbfqVsnAX5IrK2FyaCA4N5SujEBGNtKKmGPBakY78+WfN8XX//30bj4j8+v07cf3WqbufPNs7P9PGsmxu/LpjNSCc8GpBOk6ZFL1iv4gChZLlop2tFJDGGpsJEGMn8OmV2s5I29V6RJU8GSlrTtQS8258VhAZE97k6bnqahZeikIuY/YEkkJdcx/BpNPDC1g3QuBKJK2zyLmnG1R8I6g7s1PuPy9U3yEuqVGSH9jDs7lTG/56BfvdosFUgMdMvR1Lgu9xpOPu+dCrS8qGNKYBuF6wWq0AE+WKwlhcUA8G5DWT61L4BwpU1F4awWmvHl7UmeXD36z9PMvH8+WdLfXrFumi2HHod+6UhIrlbxRotDOldJyzk7aOtrbcSbHaaJ86c1rt3cBQsHVMGdCW3p/pW/2JRYzWpfnFWipTj22Z4ODzgYuaxLeLeobj23Us07SU78nzedS3DebuSerbiXTIR3u2gfMmVYKTtErXbP10vURCJZtpZikmHnPV0I91xCXjWlpG2+z9fGnLtM21Zy26WcWOaOPrsybHJRlAYtR3fYYu/C4xXEF64VbGbeZfrWmAA2V9SmhEkGAO/9b6jj8hqtOyKMNTC2vUrzrB1rZuTv/J1+V/3zuG8yJE/Ch3/as1nvzvNuhpsGz68bcrGNy7bDBpKIT93jOG3dqhtcK06rQclqEpXaGffr/+mWOkO9SnmpvM73tQEL4aFQ6JJIV4ot3XHuxMygkEKUFXlBVyl7ye080rtlZbVSWNS4Iebc1ho3aNWDUiLpdmWW/brDawYRZS+OG1LdpJ+aJdMhwFQu7mXHkwg9X0ki2oDMvnpuoRn/0b6ZvHDNWRCfVKyYdGmZbau8Vzt8YzddrB7uXQkJAJTxUGAcG3IGYRuQkmULKPombh5KI2ktZOXgc4B1hpkUpSkxmZc3KtPtogGk9fSBF6ymFci9czcBnSC9beLGSYhZvIM0P9p4+tenSl4fPlclXrWiAeTxAAOdeqYTd4A02h5Agt9FTOTI0vO/jzxnu1sEluenHlsq+Rt6StjuWV0v6b9+Kalw7wDs9bhyt1CkgBD7RwLlYsA0hrIxSjfV3Y5YOC9XULkpjub3brmulzV9ulrpkt7txkQHGleUrsR2tgF4PwAABJjUmISjik4IRbF7tmKMZYRR6ulJmrR9fVtqPhA1OJvwI+9U/5y9bOUOTtv6TX5+YcUzTayk6MwcVOFFeioqvqs5QiYPROf6/b4FLsYDLq/CQhucR0wMSpPa7wzd7H6JlpKXh/FfBGrsdkhKyHgStZcRVVC91U6thIFI9/Nm89TMSBt/I6HaL+MQNv1ytJXBm3krZApKlgOnPcvuv+18t7qAUYtugc3fkx01D7TqRgPvrQi5Bis95koLXgVOfA6u+s5r09cSFPxFiW1clDnifbY82fUUAJ5X9NGHLkDAet/PSUNgDwBjO1YbUlqwZoab6Zon6ERMWk1uFu9yzg6m5L34bLTs470Dbyzzk+uw8QIClhO3dLY+xtvQs4dgeMvuiZWl3lO8Tzt1FUPjbKu4GXmxUbE+KvNlt5A+e8JbJ6QueEuFnW/KWhwtlUz4iAJstfrsyox/MYWfsR7NMRpZkJDgw5aTtW+dFWYeOL/fvgswnUHGrnDESxTdFJCNxmWcrkR3U9UX4tBtCBeB40qDuPq9TswwICVaFsPl8Vayt7j6l3OXkm3SICAD1lakviV1Ag14PwAAa8C0KnZ50mpSe4xhocUWnWttTF6x1FcpU/GHR71div7Yr/3dCzfd3PCJtnbZH67a/Jws8GUjZpFsBveJa2Mguw8HdFAcJVDvFHgeP5GC5tKuYNmgDztqJnh4xcbHamUdXEhsFkBhmK9ixRLYDJY7HajjhYg1emaPYZ9CSGVnLy0SvCPSSUf/MJSZlQytrhajGbxzcVtZpxwpqkMXq2KhgJl6ha1zSZIVOxGWaHJQyIY7fHeZvAyyIXxJDif0mkaNrm99M/5OrqBkC2gAzPkQJaiUCWG3AQQJVhfw15EJK95Gm0JWHkq+j12tZ0yXvV11trxl6QDc/ZgEUqWD3QBcxeEE7vQ4WqUPGRxbsb5gLNmFaZU9UBJqSVvCOAPs9RzhozMrg5m7NRBRcXEvM7JBSqUvsWEYSMvSUdxXP5HFnIkV2k42pPlQqRQhWDjaqwTgKrbEh6IDqXuHDkDeLxd+EZdj3EKdinrJtpcCpPloj5Ed95D2x+5biQacS4ph87gb7uKnbEzEA6sH5fTlItjeO1n8TDJDhSc2MJWBO+sPxCF3lCQcn3hgYPhpNuiQqKFpziwZ7j4pfDppNPrW/OTubh/bNbWhOCHjyDpkbVgjp+MmCdQ1rxU835KveEr8NdQZWxs+nTOzo4bdPWS8ZnjykF6qnyr7p8J93T62Bju96o6tuEhxP95+OCFE224A+uYcxnF366ZdD59LlyB+AqZtcFXvBwAggCHOgElyBqyRBC5NVShUEqwJR7m1y2AtWGMe5/+zz3gyf2l+mZ/PXH5dT2urSoQYJ9MxPnApC0jPrjYlJsafL48mIwhA89WvV1JUfXjy1UXr656YvSrTHV10Qv0feGkmroCqFedl1SttPd/P55v57OxJz+WKDhNYSgHo8QMsHrNKG8qOrCwiVGz3obu7h+xufu+MpHomJSfm3pizojgVgHS1RQSwUNNdb3H6WobGLi8a5kleUlJKAegqUHOqyjQwIRAPs/2U1l4JDYANfMMaA6O2kyJkoAwTecoPymE8jaBFmgB+x7QI2SvMyJe+Lm4om1T0/wAATmDUjwDATg6BGdiGSANoA7IKB5gpriQWrIHc18h/V+JZap/VeDjJL+0Yw4IACCxTkb1Y0bsxmV5/DFs/GESHWGqq6qz3c4f7svpgtxMERd9EA5T82LvXukn8OgFCC7AVs88OsnV7/n8hQ4P/O7VWyRGmCQAbi59c9Qg55omIrgwAyB5RBxVcTOidclQ7IpjcTqISlCppXUT/8Z8LBvBQeAE0RHdjlxRQaAGdm4bi4fpGmdNUGiC0kc/8ENS0yx0UboBABodxFVfUr16F3oQBMsd2obddrcjCvqT26BvINsID9rYcUP2urcxHVPT66MzivuuoR0e/JscWnnPAzEICIAoCWQLYvEEwaHStUUESmoEgNvp4UW3Uzv8HFt377OC9QylTiWHiwBapgZ64MHhIK0oAkoA03BnxPQUca5u0jL5R6+EkcZAgmJzufbh1fsl7Wky0f1/dfTdrmtY2XqUBy0Zd/aJlX1oAFZW9L/0FehsyYnvpR1+EliqgxFD0R/eRbAl8tzmY1Bq8+xa95wGEK0zqAOzR7zbVbDufzCTaioGy/Yn+SQHmsR7dPlprlRmG1UA5J5K+N3eHxQAMKPJdYhQ+wVkNlPZp85dHAwA0HgsNObNTDqGJavkRAFIFi1Ecy1rCtfiSQPs/xDwke8/bttQ+iw1NdoYC5A13cuXgFqso31Uf6/kbADMkee2MLWOZo9JxqmqZbvCrsZi2JI4JRo9W27QIAPQVi5k9JW7TAy3uL+AS/rPCogjOUmtUy+0RbO2t2n0tia6qXDNC1ucB9BVLiadeMuWeM1NF7Luk0VHG+Sm52GjPCwYpS5ag080fD0oKY5aZpGxNHwkEFkuddpeIPpOxeq3KLQFmHJPAkDMTOCViRoOb446EituouMXT4dvA5oNtYQk8HlHu4Ts3FZkKgfeFT+fKYZhqOcgeNRjN/E3WHy0DzgyR2ni4qJ6WJxsBNA59znBs1LIiNM77Qieh4OHfowMHxXWz4CqnXL2TpxCN2QrJHGBd8zltmTwmdQgwxKnw2j9/BWRBeiOnfTw88ImO7tLHZMpJ8T63TOyOPK4GWjceiHePCboANDJLUQNWN+FgqL5bqw+IttCBZ4OfrEYdHkuVecOM6y9KsOjBPdPruqgaikyVHzaF0foGjsKeE8w1r0M9G8d48HRcJLin21WmRaNnKjIvdVNSFE/DytjvEv4Uqk/FW9a5PH927lUw/9Ono2LLkjcVALrnzANzip5O/+lz6UP/E+nOtqT43ll3j852anry/Ke7gDYD9rVWekAP6QYkgUmQE2QrwZaRGEV9nX4M3Z/nrRq2trdfbjReyJ7Nb7qUbcbq2ZyDs0ZX0OhJFc292wSq9Hbu78914ckiOxUQiK4ek328fWjL/HwLMYdgUCVR5Ud8aA2gQdvaD7S+/gT1xX5s8QUC6nDbK+KkM94RuOUC4CRUZftfVlVSKxidKuE8TfV1ioE3amdnIcq+JwcmGF9YTX6x52JzXVQBICDh0wUPocK5fpIW4Fdyz3TXfk4l74GgTQBsyIEGAFBNOc0JQJQAAN7H5EhdnGgtfup0CfqqqvcHAJBATi0LBwC+p7RZAFhvzhvBMEekDZHlAMkUdQHoWUx+WC65sUuWbU0PaA3cTaMgAQmPspHe1+KUAKimTDgrscIap5KwYhRDnuQ7sHF1c8g4ovjINqZZd/cYZuR7q9v6k1HtqWoRHPRIoImgLYrdkwEahtU/RYnkAO2w639Lp0dnpVr84r5hsvtv85QatmXsXZmGBJrZ95wNSAjjT/FtTajZASvCjnDlhJmyfPaX9atGu21jAfjhpUebF7ZyYOFAcJ1NA6pc570/WUkBADpyMIPSiIFzE9Q1+eggAFbHtCy/RbWxRn2kzy4KeH3T6Z3trtVRX+n6BgzLBFhVKz0A7XtGMMyC1/olWYIZaHj5zHlrar47fjo3Obrfenj1at56I9cvHmG5hR/ttbV3oFiWnzf5hsGCRqwUxnKD2Ny4aClodUIYt/2yz5gyUzJpOfDsUlp/RcksQvSmHikKX2KbyvQ5lv5mA9Mu1bz0Ikt3gbS0fizXh2yXX/zfBH8SSvpvOBhaZ+57tmC4HgDUlhyjTN0bRzU8r5GM+oVqrsqSAE7XIfqvyOB6mp5ieln8e8swOY6nFIIdx1Zz/2ZvnqHlIIHMXTD9yTrGazrzuCYA7CXLBbta0vGW7461/DoBuARbIBI9oZNqPg3hIe2UEfv1tv2a1jquv08oLB79lThEz6aEudHH6l8BkBJCA6s4Cc3RsER89ysxqWhO5HxMkiaPizmUvQA8Jj3RgAzL9II693ILgBmuweOOaSUlyzdWGF11yjAOkO69eUQ0DgXbbyfkIQulHVum1HFeuL28j7qAjeMQEL4zBywiy6J+w6jNeELud48MuO5GuvzxB09nZ1MAAMA2EQAAAAAA2V1RO0cAAAD8fz7dLS4sMzMz7vEnJzQwMe8oNTY2LCo4Mzc4NPf27Dc4Ne/5/wIsKikqKys2ODz08QQii6KnvkV2pUi5WOdqLRhAAxrf3fJDsTgUqxZ6/4lGOxFMaRipPCsMOnZcDgEEJsu68SrJ8SDDOtXa7wAQTAc30WIbVmYl0nJx9168uyn5NzADZjA9sulCCQwivYj9nZz0SvPFkW3tAxYyme0t8MyIibd1TPQ+Dhys6S2voqIVPzMhsvGk+4LTIC+mJwQ+y3s9PSzqj1b8/tfxANCgF/DtKDoOc1yP1WWieW7skynGx7TUDD+LgmUYv1USYYvoagQui+gEz4xxZXb30zZopM3Fh6FvsdGJet8bMFX8/V9E1cdYQr8Sozu4kpedihCM+JuxE1q3zKpkN8MzP36X7qwlKvI1fd+th8TrLfRsBzVgALoNQB4UQBocQpUrpQVFT6Em+M+/a/wj8mBrITM3M/3n2nx2adZWjfdX2znZ5l4NkWjmhRIBavXP/JZ2IXMlWGL67Kga3E2SNHfXZPS4y/6IR0Nykpxa+R3Lms4KGwBArbf48zbA3XD87J6yqsUfVzdPFSn4TnMDOcMSv++KPQQZVV1KCkwAAkfib5Xf0cKD99TjMAjKC3SLWcZpfqSaFQPs7/CfSwG+4sPgIl8YHP9tigA71BvN1+X9RAbNBBT94kKwWc+iUi+3BtaV0TUFmACWVrQsvCUThocLRfL3BwDQYwDUjiooYGtLgGBQkKYB0kDHEsmA0IrxGB3w7PbSyyo7OZecGMnIvrgM4uWlQSQac556EHBGby9SaVQjSPAnpjV2LUqXmKTE/mQzqlDSatJvXRghkA3jSlcCIWcziAq7iYi8vfs7ODP/063S/WF34wgTu1cWPf9a+tp0lzCNGYhAybnd/lnPZzKZ6xrbi6dRgX/QDsNKxJb1Ky3ooCz3lXPnfJhzDg/QKujYk0MLrQn29xiaIVPbmcbGREqj2Szjf9ZKzrQFHzEV9fGanwWsyOtRSzocWNmoy1LE45xNq0EARBIFomHuKrk//DgD6HBwvMZVgYhuUt6B9k2cIXC2r8Y8FaLmXKIAJBY1oMEizHxzJmyAiOEoZSeahO4j39W8lYkXdC5wOnrAL5/3EhkCJB4FaSi+rKTVzqo8AmA2Tk/GrvCnqpTdSG2rg4E42N/zPfEnuXPp76JRlD16KvXqvuF+HnQmiQXK1iPt7SsXSMd+YvLcjaS9ip0eo/HCJuX6nWF8BdHlzNh8a9v583FWSIpIKRwiaWscLBmLMvyEBdtgOvbKyY1PI3ZpRW9by7dkzL8YNhXrRONrptAxx9PW8uNbzACSSMRU1xJo959q4BD5vnfn9sLmcUwOxT7ngDwCANMBAGRAIc3gt66SE+wxKSz1539NKzcis/ZyXpzdeKz2d+9tMneTLVGseWZ/wCLV5LP9xD1GJJbvqYaKorGW5de9adPVFaRFpd7yu+JA4RU35DVDpZBkQxItO/uPNnFte/ub+iS4bPZ7rSoO47eYLwT6VVIFv4LukDjKvI/Ck/SMdXtIAtz1j2jgDkACJPxm3jDdDv1Zkk2xsheE3Z7lXETxJrbGhovtIPB5TOTWaKXbt9g3UW1rHSnYwi6W+rZLrehF+b1kmWmMNi5K0lMYtmMnACwONWNIyRQ3lvHFBogInuRHRnUQjTfbqF2SUyxh9u6Y7LPLjOzKLgDk7TyCx1C841nIk1fOQLqodltmRAPd1BGuUk4H6zof9DlqD4vtjwt+6KkDERW6T358o/V1ABwqi/0eo2XyH4o/8BUHEAc6kLO1RSKMYTTpFp+uwf9+WkCeXz/w/XlSxizj5BxmYVqfG1FfAgwqS/SBp6K8R8SeWdNNAPGE2QB7V8WkRoua929sKplmPQ6SbNL3Noyki8RtkRC7bXDGp1dRAxQeC2HgsZNCxZ//sQAdXePxT0K7iZQxrglge+lyCUgtX4gtHX29Vq8sxLoOBCpL0cCYkG9TS+ejXhBHIvjds1orEkKljrDGV3Ocfxhd9QTc+vnbmE0CHCK92LMmlHynmIfZX6csAcTDTCxu3lkmBpqjqfqux4V19qGm3DrE2bQ8TmEMKrn6mSPRKb16CQAcFkU6sLOK33zKbj9BgAbTsbh7uVEVq/e8c/YjV/ZHtJPI5bD2eDrzamsELmbtvdUIsh/8Ef1C4Elo8R9sy7MvD+JJszdgufzX+6a1PktKBtl2+updh8TY2qbGam5RF9negwnaM5qNTIYALAYR0dOzjRC3icZ3P5Wgo6d29RRMVknQyZ4yRuUfe4/WrzA3rydYd8QXjItw0or7M/fPsc/ADgDsAQugZ7ts6IeSvb59aDQcs7z7ov1svjnVb3qMh9cW7quR3rT03Y6jLRx5DVms9WAJXi83WmdUCF1kElkeAP8PAIAaKAcAdAcTYBIYVIEMboGB5IxjVlrh7Cvn7DgKi17Gasv8K9lsDwt5y9lZQFm/5WZiMnok1jhPwXwApFrOVVXV2+TsJqMSF1JsXR0iSlFzDiXlPMkrTiGYpqoqTCO++ef0gP/z7ql6dbx4uPZ7Hxaqc6TrftYx2Y/ura9ZjrCIolRyCvjSOVkomLUfoAeUp2U2a+kg8/Q3QzvAkAjpL59buSY3pBZmkcrNvJsdivyT9hGXx8sOcOKaDqgLmkW/4nCz7OEKqdIdPe5X6NkulcqarnZwL87z4z93bZQZq7ZEpVUW0R9y5+t0AN4YdAyDTDcuxsAvuS9zIesgKA0H9QHoBoAaBBCMJZK8LqG1izQMmHdNyolqlupL6zyZeZvK3J5ZvulUQzm3mz9QE1c6IPFmYQoHoGD+qB3DaPfjdfQU4iRvcYBI7OZy/U/27OyVYGoAn72J0ojaVhDgZSxfF/q5N5ydtEq22lI7dtGN5H8Ghe6x/cyQwDL9VZHV+HziBKwBGWD+sWG59Ui45UUnoRx6ut5Es1M9iT+a+wPFtM64A5RUg4KS3wxWCEwOjWQOglgNpm2FXcGiPciWUDHaRBrv5c5jpVelt8rbZ7b4lZs8PjXhXtc8wg+ZsJOTi5MNAPYnpIAC8iH/bgXvezmfynrrlyEIWwPiKABgA5DqpAe0uR4D61gorS3t3VVT53p1W1A/2GyarAj3Hjolz0JFaxtagmXG7Mp6sw+DBzz0YXWooAUEecsrR4GqdXmQS9ditF6Drnzd/h426RyKlpIAFuXn8smLnOh+a9QTlREfHk5TYzknLSyPzJYsQl/8M2PRiI+6myDxpU6Jy1Rr0RboUww3ef7BwAlNBThmjg5gJQc+5zz13nv+hVndtCSDiELVpxxXHIQRh5S8KBSVRhnDslibKMHzHFf52CgPxTMOi1lS7ZMLkVWpioq9pMMD/PlKdFLDb3g5bVvbCgiAEHZ/du72GQeGy+W/qQwPGFMJCUHO//2//b0e/1aGUgQPdGvnJ3sqANQtr9cZR0c9aSSW3reqc5CwdQytOIpq3JJYKFcyvJhkmbE0l5J7O8kQx8o8z4P4qiYEPCh7guoA/DF3Ac/pHl5jWS4Fb41yk4RZSXOWsrZU+no17uXow2XWRyP8+NetmVd8OWEDnqqO4Gq7jAa659yQVgsA02ZpkTrxhcj7+wMAAIFhA0A4GNSQ++ZJQFhOsWOKU+YkuqXewerA4+nC/KZfB2fHqJE49Vpa9RjVqWZRtLUmFzZduZTJ1/cnn3N+W8PeFw8mY4xRIpAv7/3WgL9/ceX+1KpWbZIt5DprRv37zhio5a42dvDKgmUXAODhHLp7d1Z4p2p6Jussz29NKwUKwEveUVDbzMbYP87iWhcAtHy55MurAoR1T/x+7GNOczvYEPVj/xUzuQMAsn/GnKdvtdpoO0MU0ZoKJAf8IqiZldnsPDWpk3d4x/5R2FPRJkw6VmxKsedFqZpjAJ5o5E2JQBD9BE7bjv2/ZxNW+nhl5RgkaEcDGwLYgBMMNqwhBgPMmYA06IHRSkfC0W9oaSzffXYfYYtrsrOz0XckRW0j7/sIXXrkRdYVvvwrAkDU3dQr1o2uSqPIRS8tCe6elAbxt1ki1Sb6zd3w8Ob9jaPjiAjjdGoN6rdttE3kTAcrACIqAZJmrS49uW1zda7nqMbwNcSeLy/39rjTPS3+iXstriZPARGhQjcSInRZ8RNrTNdkX1oBaiNGxgoE7PLybRsd2uZYvbsOuPswGMsSZhlBKWS8q9BKx9phL8kFCNj/60iXXiCkJNxKpAgQFP/FwF42kKWEAxY4tERBk/gR3IVT7f9+AAC+gHYUMAjosgSwPhqJ5JwkeISMEL6GY+QoSccKaXv3ZduaGure+sKWLrOWUs4vTQUclNb7//aTUV0CyPLTzgiSSpQHKUh782LRph2z+qLPcrvl0zKkl7Q/233by5+st1bLKNvOLRXvqdYE9DNTWxSRMEi6vFd/Hpnf/J9DYhIwirne0AUJYpG8dtD3NDcQlozEUiuBBixGUvhPzCOv8M+STsg2LRS3drF8sdFm3o9BiEqTdkWopLl3dWI3J5yLzS0h02UuOMjZQLgyG0HNDsy+PKu2diWglnEaoUwqqOQpj2Q7Kdck8depzWibU4WecVID3PGuBIaXLV02pTu++gVYRLZ22+aiJRV0GDDq/+3uthUnCHkWlrggc5+qTwDM9a44tiy5LLp+0uoHwLlk7cd3RKsRKylrp/6SP2hPaF4A9iapgiM+0jok+vyKtS9rOvQ3WgsHdNfg7sf0mGuWxReXBL4w1XsryWggcWvTg9b6BPT1ipTCgp3U+nrFQ8A1Pt1lqJDyRISINfxLqxhGcy6+JnoTGBEGuxyjAxTyStpJ1s46OhP7q6wBCEk26jmVLoME12mkfRR6Af9piS4Xu2SKpLBCvQMk/vyRlJNwcAlY5QnA61FhMCGzVeL8GMN6pbKPXGWjTvoo2L1iqvj0wQUJBPZKBNZkzkfXpN5XgUptvZ+M+7vNel3kIXXQO4ctAvrsxkITji/zzwRLbkCg/4SBUoTcdAsAxDFfh3pml+Y9jD64VSSAHsPUK/7UlkkoB7oTY35z5G0qrzBkNZUvZPc82y8fcsspRHV2/YR4AgDcMV+Fno+X3dS4NN97f510EjBbkIgB+1feolQSW+1PB0se8dkpanxLlfGAJlV7ItnKUN7UD1XwC8t49ABa59w4WfcLMzGCYRFHpZb93z8AAMAtgQMogGkGrBcgTxYekAYTifUsU6xiS/Ry3BvI7koZlLWPdCibVYpSyv/JFxUleozd17/ySbWiiNEa1QF/Mm/h9tF7l//7osUt9eKBSUyieAFUKCr2TQe3NXWgXHPD2071O3TpnSNXaD6Yry2/gWc2mfHjojUYpDMz3ZZLDx8mWTrNCKWBiZqqvJeQE6AmC8z6wgHUT/MyEi6dPbMA4DpdaycU4vBfg+uXGjo+2RBDiIChBU8E/N3qlwDX7xA/80cWgRalAwJ1+ppfmi7QlGlAfyHvdGFEjeKSuv5tAmwAnlgkhEuSzIx+UGvHfa/MBZ0+ZmgMETuAGwCgG9BsWEu565MEEFJKCAFOmdv4ZlMTtkFVJySzwIH7FqnlleRz2/zuajYbT/+ryaiAN3n0r7y4JHFQpJKRGumU4eanZsaXd96dZwyHTp1JzG+2ud5K4OxsJXsjuRNxBBWIFGN6HWRUzr1VFwnwhEGdyHMsaHh2N8diAeL7v2XYxafhTm1ArgWLe1xZ9nqnHxIJBpGjADIdaqnMGuap1jHANcqua7688/xpjuayPGtZ1DMYF1GUAOHUoH5fnbdzCBSHKyLv6ZWVRfUG/OHv8tMZZEDXJkEqBE9nZ1MAAIBwEQAAAAAA2V1RO0gAAAA2yU9uMfwrKikpLi0qNDn7+vUqLCcuLywwOTk4Ly0tOTk4Lys4Njc0OfnvLjY04fH0KSwqLSm2R7RBjFBG552omtvvVdzuDkNnX6WPMwnAUcAiYADYPQCAvBrtZA5AGnKIyFlWWmFz68B4X+87og1LztmMYfF889zeNHm+ka/FqtmNrqfrowgIRGfwQ6dFSPaGj2+mFh5wUwUebQa5ufgtTKadEihXJEDtmKXV22T4Q+s1BgMrAXCAkRy9coMHLn99/aJ1VFXnX7TEO2uUXhXFZ2YeAYBRZfh51PZo48N8+rGwbKUlO8gSMsuhOY9BqpXe72IRKRX25vEgaw0idfCjRK+8DW3NPj+EDbD8savMeLTvXD96XtpmbVTl4qRwrJDFQP5jEZktcvPyNHMrzYPJOAAc+vwKXAbRZagUa8UYwAeAYHvLUCyhsniiKeGDFkLtDeKPpFph/Nl6U2ECNAoLrCyPGl12fnIVLwCmS14sbTGVvizpZkAfpFLY02iLtYq+uwQLPYUOJAL9RjWfYl76+FtvPgB0vISVruuOJDeVxYNQc6N9/5O8JAoMRefuGwAs7nSEkJ2XWoNcv+YXAFxydaNKlxDazsQj/otmkHiQGCZNNreGDku7AgTySpMkfpLsyBR7q6IGMK0hHjTaotWlmrozxY/RSNf3ydMSmHUcA6iDxpwmxgHM+UqUsQmrHBkX7Zp+A2CkGLgSG+IjSVqOdcXwY9ABrz8zV5aiT8c1UmIlugD89cplybxSWhC0rdUDph4P31/t99ySoJouWpopYgZux1DF+/r9BRwNFAkEBv3FRgQpDyL9Vn1PBIBj255unBu1We99dSQR6H16EHdSB/0//H/0bSxvKm13LyzR/usA9DV3+DwxDXLGaMUiXeufckHsA8eO89b15T4T1tFBrYlrOL7a8Nteu5qeJ+ts4ANU6Sqp9al+kRgA2ifNSfK+aZcHX13oFcMneb8AAAAASxgjc1Wg5qEF8wAHjGoAEiEVOaHI0mKSVjsW3oL1uA0A3WNKTE6eTnoAMe8+f5lt1VrDdVR3xF2n4+qhJ/avtVXDS+THltaatNYaLXqkWmttfv6VT9dnX7JbSUUQBAC+dN8q4eBH6z3q/nnPUHtqVCNkucELr3SQB2wfmcpIJrjdPy4gY7Pcac2rwJJQUjIAyMuPkxRp8ekPuhEMlAcAr2ftuZ+/YEjMPk4xUWutkF+c15UKQF5+zZVvAviHGw3DlJiqphg6JQBTxz7LjMGW9VrAjY7H4ZICoAlD6XJ5dFKxIXAjkAAeKOWAC/rAT2TcQIb9qxOE9ocGUAFwpAlUmY4E6wTkBUBtQPtgTGiTKBhYXp1c0MoQ7POZq9nwy+H4fQEw+WmEC0En7z/nXEEsFXBzSUD5JKOXj2DnShcADQcniYF1ttGz0pSxV+ETRDelHW2nUSorZQIRY+rBaPeQAujBWbYHcxSob5QzdY9QRBd5DMZWlrDbBHD+8rd8kD1pxZLLCr524d2I5jHH7WjAh/ntyJSL/NUg3v9VQgcgsDilaWuf38Gscns+YsUhw8XTHU4TTFfdEwAkFrXs7TBy0FOvG0ghiaRgJxtokQFzCXbMuFkU6xG3/FQpykzClQYAtjdVoHcB+Gdcwwm8A1Dgq8sYY87ZcFa1AfsFAA7GQIMs+BsAIO3aDbjhwQBNYh0FenffTqafJsniwPQJZy2P2OKssOAxR6OVca3IiFg/2nAH6nfGvoIsM0vAw5Fevfe1Q9g1Ejku7ggkA6dTie4EnFFO2/47si8APdfsRldXyH+lCWDebP8rT6BAc2UyYAb+x1ODSqW4Jr6t/QhvAvZdhotp1u76rq0K27XB9gnJ/qUJvooyfP67a0NhJvD1UiFtA9O0Fp7HzkFlIoQfD/DaaN9l+JQT49dkTMvWgo3Zlsih4iuVLjqqQDP5t9vb5qFBYFxVOQHkNXfFYH6a/s6v6dZWGwK9BnGyqTcZezulreCVkgK0bCgfmeOBFV6KAxMMPkuCvU7Rvj3241viAgKrwf3VeiKZtqhtupTJxlmbgcn2f6kJxc4SpLrNTBQ+fTyAQ3/M5fXVbiAlQIHVxZNZ3dK3uYpjYl4NnMc8+Fb23qXPDgwyy3JHTlaeRYfboV7l0QACHoaaghZdxIFTz1NtbmceL6IIds+jYvu1TOAi8wLsNcuFRO/h9kuJaQHAP1ujOhKkgoEPcfAm4YLJ2ia6xNySIVpd+VcrvU5bAKLkBtQ1d4TEcvD8FUe8VWtp8AUruHF1PylmMHn7Aa7mpW3eAq2nALDANVdpEa0A/DmLJ8+YjOmBQ1s4LdqtmYog9pD8fCFtisaflCSzeFMZzS4NMfXUiHikLhBuKM8DDDILxIQcz/I9jzWzijnABbGVoJi//R86mssxT2lTwpTB3utfprgQTuc8BdRYU2Mc5137PHEeDRUA3DWv0Sfg86CiNZOdZhXdQJ3YDKKYOHdpbHPqTPN7iyyySs3Ia8gwbBGe9TbMhRleIRNUOD7NXhwA9EF36uy4NXmjjeW12a3iEAKF2AdRJmtZPtgaV9fXm/gB1S15ojK2v4sc38KdWgzDrRfyfhd6qADkNa+hPGsd6VNMZuzFbi1cQ6DXc/N3Xh/bzhGrEX3U1da5Kf0M+FQHX0jyGxAkABQuywNPbRn7pVjMWF29MmsQB3BgslGoZKjID0ESsRX5v5no9i3GNTIm5teqBwwudzLPOZouxWDGS/y0B9CrAU+DMVZyS4v2C6cHfCK8+1ucGg+i1dDb5J8MYSQ6PTgB1WhnUPEbuw9nVUYNKWjRXGBpw3m2NHUcVpPmngvrvcbtEjIPhCRSOVU/PfZWnqI4JgHuAFQ6Nes5UylHMRrjTmvcCTRaXTGDxN4/Z4Jx2lbJ8Q7mfJapPI8/heaS6dEYzd/SUnr6Rckl9/1yABxCC6xnXOxwBw7ddB28NSiAJCYIQML7f8RQaqU2O2aa5nq6VNYSddjr0hhK0rD8xPxsi3RO8em7FD5LTQI9bP5V/qFamUj6QTn8+u+OTVm6sExcFwz5i+r02ln3AfybGO3wTuMhgQD0Pcu7xLhY7YqMcXt9SQ2rBJ9ffN3dOFXlCllS+5JGhvu5ACFU+FARXi8SDEb1KjHrarlTiW7IrjW8IGjBIwD4ddI2MSwjPda+yuwyE4NKz5YK64mZ6Lpe9LfHjoFdt5XVLwDEOctSLsqlDfHT4R2u3YdEEBMkueK9lbxltIzXMYaSzfXtaG7RYwXzhtteSjc0aj9s/6x3cQEsQn3NNvyldm+6sb08q4gLQAug2NO3kvjcLpPqr5vSDfNnMi43vqX4JYb4BUx1V5kwfE9re3kCHEo1k3ity8ZZ68J+ci5E7JDcfeZOhdJQ2H8OJJYQqrZbj9Yb7Q+IQguopU14K5MHFIJGEyQyvSFR3JJ5H91gIW1ViiZpdTxc3e7Pa8k2/9ZiXVu45SIvxVPG6Gb+MopIjYXezx+LS2uwA0SJABpIJaHv18TnvG5/2JgO832/mW485nmeqZ4w/CIATtCAoNsRwFwCgBrbA2JhAKQ6T/kUMNaaboQDgby5foqaj1nvz2b7L65/GmoucBxCAN9v84PBg+yySpOENFllE+lJcJlrurdIshoQWmvV3HRfP4WnjgJOrMSg1cpptRiTQTN3jbS25pJNIg0DBF6opjYi3yCFRnlT5Q/agy1MwzydrzIAGAbDPUFvfqnn7As/6MGTYcsFikIRXKvZEGZCwJCUNxl1AJPXt1itXfpVQWaYNRhOc0rJm0jkCI3oru0IAgCHDNeI+82Ow9I2qmYkd5X83GInwwSgVTalA5ZHBYRYl/qz16EEnmpAvi+u7Jze0tryj6hh/1ADcIICVCELzhsApCtotBv4slEi8ZhkwB5FT0wib68Hq+emdusoR4Qtrn7n5OSIcQ6RjOhvm8NjaTy7aAiU2mbpuvxMCQR8pSSNsd1AlEiIhIa0HdIvbhjI5iOzqUwvl66wUhfjwSeXNt8KnKflUQgyRdizIe/6uhlpA/r6WEmCdjgqoHd+yNTjG2qbE0hE9NvEY/j+N4f8LqhDA2T0lsBqBD9xS2iAkel6pARjeCkDhf0dgQ/xIosZPALkBwHa4M+jNZpe2tQvxuyTc6EcsgTvgQYA9DkLU0IyaV906LoarY1NAzUBIbxIu715e0N3PwijxLPf9KLkeS/RLPEV/7qXWiQ+RZCAwq0IlguCabQGFCTlPDR/baLr1SQxGt4ubnTrD4KF1vn5+eWcs/FZj09NdjJzOTAYDfwtr0UDVIO73HZj96ITVANYw6RB1KKnufnHFRveKK7e3i/5unptjY5dJ/Vk+rCn0kb3TgK6B81g6AmQHbDT5evB/eaX8euuqEP3OyVEAfoFzgMoIHkF3hyUSZ8UJyHHTDFoZ9p7Q+TyZjF9X2xdmKlVwWVBv1Kq99vkpOYIC1+EyjaxGqAeYzJO9OBLK+BaqyzQiDFGp9oDm1YFhNW8X90f9NAkCcstrXWhabbvIWfBMz77n4G+1bi8yAJ0qrnZCUn1Wg2zI1FVtf/nH1QAvGE8NcWTKTuJwS2tK77CxwTQuH45zjKrHc12wnMV+vgdxZKStvil4xp7Hgdgpj+ws6irZ21BAb1m+Zxd0WvXX3pdoFYDbAB+uKRMZrRLrEroPCG0v5yBTvLfBhjeA/qWmCFhB+BKgIS+eejodWQQW60onp8a9OVnxCxeyOXA2p+HJC3HfAmSzub3SIhjsojpB4we0YqyksbbUwRMIk3EbmimKZWAlUN3LAkhykoqpB23D75UI9h82cdh35iJiJkA0wBoV0+qVzxPFyy1gnIIrc+sIQD23I/FVvsE6CdvV/soAlpSS1LKBNyj/P66vFLnyGuRybkh0IakQAhzLuQjJT2E40FM8hwJVd365pW3klbbLg7/bT5AGovGojznSK/OtMGE0J9Ls1+k8r1KgnbfU5QC+7TSeSABNqfkOVkvbINReKrz/QMAYD8B4EiAgB0JlAEg0GwAfp/oaRaKYhVMhc6Ub6lHzn9ne7RiPFkelpQoXWIUYbzZyIEJLdCmEuZLXYgqFUriGLQzVmlpbfh2XGpIQiTIkykRVR9rtUpQli+fbrTgumnVsLsnrb21fenJkhe4L7BkIJ04dYU33r/lmVJIVPRYgB1BaqUH8LWcwvVs4E/b/bHgmd6GhCEJTMEWeX89T963Qn4zcHTzgIXJ/Ex6BdMBTPByiNgjQlxaIRaplo+JV0OR/RpGUkgBsHxECI7pW/yv6WV25QCkaTbzYAwWfwOZVSxF0tCpAewRS409mfTJ7W2+jAfoBTU521ZLr6iVolVL/jVOTuhbXIPJpz+C0mYHBBpLrGd1EeXsHO2XnmJoEA2CVh6jWHVFog/qvXjqRyN25lcb1EwiJaD1CAAEFsuiHZPUCn00bdNjQQMSBpbTxFEavD9BrpHM95eQZjouYPl3KaFYiwAkGvXGQ8BlyOl6u30ri9ZMBOKVvWs9yk2pnZaQ8AbVZNL4k2AWu/xeB1hudgAEIouC5zgpM68jry9cElLBaD4zVrKKeN7xhqLynrlcka0iFBZIOup0AE9nZ1MAAECrEQAAAAAA2V1RO0kAAACscFzzLCkrNzM39u/7KSwrKyssMDg57vIpNzXrKTQzMzMxODktOTk39OzoKzIxOefwBB6LJxtdIQJHOdbqLICglIDNMIaEiKro0ppJPVNrKtCxIsCG0H1FOZP0IctCgEqKRSqZ6580YHjg8iFjYSJ9UHX1JHTbTF/JHFLFMPzrQkyVK24A7CmLczBdMi/TT9saQkPSIZ4Of97+IjeSy6djZm85w6gvhpPQNjQbahAhKflT0E9IZCNi3RnrABQeC7WANwdxKKijr+aCJydXNg4tJI4sgjEF+m7x6hxVrB/iSerG+fn/L9I0iJabX1QnAQQmryIBKRihqc1Sd3/KBX0iqS1unWuQbZlYTKOfRVNX+DtVBLVEqWqJDQh+xZ+aq2PdxyeczwaaB1UBP65tm3opg9fbl/cHAMB+gK2A8wA6hFdgmoOylFEyh7NzSlHkmPNgsKzEuwvs1NlFkAXcVIsd1HUVu38wmJdGiYR1tomWL2fXpVHVVk0BjzFOJgdn7ts1iCDzm1bWuOk8eXfG7CI2WH/fCK/nDaqttfeXaYYOBUDWVgDyVPuWALCvU39XDUti0IN1TgGMeQxFSbRHgaysqtoXXr0GAoTDMJmaTHkeqCgB7ClkO1tXXQ8ux0cRJ19SAdOggBDQ/qxTGW0QSnNjBpBVVbVe0wd5xZqnSoyslaHn1TGj4j2zwxnWCEjGfi5124xkDTL8UOAdBwDeqDRaJE+BKul8JKL3BwBA/wT6LuwAgAdApgP65mCw0wWxZLZCUSRAYneqpDcvjChIMj7LKir6wuE/UcF0tNfKisRXDfeEUAUJaccvj6pTAcZXUissgKyyZfl/+09jGRrdc606HVWEyZzKK/1h2mqYD7/I5JRGtoM0ACIi684+fokLXt70ZZIBMHPcHLgD7f4cizlRWoUrBisO6+DzMLO1B+3kdbCDyV1FzbFgTvU1ZukUx35OSssPyU7NufmP319dxtMuYZz23zj8e0bG2xZKajiISefWqw0/RbhfRXtPuQeZCr3wPzY9OO1i2uGtAJanpJzow0YUWWm8za/o/QEA4F5ghiMBwJHgAM0G16jO9TSzVpgLl4SV+MSABuGivc+IiVSrNRaqivWnoUhCozDUDjLJXb57zIM7gLS4b9PVXcFV1v3uneDevOru8wMyOrkCoR/493Yy2CT2h3f5a88eQz/elLvOrOpX9vxtIhWoqYy91yDqscwtSE2iV4pUIqGXmICPgRWkhuRgbcd1BDNNsvKC0QZd+Y3TPHs2Ec2/A1Z/UO0GjAZgJEtdJk8BlvcW4QlHIG0O25D6UaolrQoCWcrRLgB04fOuDhCfCVlvZ6UcmrMM9j19bw3JOoCYtqMq2CCg/oUDZvMANBL11hYOn7Opl82Gh24Mb15/lUzVtKEBH0pWhDh4V/Ogtw6+9vi1DAI8Eouich3e1uyXsd0MqNKAxldf+cOE82zYRtYZZv1d01Rp1zJDOhfpwDAzOwQSS4ONQ1uXKnXz/bEgPIiTuVtaYuw5l6x/k43DmE0/97xZZx9nGJTGtAAsDgurQjZbJtWtZlsrxAHDm/v/18gwWWk14GFjxO2Dcv0narMKiO5AP2oA7A3LoucsUp178zYvQLwOFUXjb7EibX20p7XCFGo9zuz+00hoVUdwckckACQGvdmGUEvIcNj1VSpEA/Ha8Z/m0NVog0w8ifDFWJcwV0UqxZ5IkJiRObwAPB7FrHEUO2kd2xcDrA7JeeMxU7dpVccngayGeHRvUtGXX2sTJUEnPEhQK12zvjEOTA71gkJziXA1lrB033DYeICZLzPO2ThtBjY2Lr76/+l04uluEaz4v/8/Z7a7gI4OJ1kAslevLAAcNssQctfUJHbuVEevihlAr3hois3nTppn05/8i3EmfTJeiI24ujtSo/5xIlIxXFgNIt+M4Iw3DQC618yTsLPKXT88PjsX/lQUa52F72u8RBSzCOrbx3dNwKgfAOBKkqWBHZLAh9H6USYyM4S1x//zxd4BfpT8XDBY4ddbViu7OJlMkuZGNNuKDwoq70RY9GZnrrPgY3Iy/eDX1uT9Vza1Bgr4ZNqtuz+ZTrymVGTVDsrKeDk1hTLFzxe1O5Awq/XRh81lAO57hIeiVMFu5h7Oy5UVZwCgPVABE9x7phZjJh1UU/sbmn6TuBCQLia6f2PhRelw8etAjsFP/EWOgefthh8TgEFUTYttXMBvp2OTVD1QAlBAAQOMKbo+ip2chbCWv0jQDwUANqcMFVPRtLsFvVOxNGn/AABwArBxAEGjqAE0BmhPS5Q9iY6Z4pHWZlk6iIvhOFT7ubLptB+JdqyZCs39f8UXgoj4MJfTqvD+pHHou3+XSIhqGZpbvjMfeksbAoCSynJnmJ5m1s8uh+V3/92a9fl5C8/tbvP8C79rV9UojTQGNNscSxlT3gpiXxEA1PBX8OpMAN2m9T99FL2ZX8/STzlogMmnOlTOjN0VGTLqWAY8m8YPiwhQau9keAC26mOLQJbufFj2HSAR74k3FHMEf+GqHd7k+lNlBAIMALDP8NXnQdFKgAkgYA+MTQpz6n0T7qU8KB70HUuTpx7yOCvu0ScfkEEatX+79aSNgnvRX36Hvjk1MLDlDbgI18opAvQVi5sHlT9m4ChJWUeUALPrODdzY/RicvNhrel99+WI57AdXIb55JbtuERIR4wlp1TbDc74SAA8Cn2zRlV3Qi4H3xpnQqM3EBGzM1GpKNffZEwMbhJ6i/oTc8zTtx3t2FvIzhwZOLxer+fnADKnDEKzPMqWZXwN6f1ejrKHjN3cNR/3CyUAjgQFbJYSOgB5lHAA8FLjiLLHrCia1sP4Qf3gIvxYjm9vRtV6bu+wQIRvqyzX4O/47sH/a1SoatVrdSm6e1w3EQ/PZlYlCaxPRd01mBQIAgJKCCWVyYAp6gEaQ6hlzuDZhw/ejQMCI6wneBj88yCH4AxOB2uchPN0bSh9VE2tkU5DYtjpl42KAr2CJ1DIwmKupwGObcEOZuIX8R4Eolr7YE61QchkNwHLEPrgfZpj0NnoXavmktsH9LgVfrSMoXi5dNvsxe6TvWkFTGBpQmZJ+gMkEosDkGFZ8udf3tcEUUHBI8dqJOnVZk3n1u8N34iPiUwn8Shm16sQDTwOddVA8e0mfrNOR8JCC8CxPB4tbSI+ZcvIFBLXJOk/jMpiv4IbLvS9PgZuTL1NtVIlnAxEHrVuxFgl8NdJfevUG3D1QbcyR4nxesjKoL7ereWVLkEQhoNyzFjD7l8sCGZPsFx4kUX8Kb3R8xuzHXTBdrkSGjLKnuccKUyiux7XF0U/rO1k9zrsTiOWwwMdWXy7C3jiL2jKJQCkDXdmz5HuXeUwy28AM12cTI7TALPfRuUPIcRMm5PXg1aPQ0uPXDOF6Kgn7lex3i5lmgcsDn16o3lSjcuO6XEBmVxZzIzYeDl9GuLk9PnIDlP/1pso6RytdYDR53iE22p1LA8C1DWv1Ty1FqbYP+P/VjUNArObdMDoXaRZC82LuU+l6uM9156tVI3nVEt024E5SoxSS7aPBAUcWQsUOndKcsR/V9PRa2jfXXO1HjR6C8AxlrGrTCkXLZ55I/x4ILB8VbTcLNN10Wzaor6zWf0j59CeCQD8Ja8qT2NL7kN2qnO2tgp8RA9/3m//pSWPrbSLjIMJ+FvEcRLqCUlMsUJ9NwAkJkuCXRrSMdBx7nlrjZuE7rqjo/Ckxs8RlPbLXDwt5qPV+3LF286yF2CpX9a5mcbtW+rLiwLm2gBUIqlgNz75jz7TOcf0ccPCn0Oi6J7E7h22/rRtpGRpyWHRucSjt1C24gYK0IiBMwpkEB1jBdW/DgFMInXKZob4UVfeqFO11mdixqD4wKw0TUY5YjO2KZW+VXJvGr1XS/xsRp4n0ttSqNRP1aw5KcoCOrfMqH5ohXv55Vp7ORGPdCKLe9PZaOejGNiR28+A0o8FgDdMMtAjSYPLASqRML5PwAyTwk/V0V1vVDRz1frHGfqxaVNLb8REPJjn49VLKYW1NtFaAD25UYTKVuimpX/PTN+bSUYcAJ/5PraxfZBhxFmVVM8ic+eh3KuoMgmEuuEWzpk4Q857OpLibXnspxOUsi3Li0oa4z1pTj2VQkPtY8W3T4QLWa2cIQlu6VSzqmJYFbD/+kv95JrmixjJYFYbCx1G8UyJhP6kcqfcTmtpKriGFQh6gEcG4Jqf1s9Jqwg8CcYtLbO1Yp08nBQLYLfKS6MDAD7IJAiTXmXWF+gfHiDafwCARAGALBsAt6bNEmDrLQMDtIWnUaQfIAVTNAAKvU5jBOPKmNruHsUNKXv7+lILLw88LJifk2hpIeFSTbjxzdyUlIJy3evw+ZXkXppNmy/U7D4iZ6NnfJIQJ66pNu2a3xq8XXwWSIIWfcMSkGM/c6wxHMTkZRnVaGkAsi84Pg5AsHm5SCDtV1nJq34HWwHH/f63j7Icuek6FcHigNou8Eu8x6aYa8MjzscM9bEBUlxLJEzRKL5F2qn23a5Mumvwr74whp2uJsxze27jUBQoyK4D+khENWQfsBUENg0AlrfkVD0izF6jC7XyfeVoqq7nOuj5eKoDtgx1sJ1WegBymMIAvzx0CdF6LBRFpHCgc7exdTpo6CTcwF3NmkoMrcPh8P7U4LNJG+4dyEeH6ALh2devb2VgDaXBPM7OzElIgCrU6CZffFpdTnlW1+jfrZtAG5zhzgad8U7Wm/36F+PwM8UlCJzv70CcJbrS1j40WWdKQBn5SwbA8Nq+ytcFbQh79pXhF2zA2y47YFcEXbLHawC1BkKvZ7lkCo67g+DeyuUFmNEjB6LzADFzuywNTrizK0y7Yimz9CIdnUi/IpFaRWu6pjunAkQiaWfIj0jeq0igzt5sX9CAgfsuN37iXqDsSot+3Sdz9xIHQ+JhJSx9JQU0FnXJcIx/WuicVt+XAOm8f+FraiUpVGt5Zvx+ANleqdKFtXahMsHZ/ZX2icM9z5x3ABQiS/SeFkDhfX2PLLLMGmz0xPz7/+cj2E5aZ8c2LfqVlqj7N58nBiadn186CzQwdwBEPvWF2rjTr4m0o/3Pml/SYqLruvPlhsVqndSf2EziznP5NcS+yI+/tI2GvJkjYr3lRBb+ufLewAO657SJTDd1vX+9fJbsWk4pZLP3fal7h/a0po94xlQnATjGACgW0FFhQhid2FBIkBSfhV/vl4V57ydH1VfSajY1vMo71qQCTyFiCYua0skyZ2YSI45mzXNAGaVqFX6aAEVr89nvB48nY4ywYwr9P4vRGaz3SfuC5/QtHRVZKaV/bagXVQpJUbNnwIa7uy/D5cq6KKuqav8QosV7EfsUA5MpQACDWNlThehAZtBisQlvcZ9nQ1b88rLpNVzF2eJ4+/rvL3b+/uXGFYD2ZpE9GhbDqWhqVQk383xxRVC0egw0QHsznQv/AQA+6KQELEKn/fmyyBKR7O/IRoPSPJHrHQCsfgBAn2EPgGcGMtCQATNk8ANgiM7mBQNBy0aOWB0Hq0QVTQqNDZqPvqhilis6+KXyW3JAh1V0VIQlpGgQJWBBEA9XN8qGREpRRJY233Lv6uViNvVlukcfqdOlpd3PG2sBPU+ZbjI3xZ+uQ/Eb0//7ZSbMQNCGU6JxTVP81b1cK6iqB4hDIeGnlDHZy4t9+iDSTwKPuQWDgxPHJDJtTdtdtWJdnEVLmlKa49SG3xCSMDK45zxgZ2+Vei6XNsea+rCKYYegOuTw3Zed2RcesLJGfDQYZ9N1ugJPZ2dTAABA6REAAAAAANldUTtKAAAA0VRGKCj3KiwqLCcmNDU48e7tLCouKisrKTQ4OCsuODXy7PUrLjYxNvj08+X7ttekHFyDmM5v1SNwLZQk0vpVP6ZFPcroFh3nsz4BgB0FJAB2zAoLIgN6yIBAGnQ4v4lWMDDY2X6KhN3k42Trn26ef0HGnE/Xi2HEq9LHA7rcYimbBEFUQHAaKVILb731pjGiCAJhaHydNteXorTofTX27c8ql9Zp2tWrCReM/A9uSbrTq/zg8E9jW0z0mLDUAVZU05QW7rDXWZxKH0Tz8JBpPrF93FloPoFn/JCki6tdAPzXvgkCm0bNh6Xn3xtDDYvWJtnC3nier8oTH+lJRCltoOwv1kOXpk7BuB5hBGewUtXiMANTmxHjHateRXVizfMOd5vXARQufSwBT/nK28DtXnSCBkWANGdUaRHghrXk2SNWdSKeYrS5TDykZ9XPFAQivWii/izHfPTfetkB4sKUHIh+0IiedHXBUG4GMuSCs1I1DpmpquTOljEnBDY9IDGeQvFufKtZFjSYOtg+fNmSyHlVyK8YlvSE6E4lLYqn7fY4XhAIHCILnH0eQjsnVN2+WnUanAYW6xfLooYRepio84sDTTqkKEfCRQYZWfLg+g4ELv3MM/a9krD6Pg0iGlzzA0iQ1BSUGjpEhjLxRyHSWyLqbtQOHQIcOmkkAc+6ISz7liB4Afc3p0lkXZ6aQhOtYYZSabRIlRj7QtxDAvwhPSxQnzLlPjzX2vAGNCjOr6/MaxhyZD/Th2MymyEtxKU95scDf19dH/2bOFA5Ifx0FwLsKUuLgrMR+l/oTb3cBFVYTPOwLPq6sX2RE73Pm17gxLa46yeY1nqxCADK48v56dQArUsvAhRC/SV2u4cZp1icFTuc1lYVHQ1KUn9u55+xp6wPG74fdSOMbcbj07x6w5oln5UyF5N08k1ZhjgeuvfkRbZf1bF//WbBtYwZSLr7AwB47gCAGdDsAdAvAWoGthHJnOisSjBFfQ561CCXyqTG38xlJVWqm0rFqoNKCREfD56uNSJAIGVxqkUeN9ScA5Btra3+XPuaW1E9edGknjWe0Z5VqyzW2rt99/Meeqjss64qAnAPCPIxtxrnjHm18eGog56+pUOr/GevSwOGz85uTNDtFm7gSRxqHt+vLJfL5T32m6M+YgKnKeFXj1NCNancGRAM7fDTOQFgaxgGPwAAU1NT7ixtDpceuvv90kqwoHuv29NucoeTLY/NjWhDlVy4Qu2/ujzB85WrbQ8HAD7oFAAUQhxnXS2yFIWksJ8DGtL3ZwCAXRcAAJ7q7AFwywSVAT1lsAYp24QsycCNJqe/yzP+Xod/T5PsATUDAGpu+ZOQKRALyiwCcQaOQCosm4gCAMiyR1M4FAmg7F5Zllqq2sPHX16xW/so4rcvpHxaXTuJ6SvSazV0l9GMgm1ylX7IMriYcV7dujHSvVzLK76JofOuUHeqTgMFoiIFyhK69f5hSTmewqRppDuSBQCADZ3vIhSvZPXyozk+3ZWZiUcif70BFQUFBRswxZBYnaublS182nYF0IFrrAmlr97JRh8ezqViU6yJr01dAh6292QQ9Ast7bfOC20tEvvb4/Onors3RItqXA8A2FEHANBTFrCaMA4wN6zIwDixwlrWioKTCeOG5+P/K+HQZd4z/FZOy/98o/fe+0nR1sF26feyoKyi0hGpDQmRoihK9zdkoRTUeuPK2fRQQTWYa3Gtuza/9v7NbEtPBIxEm/342rY6LdIh7pqKO4mQmf1Mu+dkej6Yek0U/i13wb35nlkl5M3Etb/f/w2+RhkA6D2GliBg3NGLUF43RipZEy5I3Cu8XUy4WO8UqGJ8+I3IbZw7HZchK6OJe4F+sPTSK2T2SAErrqX/kFIj3VnBowEsKvWIZwx55v9ymtqyfbWSOJgS3g20PqVYa60S9dyu1MaIDOIvEba6BKurAPwt/SABQ5cgfKu1rwBx0CS8krI9IDzDLnjW1SvRk423uajvPineUhMiA+xBvXTiPNLzl+rb7e8bgzg6Kr72YSBxAX9zN+2Fn0OLGsu4s+im8GI7mlAGVQD8LQuhXYyx/uH3PjkfkBqfDoX0CjTUwizvMYM8LsRRLXIaazYTB6J2NgscRvUwge/z0u9QUG02PEklPvx8Ty8W8//TxkqqnlhBuJVxZkoXU5VjMxYPLDoFEMxTfvHzAXrs9U2IaPDs11dtVPNmKB35pub6JpIPZdwr+jwi5O0vHgQuvTAQ+7R/KTlZf9d7jYiAO2nur3pjAyrdbS5diJDxHuJ6U9mYJeuR5En1MhfyeY7+/+S5BPZW0SWATOaIf9TsbdR6ro7m+fwJ1dbJb32QR1zmlFx6q2fu2sb7BpQxry/OBU2OK3BQjNmrMIBDJLGFt/O0GIkn4Z/MaOSmzr18Qcd/3ezx3vO12sj00Vlubrfu9jcGBD5LigO7nb9em8i/VrUCdDRoyYbbAiYnYvk381qH2s4wEtOPvtya33LQt/KQLYcqDgrqiF4PtAQkLks8nrV9nBapzvmKXpCSD/V+aiBgLn8oyRGY5hVLPRFClCla1mCvNfcALDYL6SCe0nIFhuKZtaabAOKA4dXdKp0CsgyKjbBGRtkCO/s3L2RpetzLv/tGADwyNTQBT5G8mBIqV7kBDt00TqyW90LuEjr+/l+nm+8le7IdcZ7YZFVek44MjejpQdKcacrQqhQADDY9VOI8C9OnvnreXkUdoCOTavHX7YmY83jUWLKHZQyPuE8WVlasGKwuoYgRkl0Pu3iwLAEaKHVIefLU5m8vvxFb0y8qU9jfcbYssg3DMAwoXe8BAAcADFrADu0MrK4qC4BnAURjE8MMLGQaugsa4cHn4OFMkm3uDD/9fMyUQSDqNiumOgnZduGhm2SMWk6vTtViEqKqT09ebdIAmOSeP3AtM9sEY5gNXUi271/+wqMDsPIx7D7zst000S3houi+9DQ11CZle+VfWEX0oHNBCO7NHt53gM8GzL5k1L2+5BxtiJ6rSi6VsssM5Zei4C80AGpEVrSaiC1kMtOgf2mp/dYCbUDd0b/7Q03ZmARcnKQmsa4miO4NIVQyU2ANuLXI7UaV1Qk0AD5YNQAURv88PxYPqlNLsL+UlgywIwCAHQ0AQJ9hAdvDCjCASMEAnsiX1hQ4ayZ9LzclJ3q6zPqEpNbkBAA9zu21WitSRYmHBCKL1EpJisM7LBQH/PQkTT5J7fQ2cVgmBvrcKyNi7TrEKnHwzMezB6pnqzQ8Df7sbW2R9XyVn3igmu8kEbayJEJPQOK7vrRWZvLq0OwM9ubI3AGYa+Lz6nsgqpt9VYANGoqUbfbp+lOWrK7D8gDfQx8jAIC4n50oBc2PfPghoAlDEfPnBQ+8wHfoD7X/SPRY0oZgI3x5x7QZwR4SUWkq8XQlKgoNFlg1DDxX+mf/1rnEsB3eXFn+rgkmD1kcgtTT/b4AwAcXAABgJ7DCMIwZsCwNtNt2MC2pScHAsrWdD95KwVYu4dbmv89384OtnJ6cTCYuMiLaIpmjVV23nigoEKVhKJYWI+tZb1cOWAQAtL3+v+faWk3PBh1DQtdzn5/bsOTW0uvr82eXfx/XeQnRhGi8BdIB4rnBC7xxey8WX9FG1yxKjXTDh/+NJR2Oiq+3IGTgZWSCoXPAJHNHx/DeBSdpbrIAAH3/HkhglMKVZ5ELYvBu+RD5S7VZAPXhCFNYL/RBWoFxYTVkxfot+5vSIYKukvS/Ap4NGwAkRkXsGbuo/DZe2yrqCgARSU4sl6lLcHpabT6sEsV9Odc+GJ8y2SjbbhYk/EV90hNPue2fo7p9/PoBcaEbxmptmUBmyZ5i47b9puSivpm8ODUmYu3gn6oQABRGCdIjg/31SzEztPavMhOWU860NhyGgW8/2ddg+SHmtqtPcty+AmjG6xRGrTlyboYtc+rlABwyPTsSCZj6Taz/6ZuCTNi88XUPiZeuVZxs600lF9s5290DGu2Wvi8MxhHerUcrzRL0QcsVej7uHL3EtgintTGYyOTzNBlyN4HNblMcbxFSbKwfJG6P1xRc4kgVohZvRsHOFbePawD6JwUsKK6L6fv7y0PVHZs/A6T1++klYou7RYPnGq4ZABwNAN1egL0lCPcDADtFBh04upB1TDFg8jnfz95GRDbnpunAXP0Nf87VmCqo3NSJcww4axcObck2CuAoTizBFZ88eNA2UwDA2nZv/ttGNqsULAEhgCqay4WXmaDW5rNtvp1tz5c3/+KV1+YFYIJKk9txsjWWffCsnU0xdIDrY1/vVWRscAdV0o60vJevEx69miwwvqhg+zDfjtvCRy9ZtoNARlHPz9sFhvz7cgCDfzyF8qDmH3yGVVHJcZKmgUCqKvuwn7ZfBgwt77K1h5absH7owPTAxC10AL4orZgoLG1+PLwoZ8sk9/5sdAPqagAA+gEA15Q9AV4iwJiBuWFFhi7gsWedVhTxz9vP+aO3czVU6iGdvnDcBwB0QDYYCUmgt+EZAACcuOdqF6MUBbndE9XWtTzOkfXTHi0L6Pn1IxuD78zrhmdF5ffdkgeVFMHyFkuhKvhR+7z9FUQA2Db3wLURnHYpHNiE5M3TlrwiQ8hRlzDExoZAvYAhzRHnqHEy/2Quba00iCgPDQC2SK9cEOXHkqVrzGh7Uu3g2MLCS2BrINOAYK0OFtPkzC8EXLiHYBoqmNXR+uaUo7z1ZDplJiuqZts/E1DuKPNXEQDeFxUAlKlN83NxIa3itP8MonsXfLwLALCjBgCgz7DBtguWwHQAoFRkYBDseQ1r6YAB7WbbdP7j9poDkSWnZy6nAgD+08Th/GuJSMS1hwGhBBTUqu6qhgugUJWv3+y7JXjLX2Wj84/07LSqDWWUNijXIi6J1XFTcn0TvferyVd/5xZf9VqdgvHkyXQfjQpVWvNvN76aCEFiJAMkGIAI8Q7HSodpPJPGP4WdbEBN5QIrE8xK2YcNqHR+vV4LTKYc2wAKVU4VVDicVBTxi0AMiSPKEOQ907nld5A6W7i1xmCJq6nSrb7SCfzoXnFmBVfRN7g/AAHeKI2QlqqlXZcVI8H+2qCXAMfE/n4pALCjAABQlb0AH4AuA55g3AKBR7LHWlFs2yjyub4RCGMDnSDmKnzr8tqM1W1iYcVe6FE3k/vihYiKGyHFK1CxxEL8LuBSAgC2zO8rWIduweZiRTbY/TeZ3D7bEM8iyyvpKRv2uTxZS6qAqOM6Tt/IVjSIFM2cRfZTXdIbLVDjXFi+EDFdXaROcMeYn0o4C7gP19xYhEboCBYOkrUnB+B6mUx5pLHzkoc7UMULFvJ05zavgMzZ6xpb9v8ib7dJEqiNEBJq3IgD3H2qMDpZ1ZEAfkj1mJYmPs9XtgiyYAXp/mmAaDBPAgBgt1MAAHzf2BPgqoEDOhAMAAPW0DaBTssUGBxme4x/ly+H1k2sv9ylZgAA98v4s029lIgTKoo8hTiFdb77p0AAABXZtiYlCQmgKjEBk9V2HyQkO1WaLSetuO/GwUtT9WrZD6ysfdFmEpm69MqzzZIpuwrO3AsXO2BhbOGLBz6UnbzA68ytCSRIR3ru7y0y4V+o+bKkUg3Y+96pCQAAYQr+BkkyYqgkCf2fNGCGsYNUcy0uvxjVURR6lQKNAZC8b03WohlUCvwylAQogts7jBHpPSrN6QM+TpDwISfCL8s9Ukf9VABPZ2dTAABALRIAAAAAANldUTtLAAAAAKiHJxPz/w//BPH6/Pz96/Xx9+7u6ubn3igtQsRqm69FL1WnFk6mryYYbMD1xr/+aACwAwCAnYg9AI4iwER6AHQJA76h85JGy4QD7/npZSh/xIYKCUHNZqr+mISFBZS0pE9x3zX/NtRVumpwjZKrDOqQBIQZ8wAAFjQec8QXFYGf1AyUMqgaCt952ZS6qCUcOJjy0Lg1xyYpdrkt6WMZlS0vTQDkncqxgVbEWs3l+SBFYCt1buS9luCJJT1qwDCBYfUYAQMAIhERlwyzKgWu6pmMo35nAbVGxbyyT8DPqYaroBzsGLIJpgar+INhWdgXAsESgUYSCgO0SdAmgWgoTM5EPRxhIkOjKngo/kc11CSPZ/7qXJIsWFK8P1rTAWS1AAA7AgDANSkP4AEALIFpBjaHA+AkDhIAG0C3mQDpGIhu/TzQoB55jU0sxOeJ43USAPhH6+omRUsiVd6FPw3AoaAWM54HChBpifj6HuUDTyQqiFD2VDA569qiG9LFbFeOkyZi7oLXSDTO2ypXtUhrhn2yr+ZI0Y0laFYSpytq/TWf6uUaHACxzQcAALDMNMR+jK1wBYZS6qIfE0Hw3TYFLXEbCDgN9V5bUAUjpRQiXmRqgLqXbT+Z4RVqYFkJ4OLYLisdwFMdgq/kPST3zRBhJqn+3p9oAAiVhs3k10qAGVZvft6LNqxQrr4dlYxrD5ujaPFfJcBYltcAXij1WJfWy/7oLJKsQSKZ97+bge4GzzkAwI4CAODjxF6AlwM40ABBeOA2QdcFAkIriuY/fo6m/fVxVA/hLUlcTicBgM/ir6cUdOlaKokGRyFSgEB+vrIAQABZrhsTqUN06iA0E7+dXA9dAriC4NthzXxvyunx2NdpjtfYRTqd/HBbtpFATyRq2JkIsVjhM7PYAT8etjpHeQqdmJKYnp+uO8lI8o8h01sAJAAlZ6/fByQA8JxaIArDDEm+zB34xwgB5k8npeTj8m6+4sSvqJNR5SFhYCWED9xVQaCbjEsJMNAvrdvcnegBUu7lkv7XS6916gXmf1N6SeEdvQhh9SCummAcAJ4pnaUvEK6tnYXqJKH9tRlNQ0/qv38IAOwAAEBV9gSoK4EZQPgcCSQcAEDet0orQA1uzuj7UTH2Sw4SNJnWbmu8UFoJ78w6WQd/8AMWPHp3aS6WkW2JQyepg3E2IikAyDLZ1FJiphYx4oqgag+IQz3G4mA+GgDdpZO6yS9uZFok2VGK6LvRrhVeACgykFU1GxRksH1EkVFV+xbTlGnAO4AKgiUtirioiyxc3oiR9s+Xbc0hGIAc0PjpwHAwtAjBt/bUBriqHUhNMNKmn84gw8ZFn/ZF7xzNwZhCWG0ZNWU4XlAy31eIfZdZg7wsFRLozBueKK0sxoppv5JVqhBi/xSWBf0eAgB2awAAPHfZC/AxABtAMAjOAUjYILEBdJsJCEUB06bzBnefzrTPOCXF0z11AgDcop6zSVS2RAmRGqU6gQhY2OMfBQCAtO2cH0WpBFGPEoC4tDnjuauOgUJqZ/3fSHqh+G8LfnY4AgWScG8/0sxM3lKrjEIcIdzeu6IAggK+FCj+znRXRot6CCLVC0HquMTFVxG+EEHAAwugm8WxR2rgxL0me2sJCh4b3by5GQ3AdUqBUwwD4RcB8Ir8E5M9CsoaAvD3bXFAAjkAOrxxJh4V5hzf5lRNIFd5IhgV+kOT9+Toi17K+JQA3jf1hG9sXPfVeVCdWphvBDoaPHf96x8BgB0AFuCZiAdwKwCAA30CjfARAjzYAJquU5oCX2u75kjD0eBfsShB1nOz159RlAEhKCnQR+UP7daKHNI6YyRDceWIDlBi8xo5AABIxNdi25ZD4FEUxe2oTSaj6noo3dcSfd5sDyXMjoNZyvjOo5DnWsm0LDKNijqEWjiFQReCpbU6U1Wg0E1fawF4p8swzjrV0PBmh4bph3ftIxMI+DM0jjrpAJgrgeTcQAlzDxZSWSIiOBPDSfo7KL9mA7JhSfglEKadSsfC8OVEkxCMEQLSqyKVqz3TasS0AbvwzBUFHUmszs4E3vf0KDZGtPNgoZoQ+wtB9wJRDQDA7gAA0GdjT4CjAA50QJIBOB+APzgIIGEDCAbo2DJgx2/6x+f/01C2X0f5n+t4gAQArqr0hBBpGkZHZxxDEViJkgS5PAAgAPEjc62igIzSqjrgk/zZAwaUujta9ZD26CnaKDXK2E/bkCQAH+3h5hkAOCoSw6GnmZmL0MRUKNGf+VQi4gDgbteqtkQVFIBVAci3CGWnM64OUCqgr7+kFqkQMhAqQcbpG4UuFD2GcKTotThvGLJUE5yZgYNRI5g0Khq6z7v/Hxo5HgDSzv9IMoFcHxvn+4h2yRTtO2cxwRrkrdSWoZvBDNAA3uf0NJV5tPaqVkpZC/YvUltwvQIA9AMAroe9AH8DOFAAQe88CX4jbGjQdZsJaJkCuV3haKF3LuZalYQk7TmX0yQAaEmSgqxQEJvcPAEAYK06oIPOMwQWD6P2SsJ3xjIHQNChtybWBEgOSgxizIQqgEqKHohv39FUYdcEhXrb/1YhRC1klxEBwaPilJZIrsMAQoaQoZ+kl+NeBRsG3LwyUc3M0uGjPdkvDOvSe1a7ZV05wfa89p0SgIO85ysyHTUIAFbBgiiOAKAmFoRABOiKggcAs5U4BWwMHhiZ1eVPpDQk5aYvN4USjda51GCOgNyYrj2oLkpoSmFY+nksAL7XNCCWslp5NQvVhIavUqMJ2An+fikAtB0dAEBXZQ+ArwkcAEB3HkDAAhKN17FPgezv/FoPnbmZnOdIaZ9iw5lnAaiEFJUkeCfrNxKD03p5gXgCC0yIDJ0VIWdn+QBgAYz6v02JAUBs2kyEkvfz5BSnmgMyvg7OXkBv5aFPb0kAUEBbu3DAbEmCgYOr1ypvlpZK4di0W99dRG/YUpYaL7dO43XQG8lHpGZS8JUFLAHQOIjE/pMk7JgcdlV5rae2Qv7t/3VcRlzqOQeoMx0xA/4mbYGocy+Cla5slIRonL8eqyG1RCnj4yVyKwA+2OwwRno6a/CiFvP+XhodsNUBAHavAwB4xuwFqEvgQAEUBoAjBRBwEECA1zRWMKBuFuJf4/vcr35LFRo22T8AILyfLOfbl9uIiKuBlLICrQEA7ZpyrQQkYKlMhAgA0qAnYlSX019Nm3CvKqec5dEj4ZxNCuLh1qBRsrgicsEGMTZTAXCiqu7IJcaQpQrxAsLG3AC4IA5O2qY6g3ihOGFKvJFIMAYzE8gOUE+Sn4aRvIm+nx6QhxSqgaqbcIAS5mHmVlp5J9/tBFOz8OUQbR25rP2gmpVdkLwbfwguJQ012ByuM6p5t/6hoWkWImlVCiur1rClB57HNGQq1dPs6ahg3j+yhAX6DQBAPwDgGbEHwO8EJoED4AI2gCbQKs0Ub68GsXZ50zFNc5wVMx1P9wGAqGicQBIQ2CkeIy0AAF1mNYKQgDocGOS1vwFAuccY/ftqmugeVbMCXfG3yX+UO4juTH29AYmxBEbXxoWhVhKXcRxngc2vzbknLg0QOxORf++7q0mTK8OV8hZVOGO50j/oBTgDoJ7F94IBgLMA82byDEBAMvafqaol37ybk1T6zr7qRAmLmsMSgEQ49RFlBQoEpHr65meeDArYvlYwzqLCeN9xN1JCKRuSdt2Iv8Jn9YjCNMcAIAD+tywsRVbaLxYQnve3RGeCoRIAIEsAUIW9ALcaODABSXeOBAc2SHRpo0kF/NTl8ambDBm56TaTWZjV+yUAgFJW0mnAShjNRYGAABLy9gRUQyEWZsJjQFyzw6xZeNfS0hA3ddHx1PDFdGqOamkkVgRfVpGsuueCxHJF34KF2ELHldPcoUVYMirGpI3SydoD8Q+sO1hnIIOl5XtV33pJWs36qZad+SiwBn+G7VA0AHG5V86FAQCRAJ0/JghIcpDf5NO53gwqkGhL91SfzEgZ2ELAeWAIyA7W8ypURoIzB7C0768IyJZDp0KhIviolWcOO6/eggcOLZkAfqc0IBWiubJGPWVCe/8LEg32AgDIEgCumb0ARwEcmAB05wAOdDZx2jHFVfz0tYGucovbnEgjDiYe7gIAQCoqkYEkxIq/hFCAwKJMBCJlRWqrcmoipUHT1EYjGgSt6rEfA9pddZ4ageUAKFJSpRJOW7fIhejVILr1q3b8KiKpIgM9qCZfehUinkIjsftgcmZy6mfDqNTG9xCGFgqcn+FmxsByffNBhQSAygnmFRoQfAYiLH6Y0vdsjOdyREBv8fKqB//ecOLbjFf+vZ2SRCgh/KGtB3yeETJliDdW/CcJw+idUdN3fu+N7LV3CDOACd6XLNQ30s39ylYQ7P0ni05ABQDAjgYAoM+wJ8B3ABtAOkPCCpDzG7aK4qOxf5rtnfkRDblxQyfv0+UUACCh8THTgAqtkSubZiWotERC5t5wQQAAKGfnqeQAFIEWqzuPadWKlFLsbGaEMovWQhX4KmWgaxMRyh7P6EAEhUDoKTU6hMC4uu+HQcbpRIVd/0Sp+ybnQ5XpQaZ8dgRcSCLTCEuFhH0VG5ixa+RQFXa/WWaCDMD+DcT+xjUxocvcL6SDI2yqmTYTdTvEJ6MqDaDk6UXGWBFvgcTVUh/rObxoBHdtnKbyhTMs1HsrfSYwagD+hyzUF7jbS7YitWjdP0RqDegTAEA/AGDH7AnwkkCnByQ0ocprxxQrsjA5oJOohnGMLEHn9L4BADSxIrGlBZVI31kQwBOgbNaV8qIlOVyLjAUcp3U55f6ktjSWb1eaMqlIuDEeMLe0sG05pbBN+uGPZRxLJwDBdy46M2vVJeniE5Qx30X2hLgJVNTs2tGhR6xdL15BKQT2d57Maj1RPE6OtzDDzFTy+dB5c2Zpe+4lXT8mKT3iquknW8tvL6AkjAplJQC9CKBNnSB1d78cIJwlGPtTGNSOqy9SKTeSo9dJZJbZB+tefzDekAC+eDykDK42XiC6+89vCAnsvQAAWQCAp2aFYdhAo5sk1irtM4O5WKMqmy+aDbBZDr/y/d0AABI0o9oJtcpfzxOAdCB+TJukKbVPd1eEupnERTbGukmkScroSynfYJpiBYV/1+vZGri8QmdQ8CUej5PFzjxaOQXIQ21MXeOHAa4HA/CZAiBT/CWMvxFHNpjRnfo36lIRlJDQgOYDlc49BtDqGkHP9LkreWhZyi68Y50ZN6VoZdGyUiiXJx0lDqLwnrcVzYWEI+p8AwjBw5HptGwCpjrdxeo77UQUZGU4tV2W9io8YqIAAL6InL0rtJtx0YFg7/+0AQkoAACyAAAq2APgI4FpbQA55ZHaKAa3YZHMm2S01TGHucr+DFCbAKAohW4psQo4UowEAEB2c4wktRakVvWtjbIEEcqcmC86yekwSEcqxNKO5hT76077KKZfbmsKznw5sg0TW5xM+kOVUAK7MxueKkt/gphZAqpWCOkmSaHL5A5nnpGUpb/po6gUj8VgJYzzYSLR1LTNBCM3chfMK206Vr6VbJapwiq7kIQ2p5pxg8mtzXCSPwhODF+WIKrpoabmqW1SCRKiCmN6BY5fSxG2miBY006dwQY8AE9nZ1MAAEB3EgAAAAAA2V1RO0wAAAB1GizEFtnc4dPb2Nrm4dbY0dnT3igvMjn28+YeWPQyltVFW0DF9L7zTEgBvf7+YQCQAbbWrwBXAJ3XyjbxWDDFruc8hWNuTngObUkiU9Vxvm6DMEK9ObWhmKpKecgC0HZSjlDrgbRQEiQUeP1WvYh5sJJFX+0BM9YX3NSPqIyIqCwEc5R61OjvrGQ5xZP8BpPTUgNqXQiN7N+ROJFQNEkKvybIsND0EjTxCQpYO2/JUHrqrpNCUU5EaKOocuonTGhaOENpjup7qZArdhhuJ4/5B6c61Nk4vYXzsfzZ6KEt7T0uQly2wMccsw8Xr19ssyy6amsNflicnQuQtlaAt5+ABJQAAFkAgD7RrwBZAGXaSCYJs6KoD9x1WwxRIsQjdqjJLq2hAQDQxFVAugTU0vV1HZLCE8CdGAjxAK35bNHkBGK6pZTS2E3COag7XOZqJFYKZPnyN4xsM7bM5rgBNw1aZ7aiexIJwsvIzffGGWuKg8j4aHDb6qWgJOmnzEPz40Jmd7LgVJ9uKd7RjTXFYbDvZCwdsGYPUrizvvdhIDqV5sem52NPn2vmRCvxxUuNrfMdFXbpy1iP3Zy6vkIcGlnWaiH4Hq3ABdUBKr7H/tmafz5I7M61EjbWCpK5/VINk7kqAECWAKBkT4AnACnbRi/xlFEU0ebfaSO3PXu3PziGgZunejcACH1IYSuCWWlPez0Ji8pRRYsqQhwBgefBFzyGqNtRsbtGUjqyIlLRbRepmuTB/qaZ5A0yEqi0RuuJWIxm1uGka9ZR0hWS1y5v2+DvwP4IwaDMPH1aAiXNsWZvsY8/EF/Ekx9BcevOQIWQ3g590MTX26o+y3BFqMPh5Vz+LIM31dujmQcPch92ukz1po7MGhTzXxRRHW8ziDhaoclFVpSoqXkU2AmKqSX2mxpNBx5IdL60IthYo5xogaT3u0UikBA+nwBA2lYsT4Q0C0XR2pwj9sSFzZe8mDS2HEWi4E66ZoZJvMa6bWs/8FaNigSU1Ot0Sg/SZLKdE6bSSer5v0MIdJihgoqz6VbFvE/kdl+4Qe8RWo1h+BSxKrWNx78TxFuMPcwpVx/De9yLLdYIDOUA97xxUG4Mh7woJzxySfyF7Tiyt7va8rP8DjhmWTB03sXcDMpkdG/N+uHdebKMUtNyE9IwK2sI7l79L6z2BRU3bR74Fjbf6KUeuRHGTSiUlgDeSJx6C0AAeP1SY6IDAEyrkjSvoxDCMj4+YLf54O1VxuPu2FDPXz5SCwA62PmXUviqOXKMLDoyp5CNk61VLIkrDZWFY2pcqpxIYEMpNI31FMp8OvUQYNHHO1YriGNhNGH9+D4Gp88uS0MU5hNb4vTq4nBa/3AeO4fedq/Wd3tk+AMX9YyC0G+OlDzvh0z66c0sm3FTqnW7ZPGWJyeyVMO4S8k2+thXpkBC+8J5Urakon44BzfhVu+wYf60L8YLr0DocnFpNP0c04MllmyUI+/FHrG3CP5cLzcUGgDeR0yyRCFEkMLdRY1n7PsuAOjlW1fRRc8JTaFy7NmrB6aSh97NL7PWp3pbaVjlpqQGbjIpWpGRzoKWD5X6mszI3Nop4OrMYnFtT+0Vam98Vu+aS9n1lTkt7bSkP94jro87SF/peNNhxshGd2V1f5n1fiTGcgN51cp1iE6jVQmEyfkfnJGizgGdJ+PKKhzbripT98dqYnhTqxmcg6ngIOha1QBiyQzHVH3LfDVWR4xSyi6M7MKHlLQlkpGho6g8Le3FMK9lfG6mmIGEaINdF6hDpkUGtWTaOQv+V3SuplxYSCC9u8VsU7FoqwOAsUbPz0ettFaMm3y5g/vz2TSzb72ky+w5rjpsyA5xawA0ZYbJvJbtMhxdFQF88T2fZdb7LZyf+i4otgo1TnKo2n0MnPvnTalDYG7Erxtt5XR2NPMvzaD4u1mX8t6zoT02GpNbRZtI8gd+9W6zaPn7Sg5ZUilBp2aPk4wgOEcQkKtAl3SPUzCKQEDrcdBdroWiptdFIRML9Y4+o0zJiY+vS1PHPhZbFMcKpjSl3qg5d/LJyuBBrJOs4OiVCQWi386mGu7svcakAT5JnKcEmT4ggejt0vMwBQBVk1gm0VprrfDa5Ksjz+Zutd98IPtlvhkzEd8UtUe2OA3K1ouzoMQ7rE10BLcOdp6qmq6qPAPVbDEioidKaPZVBvHqBgfzwc01W2p164VaZqThpdQ2yLIFe3ZTzXT1pbmmLXf2InHfmJibMMVz8dgh3AXLnrntf/+XvlKRR20YlZK/lTYiolncEjjxLuRIO3vT88vyVkm7+ToqQh3/ez57a+31vx1lNtMl7VntG2+ZPR8kxl+3qjeGLv21b7rLn0GR2NG7tOetknSX0BFvf93qtkpi9k8T/kjsU4kqojeQgLfrUTCb6wAAafXycl9pp4xSOL71/7kvf0/y+/jwB/PI+zT9M7ncwRXH9951LFzTSCD/Fm2NmhHW5KSrcTW0Wh80xlVauwASOwOiVcjWShupxn0bP7ctlpk1ps8YzjpsDVbvlzL8oiaMXaj2PxErAO6L+ZU0IuPhjGnTQelScobhcDblzERNBtSoZqAXoHiMKGWYJREC9dghe+StIFxrecHWeMhGTd+im07PMJO4xVnhplvDtVBFxB8Xt5OfhInViBym7/XKhlglSGVtv3yXPjsWWnbgBZIHvlistUadwADuLoZTLlECgGmFQxWVrIVR0kE2/TdnsOXyy9eD9Ynl7O3li2YtOxUwnTZNiM9FgpF+vBGfgMaaBOxoRlpWvcrSkx7JO0zNo4Vd1eRQfWbfTNNoc61zZLU/3dj0jHYY0WVrpNsxY9OCZFluX26asHda/L5Z+FS1lAwGRadN7OpFHbY7ISJ8LHUiJCTWtNOrwSVq9PPZXGJe6Pyti9YDrUqVIo7lEGwT0qMAYVJ27ln94oHCrPB0IRzlFNnVWI/ghgEisVYSZM9oSuu/cLQVAD5YjLHGlU00EL8bYkH/2ndgbCsfFG0kldOMz/oikfojzjy4qfKH/eP35xy8v7X5OnOVmp1M1/ikS/5tMMnVS0rnYryHEM1PEzT6w9kyfo/AjPzjgNsuRpUW7BRU71ZE8KdntfRQyCbNg/j4Ks5rVtIWXV1TIL1Z5NvGjELFFRLkIKvdyx8lZC52jANRQe0zBt5grCOb5dlrmlWvYv23QVLM/iZICvkSruxbyrC46O5WTX/YGzlwygIC9V51ZiFzhXvvpFIYiI/z/UyVuVLfkMEMa4lq6BOQAL5YnLsPCEiQyPdGTF4BhCuNfZ7QSitF8cDvK0Nra1e2hpfy3HJjfGce0S+HfX15EsbhZDfz0xNJ/71VHtxK32jpTUBTweri+FOugY0QeZQgnzlZ2PU6kcFYF1a3UbJC11LnXDaXeDohop1h+oUoxTbjbO5TEf48KpENGZvpthzKihHsaE60vmrvqWsI3/Q5Xe89c70V0S9kqqJwHMH8DOd3SpCQ6SqOI6095x7xcKBl+yIfqIs5CMcpikVB6DrMMlX2/drhqssSBjIqfI8UbcID/kc0rQUnUDBzTy7SbdSASU2TtoQmhXaM3O5T2plXXrPefG1vvXPg6ptn34m0vOfGxeQkOYyrvjFKJUGDbSKtTamQHJR6Jy76Rafm9zLqdC5r0VqKWNvxe034ECjQ6LIaPgIHWBl02bRXAYK6z0Wam+ybBgYxjcmdvjqo+ziOm1z/oPeN6syi+T0PUKn03TK9FP1kZt2vadF3rhCKnldklCyp8CndvFpKHoz66L2/XWq6cmim3hxbyqaW4lXeAxUrXCH98qZgb5Uhvmgp3g6y0jR4xCm9No4sAD5IjK0GZdCA+0oNoDd3Asa2Sk48T2u2jJyYj5PlZPplM/+3+KXhrUwv+Zs5vcWUneQ31806rZxS9yAr4J2SUvLh4EIzqq6x4wNSSabz+6mGKIvsNUJhWTTEymo5vmONghN5Q5ENL6I9omDyJxy6tbgwi0GpQmsQuSYJyxeVNmgeMBlkox6PY7LMLdttck21/Q078QbBebUMd0PVV+2jpfH9jG7jn5Mr6u091MxA6nFQ0J3evcAWPANEZzZgGmP1YSm7nNfXYsOrTbQH3bcCow09Swc2V3TGB2UQMc57Va+pYWW0dOxexzG2bVLOeTIbphj+P7kx2n6bb2pRQ+Odv5tLj//bm2mWfabqD33MPe4KFbyj5yKWLBnqzbtcG/1B/fJduVx9gZLFG9cNk5JOqQhv7s1x+c6mx6VLp2ytqPKcQxSy1LYyt9Q47j+I8ZXGCzGldQVlpkQl5aFePL4Yhu3crXohxxPCFj+y1Zsasx3Kc2eGC7yY0PiiordD98yIyMNO+MqhJwu15eCyygTK5/p0nelOXEXn08OdKr/fu/eVKznzqV22yjCUvGhUrpSmawGc9UQOlMupAtA2AJxkpYHfZ3s2NUvLDiKrrrW1ndZi64nVzwZEpRsA3P0sZ20BdWP6KYFoUj8M12i6X9HaFv1eX3JxuQumTvLdXjr2AaC/psArqPbWag/c8XZToNvPHbHQEB8n4M7nv0u9L4dM92yxWCyCtOZ/zznxpMmmpqYme5tMEP9v/+A8CLw5X6PzfDPyEV/S3ONiVSwISQMdaP2mpk7JYCo2l0WfZG+kBiYzMY+Z1pt1neH+vZr0y3W/AYLHATr3HIJ8HzD6lyUsTp2CsKz+/gAAAxbAlZcAYE3SrgDBoCENCHKUdQVIwXjMlU0MZmBCy6Be3ccIBkktAJGXHRtPJiHpY9SqdgmiR9AYfXJ/+sMq++vr77T7yRgjtVdEktWodmF+04svbEABIMZJkvNng1pr15ypzjquk/ueenXe9AO2jJzQoNJYMvT3ZeD74x/bh3U/u6m8FDDxF//itIjuVYCCxfHaSqgm5EG7wLZdURWrEhLCpKA9W7gJ/BTMy92CycIoGaWeKtGmr0/UAqB9lJV3OuJJoCpi2uoW+9V0bwAAAE5tnC6cAQA/asB6vnom2OADAL7HJAiWwA0vXbyqxySS/h8AABgDrtwVAAB4Z2pQgGkwXJVJF7B+R4hMEQKOG3j6jSBxc+zFWoMFpal+njcqLAuu2koT3aYgQBZg03Y7eMCq//bp2BEqOy4Avu+K6uaL/735xaHOha+bA8r1/Ho9wSc6+3kD4g3AstYRIeMEg3/HKrLtyAJjP03j4zew6chRp5GuCkQShfCYFBfXSWPGYvivn9YYIB8Xk6IBDRwJiYCyuyDXhAYrzqjGiKb9bocHgNYadvKzCMv30HsIKcn9LqsoaL+rgK6TArDBJNRK/I/iY78yNgAVgOVUqR6D5FQE+wN4AJa25ANihCm6Dx+qFVHS/gAARiSDVwMARbAGBAWDp5Qc6HySAtXCirW6p4Lt9G/DqfAdl5ydWd7ik7m7dXW6o11iZ6fRtQWQGHY3/yQ2et3+kD2joaVbQwuu4DmhybVND34h2f6qO+XM+6l+mbl7qaF37tx1s+IBQiDBow/tU+SnlBoMIFKG9r8rgfjK5vWy83Xr1uyuSAEd9jP2H2svAAiT+EUY4eEEe6rtw4Bo2R2GPmvBRQZcA1TxQ7QIM4DSyUHaAPm04BsEaUvZot8+tQ/IxGa4zUl7PRJ7EBgASLBWxVdVAB0bT2dnUwAAQLYSAAAAAADZXVE7TQAAAAPSMs8xKSksKSkqKS848u/uLCsrKS0rKTA1Nejn6ioqLCssKis2ODk1+uDnKystKigzODfn7AwavcoTxYzYap3jlU8Co4OxMkpZgkEylbEVnSt8Na9SLakF68HqKvoIFBo9wI5iRYX211NuwroG20y0jJW2807v9M9Mv7bPtejcO7uI4B09swAEFn3MKAe1+sxUQlSv7FKiAQ00PCd5CnkiIZ+AvUNMoE1RGCS4czKvyB7XAfwVC7g9hiPwbabqlRLBO9wvLQRK8lX+ZkcU+bdN5Db6zy53HBB8pDwFHBYRwa48eclYTvXhA2yqYMrALwqpRQcdQJdS4nJKIgoHUvm9/ZouowEMGguTLW1+iSNjA83EZyBiwHBgMtKp7Clgkh3zwlBJGM2VX3kCpXAuXDwkGv3RTlq/wfN8674ODDKkTVjPkiazBRoHJhUozT3n2244yPwuWCQwAAQe9YJnjMBh9n14+GyAy6Q2xXU/0Lv2tX54KI8O0x2dWmP9oI4Tl1MyRj9gjWMC/B2vYZ42CLdbrlO3to2J1spJQYNBtsEXDhit/8d6L+kmatfIODPO/JukbsZSUojfe7U6HD3eBwv65sxxdMuktXXNa131C36FCbc/AABVwAzYkZ6dAoBg0JAEpEBOysoSJFPccVxLq1sAD3d1ZXZsHH6frnE6xoOpNkATWmvtwpWsHp8xxDTaKUcI4DiegKq2dnbhlRdX/vnqVlQFgFqtMsPUw4fiRC/0PL3/xo+u99V+XGPeFo/jk8ZUe1VtVVWFH7JIUYD9BW4OazTuzDhNo1BWZ8tmXIKxWdMa7fCVB0hYO/y8OeAKBpImFobLeL4iSBOnT9caT2NNgIO2oHIJMa+vAYAxu2moZfWRMxM0c2Awuvx67XdrBwEAwNS02/UHTURzgNGEHgBgAN7XBLyrS7RZf1mXtbY6WewfAICgYeAuAQDgfgfBrQIMAMEwl9N0UlayBEmBBI4BDk93I5RE03Y1ILG1J7OuXSwi4whCcEl1aQmsDUBIbbw69a/InvLeUiGLT+hCSAC16beE7KmxGgKtFY2UxOppS+Sc6dB59X1lwtM/lysDaH2iG5/QFquWpoEdvhxHt7VTHdp9FNpU85Dl5FUDiU6R+u8zBiB81fNPWgOgkZAp4D3JisgsQq2iU4/ut71pUw4aG8PvK53HtQuzA9BnO/MrJG9xxZeIddgFoBNDT+f6IubLJAAAPWbhK0V6p4dwinIANtdEPBuYta+XF06PdP4BAAC4AgAWBUsgGNTIwF1dY9t8mNQMzHOjb23geJ3Xr27e6K/u67LunceL89uCC6NOMSIyKe9l0Iteenpqmy8x9f3JLk/pqFnaegi9oGRwWlt5+N5IUKCyJsnl33rcsS97eqOPlv/y3bG29qKi9e1X3qpHwaDpug/0zzvs7gR2CviwmbZoKXa7f4E9DBR92W4fuMAt0eJQdm0e/EZR/hrQwUwBfRjFC5hcR4cIwGedBKarGrvqA6iuweiWhQRGCBH3gar+/cQMTEjneo26agCG8nYiGe/TsnAt19DO9JG9AdQlS4OdLL60Upzkyjl1VAqkEg+h01iChe7xI/+txvjJcJDCRCTYLh/y9fIALCqFai83FcHRM15f6HQpuO0BdvkI54SgGfOqDfS7w28kuUTK3/H2tpVCABQiC6wdxd+uDyW4/vCRICULXgWrFcGssDgAfk+MFmFsAa3otNqZlwr9QQVEKsUgubVKP/QEN/WHBtd4eK7dO7god071rO3LFDuwhJNnYXLK5P8rADQiKWcn975Sp5T05HLiFtAZBL0L7Iq3eCc6ioXKrW0KSzQrpyfVXaxE0sMBHQwifcGT3PvZ/imVpq9WEK7Bxye6l6P+krkJvFtyF4MOpfGfakj6V7GsywkMIn3JwwyuFB82UxwBETHQe0M60UAsYTmiozj/3g3bLF6DD/CfpsvhMywiBdquydUISQM3j9eAjiSDAZpEVJya1p98FfvB+hH5yYu3zJrQQAt1fbqrlgbHJxQyy/kCmGXQsPvZNxzRwt7lPbVdze6PhzRVIbYovjPF+f3fQn4U0bLJ7Fo90I9knWnUzSoAFDLLRM/3TcQryJ5sbYRJgxkD5gYe4q43Y5bVMzxOr2Wy0cy6JZ+m44rKMvvsxx42ygsUZxM6p8yTOJdDG68Pr0Obts73fmGe2n3cZti+hsYGcIwBgDwASINLpETaWJIpmHOWxtvzy+HB2sxMg5g+uN167dKm1qRt2vWSRmuXvo351lprRWWB/f8zxsOT1BiVAiJQrObnB15E1ZXxxWwFSp7bslrhPetx5rDW0yO2KTPTcVsTV03Trngniv8BkxT3P4MtqO4eXok0MVFWKvs/PSsFjzzww/3sBpAVsqZv9QvCrKQ950sMU8uEqRiAD+PT4tHoqwADJLHS96a1CRDA07xddiDbBdrJ3yXdO1fsBHCtdJmkAW1vIJmNRG4A3leEEJZDlmb8dGHg/X4AAKKKETsAADAmGKgKBwNIwyv4zNayYpRa4Jhgd970/bglzjcj3jtsVJbWon6IjSXgZakcLCyol5RKd3yRg7EhEVTKZ/4zDXU3A4K6Pj60OWqiq66XJ5a72cn27zHZPMen4zSVm3+d+2s/qYhUnK+t2hdU0yQ8AJ01DQFPFnPuie33ehhjH16ZLdr9BUT3s2Jg81Y/kRwFDZKKbHkhjY6JC6O6U3XHRzfvTv2h4KkNMu3Qbl/vPQf3ZSzWYefUCustOc88VQ5ENwmEPr5qMGakGTs831nLJcADlldEmNUsS8fL1RiE+7573wzSx/Grsyd+/+O1DmAKRwPAcgcAZpA8gEMaRMdjz7FQjLm+ttwKTyMvAqNA9h1GBk/j1Zbz1KXxtqV7mpbJXmqeWY6iud6lS0ca2jeWeMnGgOpzCVNRCBEh/kg2EK3i2PFEIpxfgA4VPePV2VoklkzDWB3459/TlqdZ7QgyE68S3jDSwI9h+kdtQCMB8jloQa/55eKqPgBZlifWADhO1DBWxZ1pik0fUGECP/tg9ZISIQKo7wS1JdBu8EXbKotiRuvQDSqGNJsB3FlJXwqA4kGUVnG3UZsdUCYAzPWKKM/2o7x+0oyO/5EExgBnU9sYB8ZU9KTGyiutBz5I9Azf2JZFCMHkDPb0qDYOTv5TisiZNpAq5vYIc+qQ8fDnEFTlzF0N2OojSrrNWfTxUYwHJPpEWtoZ2T9JLRaPz+dAGpJ/tmb2VFeQVMGCGu26yrYVCqJdW0GIDdEXcAYE9nTQsCs0XnSev/YcgLjQBOUn6U3hRyo6V8iOEwnufpORK7b2tktpr7oA1PkKVGDXaD28YV8J4hxd8L/X0zMzXYf+k7PizL4YfTBaGWuQ9SY3KreLSgDE/Uq5JxlMfTMsZfxYJLhk7jq4SxFcSXhoaFz4QU6vrZN4zKUM/OUoexXc8Yqx7SEd+U4elf91OwKAETxpL/aNHYJF2rxWHwisheLy12r2UvLHQbMA/AHLPAbENd00SnJ9W1EtrCLAqR93Ft/YMIty8X8ufzlYwD2cTp89ztOpHeenhuPzvGNbLCgl1DFLi4MfO7J/UuzXraEqDVQHxafcid3zWl6a/Z13MzlWcEt/t8h1x0R/+h04543k4vcSYJ2tWgDENcsVJPZ4pl+/AAKebbUsPB29eMD2f2sfety0nX1ZNo3IodG2ng1iytn+1AQSiEwcuaw4IMF9EQAMMn1o0PPnor+iv1vTbVCODgVL5k1zwOiZn9P1OBHjrPnAZNJbZmwZ1aSbRlYfRMIfmj05C1qXDBAuLjZlWvTv6HJZk066753pPIu/8x+XsANfegBbATOgO3YBAMGAGFSBAVanCfieU0Sm0MxG8x331bSu1c5M1QIyyI89ME81gSanrRp46qyM8scGkTAIJUa90K7KhUA1ARVEiFXE1aBL2WbEbCtx9ZJqZ4P84Own0qRlqcNBnbbapapP73/5+4/0L7LAqVWv8hDmMHOe2/ldEjuHr2IbFlGfQ+3fUrp9xqp9ALgfvCkjxGQAErf0m/AuyGC3KXFffNCX7QQB85IXG87gqRPANPJ/is3e9TXfyg5SAEzfU8PmXACxDfTeeijyVty6XgkGHO7/MX24ZgP+V8SCZmMTqx7k97XE5gNU6DFAAUcdAMUMwB8AMriZNKT1lFAUrzZTPA0FOT9xnUwbFg5+6me3gaZXkdSoCqSFUdnwMZEPb0CiRoneo4cyKH+ydspVBN8Uy7yewQy9/dOgpFqLoQS31HqpbVfId+fX0E0Ybf/5Q7etWikAvOqcRD3MOg2iRMhZc9GSBByUdfRtP813A6idwThwUWW7AAhQ765ZxnTNTRHfzHopg+FrtiwPXDR4KSY23ICL+GbZDATU/LzRMG+9pN5Tm0qY/5gScYpwUghK0v9+UZbsWTojABZHBAD30QTdywfI99tfKHLFmb8jQR96JbgOOCoAmHYAALgW/pAASZAjPMGWjaJo3VarJm3+0Pd2Xm7eNY9GXuVUFBGZ+Porrx5K2UkwcN6RdVawd3Efo0sE3AhTBeJ7r3VkzPVcFVilE8iSExDza3diKh9IWiMhyNlaqKKeev5k4vQi7WDr9GplBNfpDfL1DtfglSg9+r7maQCscd3OiZcpX5sqnnJsBAGgFLCsmBhMHbcdHwxtrNv7fC8lVIaHWGE77Mi7xeRrmsmF0roGVz6PuOR941Lem+iETxQh2s1ypUVxaMyjAdT19JpnTzs9f2z3OUUkiAOCYiYml8vYRIZ7iizHYvO0JGeUoPtjWbfXpwb0+XyC4ZndMzUci1fsQyKiguO3hwPzKho3/LDMUCPqZeMMruuxLW67c2IA/PlEzf5plN//zF8kX+MagIgSty9boleBKin+3crszG8wfpKyOL2jx5SFYbIA7PH80G4zOJ9M7O82EAck/86LRmMLERlkNtW0pelqydIOQQj1SDxHXtUGBPZ8nN0E6f+Rb5uFICJJ+tffO1fT3n/qE/OhZAfuMoZiQ845FCtNEvT5ykStid0IPnUfHlTyaf7k/mm9ge5fLPQUHOddO51Op1MDWjt110cEQUAA1oMD35WyCsQtXw89HyY7a5R1LfDWCYDegqSEOD3/HWEm3XRa+xFhYpeWZe2JdRywYno430oRbyvzhogf3S0BnDF/jHtu/nbeSX20q1oLMGPgGJM577N7TTU1ZLMN4cfHmhfJ7pLQtX3UTke+KGYfcSmzJZQ9BvrG3Dii9My2KYTGoja/3u/fKiujhx6aj5d5Dhuw7wCOBB3Qkwbm6vO7eR9AGkBICcuAJtv0+XmUNKWHq+/C27vq5Pkpte7kscFZM+DkKizvZ2nRaK1V1p+/Eli1Ap1wCoUzmfhqoti/+6r7hl6IcvD3ltYEqpU0mRBJtun3q00CcD3Ut9LCQia1AgDIqtpLKFbmdrTwZGoi1sd2UFIAKD6bKYShxPXvzlppKQBQAVD73W+Z1WRQNLe2NsLmfm1XFOTF04xaJCDOC7dWA+usbzxyPaxzR0VOCCCgx6bS6ThzlomzB2A7Ff5WHCBSrBaqu1bV2ffebzXodJ2dhWqnH88MABwAkAaQeANAPihnhbYUCzufkMwZ4yM2qzXOPvZnF7LSddp+9qduVJf1AbMokVgWUooCkUL4OZ3aMUKsTJDu1OIoJZM0y76WMsmT0Nerh2ZbdZfeKFQTH8v3WBUiOde/7jwBAGISr449aM6UXWCmZ41Qz3F3tZjJ1P2GyMTUivstLFfonyFgBnPjdMs+2QjShN+2QlXDofycn/cKAscNADJM/z7NwFMiVGUBJ6No2njTug/rY85fjH4EAQYwtkt84g55CG8oxAs0cDlMQ3ur8xkeT2dnUwAAAPISAAAAAADZXVE7TgAAAMi6OqYu8SkpKiwqKDQzNPT19SopKykpKyo7O/T07isvLy4tLS43Pfn15S0tMC8uLy42MxZXzOHSkwxUc3BW0b0fAACN2I5ZAUwG+IUJRioJRkLOkoop5pglFK3JKS9OjuRNxjD8Y/31RVVhs3XVEoKI+/hukQrQNG/UwTdfX76swwQqzt61WS9qvoIT0xfuFT9vwPMDr7yi0PKdi9fMR7pu6gmBJsDYGIz3D2EX4sOhUVy9j+xjb70ss32B1iYqmQgbBW4vb8pV9xy5Lkp4UVde4kwJeMVL9HeUFVHqv76A5oO0uEPFOIdIMO1urw0B6M/VjDwcTBST2/N3nq5g3N1/xb6wJysdMZrqDqDAnG0u00V9buX8/r/8EOb+Y6RcDJ7RKgH89UqkJicRF23qqyIAU8VV/tTDNYr2iEK8FlO9EpdX7lhX48ISB85YABT2ii0bSx8qsR/9ToCVPBakZtIl5Yycm21fo6z5kicZclNtB5txt0MdDAILrZYCdHRKr9ZjBFglsl7x9baVzw0Lg33UfVgP9YFO2BZ+43dixRIAzPV2Ss0e43tJ45boUQLBBHE2lVMmrE/HKc1Vmu9G43RfhvAdSJNUlBYZ8wEU/orcSdYjloxUiWUEoLsS+6cN9SQJbdTKcHVbrFjNxJyyWtUWpEdlThsE/kqTZm6NzvaiLyWAiSwh2ZuNvWVVlMoz0Cvrq6RATfAdXCFTXiXUDP4KKsPU5JGXerFiBEAs0AA3fmOcZmRMzwy/YPT2aZCgZX47fZQ37dC27yIvYv6ahINqAiwGywkgC3PTdV1eCcTAudBX0JGanpxEqcv636vBcc4THV9OTQdHZ3fJIfVXa+7+15qsAfQlrwO23WGk09fvVbGA6ao4s8aZJysNSFrVpslqe0i2hwr/HrspONcza0KnpppdI69sKQHa1txUNubSkzb8D5eev/Pd++bJU7G9T9XhX196ANgrgSNAAWSAJhh22xjIdt46gUTI144pzn/Dhsb7KcGBQDC7Hi2upcWxPtUwdzt7v22sQOGT/cv5UcBjjNPx50ULrbXWWiMqogqUCLQXX4hcwCfT+/vW1T/jd3Lr7kK7Pf3wsTQNoDwCR3fq9Gw9WGRf4LdMCpsPeekNZhQ5dPXnq/ajHdirBaQBcoox+bqUAgDV/aydkqZdHWpaLUvG3wUA4NvvO0JqgNNxqpyXiLYTGsUHS569AiYSGJMfAGPNXGiABmDL1G3c8rIAuL0RvUX4VhvxQUMH3lcMaYuVTuMbezmYb++dSWBLv1+hUJvsaOCWAMAApAMAgTkAgAVABiZsXrBH0dFGz7YDPTzs08seu9Uy/+SC9Nb/ub0lzwaywka7u7Wiiggke1wgVpRIEwtiS08RC0pHMYkzDy0j43tBRgURbQXAZCPMhDFs/7f7XWsEURMOLpnqP4adrlBpydGkY+7S6hvDiNOGUE7Nhx6HNl98tPmUTTh+IMdXD6j0Q5J+6zO0qBPWVHPPNDo5YB5NiVWosWfhQZoXQBvwpYkAkwJQjaRnikQygSDOPv9ac6zJVRnRsPjG2q/42LvxporUGLNbABxvZGbTNQl2VhxSShAO3gnZfT8AADAkjgIaYAaEARxJXyIJBjZCSghF8YlsgtV93BUX69q65/nlfOntffAzzUV+Xh46CNAq5WySNy/GKig4tlpIr46Jak2lXcYR99K1aWy+y4E/SlBzNKPtnNycQV+tgng2b+v7xtXMjFjz+3n/JTjyf81F3IlS/wNyyoZMDv4xIrMirDTiQkiEH8G1zaNyqNXvKFiXFiVzF4N5mg3bjS79ONnX21wiQQM6hvPMYEs07CvbaJGnn8jE1kKGRnSlb5SuX6bCtwfHVc6m1ucMWkvuBgAp2X+7tzYQqdUatuubuTjkHhAj/ZtZAQT+CixbplanXKmCf3MBesGnVAxqliul25sSHUFK3Q4CTOknO/Enfv0dBvT1ypymL6mVeMS+g0Xk3R9LcqrM0mRqxouktkVBYUzA/oge4wzmOyUBDPbK1VVFGqVvg3yeAzF0yeEcwpuULCmlkDCIaVixrU7w7Nh+e6QJiEtOAAwCi+1WjIdYUKLDjx9ALxhnNTPJSPlkjmhrU+HqQ32nMsh6/ALsFskE7PmKpFKqrd7SUhL18QVYFATcNF58hTyK11n5h3Z5L/krE0m3KuIWqxMM/gqDYj87Kq2P8nkCAkAwqiXO0ZaimgFhfGsT6EbYftnqlBrPzX6WChoA5P12JoNchE9qB3zlOeD1YAKOLpchS7SkJOwX4SrmOUp+DUz+vbPyhXIgHBILNSC9w1FMBtDsqm8fAvaIB+pDy+DcE+t8//vV65c3lEAnhHD+/+n0xWi6u6v7//XrvRVaJ8VUCwHkMXd67PdOaw2mW84Va1UUC6RseS5JhUG468t8mskuD43ebTaJ61vqHRhusYnUGEBe1nvdjcMHaE6JBNon3dC79+U96befuYZ+99D2neXbf/+ijqxR0f/BNwAA6EkTgDS7GjDzNLCBsmy1JTtiyDLw/kurk9EQs24kELJT0wEMTQDOvi/Mjpg4Jau20vbsRf7Jw+nQFyMqcWlnV+YI0rRJm28rQCFOHzz8b9rr16f+8Qa7feE78ykbHaSkk92H4DC1/65YrSE5O5iwV8Jpj8xcD3K0Xs/PgmgaWM+8NC3bHi/hWiaEF2DcwH1j8P+L3YDWBMBrPRvgfn5cVQX+WFdVEQBw+tnN6edZhAsC0JsvMsBy9X9dLi6ivERzZClFCRqOpnltOXbRG5AnhX5MjQf+R1Whz6AjtXk225TIzP5DgA7jUwIAcKTmAQy7ChDsx0BkPWACCAqXVQxcxWwSu5Kb/ShT4YpJLzA+FgCktVVK8+VkJ6GPtD/SKB2ppDtTlPH+9f2oOc/iq+AtFLlXHsgwcy33qttq7MKyxvHoTw5+zHfcaHPFso84q5UUJURi2EJ9ISxQoIEIPY2j3sQSKhB5sL6ahXaLYpn34y1iOKGoJ56lf+mBl0eCAmm93LZVlUEAeJe/Etb2X3/KsAAYEEhbjbukrbWnVn20+n2GIgJB64f4F0YoFZg3m1X1IlgCc3gPT3ONj77oRLjbWNbOd84EdHQA9le1U3tfj5F1eg9hJyV+AQAAAA4AIEtXAoBgGg0y+8D95gAEJKSsokDm2mjHcPAqcHkBAFbM7CzgFUum88va3zoNVyrFPQwU8eSEelqzoFQxVorOpeXeuE5OpqZmBVPVXVcC0b2+V1tXb7Y1TNGIl3gF8E+j5T9+WAPVr9Q576vja/vISuW9jqNbK7RYaQyWxT5pqohepFb/J8y/QYWKhlvzzLa6lpVhtu7HDIa8z+S4UYoloDVOyAi8HR9WaP58Z7MgOTwtVtX40Nd6x4IugoTYZVMShPI8vkjAAKUQyjVtRPdsDMFEXPK0CToNAARC9S4R4F1BREsA7+NcEKYEiyatleJJSt8jlbZtdneEaVtkDSTTloq2iAKUQXeqXOymVg8yuAHs9wEBK1BBDQNAuqpWpF4IDpMRwe1Ton07vNollmIPgwNOAfQ9i22A23j9AtGSwVXeVekEIGANCT/ROzUaBlK7/Up5GmSWBghFv9sC3+HA1VoEBEK9xDPq9lMALZnwtD+jANFAsGnImJKil6ivB6A2XXxcukx/Hy0hnP9MSPf8APQ9S6PnXMZzBUiHW5UxBoIACSLohiMtjVPHMNsgF/zWADBtSv8ov1NGpTDaAPxBy3oQh1wziFYg7sF/KnMGaoKAAUHCuhSacbQ3YVrvxUX8e4T1Yew8LfcdDeRBC2LietnPHkyHpU7vZQxAzYOER5qXoSVRPEkF76ahr1NSpG58vfnHOWVHcQDsNQv1iaS8OA/HXkM+BBCwT4q+eqzDJmLK6fqG+oGpl8f+2dy7erKpNPaBPI4v51/OT820pvYA9DWLvEHPsq33+GI2B00aaxQNVGg5elIK0/HI0K5p9rpcHVW3Xmqmnywnrfm0Mam1GYDCLSR1xUB+X2N7AJoXHYpo3/blKr4j+s6me0i9XwAAAIANCqSnXwIAJNnmMGDmKODAHK92AjJoIEjpL0QAiEuvRvaPAS7fFgCYUaPGOPk5qEll0tTYvc+c1Wo1R4itnFz9+WJ2/k9zJ9OTGByYxMnM6+CRGGMkAjFOT6anp+/PefrFTT676ZlpoisAQGauZalbCVdAYd3FtL6c7Jf1cozvZGC4aBppkx2d725Ct1dXEGi2/SaJhkarX+a4Ymqd3aZImRq360IDnluWG5qaWGTGcdJcsAEYgOnv/q4Dc6p1cLIrP66GKh2XDfw+7zwC4D6HjJoibg5NaNI8vLZL+pzwlQMNAJ5XzbCWcY7000+ybmub74L91ZWA/sUTAAAOxg7wMoYDWcBeCYCeAzgwmr0BgoLInKHAe9Pz3Ii2y7FxOLDJ5QP9+wCIOMmIq+aQb6smsxUKnHzU/l24cH3LlQUEMCNLFr55IVJQny5pbskokOYs/6RQWUfiOiFViAQlTt+3H4eJy1+8C/O3u4zVikaJxD/h5xa9IwrGiSp7JGQ8MAtCk1p4rLqO8kdWAYae7pEsMH2sejRaxr5Bg6beKLVZ5tcqZiUDQE3E7QMu2K2LZ+PvKybB1jwNvkrQzDJW262AwcO4v/fo1sxh2SSAlXRXdfBpqJDmXgUAlldVRfQE3j7hsc1EW21C4Hui7s7a5v6qEji+BAAHxQEm6YkyASCYGnBZD9heJQASEqQ1FIj3cbi5eYNGwhhTmq3X6/XZ2Y3j5xwxLooZRiPbUGKg/dWZg4RCViixwK+W9gyXTHY4L4IQoFaS0DmVK/FhMawqffaBUAqAl7vX1PtDV+03VwjJpNKgHAiWDkowbZ7WImHnULFJZWbfXBsgCiuZLcTc55+dqUTM2iLF2sZaAMdsXU90eItHDNy0fZ11NNFQ4TJ6N1tbTntb33zIDrBTplk0BA2E+2qJ2a3iOfnuIFXABOxFvSYRwcwvgG7CVplVETOAMAnC6PdGmzDSZHYUvlcsFankCD8BIi6tyA83NrxBd5rEzB/xCxUZ4AaYyxsI6MDBXm+JkwqJHM+voNAWKcobb/VXlexcgjEkUQRCC6x9WlhXfDGYDNXdiopvAEi5WwIBWy22RKCc1AFBfiTshQkAxcw+KgkZ9t1fT+RBi1Ri9SW4U8ZFaxbjfCvyAkIJpoJjH7PKtCVDWDv63SkrPyXJ7xNA4lRSXWgA3D2LTC7SzeoXQCtWpnP3IdZBShINPqe1ybppeAtZGN3A/Gmwt27TSRgVFND2Adw9C13iIqifMbpBGnytMmsALZAgQrzF5rpXeHxu1O7PgpZ+i8joGYprszDwHTUBzD2LXKI6pXwChw63FedTJxBwkLCVeeQlMhT5lQouRYdyOOqn9e1YhLZ/C13IdZxFS2wu2yXVFy2au3Z0q1TQQGyfOKzsx3w7y1zp8lDQkD3LzdqiRHIHD7E6apMoxkWwnWdYC7w1d6GJryRGJRXUeqUBlHN26fKsqM0sdIz3/yWO/3c6O9vOr4/YJDX85wn+PQg3q62dA09nZ1MAAMAuEwAAAAAA2V1RO08AAABxL7LKKTf55PksKygrLCkyMzn36/MpLigrKSgoMzM57PTvKispKSkqMjU48vju7ClfVUFiachNpjZ8H9uAfoh18GLoeTgkxzGn877iQGR5GDyh4iwfVjjhEvp/Gp5Jf1ZLUurdARr3HETCDUBecmfGlzfvdEr2HwAAbqATZmiQUYVmBd48/IgmAyTZD2UVDOyjoDOtlO4YHKqDYn+q0uz5pOaca7RWqzs2iFdrVXXgitlLiJr9M8uCgnhv0mRFyVdCNamWbU+2HRicqZOSVqIoZfjk9gOHp+PW5y+p8WTyTRd25xZYa96mvZxV1TclLJvIyoA3SIr16eGlUMfebhHrigBogzblz+ZSY5X83VqzAOpMzZihMpAXH3wUwpfegAc9ww9A+yidFhGYJgpczxMVlCk/bUC1pwDy8ktKOadKabHK8KIAZO3r+rWgTEC/XSo199gqO5HIMnI2m00HBb6n5DlXYNbA1HuC/QsAAABwouAg4ABmYNLMwz+xtUFsFQPFTLDgFbgGCOgn20v/0upk08pXikQna1yeTqCRqE3h5htqFcujhjAODLakmsELz7hvSqRoSO3N2qoP9Glt+xssnE1V1LbqENMvfPBUSlrcmdmKb2IDL3IqtgMD85h9IZpqUb3Y8BTIwBZuTbVTuc+3mDe9fmJtABzxQE4Tv4K/9Oqb48PvVXv1FFTx0RRQ6adRaxe03ruqxGGWoF/9Xft6F3BsWcyVa5cAG95eQH8b0JmE5LoTpBQq7a1AZd7mzjY3DzaWHAhc0AUn8myK+xcAAADgROAg4UjwgA1gDnqNpHMZAOtIpriek4Y10PG4RchaIAHsD33nev2cCP7XKErQ9VezQnCaJXokjGkod6hykqtrczrEoMgDGUj0ANQi5p9uO5wfRsSJQu7snIPhyqmdxBha352ha7ueJMvkQUO8q/M7Fe35v2N1h/q1avfFxe7uIlUWqUq0MtNiylK2yJjF0gBV1wdLcN8JBRyUixUDVNRAhYAht+3VP1zGR5Sapr3H9BrQ/bwCMWoREc6DjAaz3kLapy3TbWu7M0PG31U+DBVMzx1lo0SbDIESi615+MNumL9I5UtqIAfxAAwSyzW7K5M10J2boV6ogT6IBy/vYN2EWMN5ZghX1q2Id9xrMnjiDQiq8xoA9BWvdvv1gVzj1q94EqgJKsZ2vkjp9izvg+k4LZVBLoXvU8JFq5oT1pKSAEwSPQ0cDce8bosiQBwI4uBTRVNC8rEbetBQKG4cqrYiCrzdGKh7TAEcGv3Rg2UkuL1wL4YEGYg9wbNz8lrmZR9QVl5/AyUNMdoIkYH36Ex8eEgGFBpLqwdLMp3pWq/pMQOJMdxub1OJNtN8YKnF3Q20nzPwW2/LUKCdABxfMwH0HcvlANPQO+2ZZisLeI0vDl8Pa7rx/jllPnRS+WZVIcknRZlkMPv4CeQpi7unEpLXM7NfFR8LoJwxUxMbd69FOcsoY0Y69x0eGeGNnu5Gm81WVZFoAfWaZnQA5CH1BcGMrM0pCQVJXiVrUBES8127lHX2dJ7t9KWzRX811vnZXfvzZAS76w/AWm/F6RUABC6vQrvUJSPi2Eo026exTWefaBTYfmt/cPBlkpwP5K1bx/xrlbUqKeNvCCcq1cuOnfWTM3fTd6gC+vbcAGh3QDMRPcvl+yOUk/YHAIAKOw4AIAOwAN4K1qlm4JKWii1T4MsOA2JtYlUKVvMXXjAdY5y++30p24Q42m4zylhA0Ul0j9Enn03R8qgOYWJGFZ1M68Z3vlYCrk2KFWU8ZBTVVvOtvRhtLn/5QKqb1bLaaGVkx4ufjk7rxkSaeX6ujluQ8PCZBWulSgQOaCmHSkoq8NOEBLgSCNdKJuVDFparPWp9uE3jCyN5iphKDCAB9/uHSzcGMTa3qLlS8xc0YAKDdTejEeSyv17aqS4WA2lniSbGeLYpNkCpJtQ0a+3+FhoArMYuShnIq8sfAxv4QN/OAP6WVFWZwTQxC3qvW8n+BQAAADgaQMIBAGFcQeJSGwzATiuKUgFW4h2g3wJjQj1zPNyUioo+t5ZTnrTNuJJTWmnrInU+t0c1DRTw9jKfmRVXk9XqcGwl1FRjsdUnr2/a2DiVZMf99HrtkGlMT1cTn7S/VDulzKE22iQ1F86/nUCUyTcDpG5N3Vki0JCwjcm+nSle5LowriWYCGrOLSf0b5tPPDM70E55u4u2UP8wlKAghNdbn8Rp67J07gWSwCugFnpVKYsJrpu7pYCFqDyDEzKwgDHNyNgkYMI1boKvhgBizKd0IKz3u9JoUADWlgxRGVeykQyLZ2P9A4AG+7kBOAoAOIAHrAB7AHZ2ldD1bJhkxxS7Fl3BZcSvhmI9NvuRI4ry5rMUqVRdfq6H7o2AbMrrzSEMr13tvVBljfI9x73hgDDZPXShwB0P95510QhCVXFBH546hQhFJSWkLzZb0BeuWPVc27yv1lzozkTnLazt9r9v26iXlhUygjiDEJmPa14xWcV/6lwMWmGBIp1k9fcE+twMycsVwj7jujlpCiWjrqHeEgA+CRzm1qkYCdvQjkkWeGPZ9J/lTkNqMolNPVZaFeBFHxS6BbZNQ+c1Aw+6hR3RBIu1Yq4XGzqm2QAkDkurgUWeDJeZ8phBSMXP1WFpZYcyztEhjNg7M+HMWQg+JQJC0JLoACwWi4ZWJ4lKwTb6zVaL0gII4rZXNhbn22B7nEBP5S1rikPvKA81xBeFBJRspgAsFgujjcloht68vvAwSjyS/Nd79cyEotk6qdrlMaWXY87s6SlEPzUFJA4Lu01Mo9GbztlnkHEAvr77YEvIqTvfGwiYtQkrTLpPllPh1mMSRKOEDQwOi4OdZtbjvL7tyVdAZ2gUdYkIKfXuz9/5u2DcPbJwhVZlYQHWUlcJFA6LBghWIGttdBMjwDV2fEbU+jjt3Ui30VtJLqpK4Tz5stFAsEMJABwWfdUWyop82b/1FDfAlUBY9cNAVkV65nWYvmAGH3YfJlq+stu5iwAcGrXhGcpGlpceen1bQ+8Tzicp23umJu3Z1jdyUm8B55nfRjE9smtE5nJ5mol7h+P+MgI0GotQm2/6FbJaaKVfzAkqHhYCp7o5pfX6BFTi/M/El7HN5f2Z07a6JK6ebgHEyY7PBwAMMsuI9rRzbPnyRp12FQEaix1aAFy5FQciop2L5mRlyLhN+nna8uHKW1RP/LBr7zpoUj307OJ7bAE618yT7Bp9cXmsD0eXlt4fAKDRAG55wAPWKpjVAclpNCw5EYrigIXNQoeiqfOEV6GysV2Drqs0ld0fTozOJMbojo8HLykA3NI4mY7xwrXMVWYx6OfcgyoXxml1nt6z4K9ra5RusHdmkOoRNScrYrqQU+VzJi3/gATLmueSeV0Jh92ZZ8LLNAwAWbX+WG0cW5zGGJ5eSgk+elwTkFm/IgawwQCGJp9QEQ9+YDwWzHJYbutM9kjOXAJc7NPCbmcqYW1lj1CNyzGHIcv9vr2joEIAfrg4WH4t3WAMsH2ZVKDePAZA5CG9Mr5r7KoGAH63tAKfHm1aVIuefOr+ngAQ5ttXeAOgcwd8Agl2GgaALGEMgH4A5DAm6fMknGxJpuDzN47NLjbmKlIuvRLUrMTWmnNsRbIxIjaJRt1tQShXbUZGBAGsitLBSHl1V1fxLblegetYkt4RxD9nHnPjlfPV3gKOUr+Ht8WooyBybaK3AO6G1HReVNQg5J4SUYbtKR0ARsOzp1dXVkPfI8Pv1TYszChwmxwvgWUu5/Ayhf+KCjmmj28rwnzg+KDWAmAAUGj+9r2UxyAXGQws6oep+loOJXp/p5+IzUBL8tYB96YSMGxbTqH4754UJOVOP9ZSM5OOBgA2thzKlrTloF+ROL4/AABMAJJ2JCSCLhg8A0Av1cQKMzNFfSwbpM1JTq+HiERzKr73VCP9W1OskJoSgrhEElcsHWAo69RYSebcuaCyGa9QYiJL/XY6Ry4PbOwlzXV2D1S/1nT23Lj42c77LlS/uvnSjxXjdwvB4xR0K7Af7nnUG+3bCABefTU6MswEQBLnkWd7TdpuRLLW1icBhgQy4Vi10kQZCcjAIOm8lrWyRBnpo/HQ2FvXRDVI8PB5YTKqBAVp235WXJAkALBMgnAVogiqNl/6i78+HAZeh2OHmWXcBCr2BckP6rM7BJppdjbBBgwWd3Tpct8w5fpp7XcCMCpubpFETJLQUHljzPaTP2YqZh9M4TWNAPnvBwweS5I9yU92RQKFRuzbkoRU8MBMVI3+LDX9QRyi5+LHjdvqhlqwyONP6QskHsu6crlaFr7lxHmCcElGZ9iqaDOh+0JnF/TSprV/93JnFdu337otHSwOi7NC1YeJ6015JQhJzpzlEepG9ee/R8rDO6VPrESkMfN0tN2ZtS4ANBYLmnQbnw3cqvnxBRjJuei31LbJqBnrwrtqvHCy8+fTZFqUmkm1zAZUGj0dWH+b5c6Hep8HCBn4Hh4slYovPU0np0p2kqYG6wNmiaAbU9YgSgAsLr2HPc7LxG3P1Vc76DrBeGxjq/TTJH9IMCMuiSiNFs82VVMn7FO3LCxbxN6Ix8oqABQeS6BhHERWWqE18/IIUPGwwkDAkfEMNIkCP0/+f0fdtPWCxvZ1v2jTJos1ruXHRykomioA7DXLsKftYTW50uYSoulbcfExZMcIjn7PrOy9b7UzzGLMZ4gKYbn7fKepKehjdcat0x1zXhtM7wla1xzi9NCVPat5XdVDIUuLif99HQzz/DIvh/763oA+A3pmwHEAbgEQDImwkqwChmSKnEnuuVQ7A8tkXJ96rR9+eThy73DSnEwn4/RB61ZAaAZtNd/k6ZGZctMntKLx4xQwJ6aGuWWgVFWZsDf79fdfzz2urL6ejlHB0Th98Cu12X/woFlxVVVVUVG+HrGEPhMJU4erQVOwCCCYVr8wKmJzBlDIy6Ohu/sUJwCORWFRhSFbnuJaDYkX4c9q66qqvWIN9/PVMyD3OACLDsd4s1G5wuBIr95jDBjGfP+TpplOBxOcgqo5dfNUAJTDVaow4XdCAf7HxKpJo0yLq2OXKMx/AIDAARY5/QDABQD0OOX7AWMASAKNDEA+7PeioMAIQFuDvY2kypjQJVe5GyZecW4kG2BkKQhcldwQBQUAxmYVwvnfpUyT6OJWYTrHhOXIAgx4dGFM+JHhOjObBKDkzbI4CGy+qr3Stbm2sxlTvpArizxbgSzQYOcYt2SY01oZlk4+bNp10q6S2x89TNO+B/fg4KLKoc5cG63xSwiIld10i9dkKQFOH2hSbc5SUbUuKUxoxgbOdeV8b0da+SMsdpKLWUA14X4sKMtaOSboE+/iY4+Z1yiToRelzBYlXgtBiRqvcJj9TBTKb0UHNte0rLrK1/N1WfrqhKXG+X2pp1bLUUS96utdgAMugKmXIYAkuMIA0PhNwAkGTFuj1wUJh59d/jN5dUPh5Y3N5+9znqd1toyPuUSSyLSIKFniUTOIAHKplzauPqYmujl8Oej89sSsTbeGKKBMJPjk339Tl2orFC3kd1uqaHQLIxIIT0RVtlZM2Czb70sahbf3J13ZCvOIP7wkjE2tXf0Lv8B4imruX4CmENLcyntGgGFeJvaRb//oIKuQdGG4IjGYgfDV3AEZQMw/2sOSWdftawWvJSAI8CVHsCFPCuRPjF/ZLw1sCLddtqhQfmcHAE9nZ1MAAMBpEwAAAAAA2V1RO1AAAABpciXLMSgoLCspKDM0Nu3z8isuLCwsLSw1Nzj48+8tLisuLC00Nzb29v8ILC4sKy4uLDQ4OfssJgsnA8TjVOTQ6kUniAgoTUJKPMnhIgit2Cx5qZF93/Z2W0i1tbIDJBpLuuHgoqNzLgTxok4QEdCfamRQylWdeQJFDHLEhIpQUF/qrWrG3Pwhyw3lWEfm8h/UqabiXwkigeCmaKZhnE7e3czfjn38C3CYXZffNcH+0U1/NCYLJilnx2Q3uATQrz8ChAyccfiJ2AXDsm1Jl4jFuelqTmLviiXCW0hJAzQii5pySW8cub5OsYohABgB/F7K+CJJpXTS6rsZP2ZKeneJHIbvXLIB1B13ZCMmbJO6WlMVsJgRCbVlKKLyVw1pTcjntP3YYK4HEpqG3n0yCgwmi7odwtQbGfbotLY1gEq+lumj7sU0yZyRzDL1Zq2ds43uNBUMb5WX7gAlx+OH6l5XASwuveXsGQ4XFD9W3/AgLY/kbMPULuymRX91tlgEreXJHjxYY5fL5b4teeAfX879Z/0EBAAUTgv8nj+KWjpageHyWlvQ0aBb3r9yt+ceLaTWqnWS1yXmypy/axAkVXxQ4qYf90MsJH8AmwRa19yAYKe4y3x9iFfV9jdT/r/55WbzWVxzbK0nBQAHALCAzUEGTKRm8NsYJDThiVFMcdfre807L88HmuC49WBBf+q/0qJEbao2FbgAQVvNXxpIugLV2im7515CW1Dar80qUDKJGn/tvb6ptSZ4LWfZ+VplTj3wYGqIEnE5qr7pndx9/dJ8g09KPbqqlo3w7kZZBiMZuAXLbvZnzAB5BtQvpLsx3N0Zdh/67YzJrgmw1oDj1toV4PcvwKjXigoMVTyZmpKnYMF9XyYAPb6iKJdLws0tTPDuC4oBwvW/+qxZKhmEH2otKh6PxY0EKACe51RVVnhbUyfjkoh1/1nCokapJwMAHAkaWG4PgA9AxgdVpgO/ETRpG2uYIj/W91wZTvP/KToLdxdFT/cCAAnBvL8Spaoq2NblArg7wUs/5JsHgLWkYo5jSVp3FYTkzXbp8yEv39WX6iriziRv9vJh8/SokQTNZ5SxhLblxU/Zzboqrq+OMv8Wam9xJ6AYPHbjBHTcfOON3GPhbYAAtuW5ml1tk2L0RLEvP8wGYSTgMFRH5YiAXBst0k1mMOKcWudYCnzXNOHalfMaEKsH2Ge+0L3qwGkgv/srw8rF9RI4n4N+1OgJipDNzM/uJZ/FTAPoAAXW51Shq3ZP5YqWleOWfL8AAAAAR4ACugUMhRlAGkzbygLrWasEU+zJQdSzEkWSCgBgnuG4efEqh3ep+pq1SjhJ8GHtJZMKQN/I++omzEpIedRlw5KSjCxb3t3RpCyOvnty9f6LcdB+THXNM36X37X4yaG3T++d+KOv33yz34/QcHN1VeiLlUJkTqkQSksTCj+KQ2zE6BM0nU0X6QGAlv3TFbkUDWh+82S1vmX9zBfJVU2bJrTxBeOXjcHhqgVAE8lhEIUzAWNx5sEJpxeVtyvYxh8Tt+wgo/AgTzvZrawrLly4gA2q9tBn0z4sLMxBtp1SByQmC5gnUk+Z8GqV8wA6wvHQv/0n2YTQsrYoKZZvm4BiV8sb36HEmnosswDUJctje1JXYmBE+lKvzCogNe5wuIFLwdhq2irmq/ZUJqa4I9xUyRKOq+dsbRQAFCoLjOekcHfoa/POF8RBMYz93UZcsom4jCuml6GoVqbX2zuvH+kCWdBmJQAUJouUrRo/bvpTryxLgBkHJAwI8tkyzmI4L6Gr2ki2usrcsKa7n22iGPM0AEwiIfaoO3da47B3Xz1qEAdNsrWVL4pKCM2SKH0/zn0BaVocdhB5PTpCFEUBPDb1xtNlvfJFpIi3KgSYaNAEmzZfmbD0CksXJdW+8K71lpgLzSGtLQjtcmcALB49xrM5hOmCNolX9AEaNBV8nz16ZkQtvbus3pZNtSfbfgfBsqcrOTQokg0MNkWesO+y7S/q2uRWcQwAstic8+fpONGeP9zU2+7yTHkotVDtHDZfLVBQRGsGb2b+lJqWBRw2vWWJsXObDx12/V+rEAA6WH7+FWoyWo68c2w15uRiXtjwYRsfr1uDUZ4ftL99s2nt+GKkaRXkTcu8np4983GLw8O2A6A3mMUyC7y/thejGovU/siyKfXktUPBqckX/du3zOkKmYJTp0fEoW1OANoHzUm4eKby65flkvq9phn47X8zb4ym83DYP48BAHDUQANsMEYGFAIZsPpJQieJUQz0vl3lms4bfp7ZtTxDz/G9NTEBoFq79Dm6ukaN3Nd38w2aMQLtTCOATyap+98PXtokhYjGuD/94Mzh49vPzl44CvRt1MHd/J+HDk9Pd8cq+Y2LjNIOQrFfLUDwWw32f+Oe+T2cSSmEg8BldvKntfbVkTUrBWrMBFE5VYBrq0Bi/vesTmc1sPhbrYUrxj2osGhpx7MqauALnmI1HNmLCYXLgfIclVBkSO3GXHK5BJjgfm3bjSVQM/KsGDDGxO9nH3u+pTwB15IAnviEVHYRq8kaLiMp7/0pLPDUzAAAO6rgAgDsAfAxDjCAhWUSzC38B17XWJZiwCzMbt0zVXsnUmn5UpPx6yMAwEpzFzNtxFVhlWeWiQIwXXkAtQIHCjCQNt7SIiRZQhi670wVV+PTtUS1TAfavS3x4/2ZlZFG2Nb9p6Vq2zIT/EBpnAqYKAu7OyQGlQVQm8o7N3IGxJFbNhrfb0fX3zFK4Xqhqt0aWPnM+1jxZzkc1UDkM/0KSABIeP8M09AEkKyyJ66NBNrwdxA2ntM6Doas31GVTQCdMwNruVCY3frSN+fTVBj4Gu4EIBGU91DpAOfQ1U0Adve0mFmb50qvqF9poRrI9AsAAABwBGigW8CQCLcDt9oNHkn02KfAza1uFlwmkFZ5AABjMJ4/73RtEHJyOdOhbHIubuy+kw7u9B6PjIdSAiIqxLtnx167u1jOa35Z4tyMjBpeViBP7ooR/v+3np2k10wokjNHVlpXb1nCqsEIPDR5Y2lrEl27giExJ7lxd0Jq6/EvC1AdgFlK+XW6sDoPpyD4btt3SUA0tg0Upi6kDYDJyMt7I5Vg/nWUagJPNydlJejtudAtcCcGX/am2Yxf5TS8rhob73hlGBZnyX2NemZq6QWRHGX1A6ENs1rxrXn0LUukZwz9JKJ2ntssP60XxIWpBJ1FAVKrWK0ohi4DFrU06D7tOzzIpRrCbgn8MYuh59hukWpA38+KoQQQNRxqCdiqBLnpS6vq15ksG/4NaVT+tEj3dcyGGSISBDILiAcpKn+R0Wv3+WkQF5oGV8ddZCZEEbSkpuJFOTbEudjD73zqjNXICgwuvSSY0ZduhPXKtBY+mAgZpm/OlzVXRrEtNyyN85muvkdQ95QIzjkGgjjSYQIMMgUqgT9i+x/xXG3WuBcBIji4aDWlAQxYp9Uq6bssQuCXOpKw+E1WWpUUAEwtXyG56lvIP3Dise3yIxNASvj3UcYKWjxXzJj1agU0Sd+6nn85ZeTXAUGRDNRBPTxXKF75p+/Ib22qiMas5KCN35K9sV/auMy3XrOoTTZt83cNK4T04mlLBXiX13RHBQD0MX07EqetEK0ZuIyLvlKjAcuLm78MwxuxTIy+Hh+vj+9TLyW9v6j0/367V6/eJpGfs/ro0DQADE6LfJ4e29+OIlgTcXMxAEqgwcjCdsy5fDu0tCdHeoMMhpisl6CRNd9g3XNgj7KpW3loWkk7egcdFNxlz1E+qtglb+BhvjRtvwAAAADHGBTAApYjA3ZIZfAbA0kAST7kiAxshQtgXYZh1QKAktq3nTUTFYBn2acTr8IbeLzbGhC1VWj310enY4wKMU6SM3F6Onn3lU0qxqo1OXvxxf/H/m7JZltzAFzBmXswGfvq6/h9WRLPpL9dfvfXFZfuBluypvGQIiObszO2ycyIRpG0mkghliM0qxYtCkCADzy7Bd6r12gN1iTcIxdeRF///Q5aD1I5fFxklokvuYScITGNNt1/t3vTgLEMio1mP30QDTKCNAEM9iZzEtQzWCjBdVsXOvwhz2MDEr8GtgkAHhglhC5THftKAt5LVJj3jyJhwH8vAADsaOAbALAHwN8AZmA504HfsEMj4SWJYeDznYlUU1M/ntlPvuPdiS/PAZA09kMe7VWlR5ZElowJAZQGILY+cgA8lbY93RPRjjmqS1GP6TXGjSP5tmXIykaTrHI3P5e5h6/5oTZSevubxEYIQy9lZxjnyyrJUD2X1ADdB4Qi+9GYTOLopyw+gO4j+Gk4CHBt2MufAwyUgX70ZMPJ7nGGySGH4edP8wSsrY9vWgMADNQoAUM/wgwOBiuUze7dVZM3NNxmB82cloGgi6pqKF9s+5bdphCGUw0yNFeI/yClADIBlhdVqL4261N+NZSwLX0DyvvfKT/sHnk4/vN+BAAAOwo4B4BkD0DUJ2AA25ZWoMtAFX5gAEhkx8CV+VPb3p5TGxMj3tcgMbbKAAC65E89ENxwB7wX5oMSYglASC0uPURiZbzPlCxHrZQqKu7oksxOvTMeyJjVZDGKxSincxjbdTaRgwuvXvz428Y6MyapU4bgSBUgrtLLmy5a58jKyrIsy/g5QW1DbXN266XB+wuVMJqqAQh7w3E0efJyK109BDbzhTccQy8MuPHPyWpghMK/rgtXAIQBtROGNwpJxJUPs13rzAzJQHgNvunw9twq+XYPS1JHH4sf8jP2AM2UEXO7oTqEUBLzKQDkMUtBMOVfH0nQ/9lauBoTQRozLqazGg0fDcJQfOgCYfBd8p/FmJay4WnqHQQyC0mwm+6RqE5a8qqvdhIHXQUbz7bmxl2Vatadoe2mkllzntNIN/RDonlRXQDsMUuxZ9iuJvGu/3uV3w0gLnQB60k/2Lgni71OaMtdPIt6ctCyfUsvtsXM6AQyi3ggW7/2w1zydmVdAHSjxOViRBOkLE6jSg62D0eyJwhXVkmu6cJu+yX8MT0ymJ27fFC3VmUvUkdcmBr7WCFVicCeZkS79OTSIppQmxcLrARRh0dvcz8A9DX9JEDxmj8ixdWtyixBhwlipOApUlkhLRsLpko+i7hL17VlhcWvUshkITwHAAQyS1Sgm/+SYrX/clVuDTqMgIHXaZeULB3zh+qltjvi71glfR6kh8t5bS4KFD71IFEubn2RUwq6tBY+QE/npusvZf09LTdX2oYHbMMg5aLuJ1ec9qvYr2bX+GemVNrtAAQ6vTsT7XZmetEG5uKfbQ1PJjK5+/SKDmdZ+L0lMZqydybf3OTpwbv6V3muGNdXcy1SLtasotcB/EWLChI+PY/bFB1fW2tzMpkNxq54av3Knw6N9uMB62h6nxVrQvRVFt/+7v7nsPcOysuO7+icTBoA2icd8nSY9xq/LfKSvM2rZKRJ+wsAAAAwA9igIxh6w5cGS6tIKH8OQMgMbGJQQIdVBmsSAPixatBaUI1RVwJQ86vMZ99XpqcjaFVrq+ylTZf+H0gZD+YhEefj1w9/dfXJ8dTkdFwsvzJXu4qOqzQ0rePpEfZ+/eZstJjHw049LOrp5014RK7DkYkJ38d49Kt28X1Vd2eH+QxgCgy0N7BsYyyOUQgB/KzKnlnkDuHyARXHj1uzBoFqVZl8a0II8PvvV4emEZ6vjH9kwR7NHwT26Svxw53eYkMI/qJWYeBCwy9qeeyesQB1oYGA79m7F8E/nXtl6sBRdYQgGgBPZ2dTAADArRMAAAAAANldUTtRAAAA5+ScgBT19+z9/wH/APH4+Pf/Bfv17+315j4Z1V500470IuFa1Aac9g8k4KoCAIAddfABANgL8GOaIAsAFAdsAMHcaj08GwwQFcnA61vjcy/p1j9ONLxFjrRurgEAjDU8vVB3OlS3lktQS7gOoPYgwgJACJvQnl4TWsFTwFZMQskYhVopltmfwaGmslp9PfSbkeCEvHObK3KXShHKTpASAYCG+aOUzNgCbIHJfiHaQKKYPLcmPGWetAmauM767fCxyYUmY5zpr9Z6gXvxuGCOyQgNKNST10SAjflU1uASo782HdN49StcHTlX34sYTowxrJcGfwIkxX/PpLoHT1XXa/a575p218sbsXbOZAMA/kgVydQ0/7SPpIjarQbQ9osB4F9TAAB8cA6AVwBI+hXgT+UBMgAbwICvoQskOaEYuPg+6y8MYmpu9UY/ZkDdXCcBQFJLp6MsrCeAta5qkAD9oLBWPnKkBWyRpthv/z7zPTyqOTIu8Xkyc/Y/ZIZmOCXZSLWw/1OXC876fJx/dzOm2TJvtCU1cDcdAnxVEP7GKyXyHoWPNKcGigc8Wf6p8e+mZgW4MGR9n5YkFwlHCUbvYxs0AEQxb/UQAoay37eKpJcBoAoef9Y0aJAOvZTISSpyn8BcyOutOMIdWoPkbCOb/WfEgnjAVbmHADXZIMpVLUpH0E0jAP5HJZhZaf4pH02UvSSU1P3VKCzwr7MAALBjKDBKaNDYA2CuBLIAYLOE7AFtAUg1UiEhKHCVO5v71KLxgepOZlgqrekEIERfta9e9+gKiKcYG1mIdM8AwG+epYAUpSymtMjle12BgStLElGNedo+xRBvZun7z/fe+rkNuvbiMqMBoAvA3obZysP/yVDKkM612bisas5MtGsZA3aK8tMsJA8qscRnAKDDS1p5AVb2dIkFQIJO6VQEAhLY/k1XE3OGYThpFlBu1CMZCZy5gSCN+Mn6GfNGAI5KH57/mR3lUYLYeCtbbZELSWwSqtkEvjflcCrs/MxHEwSfaQD1FwAAAGDHUGAcACz2BDjvBAOYbGgwQA3BINkAggH6mKRANgAVeH0BAMllXE/l3HRt4Bo5xgDsJ4dY2E0TEUAK2IPugTBNIQG6NNDebm5eXS15aYIG1/4usQLPrurAStVT730nbuXPC2IIBeAqGr8a7pWgWlBqlKh/qzk5nws4ExB1IjUf/xHbGq24srFX2aavrk3Ju5QeiSkBREkEmFaJAVco5FOgQayYTcH6d9QRTDkSkmddGQGV2wuW0DwQ5EAWIxBYHjFcoxDrxnixjJ5fPgTBGkEJgGFRp80FOBzXmkkTmU+MdjesGzO1VlMpDb5HJWEpzPopV9MkTyup+20CfE8MAgB21MBXACz2AvpfDQxgkjnAgG0P0kDjgALQJQEsTGAOQFMg4JHcYqbvPGql1D0fVNQGAKB14WraDji4t515SJAoEGtJwTEFQOGIPPh8WGedFdFji+aYbG/BdvWHH7L/nc8CqEIxYiptWd2cHnrgkVBRAJQaFe5NYscpHLoIjT9WVaCBIvjgiM99eqxCdck6CCou1BaMEGBxfHUC8OKtGuBglqoARHEApTUEcH0hEIuBQn5BSJOBFL7+UjsbSHyjVQ09opEwcL1c/mGOC/WaEQs3gx3+G7lvRsFhrQS2e7TRptF5fzJlC26RHQA+OKW6JVvXeE1WqT+gAfgFAAAA2LEM/AZAYy+gbyPgJgAMxx/YslEj3QCCO+CsAAA5pkAC8DqAp3sCALQyjj+NeJXg6s1XgMUDASAb+ABQOmnd1zvhJnFRwhhQD2ADLKO59qU5Olmjeccs0+TCIoS3d+lpM3g43JYWwYEupfDeAh4FqIkDOGiov2OLUohFIAEI7xzES1E5M8t1yxrntR0cQmWNQjJYjf0W9kRSzgLD6GM2XFGDX5B7qYGQXtiPdk5b2AMDVyfgv4iElfCeN6bYGpIacQIiFpDAX9cdSGgkgzxRZgQKLdUbAMxnAxC0waAi1irL4KIn97EdebHt3QC+NyVwid2f9lmUntNrhsn777WaxPckAACwYwR+AKCxB8CPCDDAI3AeQIDUBjTBBdCxoMAOd6UzB+MYHbWdBQGc4wESAEST01tCoR7Aq3XmKGD3BKBylgWAAynRQ38LTKtSpNIhdtTPvrgqS0LPqD5BqoG1uZcnpfmzV3SwfxmrASKAnIqR+pzP5ecrAso84AiYyy7XAJHyBJCdynY8ObxHffcrjXUdq663giyZXEDW43LcQGuY+fOos4bSD0YBkGfAdwroZMAAiIMS9G2i5qM3DfL/L6GB3CAF8h8CkDGQ3AHLEHtvlvKsV0hBhJDuKgUA3jcFspXZudqvwRKcVEX1FwAAAGDHUOBOArCQ/gEAet6AGgygcEADEDwGpDlNgQIAXQ6X0yQAoRWrh+wXBRSwHJpIwIoUIOqBAwC8AnJaJYNvp7my0SUbukdF8EmHs1FFwAHEgT64O4oXBRXZXu7G06ZCeSrgALlJpjuzLGfNIuDnnF7DJixyuAdsVUCUi/hgnKSJZqm9pAjIFMy0DtjBYLFFBRXqURVkAwM0Fdn7p5VHXhyLZkIv+Kr25n0ui6Ih+C8Es7AlfTjMNIsaMBgy/Hcf4QmfhmRc4AdFsrc4gTTCCWm+cTpTGZw5tZczDz7DH8hoOq7xAQm+B4VsLLNq5XNLJNgq8U0OkPjXO/DfP1IAsHYAlQHAYg+AnyYAGfgx6ZGAazCARhM8AV3OUSBszeNPV9E8ljSN1gOgHPgzBaRXAEjnDuOQ04BlTBAiop7UGKwH0S0BwRolgEqso8WKvpciBQiRoinZezo/zJ6dTKHsQFmPhYIEaasTdSTmWXUIKKCeg6NNVFimFIoG4A6tlRM1ZK5HiKFM9o7tcKU2PlL8k4H8YiTSyKynA2csWsDOU0ySA4CznOBvhaCagy++Pf07Z9cWzG24jhe0zSuCDoi/SxmMDoDcGj9HI0lltJl/9nGIKCIJKl6dJ+456AgJG54XJfFa2jW116bjUBfByv61kPTvMyAA4ABqgD0A3q8EMjAROBJwCQOo0EkDOBPgQaMpMN3lRSa+tSBgfr2Zy8LgAAEAZkLc3m5euroD7cpWKG8SKIY5BVSJAE2EYosIAE06DEXlmPnAthDHILyz04Lz4KMK1cZmXPkPtfQooBEEMGn/RoAfkwL1JAgqpbVothslUAawokraW+8UoyIlltDiIBBUJBJ/XaDcxjwtU/p08xagZdCb6rtz5/rNP8Y1gJrYVo6jGfIHAFIDOENmXxQSUAKQ35ARGYCymhQNgH3EDNrsymj2Obx7JXMPkuKMDcEdQZRm6gCe9wR0adMsbbkFnF6F4RcAAABgRwOfAdDodwAAGdjtGM8BXMJBAiQb0EjqgNMBAE8zUA9AV+DDKwCYF24+NUV9USDKPgtp46CgZCyCAPpDA4qraXjMdtmwb7NfKfE8WxBfglIsECT1ya2NYZ2i2TpeAUAzKILiTQS8OmwxgAIoouBaNwVn6VANAwdwL6+HJw2lAk3ZaVW1d7RCR1elZ0Gsa59Vs24qXnW+U0yI0bceAxZ2bwDDEAhBYPyfD37x6hF+YLiEsUW0cZEQ+SjuFTODPjjDDjEsPoKXZeZLgQxgBB7wmRA8d6WfDsH6SbKYligqawTHdTtK4C9ULBtj4txzK2QDAH7nRHRNukv7uFlZVWJ/KSDxTAwAgB0NfAMA9gT4ogqQgYM5B3BgAFgASAI4AIBWMVDfIKf5243PfKU+Y6Mp1QdIAMCHdfPeCCXBy+mGKRBIT0CpjQTSUWsBKq9uORaARSxfoFX7//B+WmrfRTcMRHRJgaJE8Xq2/fbB5trRqC5FdC3J0F7lANBFxT3DJNYAKOQoEHCV8TfqCKR6qGToTeV3i8ElUgHT6T6VADghAylNQOvEy9+4VTet9CVdFK+08vLMCAp9s58shIb6+iszSHYOgGf8Ja36ba1IW6tY1EgItn8hEYK/gE9sc2wC0uekKyLjMBx1k8e7BoANntcEYk2azsdUcCgK0/5JWEnibwMAYAdwDgDYA+AfJgUy0MdkHnAuAJeJdB4opAKeZgoN5RkG2j28tZWjt6FSSg93AQAeyV2fJxK1AKnlA6AOtCJ4BWCt9BDFY8M2T3oKBFVENNblLWlOVVvqDa1YAg2WGmbhb3qBiCQqKk2C6LfZM3JNVBQHxxf1hj53NOQ+cgch6A2BqMlgwm6D5E4GBkBKnYGl0krSlrNpKRtD90m/GojM1FGchv8HqrIVjBrDVkuc3SiU6xgGCRhDWPDVKs9h6ym5c0gEg+gUvt9qGcym7/5NbBhQVBVKcwPjFJerFzToQAKex6RsLm1z6XMImBSm/a8SEs9EAADYUQOnAAD6DQAgnB4BkBAMCjmJVGumuOAKX5YdMc5IbtPY7OByCgDwYc1/XaNCVUFMYimFlI5ahQxLAPAFoNp/26MJwjzq6loA0yPuFQGhQCoK/2gvqnThQjog2GVBCJQAgyD6vnybpzEAB4Q/HDgqMCb0zmkcAO26m/df9Wh0mC8V7+PIVu73IKeeO9MxBVYJy4bm7ZmdUcoyHd660PlVYzR7WG3qDv/sBhAV0F30qs0tgwyCnT1PZleelBZl+pTdSIL6Spt2HogXfaEGY1joe6Hn13aQXTNBAp63xGxuzVThowk4juK6/1wAdBUAAOxIME0AYA+AP64EMvA7MgDnASRI5QKeJxjIkh71IU63ZiaJ+a2WQu8fAJAz1uOcxDgRVYpq6zES3npLAHWjoQBEqmDH6818CkiUrnPDoDV+kf51M4x5eZ8tLQPAtbpYfI2leXkALQpXlR939m+lFmiJWe9/TcBEwgiCKyBsVa18q0jvCfLnUeEDyi90HzacyTIfQhYCAFyV/z+JSGiQ6mZf9axVxZIGLNI5bXOd0DtUjOiQz1k5no83RPtM3XO+19pmwXiogJT4ln2QdMRKf9UCG5IqGZnAA56nxHIpzVLlkSScSHLdf8aMhY8pAACyvAEA9gD45apABiZmAOcBHgTmgSLQOWZgobvOvrJ3kTDHiCkWAU+PAADHfRYWUnkrItQQQDoQhdVDIz4oAaFVnCab0jLibdXF5KehXkuhgWIdcU1JFZjEUqBJp9du18zTRKEDRARB0F/u1ZhbL2bANyEII3Xlh3oGL0dWbR0AYilejntlKi9pKJQf/kWCeUIgD//nyNyIlFbVLbEdE5Bd9TxVa6V1WhCsWPnGTFiIuOG8GGeAoJIJnAtUDEJHKlaeW8bArdGkfU2kwu6TZLGstIQfTXY/QDSrfr/SOlMDvpeUcixMM+nVBBI6iuS6/5IAHycwAMjyGwDQ7wAA0rSTsKZzgin2q5eLvRmVm2aTxYf3DtE1EwCGRop4KalIrR17CoAngLlCh246lIKKJZD6Ejyd/z9cvJJdDGkHISVX3x9rIxE0TFDVRY/OdnRClQzayrifmgXdpcjwlkTMLjZp3FaDTzkZOAFIp7O8ihJpZ5kimRr9v1M4dZoGywfnYdfBctCipm+gJQ678kajqYFjHA5kLXplWe8eG3oERQidOKQbww93VDM9w1LveIWhmhYssos8EKVIdycQuRGHg6nsqATaDABPZ2dTAATN+hMAAAAAANldUTtSAAAAUdVoUBTo2+bf4ePi1tPYzM3Y2tDNz8PMET6Y1HEJR7RXUToOtNL+Vg1rqQr//Y8AwI4A5wCAPQC+qADSwEYCiXkAXXnNQKHgMryK13pnl9nbXAPjLPtjLL0VK9hSh/SBfUmrcWnaHUoMuYCyjoJQXCWkpHAgkqz0JaICATHK9+yg3E2nIkDAeydK+yELm5EdJv1VYW+Lf40SnkEecRC+6k5MX0tdKd9325H40yb67g4sXRAB3wdBn7G4+D367GkSKo4AlSRvcUYLMjjGJ8Ih+lR0wPzU6c93hR4SY2Lah84n+mg+2ieet7RgMvNRyla3UZyUNANoExrt0mBKR/uO4gG+d6R6ClN4JEV2JMm7vzCD5CkBADDUAXsA/FwFCEttAKQlWWumUPndz2xbk5PTDe52I8q6TAgA8MzSGule7pOiSUkoQF/zWs0ABYT+vhi1WpkGriQ6ykM5BOkkLEzJNwdeMvJsvakM2rLfoGqfkQwBETfWj13f540O6A2qWEtu1JW0XSRJ5fOjDZmMqo8hCb1E3AGACpcrRSgM68W28rp99p1bK0euzdftHmtP7vmLFslL3N9cbPjxc2eVBBkQPm0BFr57tJH6ZuFOs+7gYwzYpsuGMMm9J3lAQgE+Z8RsDJ14UTBLvv0VSkHiqQEAMASAkA8AUNVJ5GQ5EYLCaDPmjMvpDOj7nJbLYiD12QMA7GzxrqISVss6AMBrANark3QGIUtZvm2nhUMe5FZa/56phoOJgk9g88i9fYSAZbuC6yFfiD4FUhQc2ZHpGsU7znaFKeBM2K+bjsDBEloZulTgLI58j56QnoDJjUw/URQDgPTxw5Y1S2NU4QNANnhtFPPOclRTVLRStypvGd2rGiSiiJQZUdukdV2dF6BOelemEU79frxwpD+em0pShNkCGeWlTlXouJ7Jyrm9CsQheTrhAd5XNLHHNORBwrVkiffNmpV4qsO/fgkAGKqAPQG+lkCXzgCkrPYSxRRX4/pVecVioeQyv4i4+PxxxPrAgYY+Ak6ONaWE2Og6dnGNRFoRUk6GmikBgEWLcbSTGFG0KNcr+PSZrQrUeYGZvHPskmnCR7TkuNUmZSEcF8RdYZFSN9FJqvIcoHfENjHVNKA6F9QwlVmQZG4dyyZZQQ5qkb5uSM69ScW98pk9pcMr5oaMGrPXTOj2DeaH1vYKElKZD9YRmYHuDmyn07ckr9DMP4y7bBkAcs/VVdbd7LZ4mjZTgQSeSOxjKpmkPDKo8PanAISKgAFAFl4AAHsCnFcCPbklQ0Y7wYyV+2b2a7KQb7h5IUbRGiunJADsFkEqKYJSJaWVlnhYD5ncSksIAUrutXgsK6lStYQfqZRExdXgPDepixJAa9IJGbKZVWrE7KMibZrxqZ0PzCl6JxLccQ9+vYamEcPz/Ru+YB4kgteoo6O17jOqR7fEjhgLNMyVqKDVHbi5CThvgtpcUdoQTHYsZowp5iV2jXtLozEa0UTAFlpfdtdlI8O/qVT0HMKc5wtZbZqkGp+A9yQ01S+SyrL3CwztaAAeRzQghU4gA7dfcuErkwYAIAsXAGBPgH8lUP4GYHLGM8wU15b5za9ff5IhevrwRVvj9TYA4BhKiSIgiiiVBBwIoZauvg6wcNTTfEv7laWXL6VJxuTmrFltKkJYaaknwvdtuNAGallRj19vXW8+Xbtx7frDexqdPKgda64j2z5IPvvyYDPAwctyyZCBi47rXXt/EKyAOYKwrFSRBjc2O9FW8dCkqvfSdPQ0u5p1toTkvW9La7YePl6HCcrUPdyOpLIK9Gp0RZ1rMaHghx6D0Fab1u5md/wVTZ4f/GXSrPfQ+daJBL5HNLKlJiODTM3bP9aaRB8AAMg0wB4AtwCq8qEoPFkphhrtZz6CFoEG8bfnuuW71AwA+GxxAZdyqS6+WA/l6UiWCYqUSiy1x6SlUimZCqXsWLfdLd/fTcO5ifuDGmMxK6+BPzDHHrz295452OUThts9uWNK1PXyl9wcVwIlCEAJ7c2CI1zCs0Sc8bMggIB+ej0kCmkBr5RoBZkbsYugJIBoj51MpwpJskE5ZJQ+YDxPPgPwRtNHOlvbMrvKmwdHb21mS8S6Q4YDPJUIe4Ji4+AiHKpzpvEElRwBtL1ZSW3qCACeV/SyJ0IAELr7JwsACQCAbgEwVkycJp1iioGGSWdXPBGy/W/L4NUf6d0AYCwBaa1dK3fgr0vXHFNzpN4oQ7b0tJTiZ8uZemr9vmwc0QdwIzvtgpJvaXZipIJRQLL2P4f2aEPwDeP6DDs6dibTIj2+msTK5L9l+ExtqruzFxLmx/hk9FxtvFBEuLcJ1S5mXfm9vbpUyHGYCB15daXWSmAd3weC5rP8lG13yyim+DJ9qVvffA4r+462egpd4YJcr51lvAVva1uragdXXcy1bEJFKmPUB+kBfkd0ZgxCkEGSvHe1NNkkPl4BQNe2flVFrTUDnw9MLT+yljR+fiCRcnv4YrdoalDLUgbpuLQ0kbXDl0uRyOhK4SYOyK1C47cld1bVnyguAJV1JZqTBD/xFFJLF8axowYF/dWUS4GXPL69VHVc2lQFN3MhghE4cmvJROkIxPE214HEhQO94NDHKmzHD8kU1mUQ9UgzBz1EvQkNbYrM7DybcBuYrGpUQ/BaoZBFps9hdUjgt9QfQzvKdi+h2lndCMXb1NE8tqSdAP//FpmClTRld8W0G35XdGWslADA7peKYMseAEDaVlLRKeGIiuL68/w/Xj1qa50dbw6mPZILkVUA4K6LdbXvTBD5oeSS7VeCbvqChePHSOHg77JNU4UMb7VAQhf/i64AShKCQfkDEk+njlR9zWm88hFVO50fB48dyFFd5ewBwyL/OirZ9vo13Ap3h3lstR7hohkvAPo1AhkvEuW3h4PcOs4SUmEf/EdjxiQBMyH3ijLtkQYr9d7F+di89IxAHzReTin0IygjORqKW4pKZjinVc4+2AGZhCxEEiIMWQOMnCeahtZqEn5XjGkKIagKErB3CzD9p+cuAKhq/dJRe0IzxSvHZiVa8lfGfjJ8vvtlyiB6sMHVMhU7SlIkxXrXzodeO6jTv7ejvMtLcgy5ipToXkE7b58F5lkBP5zjFbw1xK9U3gh2L7k9YV2asr6p5Na9rDiCXBiFwYisU9CLm9xzWnTMebk3DbgxJFWBur5lXhZyGqenCESmj/Pd3LLh80xUmbNJvcIiHAfc+AdnXx6N4QpNR6Ydg+1rygU4IEniUBuITRihkD0thj3s3l4+NbgM2D5XTK6HZiAA81cGSFLItQUAaNsx3zqholaK4jpaeNPTzw7RD5NkU5y5Jgc5AqJUz8jaVSqi+q5znkngWCfoaX8ulIULmbpUM7M4OYsaramud5mCyJVMeraNgA7fzohnPae7w3+ae7vRCopoSziIfl/PzJjh0lad84dzB9Ooqr+bLjx4d+c2l3zZydA60zWSoZ3whWgdpS1CGHxdTEoNGkIviKgOhwjCQrI6KzlDmKwftUARjj2kcH4BHhWFaVi5gtzFfGu8kwsQRYD0AQD+VkxxDi4gIEm87jYpzChiCgDatmJbshEmxBSbbj6br6/Np0/mvHtoUPZ3lrvJ0wiJLeqZbjUKSVgir/4wvKBxt8PQq8x7gcTYW1VtXH8ZyZ2yu4miEVhFZCQBInLl8v+2yxxjbYOWu1a+F7MbLaGnnmq9XR7jQqrVVipzSTuS7lwiRN4xdlQ8N4pmQvMUgqPp4Z2c2Y7sROq5DIn+1j3gMDAi4DvxGY4ypP2CwyEO+fOiG4sYk8TZSqxDXVla+MYYDXJOiafiaQ3WIJvXLoJuCF30ztQeCQAeR6x1bm2IiQYS83sDcgOwBFBt1ZhErbVWjKucgjR6/7cWe4FtwahJ7OHfytzNj9ZD2ixGNSsPJOeJy4OuifMgLRd53VxuUMfan9FVUAvmlcMtSd03EQxTqCj6/fKGT2aMvkuAhFQE8Gex+1DdTF2bUoJwG22dsjGYdYU8w84rEm+60KF7XRishx3HsDZa8T61tX8I4fMD5szkHIDfMQxCX2bRlEWHGGzU0QkNncQ+7PEInpzf4y26zC6KrEYvjGPLfkD0xrzC0ypEyLM0VxHgiYpcY9ZMehIaAP5GnFILoehBIqbrCXKcCaqqymghtGwZX16/kHzsF5dffvDi6o/d/KCvDp6n8Qrr0U9eN6orTNN1qIMs1S44bFBtyFvSLMGM06hm9wQNsmsnGYxXNxfssydb8cnQrGochci8aOvl4ff5oRBf0XKHQIUPs/fK3cgLpVf3jSNAuUyulu0F6mUehMYcc7yMQ6IqBQnlZNi7GkTZC1b18BorWmpt+ZqpyVMcIcFND7kELRTj1QepYAk1GWQlfUoOkiPsT0FI1L3oqytAfFb0f+bGBgC+VpzqGBAAmG/B1KZpvQbGWH4ZbbSQmeLOwJExDN+mUh9K/3/uK8/mjpu+HtgcW/hyJ/tzE9kEr8Vv3eWOvDTezS0iSQcJWrXg4+TrgycwJia5rdBgdTziT+MANEX1H6nNkBR6p13+PU2ErrXDwrZq0aD/goCCR6TE1iA9x8rMZpHu0FIuY033OXfWK9fbOErKOYTWaoCp1baQYR/eC+f8fBS2qYqQFXwhr0E5GpVW/8pDGlgMpm43jVKZdYuQjHHDeTUfOjv6uW4mKwBsHkZMdQlNQQGGq5Pk/QF97di2VitmT1HM3k9cnhpPhy/r/GbL9vH38/c2319abPMOeOJ8e9znI0icjALLzVjP0F2FkZSvutEWqX545YSt5fd8U5bQHvCG0lmZgy6GVw/beTio6qT4kJiZTWU6lh4u2sJ6jC8yvYm4rHKgVlqGhMj1tPkBLfjriC1o1ovMH10a/RBG+t5GqFRZnHJxWOzw4RhiIb7lO/V9N0JXkcv5YM7xGX1dedHXu+7S4QruPuM0t7m9j281dvQrf4w3DWw6HmZc+xSB4gLgEk9FA6qqyiSK2SiK+PDLF0N+jm93rIvZ/v/XxvYhD+Oy8SSbbZNLtToWX3V845+N1SOn86Y65HI3xOGWbhgvfCHf2+SnwdILvAOtOWr0atROtsBMcleloRUCZaJuBxc+1F+JLymE552rO1Cs23PpO9UceYSzNdCwDsylM3wzFNQyoIenSxsL+GQdDZGXTnLFgJ4SJntygl/1Zb2gaLvtZTGNBxssyowcD66L+z7xY1RE5cRy4feMmgQA3kU8j/lOQZBtdNNhZJuhASqGY/RjSBnLwDhz9/HSK8fsf8w/9ODrYbY/kLLedOFFdv7SpSyTu7OXQhV80EPSnJGei3BsSTJcbH9dLMrPWFILPHloWFvPq2ehZJmHDzAYZJbkXJjvIzb7Kz8HHau1aFrj0xRvKSzdlmKalQziBb/1pFhZIK9pmiiOVx4SARvu9PYlFj0uTfJLU0WNhvuU1RYlgjb6KNOiq8mLFgIs3gzN36yymQE7ES6oWkuj+ai5uMiRtGaHfXK+dTsBvmXc/CgfmgIOAAAAKAAA8AA="}
},{}],953:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Sound, {
  media: require('../../js/media'),
  config: require('../../js/config')
});

var utils = require('webrtc-core').utils;

function Sound(eventbus, debug) {
  var self = {};

  var soundOut;
  var soundOutDTMF;
  var audioRingtone;

  self.init = function() {
    soundOut = utils.createElement('<audio>', {volume: self.volumeClick});
    soundOutDTMF = utils.createElement('<audio>', {volume: self.volumeDTMF});
    audioRingtone = utils.createElement('<audio>', {volume: self.volumeRingtone});
  };

  self.listeners = function() {
    eventbus.on(["disconnected", "endCall", "ended", "resumed", "started", "failed"], function(e) {
      self.pause();
    });
    eventbus.on("progress", function(e) {
      self.playDtmfRingback();
    });
    eventbus.on('newDTMF', function(e) {
      var digit = e.data.tone;
      debug.log('DTMF sent : ' + digit);
      if (!digit) {
        return;
      }
      var file = null;
      if (digit === "*") {
        file = "star";
      } else if (digit === "#") {
        file = "pound";
      } else {
        file = digit;
      }
      self.playDtmfTone(file);
    });    
  };

  self.muteDTMF = function(mute) {
    soundOutDTMF[0].muted = mute;
  };

  self.pause = function() {
    soundOut.trigger('pause');
    soundOutDTMF.trigger('pause');
    audioRingtone.trigger('pause');
  };

  self.playDtmfRingback = function() {
    self.playDtmf("dtmf-ringback", {
      loop: true
    });
  };

  self.playRingtone = function() {
    self.playTone(audioRingtone, 'ringtone', {
      loop: true
    });
  };

  self.playDtmfTone = function(tone) {
    self.playDtmf("dtmf-" + tone);
  };

  self.playClick = function() {
    self.play("click");
  };

  self.play = function(media, options) {
    self.playTone(soundOut, media, options);
  };

  self.playTone = function(audioSource, media, options) {
    // avoid restarting same playing audio
    if (audioSource.attr("src") === media && !audioSource[0].paused) {
      return;
    }
    options = options || {};
    if(!self.medias[media]) {
      console.error(media + ' not found for sound in ', Object.keys(self.medias))
      return;
    }
    audioSource.attr("src", 'data:audio/ogg;base64,'+self.medias[media]);
    if (options.loop) {
      audioSource.attr('loop', 'true');
    } else {
      audioSource.removeAttr('loop');
    }
    audioSource.trigger('play');
  };

  self.playDtmf = function(media, options) {
    self.playTone(soundOutDTMF, media, options);
  };

  return self;
}

},{"../../js/config":951,"../../js/media":952,"webrtc-core":957}],954:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],955:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],956:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],957:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":956,"./bdsft":958,"./constants":961,"./cookieconfig":962,"./cookieprop":963,"./dateformat":966,"./debug":967,"./element":968,"./eventbus":969,"./factory":970,"./icon":971,"./loader":972,"./popup":973,"./prop":974,"./urlconfig":976,"./utils":977,"./visibleprop":978,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],958:[function(require,module,exports){
module.exports=require(54)
},{"./app":957,"./binding":959,"./classesbinding":960,"./databinder":965,"./stylesmanager":975,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1002}],959:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":958,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],960:[function(require,module,exports){
module.exports=require(56)
},{"./binding":959,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],961:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],962:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":958,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1002,"jquery.cookie":1001}],963:[function(require,module,exports){
module.exports=require(59)
},{"./constants":961,"./prop":974,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1002,"jquery.cookie":1001}],964:[function(require,module,exports){
module.exports=require(60)
},{"./constants":961,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":983}],965:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":986}],966:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],967:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":954,"./bdsft":958,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":979,"stacktrace-js":1004}],968:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],969:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":958,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":986}],970:[function(require,module,exports){
module.exports=require(66)
},{"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1002}],971:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],972:[function(require,module,exports){
module.exports=require(68)
},{"../":957,"./constants":961,"./factory":970,"./stylesmanager":975,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":982}],973:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1002}],974:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1003}],975:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":955,"./constants":961,"./css":964,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],976:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":954,"./bdsft":958,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],977:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":956,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1002}],978:[function(require,module,exports){
module.exports=require(74)
},{"./constants":961,"./prop":974,"./utils":977,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],979:[function(require,module,exports){
module.exports=require(75)
},{"./debug":980,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],980:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":981}],981:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],982:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],983:[function(require,module,exports){
module.exports=require(79)
},{"./filters":984,"./utils":985,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],984:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],985:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],986:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":987,"es5-ext/object/valid-callable":996}],987:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":988,"es5-ext/object/is-callable":991,"es5-ext/object/normalize-options":995,"es5-ext/string/#/contains":998}],988:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":989,"./shim":990,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],989:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],990:[function(require,module,exports){
module.exports=require(86)
},{"../keys":992,"../valid-value":997,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],991:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],992:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":993,"./shim":994,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],993:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],994:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],995:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],996:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],997:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],998:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":999,"./shim":1000,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],999:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1000:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1001:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1002}],1002:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1003:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1004:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1005:[function(require,module,exports){
module.exports = {view: require('./lib/views/stats'), model: require('./lib/models/stats'), constants: require('./lib/constants')};
},{"./lib/constants":1010,"./lib/models/stats":1011,"./lib/views/stats":1012}],1006:[function(require,module,exports){
module.exports = {
    enableCallStats: true
};
},{}],1007:[function(require,module,exports){
module.exports = Stats
  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


function Stats(callback) {
  var self = {};

  /**
   * SsrcInfoManager stores the ssrc stream info extracted from SDP.
   */
  var SsrcInfoManager = (function() {
    'use strict';

    /**
     * @constructor
     */
    function SsrcInfoManager() {
      /**
       * Map from ssrc id to an object containing all the stream properties.
       * @type {!Object.<string, !Object.<string>>}
       * @private
       */
      this.streamInfoContainer_ = {};

      /**
       * The string separating attibutes in an SDP.
       * @type {string}
       * @const
       * @private
       */
      this.ATTRIBUTE_SEPARATOR_ = /[\r,\n]/;

      /**
       * The regex separating fields within an ssrc description.
       * @type {RegExp}
       * @const
       * @private
       */
      this.FIELD_SEPARATOR_REGEX_ = / .*:/;

      /**
       * The prefix string of an ssrc description.
       * @type {string}
       * @const
       * @private
       */
      this.SSRC_ATTRIBUTE_PREFIX_ = 'a=ssrc:';

      /**
       * The className of the ssrc info parent element.
       * @type {string}
       * @const
       * @private
       */
      this.SSRC_INFO_BLOCK_CLASS_ = 'ssrc-info-block';
    }

    SsrcInfoManager.prototype = {
      /**
       * Extracts the stream information from |sdp| and saves it.
       * For example:
       *     a=ssrc:1234 msid:abcd
       *     a=ssrc:1234 label:hello
       *
       * @param {string} sdp The SDP string.
       */
      addSsrcStreamInfo: function(sdp) {
        var attributes = sdp.split(this.ATTRIBUTE_SEPARATOR_);
        for (var i = 0; i < attributes.length; ++i) {
          // Check if this is a ssrc attribute.
          if (attributes[i].indexOf(this.SSRC_ATTRIBUTE_PREFIX_) != 0)
            continue;

          var nextFieldIndex = attributes[i].search(this.FIELD_SEPARATOR_REGEX_);

          if (nextFieldIndex == -1)
            continue;

          var ssrc = attributes[i].substring(this.SSRC_ATTRIBUTE_PREFIX_.length,
            nextFieldIndex);
          if (!this.streamInfoContainer_[ssrc])
            this.streamInfoContainer_[ssrc] = {};

          // Make |rest| starting at the next field.
          var rest = attributes[i].substring(nextFieldIndex + 1);
          var name, value;
          while (rest.length > 0) {
            nextFieldIndex = rest.search(this.FIELD_SEPARATOR_REGEX_);
            if (nextFieldIndex == -1)
              nextFieldIndex = rest.length;

            // The field name is the string before the colon.
            name = rest.substring(0, rest.indexOf(':'));
            // The field value is from after the colon to the next field.
            value = rest.substring(rest.indexOf(':') + 1, nextFieldIndex);
            this.streamInfoContainer_[ssrc][name] = value;

            // Move |rest| to the start of the next field.
            rest = rest.substring(nextFieldIndex + 1);
          }
        }
      },

      /**
       * @param {string} sdp The ssrc id.
       * @return {!Object.<string>} The object containing the ssrc infomation.
       */
      getStreamInfo: function(ssrc) {
        return this.streamInfoContainer_[ssrc];
      },

      /**
       * Populate the ssrc information into |parentElement|, each field as a
       * DIV element.
       *
       * @param {!Element} parentElement The parent element for the ssrc info.
       * @param {string} ssrc The ssrc id.
       */
      populateSsrcInfo: function(parentElement, ssrc) {
        if (!this.streamInfoContainer_[ssrc])
          return;

        parentElement.className = this.SSRC_INFO_BLOCK_CLASS_;

        var fieldElement;
        for (var property in this.streamInfoContainer_[ssrc]) {
          fieldElement = document.createElement('div');
          parentElement.appendChild(fieldElement);
          fieldElement.textContent =
            property + ':' + this.streamInfoContainer_[ssrc][property];
        }
      }
    };

    return SsrcInfoManager;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  //
  // This file contains helper methods to draw the stats timeline graphs.
  // Each graph represents a series of stats report for a PeerConnection,
  // e.g. 1234-0-ssrc-abcd123-bytesSent is the graph for the series of bytesSent
  // for ssrc-abcd123 of PeerConnection 0 in process 1234.
  // The graphs are drawn as CANVAS, grouped per report type per PeerConnection.
  // Each group has an expand/collapse button and is collapsed initially.
  //

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  /**
   * A TimelineDataSeries collects an ordered series of (time, value) pairs,
   * and converts them to graph points.  It also keeps track of its color and
   * current visibility state.
   */
  var TimelineDataSeries = (function() {
    'use strict';

    /**
     * @constructor
     */
    function TimelineDataSeries() {
      // List of DataPoints in chronological order.
      this.dataPoints_ = [];

      // Default color.  Should always be overridden prior to display.
      this.color_ = 'red';
      // Whether or not the data series should be drawn.
      this.isVisible_ = true;

      this.cacheStartTime_ = null;
      this.cacheStepSize_ = 0;
      this.cacheValues_ = [];
    }

    TimelineDataSeries.prototype = {
      /**
       * Adds a DataPoint to |this| with the specified time and value.
       * DataPoints are assumed to be received in chronological order.
       */
      addPoint: function(timeTicks, value) {
        var time = new Date(timeTicks);
        this.dataPoints_.push(new DataPoint(time, value));
      },

      isVisible: function() {
        return this.isVisible_;
      },

      show: function(isVisible) {
        this.isVisible_ = isVisible;
      },

      getColor: function() {
        return this.color_;
      },

      setColor: function(color) {
        this.color_ = color;
      },

      getAvg: function() {
        var sum = 0;
        for (var i = 0; i < this.dataPoints_.length; i++) {
          sum += this.dataPoints_[i].value;
        }
        return sum / this.dataPoints_.length;
      },
      /**
       * Returns a list containing the values of the data series at |count|
       * points, starting at |startTime|, and |stepSize| milliseconds apart.
       * Caches values, so showing/hiding individual data series is fast.
       */
      getValues: function(startTime, stepSize, count) {
        // Use cached values, if we can.
        if (this.cacheStartTime_ == startTime &&
          this.cacheStepSize_ == stepSize &&
          this.cacheValues_.length == count) {
          return this.cacheValues_;
        }

        // Do all the work.
        this.cacheValues_ = this.getValuesInternal_(startTime, stepSize, count);
        this.cacheStartTime_ = startTime;
        this.cacheStepSize_ = stepSize;

        return this.cacheValues_;
      },

      /**
       * Returns the cached |values| in the specified time period.
       */
      getValuesInternal_: function(startTime, stepSize, count) {
        var values = [];
        var nextPoint = 0;
        var currentValue = 0;
        var time = startTime;
        for (var i = 0; i < count; ++i) {
          while (nextPoint < this.dataPoints_.length &&
            this.dataPoints_[nextPoint].time < time) {
            currentValue = this.dataPoints_[nextPoint].value;
            ++nextPoint;
          }
          values[i] = currentValue;
          time += stepSize;
        }
        return values;
      }
    };

    /**
     * A single point in a data series.  Each point has a time, in the form of
     * milliseconds since the Unix epoch, and a numeric value.
     * @constructor
     */
    function DataPoint(time, value) {
      this.time = time;
      this.value = value;
    }

    return TimelineDataSeries;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  /**
   * A TimelineGraphView displays a timeline graph on a canvas element.
   */
  var TimelineGraphView = (function() {
    'use strict';

    // Default starting scale factor, in terms of milliseconds per pixel.
    var DEFAULT_SCALE = 2000;

    // Maximum number of labels placed vertically along the sides of the graph.
    var MAX_VERTICAL_LABELS = 6;

    // Vertical spacing between labels and between the graph and labels.
    var LABEL_VERTICAL_SPACING = 4;
    // Horizontal spacing between vertically placed labels and the edges of the
    // graph.
    var LABEL_HORIZONTAL_SPACING = 3;
    // Horizintal spacing between two horitonally placed labels along the bottom
    // of the graph.
    var LABEL_LABEL_HORIZONTAL_SPACING = 25;

    // Length of ticks, in pixels, next to y-axis labels.  The x-axis only has
    // one set of labels, so it can use lines instead.
    var Y_AXIS_TICK_LENGTH = 10;

    var GRID_COLOR = '#CCC';
    var TEXT_COLOR = '#000';
    var BACKGROUND_COLOR = '#FFF';

    /**
     * @constructor
     */
    function TimelineGraphView(divId, canvasId) {
      this.scrollbar_ = {
        position_: 0,
        range_: 0
      };

      this.graphDiv_ = $('[id="' + divId + '"]')[0];
      this.canvas_ = $('[id="' + canvasId + '"]')[0];

      // Set the range and scale of the graph.  Times are in milliseconds since
      // the Unix epoch.

      // All measurements we have must be after this time.
      this.startTime_ = 0;
      // The current rightmost position of the graph is always at most this.
      this.endTime_ = 1;

      this.graph_ = null;

      // Initialize the scrollbar.
      this.updateScrollbarRange_(true);
    }

    TimelineGraphView.prototype = {
      // Returns the total length of the graph, in pixels.
      getLength_: function() {
        var timeRange = this.endTime_ - this.startTime_;
        // Math.floor is used to ignore the last partial area, of length less
        // than DEFAULT_SCALE.
        return Math.floor(timeRange / DEFAULT_SCALE);
      },

      /**
       * Returns true if the graph is scrolled all the way to the right.
       */
      graphScrolledToRightEdge_: function() {
        return this.scrollbar_.position_ == this.scrollbar_.range_;
      },

      /**
       * Update the range of the scrollbar.  If |resetPosition| is true, also
       * sets the slider to point at the rightmost position and triggers a
       * repaint.
       */
      updateScrollbarRange_: function(resetPosition) {
        var scrollbarRange = this.getLength_() - this.canvas_ && this.canvas_.width || 0;
        if (scrollbarRange < 0)
          scrollbarRange = 0;

        // If we've decreased the range to less than the current scroll position,
        // we need to move the scroll position.
        if (this.scrollbar_.position_ > scrollbarRange)
          resetPosition = true;

        this.scrollbar_.range_ = scrollbarRange;
        if (resetPosition) {
          this.scrollbar_.position_ = scrollbarRange;
          this.repaint();
        }
      },

      /**
       * Sets the date range displayed on the graph, switches to the default
       * scale factor, and moves the scrollbar all the way to the right.
       */
      setDateRange: function(startDate, endDate) {
        this.startTime_ = startDate.getTime();
        this.endTime_ = endDate.getTime();

        // Safety check.
        if (this.endTime_ <= this.startTime_)
          this.startTime_ = this.endTime_ - 1;

        this.updateScrollbarRange_(true);
      },

      /**
       * Updates the end time at the right of the graph to be the current time.
       * Specifically, updates the scrollbar's range, and if the scrollbar is
       * all the way to the right, keeps it all the way to the right.  Otherwise,
       * leaves the view as-is and doesn't redraw anything.
       */
      updateEndDate: function() {
        this.endTime_ = (new Date()).getTime();
        this.updateScrollbarRange_(this.graphScrolledToRightEdge_());
      },

      getStartDate: function() {
        return new Date(this.startTime_);
      },

      /**
       * Replaces the current TimelineDataSeries with |dataSeries|.
       */
      setDataSeries: function(dataSeries) {
        // Simply recreates the Graph.
        this.graph_ = new Graph();
        for (var i = 0; i < dataSeries.length; ++i)
          this.graph_.addDataSeries(dataSeries[i]);
        this.repaint();
      },

      /**
       * Adds |dataSeries| to the current graph.
       */
      addDataSeries: function(dataSeries) {
        if (!this.graph_)
          this.graph_ = new Graph();
        this.graph_.addDataSeries(dataSeries);
        this.repaint();
      },

      /**
       * Draws the graph on |canvas_|.
       */
      repaint: function() {
        if(!this.canvas_) {
          return;
        }
        this.repaintTimerRunning_ = false;

        var width = this.canvas_.width;
        var height = this.canvas_.height;
        var context = this.canvas_.getContext('2d');

        // Clear the canvas.
        context.fillStyle = BACKGROUND_COLOR;
        context.fillRect(0, 0, width, height);

        // Try to get font height in pixels.  Needed for layout.
        var fontHeightString = context.font.match(/([0-9]+)px/)[1];
        var fontHeight = parseInt(fontHeightString);

        // Safety check, to avoid drawing anything too ugly.
        if (fontHeightString.length == 0 || fontHeight <= 0 ||
          fontHeight * 4 > height || width < 50) {
          return;
        }

        // Save current transformation matrix so we can restore it later.
        context.save();

        // The center of an HTML canvas pixel is technically at (0.5, 0.5).  This
        // makes near straight lines look bad, due to anti-aliasing.  This
        // translation reduces the problem a little.
        context.translate(0.5, 0.5);

        // Figure out what time values to display.
        var position = this.scrollbar_.position_;
        // If the entire time range is being displayed, align the right edge of
        // the graph to the end of the time range.
        if (this.scrollbar_.range_ == 0)
          position = this.getLength_() - this.canvas_.width;
        var visibleStartTime = this.startTime_ + position * DEFAULT_SCALE;

        // Make space at the bottom of the graph for the time labels, and then
        // draw the labels.
        var textHeight = height;
        height -= fontHeight + LABEL_VERTICAL_SPACING;
        this.drawTimeLabels(context, width, height, textHeight, visibleStartTime);

        // Draw outline of the main graph area.
        context.strokeStyle = GRID_COLOR;
        context.strokeRect(0, 0, width - 1, height - 1);

        if (this.graph_) {
          // Layout graph and have them draw their tick marks.
          this.graph_.layout(
            width, height, fontHeight, visibleStartTime, DEFAULT_SCALE);
          this.graph_.drawTicks(context);

          // Draw the lines of all graphs, and then draw their labels.
          this.graph_.drawLines(context);
          this.graph_.drawLabels(context);
        }

        // Restore original transformation matrix.
        context.restore();
      },

      /**
       * Draw time labels below the graph.  Takes in start time as an argument
       * since it may not be |startTime_|, when we're displaying the entire
       * time range.
       */
      drawTimeLabels: function(context, width, height, textHeight, startTime) {
        // Text for a time string to use in determining how far apart
        // to place text labels.
        var sampleText = (new Date(startTime)).toLocaleTimeString();

        // The desired spacing for text labels.
        var targetSpacing = context.measureText(sampleText).width +
          LABEL_LABEL_HORIZONTAL_SPACING;

        // The allowed time step values between adjacent labels.  Anything much
        // over a couple minutes isn't terribly realistic, given how much memory
        // we use, and how slow a lot of the net-internals code is.
        var timeStepValues = [
          1000, // 1 second
          1000 * 5,
          1000 * 30,
          1000 * 60, // 1 minute
          1000 * 60 * 5,
          1000 * 60 * 30,
          1000 * 60 * 60, // 1 hour
          1000 * 60 * 60 * 5
        ];

        // Find smallest time step value that gives us at least |targetSpacing|,
        // if any.
        var timeStep = null;
        for (var i = 0; i < timeStepValues.length; ++i) {
          if (timeStepValues[i] / DEFAULT_SCALE >= targetSpacing) {
            timeStep = timeStepValues[i];
            break;
          }
        }

        // If no such value, give up.
        if (!timeStep)
          return;

        // Find the time for the first label.  This time is a perfect multiple of
        // timeStep because of how UTC times work.
        var time = Math.ceil(startTime / timeStep) * timeStep;

        context.textBaseline = 'bottom';
        context.textAlign = 'center';
        context.fillStyle = TEXT_COLOR;
        context.strokeStyle = GRID_COLOR;

        // Draw labels and vertical grid lines.
        while (true) {
          var x = Math.round((time - startTime) / DEFAULT_SCALE);
          if (x >= width)
            break;
          var text = (new Date(time)).toLocaleTimeString();
          context.fillText(text, x, textHeight);
          context.beginPath();
          context.lineTo(x, 0);
          context.lineTo(x, height);
          context.stroke();
          time += timeStep;
        }
      },

      getDataSeriesCount: function() {
        if (this.graph_)
          return this.graph_.dataSeries_.length;
        return 0;
      },

      hasDataSeries: function(dataSeries) {
        if (this.graph_)
          return this.graph_.hasDataSeries(dataSeries);
        return false;
      },

    };

    /**
     * A Graph is responsible for drawing all the TimelineDataSeries that have
     * the same data type.  Graphs are responsible for scaling the values, laying
     * out labels, and drawing both labels and lines for its data series.
     */
    var Graph = (function() {
      /**
       * @constructor
       */
      function Graph() {
        this.dataSeries_ = [];

        // Cached properties of the graph, set in layout.
        this.width_ = 0;
        this.height_ = 0;
        this.fontHeight_ = 0;
        this.startTime_ = 0;
        this.scale_ = 0;

        // At least the highest value in the displayed range of the graph.
        // Used for scaling and setting labels.  Set in layoutLabels.
        this.max_ = 0;

        // Cached text of equally spaced labels.  Set in layoutLabels.
        this.labels_ = [];
      }

      /**
       * A Label is the label at a particular position along the y-axis.
       * @constructor
       */
      function Label(height, text) {
        this.height = height;
        this.text = text;
      }

      Graph.prototype = {
        addDataSeries: function(dataSeries) {
          this.dataSeries_.push(dataSeries);
        },

        hasDataSeries: function(dataSeries) {
          for (var i = 0; i < this.dataSeries_.length; ++i) {
            if (this.dataSeries_[i] == dataSeries)
              return true;
          }
          return false;
        },

        /**
         * Returns a list of all the values that should be displayed for a given
         * data series, using the current graph layout.
         */
        getValues: function(dataSeries) {
          if (!dataSeries.isVisible())
            return null;
          return dataSeries.getValues(this.startTime_, this.scale_, this.width_);
        },

        /**
         * Updates the graph's layout.  In particular, both the max value and
         * label positions are updated.  Must be called before calling any of the
         * drawing functions.
         */
        layout: function(width, height, fontHeight, startTime, scale) {
          this.width_ = width;
          this.height_ = height;
          this.fontHeight_ = fontHeight;
          this.startTime_ = startTime;
          this.scale_ = scale;

          // Find largest value.
          var max = 0;
          for (var i = 0; i < this.dataSeries_.length; ++i) {
            var values = this.getValues(this.dataSeries_[i]);
            if (!values)
              continue;
            for (var j = 0; j < values.length; ++j) {
              if (values[j] > max)
                max = values[j];
            }
          }

          this.layoutLabels_(max);
        },

        /**
         * Lays out labels and sets |max_|, taking the time units into
         * consideration.  |maxValue| is the actual maximum value, and
         * |max_| will be set to the value of the largest label, which
         * will be at least |maxValue|.
         */
        layoutLabels_: function(maxValue) {
          if (maxValue < 1024) {
            this.layoutLabelsBasic_(maxValue, 0);
            return;
          }

          // Find appropriate units to use.
          var units = ['', 'm', 'M', 'G', 'T', 'P'];
          // Units to use for labels.  0 is '1', 1 is K, etc.
          // We start with 1, and work our way up.
          var unit = 1;
          maxValue /= 1024;
          while (units[unit + 1] && maxValue >= 1024) {
            maxValue /= 1024;
            ++unit;
          }

          // Calculate labels.
          this.layoutLabelsBasic_(maxValue, 1);

          // Append units to labels.
          for (var i = 0; i < this.labels_.length; ++i)
            this.labels_[i] += ' ' + units[unit];

          // Convert |max_| back to unit '1'.
          this.max_ *= Math.pow(1024, unit);
        },

        /**
         * Same as layoutLabels_, but ignores units.  |maxDecimalDigits| is the
         * maximum number of decimal digits allowed.  The minimum allowed
         * difference between two adjacent labels is 10^-|maxDecimalDigits|.
         */
        layoutLabelsBasic_: function(maxValue, maxDecimalDigits) {
          this.labels_ = [];
          // No labels if |maxValue| is 0.
          if (maxValue == 0) {
            this.max_ = maxValue;
            return;
          }

          // The maximum number of equally spaced labels allowed.  |fontHeight_|
          // is doubled because the top two labels are both drawn in the same
          // gap.
          var minLabelSpacing = 2 * this.fontHeight_ + LABEL_VERTICAL_SPACING;

          // The + 1 is for the top label.
          var maxLabels = 1 + this.height_ / minLabelSpacing;
          if (maxLabels < 2) {
            maxLabels = 2;
          } else if (maxLabels > MAX_VERTICAL_LABELS) {
            maxLabels = MAX_VERTICAL_LABELS;
          }

          // Initial try for step size between conecutive labels.
          var stepSize = Math.pow(10, -maxDecimalDigits);
          // Number of digits to the right of the decimal of |stepSize|.
          // Used for formating label strings.
          var stepSizeDecimalDigits = maxDecimalDigits;

          // Pick a reasonable step size.
          while (true) {
            // If we use a step size of |stepSize| between labels, we'll need:
            //
            // Math.ceil(maxValue / stepSize) + 1
            //
            // labels.  The + 1 is because we need labels at both at 0 and at
            // the top of the graph.

            // Check if we can use steps of size |stepSize|.
            if (Math.ceil(maxValue / stepSize) + 1 <= maxLabels)
              break;
            // Check |stepSize| * 2.
            if (Math.ceil(maxValue / (stepSize * 2)) + 1 <= maxLabels) {
              stepSize *= 2;
              break;
            }
            // Check |stepSize| * 5.
            if (Math.ceil(maxValue / (stepSize * 5)) + 1 <= maxLabels) {
              stepSize *= 5;
              break;
            }
            stepSize *= 10;
            if (stepSizeDecimalDigits > 0)
              --stepSizeDecimalDigits;
          }

          // Set the max so it's an exact multiple of the chosen step size.
          this.max_ = Math.ceil(maxValue / stepSize) * stepSize;

          // Create labels.
          for (var label = this.max_; label >= 0; label -= stepSize)
            this.labels_.push(label.toFixed(stepSizeDecimalDigits));
        },

        /**
         * Draws tick marks for each of the labels in |labels_|.
         */
        drawTicks: function(context) {
          var x1;
          var x2;
          x1 = this.width_ - 1;
          x2 = this.width_ - 1 - Y_AXIS_TICK_LENGTH;

          context.fillStyle = GRID_COLOR;
          context.beginPath();
          for (var i = 1; i < this.labels_.length - 1; ++i) {
            // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
            // lines.
            var y = Math.round(this.height_ * i / (this.labels_.length - 1));
            context.moveTo(x1, y);
            context.lineTo(x2, y);
          }
          context.stroke();
        },

        /**
         * Draws a graph line for each of the data series.
         */
        drawLines: function(context) {
          // Factor by which to scale all values to convert them to a number from
          // 0 to height - 1.
          var scale = 0;
          var bottom = this.height_ - 1;
          if (this.max_)
            scale = bottom / this.max_;

          // Draw in reverse order, so earlier data series are drawn on top of
          // subsequent ones.
          for (var i = this.dataSeries_.length - 1; i >= 0; --i) {
            var values = this.getValues(this.dataSeries_[i]);
            if (!values)
              continue;
            context.strokeStyle = this.dataSeries_[i].getColor();
            context.beginPath();
            for (var x = 0; x < values.length; ++x) {
              // The rounding is needed to avoid ugly 2-pixel wide anti-aliased
              // horizontal lines.
              context.lineTo(x, bottom - Math.round(values[x] * scale));
            }
            context.stroke();
          }
        },

        /**
         * Draw labels in |labels_|.
         */
        drawLabels: function(context) {
          if (this.labels_.length == 0)
            return;
          var x = this.width_ - LABEL_HORIZONTAL_SPACING;

          // Set up the context.
          context.fillStyle = TEXT_COLOR;
          context.textAlign = 'right';

          // Draw top label, which is the only one that appears below its tick
          // mark.
          context.textBaseline = 'top';
          context.fillText(this.labels_[0], x, 0);

          // Draw all the other labels.
          context.textBaseline = 'bottom';
          var step = (this.height_ - 1) / (this.labels_.length - 1);
          for (var i = 1; i < this.labels_.length; ++i)
            context.fillText(this.labels_[i], x, step * i);
        }
      };

      return Graph;
    })();

    return TimelineGraphView;
  })();

  /**
   * Maintains the stats table.
   * @param {SsrcInfoManager} ssrcInfoManager The source of the ssrc info.
   */
  var StatsTable = (function(ssrcInfoManager) {
    'use strict';

    /**
     * @param {SsrcInfoManager} ssrcInfoManager The source of the ssrc info.
     * @constructor
     */
    function StatsTable(ssrcInfoManager) {
      /**
       * @type {SsrcInfoManager}
       * @private
       */
      this.ssrcInfoManager_ = ssrcInfoManager;
    }

    StatsTable.prototype = {
      /**
       * Adds |report| to the stats table of |peerConnectionElement|.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!Object} report The object containing stats, which is the object
       *     containing timestamp and values, which is an array of strings, whose
       *     even index entry is the name of the stat, and the odd index entry is
       *     the value.
       */
      addStatsReport: function(peerConnectionElement, reportType, reportId, report) {
        var statsTable = this.ensureStatsTable_(peerConnectionElement, report);

        if (report.stats) {
          this.addStatsToTable_(peerConnectionElement, reportType, reportId, statsTable,
            report.stats.timestamp, report.stats.values);
        }
      },

      /**
       * Ensure the DIV container for the stats tables is created as a child of
       * |peerConnectionElement|.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @return {!Element} The stats table container.
       * @private
       */
      ensureStatsTableContainer_: function(peerConnectionElement) {
        var containerId = peerConnectionElement.id + '-table-container';
        var container = $('[id="' + containerId + '"]')[0];
        if (!container) {
          container = document.createElement('div');
          container.id = containerId;
          container.className = 'stats-table-container';
          peerConnectionElement.appendChild(container);
        }
        return container;
      },

      /**
       * Ensure the stats table for track specified by |report| of PeerConnection
       * |peerConnectionElement| is created.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!Object} report The object containing stats, which is the object
       *     containing timestamp and values, which is an array of strings, whose
       *     even index entry is the name of the stat, and the odd index entry is
       *     the value.
       * @return {!Element} The stats table element.
       * @private
       */
      ensureStatsTable_: function(peerConnectionElement, report) {
        var tableId = peerConnectionElement.id + '-table-' + report.type + '-' + report.id;
        var table = $(document.getElementById(tableId))[0];
        if (!table) {
          var container = this.ensureStatsTableContainer_(peerConnectionElement);
          table = document.createElement('table');
          container.appendChild(table);
          table.id = tableId;
          table.border = 1;

          table.innerHTML = '<tr><th colspan=2></th></tr>';
          table.rows[0].cells[0].textContent =
            'Statistics ' + report.type + '-' + report.id;
          if (report.type == 'ssrc') {
            table.insertRow(1);
            table.rows[1].innerHTML = '<td colspan=2></td>';
            this.ssrcInfoManager_.populateSsrcInfo(
              table.rows[1].cells[0], report.id);
          }
        }
        return table;
      },

      /**
       * Update |statsTable| with |time| and |statsData|.
       *
       * @param {!Element} statsTable Which table to update.
       * @param {number} time The number of miliseconds since epoch.
       * @param {Array.<string>} statsData An array of stats name and value pairs.
       * @private
       */
      addStatsToTable_: function(peerConnectionElement, reportType, reportId, statsTable, time, statsData) {
        var date = Date(time);

        callback.onAddStats(peerConnectionElement, reportType, reportId, statsData);
      },

      /**
       * Update the value column of the stats row of |rowName| to |value|.
       * A new row is created is this is the first report of this stats.
       *
       * @param {!Element} statsTable Which table to update.
       * @param {string} rowName The name of the row to update.
       * @param {string} value The new value to set.
       * @private
       */
      updateStatsTableRow_: function(statsTable, rowName, value) {
        var trId = statsTable.id + '-' + rowName;
        var trElement = $('[id="' + trId + '"]')[0];
        if (!trElement) {
          trElement = document.createElement('tr');
          trElement.id = trId;
          statsTable.firstChild.appendChild(trElement);
          trElement.innerHTML = '<td>' + rowName + '</td><td></td>';
        }
        trElement.cells[1].textContent = value;
      }
    };

    return StatsTable;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


  /**
   * The data of a peer connection update.
   * @param {number} pid The id of the renderer.
   * @param {number} lid The id of the peer conneciton inside a renderer.
   * @param {string} type The type of the update.
   * @param {string} value The details of the update.
   * @constructor
   */
  var PeerConnectionUpdateEntry = function(pid, lid, type, value) {
    /**
     * @type {number}
     */
    this.pid = pid;

    /**
     * @type {number}
     */
    this.lid = lid;

    /**
     * @type {string}
     */
    this.type = type;

    /**
     * @type {string}
     */
    this.value = value;
  };


  /**
   * Maintains the peer connection update log table.
   */
  var PeerConnectionUpdateTable = (function() {
    'use strict';

    /**
     * @constructor
     */
    function PeerConnectionUpdateTable() {
      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_ID_SUFFIX_ = '-update-log';

      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_CONTAINER_CLASS_ = 'update-log-container';

      /**
       * @type {string}
       * @const
       * @private
       */
      this.UPDATE_LOG_TABLE_CLASS_ = 'update-log-table';
    }

    PeerConnectionUpdateTable.prototype = {
      /**
       * Adds the update to the update table as a new row. The type of the update
       * is set to the summary of the cell; clicking the cell will reveal or hide
       * the details as the content of a TextArea element.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @param {!PeerConnectionUpdateEntry} update The update to add.
       */
      addPeerConnectionUpdate: function(peerConnectionElement, update) {
        var tableElement = this.ensureUpdateContainer_(peerConnectionElement);

        var row = document.createElement('tr');
        tableElement.firstChild.appendChild(row);

        row.innerHTML = '<td>' + (new Date()).toLocaleString() + '</td>';

        if (update.value.length == 0) {
          row.innerHTML += '<td>' + update.type + '</td>';
          return;
        }

        row.innerHTML += '<td><details><summary>' + update.type +
          '</summary></details></td>';

        var valueContainer = document.createElement('pre');
        var details = row.cells[1].childNodes[0];
        details.appendChild(valueContainer);
        valueContainer.textContent = update.value;
      },

      /**
       * Makes sure the update log table of the peer connection is created.
       *
       * @param {!Element} peerConnectionElement The root element.
       * @return {!Element} The log table element.
       * @private
       */
      ensureUpdateContainer_: function(peerConnectionElement) {
        var tableId = peerConnectionElement.id + this.UPDATE_LOG_ID_SUFFIX_;
        var tableElement = $('[id="' + tableId + '"]')[0];
        if (!tableElement) {
          var tableContainer = document.createElement('div');
          tableContainer.className = this.UPDATE_LOG_CONTAINER_CLASS_;
          peerConnectionElement.appendChild(tableContainer);

          tableElement = document.createElement('table');
          tableElement.className = this.UPDATE_LOG_TABLE_CLASS_;
          tableElement.id = tableId;
          tableElement.border = 1;
          tableContainer.appendChild(tableElement);
          tableElement.innerHTML = '<tr><th>Time</th>' +
            '<th class="update-log-header-event">Event</th></tr>';
        }
        return tableElement;
      }
    };

    return PeerConnectionUpdateTable;
  })();

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.


  /**
   * Provides the UI to start and stop RTP recording, forwards the start/stop
   * commands to Chrome, and updates the UI based on dump updates.
   *
   * @param {Element} containerElement The parent element of the dump creation UI.
   */
  var DumpCreator = (function() {
    /**
     * @param {Element} containerElement The parent element of the dump creation
     *     UI.
     * @constructor
     */
    function DumpCreator(containerElement) {
      /**
       * True if the RTP packets are being recorded.
       * @type {bool}
       * @private
       */
      this.recording_ = false;

      /**
       * @type {!Object.<string>}
       * @private
       * @const
       */
      this.StatusStrings_ = {
          NOT_STARTED: 'not started.',
          RECORDING: 'recording...',
        },

        /**
         * The status of dump creation.
         * @type {string}
         * @private
         */
        this.status_ = this.StatusStrings_.NOT_STARTED;

      /**
       * The root element of the dump creation UI.
       * @type {Element}
       * @private
       */
      this.root_ = document.createElement('details');

      this.root_.className = 'peer-connection-dump-root';
      containerElement.appendChild(this.root_);
      var summary = document.createElement('summary');
      this.root_.appendChild(summary);
      summary.textContent = 'Create Dump';
      var content = document.createElement('pre');
      this.root_.appendChild(content);
      content.innerHTML = '<button></button> Status: <span></span>';
      content.getElementsByTagName('button')[0].addEventListener(
        'click', this.onToggled_.bind(this));

      this.updateDisplay_();
    }

    DumpCreator.prototype = {
      /**
       * Handles the event of toggling the dump recording state.
       *
       * @private
       */
      onToggled_: function() {
        if (this.recording_) {
          this.recording_ = false;
          this.status_ = this.StatusStrings_.NOT_STARTED;
          chrome.send('stopRtpRecording');
        } else {
          this.recording_ = true;
          this.status_ = this.StatusStrings_.RECORDING;
          chrome.send('startRtpRecording');
        }
        this.updateDisplay_();
      },

      /**
       * Updates the UI based on the recording status.
       *
       * @private
       */
      updateDisplay_: function() {
        if (this.recording_) {
          this.root_.getElementsByTagName('button')[0].textContent =
            'Stop Recording RTP Packets';
        } else {
          this.root_.getElementsByTagName('button')[0].textContent =
            'Start Recording RTP Packets';
        }

        this.root_.getElementsByTagName('span')[0].textContent = this.status_;
      },

      /**
       * Set the status to the content of the update.
       * @param {!Object} update
       */
      onUpdate: function(update) {
        if (this.recording_) {
          this.status_ = JSON.stringify(update);
          this.updateDisplay_();
        }
      },
    };
    return DumpCreator;
  })();

  var peerConnectionsListElem = null;
  var dumpCreator = null;
  var ssrcInfoManager = new SsrcInfoManager();
  var peerConnectionUpdateTable = new PeerConnectionUpdateTable();
  var statsTable = new StatsTable(ssrcInfoManager);

  var STATS_GRAPH_CONTAINER_HEADING_CLASS = 'stats-graph-container-heading';

  // Specifies which stats should be drawn on the 'bweCompound' graph and how.
  var bweCompoundGraphConfig = {
    googAvailableSendBandwidth: {
      color: 'red'
    },
    googTargetEncBitrateCorrected: {
      color: 'purple'
    },
    googActualEncBitrate: {
      color: 'orange'
    },
    googRetransmitBitrate: {
      color: 'blue'
    },
    googTransmitBitrate: {
      color: 'green'
    },
  };

  // Converts the last entry of |srcDataSeries| from the total amount to the
  // amount per second.
  var totalToPerSecond = function(srcDataSeries) {
    var length = srcDataSeries.dataPoints_.length;
    if (length >= 2) {
      var lastDataPoint = srcDataSeries.dataPoints_[length - 1];
      var secondLastDataPoint = srcDataSeries.dataPoints_[length - 2];
      return Math.round((lastDataPoint.value - secondLastDataPoint.value) * 1000 /
        (lastDataPoint.time - secondLastDataPoint.time));
    }

    return 0;
  };

  // Converts the value of total bytes to bits per second.
  var totalBytesToBitsPerSecond = function(srcDataSeries) {
    return totalToPerSecond(srcDataSeries) * 8;
  };

  // Converts the value of total bytes to kilo bits per second.
  var totalKiloBytesToBitsPerSecond = function(srcDataSeries) {
    return totalBytesToBitsPerSecond(srcDataSeries) / 1000;
  };

  var packetsLostPercentage = function(srcDataSeries, peerConnectionElement, reportType, reportId) {
    var packetsLost = self.getLastValue(peerConnectionElement, reportType, reportId, "packetsLost");
    var packetsReceived = self.getLastValue(peerConnectionElement, reportType, reportId, "packetsReceived");
    if (packetsLost != null && packetsReceived != null) {
      return Math.round((packetsLost * 100 / (packetsReceived + packetsLost)) * 100) / 100;
    } else {
      return null;
    }

  };

  // Converts the value of total bytes to bits per second.
  self.getLastValue = function getLastValue(peerConnectionElement, reportType, reportId, label) {
    return getLastValueAt(peerConnectionElement, reportType, reportId, label, 1);
  }

  function getLastValueAt(peerConnectionElement, reportType, reportId, label, index) {
    var srcDataSeries = getDataSeries(peerConnectionElement.id, reportType, reportId, label);
    if (srcDataSeries) {
      return srcDataSeries.dataPoints_[srcDataSeries.dataPoints_.length - index].value;
    }
    return null;
  }

  self.getAvgValue = function getAvgValue(peerConnectionElement, reportType, reportId, label) {
    var srcDataSeries = getDataSeries(peerConnectionElement.id, reportType, reportId, label);
    return srcDataSeries ? srcDataSeries.getAvg() : null;
  }

  function getDataSeries(peerConnectionId, reportType, reportId, label) {
    var dataSeriesId = self.dataSeriesId(peerConnectionId, reportType, reportId, label);
    return dataSeries[dataSeriesId];
  }

  function getDataSeriesByLabel(peerConnectionId, type, label) {
    var keys = Object.keys(dataSeries);
    var results = [];
    var regex = new RegExp(peerConnectionId + ".*" + type + ".*" + label);
    for (i = 0; i < keys.length; i++) {
      var key = keys[i];
      if (regex.test(key)) {
        var obj = {};
        results.push(dataSeries[key]);
      }
    }
    return results;
  }

  function getValueBefore(peerConnectionElement, reportType, reportId, label, timestamp) {
    var dataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, label);
    var srcDataSeries = dataSeries[dataSeriesId];
    if (srcDataSeries) {
      for (i = srcDataSeries.dataPoints_.length - 1; i >= 0; i--) {
        if (srcDataSeries.dataPoints_[i].time < timestamp) {
          return srcDataSeries.dataPoints_[i].value;
        }
      }
      return srcDataSeries.dataPoints_[0].value;
    }
    return null;
  }


  self.dataSeriesId = function dataSeriesId(peerConnectionId, reportType, reportId, label) {
    return peerConnectionId + '-' + reportType + '-' + reportId + '-' + label;
  }

  self.graphViewId = function graphViewId(peerConnectionElement, reportType, reportId, graphType) {
    return peerConnectionElement.id + '-' + reportType + '-' + reportId + '-' + graphType;
  }

  self.matchesType = function matchesType(label, type, statsData) {
    if (type == "video" && isVideoStats(statsData)) {
      return true;
    } else if (type == "audio" && isAudioStats(statsData)) {
      if (label == "googJitterReceived" && !containsLabel(statsData, "audioOutputLevel")) {
        return false;
      }
      return true;
    }
    return false;
  }

  function isVideoStats(statsData) {
    return containsLabel(statsData, "googFrameHeightSent") || containsLabel(statsData, "googFrameHeightReceived");
  }

  function isAudioStats(statsData) {
    return containsLabel(statsData, "audioInputLevel") || containsLabel(statsData, "audioOutputLevel");
  }

  function getStatsDataType(label, statsData) {
    if (isVideoStats(statsData)) {
      return "video";
    } else if (isAudioStats(statsData)) {
      if (label == "googJitterReceived" && !containsLabel(statsData, "audioOutputLevel")) {
        return null;
      }
      return "audio";
    }
    return null;
  }

  function containsLabel(statsData, label) {
    for (var i = 0; i < statsData.length - 1; i = i + 2) {
      if (statsData[i] == label) {
        return true;
      }
    }
    return false;
  }

  // Specifies which stats should be converted before drawn and how.
  // |convertedName| is the name of the converted value, |convertFunction|
  // is the function used to calculate the new converted value based on the
  // original dataSeries.
  var dataConversionConfig = {
    packetsSent: {
      convertedName: 'packetsSentPerSecond',
      convertFunction: totalToPerSecond,
    },
    bytesSent: {
      convertedName: 'kiloBitsSentPerSecond',
      convertFunction: totalKiloBytesToBitsPerSecond,
    },
    packetsReceived: {
      convertedName: 'packetsReceivedPerSecond',
      convertFunction: totalToPerSecond,
    },
    bytesReceived: {
      convertedName: 'kiloBitsReceivedPerSecond',
      convertFunction: totalKiloBytesToBitsPerSecond,
    },
    packetsLost: {
      convertedName: 'packetsLostPer',
      convertFunction: packetsLostPercentage,
    },
    // This is due to a bug of wrong units reported for googTargetEncBitrate.
    // TODO (jiayl): remove this when the unit bug is fixed.
    googTargetEncBitrate: {
      convertedName: 'googTargetEncBitrateCorrected',
      convertFunction: function(srcDataSeries) {
        var length = srcDataSeries.dataPoints_.length;
        var lastDataPoint = srcDataSeries.dataPoints_[length - 1];
        if (lastDataPoint.value < 5000)
          return lastDataPoint.value * 1000;
        return lastDataPoint.value;
      }
    }
  };

  var graphViews = {};
  var dataSeries = {};

  function updateGraph(peerConnectionElement, reportType, reportId, singleReport, label) {
    var graphType = bweCompoundGraphConfig[label] ? 'bweCompound' : label;
    var graphViewId = self.graphViewId(peerConnectionElement, reportType, reportId, graphType);

    if (!graphViews[graphViewId]) {
      var statsType = getStatsDataType(label, singleReport.values);
      graphViews[graphViewId] = createStatsGraphView(peerConnectionElement,
        reportType, reportId,
        graphType, statsType);
      var date = new Date(singleReport.timestamp);
      graphViews[graphViewId].setDateRange(date, date);
    }
    // Adds the new dataSeries to the graphView. We have to do it here to cover
    // both the simple and compound graph cases.
    var dataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, label);
    if (!graphViews[graphViewId].hasDataSeries(dataSeries[dataSeriesId]))
      graphViews[graphViewId].addDataSeries(dataSeries[dataSeriesId]);
    graphViews[graphViewId].updateEndDate();

  }

  // Adds the stats report |singleReport| to the timeline graph for the given
  // |peerConnectionElement| and |reportName|.
  function drawSingleReport(
    peerConnectionElement, reportType, reportId, singleReport) {
    if (!singleReport || !singleReport.values)
      return;

    for (var i = 0; i < singleReport.values.length - 1; i = i + 2) {
      var rawLabel = singleReport.values[i];
      var rawValue = parseInt(singleReport.values[i + 1]);
      if (isNaN(rawValue))
        continue;

      var rawDataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, rawLabel);

      var finalDataSeriesId = rawDataSeriesId;
      var finalLabel = rawLabel;
      var finalValue = rawValue;
      // We need to convert the value if dataConversionConfig[rawLabel] exists.
      if (dataConversionConfig[rawLabel]) {
        // Updates the original dataSeries before the conversion.
        addDataSeriesPoint(rawDataSeriesId, singleReport.timestamp,
          rawLabel, rawValue);

        // Convert to another value to draw on graph, using the original
        // dataSeries as input.
        finalValue = dataConversionConfig[rawLabel].convertFunction(
          dataSeries[rawDataSeriesId], peerConnectionElement, reportType, reportId);
        finalLabel = dataConversionConfig[rawLabel].convertedName;
        finalDataSeriesId = self.dataSeriesId(peerConnectionElement.id, reportType, reportId, finalLabel);
      }

      // Updates the final dataSeries to draw.
      addDataSeriesPoint(
        finalDataSeriesId, singleReport.timestamp, finalLabel, finalValue);

      // Updates the graph.
      updateGraph(peerConnectionElement, reportType, reportId, singleReport, rawLabel);
      if (finalLabel != rawLabel) {
        updateGraph(peerConnectionElement, reportType, reportId, singleReport, finalLabel)
      }
    }
  }

  // Makes sure the TimelineDataSeries with id |dataSeriesId| is created,
  // and adds the new data point to it.
  function addDataSeriesPoint(dataSeriesId, time, label, value) {
    if (!dataSeries[dataSeriesId]) {
      dataSeries[dataSeriesId] = new TimelineDataSeries();
      if (bweCompoundGraphConfig[label]) {
        dataSeries[dataSeriesId].setColor(
          bweCompoundGraphConfig[label].color);
      }
    }
    // Restrain packetsLost to 0 as first value might be -1
    if (label == "packetsLost" && value < 0) {
      value = 0;
    }
    dataSeries[dataSeriesId].addPoint(time, value);
  }

  // Ensures a div container to hold all stats graphs for one track is created as
  // a child of |peerConnectionElement|.
  function ensureStatsGraphTopContainer(
    peerConnectionElement, reportType, reportId) {
    var containerId = peerConnectionElement.id + '-' +
      reportType + '-' + reportId + '-graph-container';
    var container = $('[id="' + containerId + '"]')[0];
    if (!container) {
      container = document.createElement('div');
      container.id = containerId;
      container.className = 'stats-graph-container';

      peerConnectionElement.appendChild(container);
    }
    return container;
  }

  // Creates the container elements holding a timeline graph
  // and the TimelineGraphView object.
  function createStatsGraphView(
    peerConnectionElement, reportType, reportId, statsName, statsType) {
    var topContainer = ensureStatsGraphTopContainer(peerConnectionElement,
      reportType, reportId);

    var graphViewId = peerConnectionElement.id + '-' +
      reportType + '-' + reportId + '-' + statsName;
    var divId = graphViewId + '-div';
    var canvasId = graphViewId + '-canvas';
    var container = document.createElement("div");
    container.className = 'stats-graph-sub-container ' + statsName + '-' + statsType;

    topContainer.appendChild(container);
    container.innerHTML = '<div>' + statsName + '</div>' +
      '<div id=' + divId + '><canvas id=' + canvasId + '></canvas></div>';
    if (statsName == 'bweCompound') {
      container.insertBefore(
        createBweCompoundLegend(
          peerConnectionElement, reportType + '-' + reportId),
        $('[id="' + divId + '"]')[0]);
    }
    return new TimelineGraphView(divId, canvasId);
  }

  // Creates the legend section for the bweCompound graph.
  // Returns the legend element.
  function createBweCompoundLegend(peerConnectionElement, reportName) {
    var legend = document.createElement('div');
    for (var prop in bweCompoundGraphConfig) {
      var div = document.createElement('div');
      legend.appendChild(div);
      div.innerHTML = '<input type=checkbox checked></input>' + prop;
      div.style.color = bweCompoundGraphConfig[prop].color;
      div.dataSeriesId = peerConnectionElement.id + '-' + reportName + '-' + prop;
      div.graphViewId =
        peerConnectionElement.id + '-' + reportName + '-bweCompound';
      div.firstChild.addEventListener('click', function(event) {
        var target = dataSeries[event.target.parentNode.dataSeriesId];
        target.show(event.target.checked);
        graphViews[event.target.parentNode.graphViewId].repaint();
      });
    }
    return legend;
  }

  // Copyright (c) 2013 The Chromium Authors. All rights reserved.
  // Use of this source code is governed by a BSD-style license that can be
  // found in the LICENSE file.

  // function initialize() {
  //   //    peerConnectionsListElem = $('#'+'peer-connections-list');
  //   //    dumpCreator = new DumpCreator(peerConnectionsListElem);
  //   //chrome.send('getAllUpdates');

  //   // Requests stats from all peer connections every second.
  //   //    window.setInterval(function() {
  //   //        if (peerConnectionsListElem.getElementsByTagName('li').length > 0)
  //   //            chrome.send('getAllStats');
  //   //    }, 1000);
  // }
  // document.addEventListener('DOMContentLoaded', initialize);


  /**
   * A helper function for getting a peer connection element id.
   *
   * @param {!Object.<string, number>} data The object containing the pid and lid
   *     of the peer connection.
   * @return {string} The peer connection element id.
   */
  function getPeerConnectionId(data) {
    return data.pid + '-' + data.lid;
  }


  /**
   * Extracts ssrc info from a setLocal/setRemoteDescription update.
   *
   * @param {!PeerConnectionUpdateEntry} data The peer connection update data.
   */
  function extractSsrcInfo(data) {
    if (data.type == 'setLocalDescription' ||
      data.type == 'setRemoteDescription') {
      ssrcInfoManager.addSsrcStreamInfo(data.value);
    }
  }


  /**
   * Browser message handlers.
   */


  /**
   * Removes all information about a peer connection.
   *
   * @param {!Object.<string, number>} data The object containing the pid and lid
   *     of a peer connection.
   */
  function removePeerConnection(data) {
    var element = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    if (element)
      peerConnectionsListElem.removeChild(element);
  }


  /**
   * Adds a peer connection.
   *
   * @param {!Object} data The object containing the pid, lid, url, servers, and
   *     constraints of a peer connection.
   */
  function addPeerConnection(data) {
    var peerConnectionElement = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    if (!peerConnectionElement) {
      peerConnectionElement = document.createElement('li');
      peerConnectionsListElem.appendChild(peerConnectionElement);
      peerConnectionElement.id = getPeerConnectionId(data);
    }
    peerConnectionElement.innerHTML =
      '<h3>PeerConnection ' + peerConnectionElement.id + '</h3>' +
      '<div>' + data.url + ' ' + data.servers + ' ' + data.constraints +
      '</div>';

    // Clicking the heading can expand or collapse the peer connection item.
    peerConnectionElement.firstChild.title = 'Click to collapse or expand';
    peerConnectionElement.firstChild.addEventListener('click', function(e) {
      if (e.target.parentElement.className == '')
        e.target.parentElement.className = 'peer-connection-hidden';
      else
        e.target.parentElement.className = '';
    });
    return peerConnectionElement;
  }


  /**
   * Adds a peer connection update.
   *
   * @param {!PeerConnectionUpdateEntry} data The peer connection update data.
   */
  function updatePeerConnection(data) {
    var peerConnectionElement = $('[id="' + getPeerConnectionId(data) + '"]')[0];
    peerConnectionUpdateTable.addPeerConnectionUpdate(
      peerConnectionElement, data);
    extractSsrcInfo(data);
  }


  /**
   * Adds the information of all peer connections created so far.
   *
   * @param {Array.<!Object>} data An array of the information of all peer
   *     connections. Each array item contains pid, lid, url, servers,
   *     constraints, and an array of updates as the log.
   */
  function updateAllPeerConnections(data) {
    for (var i = 0; i < data.length; ++i) {
      var peerConnection = addPeerConnection(data[i]);

      var log = data[i].log;
      for (var j = 0; j < log.length; ++j) {
        peerConnectionUpdateTable.addPeerConnectionUpdate(
          peerConnection, log[j]);
        extractSsrcInfo(log[j]);
      }
    }
  }


  /**
   * Handles the report of stats.
   *
   * @param {!Object} data The object containing pid, lid, and reports, where
   *     reports is an array of stats reports. Each report contains id, type,
   *     and stats, where stats is the object containing timestamp and values,
   *     which is an array of strings, whose even index entry is the name of the
   *     stat, and the odd index entry is the value.
   */
  self.addStats = function addStats(data) {
    var peerConnectionElements = getPeerConnectionElement(data);
    if (!peerConnectionElements || !peerConnectionElements.length) {
      return;
    }

    //    console.log("addStats : "+ExSIP.Utils.toString(data));
    for (var j = 0; j < peerConnectionElements.length; j++) {
      var peerConnectionElement = peerConnectionElements[j];
      for (var i = 0; i < data.reports.length; ++i) {
        var report = data.reports[i];
        drawSingleReport(peerConnectionElement, report.type, report.id, report.stats);
        statsTable.addStatsReport(peerConnectionElement, report.type, report.id, report);

        if (isVideoStats(report.stats.values)) {
          var oneMinAgo = new Date(new Date().getTime() - 1000 * 60);
          var videoPacketsLost = self.getLastValue(peerConnectionElement, report.type, report.id, "packetsLost");
          var packetsSent = self.getLastValue(peerConnectionElement, report.type, report.id, "packetsReceived");
          if (videoPacketsLost != null && packetsSent != null) {
            var videoPacketsLostOneMinAgo = getValueBefore(peerConnectionElement, report.type, report.id, "packetsLost", oneMinAgo);
            var packetsSentOneMinAgo = getValueBefore(peerConnectionElement, report.type, report.id, "packetsReceived", oneMinAgo);
            var quality = ((videoPacketsLost - videoPacketsLostOneMinAgo) / (packetsSent - packetsSentOneMinAgo)) * 100
            if (quality < 10) {
              $("#quality1").fadeIn(10);
              $("#quality2, #quality3, #quality4").fadeOut(10);
            } else if (quality > 10 && quality < 20) {
              $("#quality2").fadeIn(10);
              $("#quality1, #quality3, #quality4").fadeOut(10);
            } else if (quality > 20 && quality < 100) {
              $("#quality3").fadeIn(10);
              $("#quality1, #quality2, #quality4").fadeOut(10);
            } else if (quality > 100 && quality < 1000) {
              $("#quality4").fadeIn(10);
              $("#quality1, #quality2, #quality3").fadeOut(10);
            }
          }
        }
      }
    }


  }

  function getPeerConnectionElement(data) {
    return $('[id="' + getPeerConnectionId(data) + '"]');
  }

  /**
   * Delegates to dumpCreator to update the recording status.
   * @param {!Object.<string>} update Key-value pairs describing the status of the
   *     RTP recording.
   */
  function updateDumpStatus(update) {
    dumpCreator.onUpdate(update);
  }

  return self;
}
},{}],1008:[function(require,module,exports){
module.exports = {"stats":".bdsft-webrtc .stats{position:absolute;top:10px;width:auto;top:auto;bottom:40px;right:0;left:auto;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:5px}.bdsft-webrtc .stats .table{width:auto;border-spacing:5px}.bdsft-webrtc .stats .statsVideo{position:absolute;white-space:pre-wrap;color:#0082ff;left:10px;font-family:arial;font-size:18px;text-decoration:none}.bdsft-webrtc .stats .statsAudio{position:absolute;white-space:pre-wrap;color:#0082ff;left:260px;float:left;font-family:arial;font-size:18px;text-decoration:none}.bdsft-webrtc .stats a{color:#2ba6cb}.bdsft-webrtc .stats .spacer{height:15px}.bdsft-webrtc .stats .statsDelay{display:none}.bdsft-webrtc .stats .videoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats .audioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats .videoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats .audioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats .videoPacketsLostRow,.bdsft-webrtc .stats .videoPacketsLostPerRow,.bdsft-webrtc .stats .audioPacketsLostRow,.bdsft-webrtc .stats .audioPacketsLostPerRow,.bdsft-webrtc .stats .videoGoogFrameRateSentRow,.bdsft-webrtc .stats .videoGoogFrameRateReceivedRow,.bdsft-webrtc .stats .audioAudioInputLevelRow,.bdsft-webrtc .stats .audioAudioOutputLevelRow,.bdsft-webrtc .stats .videoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats .videoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats .videoGoogFrameWidthSentRow,.bdsft-webrtc .stats .videoGoogFrameHeightSentRow,.bdsft-webrtc .stats .audioGoogRttRow,.bdsft-webrtc .stats .audioGoogJitterReceivedRow,.bdsft-webrtc .stats .videoStats,.bdsft-webrtc .stats .audioStats,.bdsft-webrtc .stats[class*=\"hasAudio\"] .noStats,.bdsft-webrtc .stats[class*=\"hasVideo\"] .noStats,.bdsft-webrtc .stats [class*=\"avg\"]{display:none}.bdsft-webrtc .stats.hasVideoKiloBitsSentPerSecond .videoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAudioKiloBitsSentPerSecond .audioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasVideoKiloBitsReceivedPerSecond .videoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAudioKiloBitsReceivedPerSecond .audioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasVideoPacketsLost .videoPacketsLostRow,.bdsft-webrtc .stats.hasVideoPacketsLostPer .videoPacketsLostPerRow,.bdsft-webrtc .stats.hasVideoPacketsLostPer .videoPacketsLostRow,.bdsft-webrtc .stats.hasAudioPacketsLost .audioPacketsLostRow,.bdsft-webrtc .stats.hasAudioPacketsLostPer .audioPacketsLostPerRow,.bdsft-webrtc .stats.hasAudioPacketsLostPer .audioPacketsLostRow,.bdsft-webrtc .stats.hasVideoGoogFrameRateSent .videoGoogFrameRateSentRow,.bdsft-webrtc .stats.hasVideoGoogFrameRateReceived .videoGoogFrameRateReceivedRow,.bdsft-webrtc .stats.hasAudioAudioInputLevel .audioAudioInputLevelRow,.bdsft-webrtc .stats.hasAudioAudioOutputLevel .audioAudioOutputLevelRow,.bdsft-webrtc .stats.hasVideoGoogFrameWidthReceived .videoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats.hasVideoGoogFrameHeightReceived .videoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats.hasVideoGoogFrameWidthSent .videoGoogFrameWidthSentRow,.bdsft-webrtc .stats.hasVideoGoogFrameHeightSent .videoGoogFrameHeightSentRow,.bdsft-webrtc .stats.hasAudioGoogRtt .audioGoogRttRow,.bdsft-webrtc .stats.hasAudioGoogJitterReceived .audioGoogJitterReceivedRow,.bdsft-webrtc .stats.hasAvgVideoKiloBitsSentPerSecond .avgVideoKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAvgAudioKiloBitsSentPerSecond .avgAudioKiloBitsSentPerSecondRow,.bdsft-webrtc .stats.hasAvgVideoKiloBitsReceivedPerSecond .avgVideoKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAvgAudioKiloBitsReceivedPerSecond .avgAudioKiloBitsReceivedPerSecondRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLost .avgVideoPacketsLostRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLostPer .avgVideoPacketsLostPerRow,.bdsft-webrtc .stats.hasAvgVideoPacketsLostPer .avgVideoPacketsLostRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLost .avgAudioPacketsLostRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLostPer .avgAudioPacketsLostPerRow,.bdsft-webrtc .stats.hasAvgAudioPacketsLostPer .avgAudioPacketsLostRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameRateSent .avgVideoGoogFrameRateSentRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameRateReceived .avgVideoGoogFrameRateReceivedRow,.bdsft-webrtc .stats.hasAvgAudioAudioInputLevel .avgAudioAudioInputLevelRow,.bdsft-webrtc .stats.hasAvgAudioAudioOutputLevel .avgAudioAudioOutputLevelRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameWidthReceived .avgVideoGoogFrameWidthReceivedRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameHeightReceived .avgVideoGoogFrameHeightReceivedRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameWidthSent .avgVideoGoogFrameWidthSentRow,.bdsft-webrtc .stats.hasAvgVideoGoogFrameHeightSent .avgVideoGoogFrameHeightSentRow,.bdsft-webrtc .stats.hasAvgAudioGoogRtt .avgAudioGoogRttRow,.bdsft-webrtc .stats.hasAvgAudioGoogJitterReceived .avgAudioGoogJitterReceivedRow{display:block}.bdsft-webrtc .stats[class*=\"hasAudio\"] .audioStats,.bdsft-webrtc .stats[class*=\"hasVideo\"] .videoStats{display:table-cell;width:220px}.bdsft-webrtc .stats.videoKiloBitsSentPerSecond .kiloBitsSentPerSecond-video,.bdsft-webrtc .stats.audioKiloBitsSentPerSecond .kiloBitsSentPerSecond-audio,.bdsft-webrtc .stats.videoKiloBitsReceivedPerSecond .kiloBitsReceivedPerSecond-video,.bdsft-webrtc .stats.audioKiloBitsReceivedPerSecond .kiloBitsReceivedPerSecond-audio,.bdsft-webrtc .stats.videoPacketsLost [id*=\"send-graph-container\"] .packetsLost-video,.bdsft-webrtc .stats.videoPacketsLostPer [id*=\"send-graph-container\"] .packetsLostPer-video,.bdsft-webrtc .stats.audioPacketsLost [id*=\"send-graph-container\"] .packetsLost-audio,.bdsft-webrtc .stats.audioPacketsLostPer [id*=\"send-graph-container\"] .packetsLostPer-audio,.bdsft-webrtc .stats.videoGoogFrameRateSent .googFrameRateSent-video,.bdsft-webrtc .stats.videoGoogFrameRateReceived .googFrameRateReceived-video,.bdsft-webrtc .stats.audioAudioOutputLevel .audioOutputLevel-audio,.bdsft-webrtc .stats.audioAudioInputLevel .audioInputLevel-audio,.bdsft-webrtc .stats.videoGoogFrameWidthReceived .googFrameWidthReceived-video,.bdsft-webrtc .stats.videoGoogFrameHeightReceived .googFrameHeightReceived-video,.bdsft-webrtc .stats.videoGoogFrameWidthSent .googFrameWidthSent-video,.bdsft-webrtc .stats.videoGoogFrameHeightSent .googFrameHeightSent-video,.bdsft-webrtc .stats.audioGoogRtt .googRtt-audio,.bdsft-webrtc .stats.audioGoogJitterReceived .googJitterReceived-audio{display:block}.bdsft-webrtc .stats.audioOnly:not(.offerToReceiveVideo){top:45px;bottom:auto}.bdsft-webrtc .stats-table-container,.bdsft-webrtc .stats-graph-sub-container{display:none}.bdsft-webrtc .statsVar{color:<%= statsColor %>}.bdsft-webrtc .stats-graph-sub-container canvas{width:100%}.bdsft-webrtc .stats.enableCallStats.stats-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .stats.enableCallStats:not(.stats-shown){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}"}
},{}],1009:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // stats.jade compiled template
    templatizer["stats"] = function tmpl_stats() {
        return '<div class="bdsft-webrtc"><div class="stats fadeable popup classes"><div class="statsContainer"></div><div class="noStats">There are no Stats yet</div><div class="table fixed"><div class="cell videoStats"> \nVideo Stats<div class="videoKiloBitsSentPerSecondRow">Bitrate out: <a href="javascript:;" data-type="video" data-var="kiloBitsSentPerSecond" class="statsVar videoKiloBitsSentPerSecond"></a> kb/s<div class="avgVideoKiloBitsSentPerSecond"></div></div><div class="videoKiloBitsReceivedPerSecondRow">Bitrate in: <a href="javascript:;" data-type="video" data-var="kiloBitsReceivedPerSecond" class="statsVar videoKiloBitsReceivedPerSecond"></a> kb/s<div class="avgVideoKiloBitsReceivedPerSecond"></div></div><div class="videoPacketsLostRow">Lost: <a href="javascript:;" data-type="video" data-var="packetsLost" class="statsVar videoPacketsLost"></a> packets (<a href="javascript:;" data-type="video" data-var="packetsLostPer" class="statsVar videoPacketsLostPer"></a> %)<div class="avgVideoPacketsLost"></div><div class="avgVideoPacketsLostPer"></div></div><div class="videoGoogFrameRateSentRow">Frame rate out: <a href="javascript:;" data-type="video" data-var="googFrameRateSent" class="statsVar videoGoogFrameRateSent"></a> in: <a href="javascript:;" data-type="video" data-var="googFrameRateReceived" class="statsVar videoGoogFrameRateReceived"></a><div class="avgVideoGoogFrameRateSent"></div><div class="avgVideoGoogFrameRateReceived"></div></div><div class="spacer"></div><div class="videoGoogFrameWidthReceivedRow">Resolution</div><div class="videoGoogFrameWidthReceivedRow">In: <span data-type="video" data-var="googFrameWidthReceived" class="statsVar videoGoogFrameWidthReceived"></span> x <span data-type="video" data-var="googFrameHeightReceived" class="statsVar videoGoogFrameHeightReceived"></span> Out: <span data-type="video" data-var="googFrameWidthSent" class="statsVar videoGoogFrameWidthSent"></span> x <span data-type="video" data-var="googFrameHeightSent" class="statsVar videoGoogFrameHeightSent"></span><div class="avgVideoGoogFrameWidthReceived"></div><div class="avgVideoGoogFrameHeightReceived"></div><div class="avgVideoGoogFrameWidthSent"></div><div class="avgVideoGoogFrameHeightSent"></div></div></div><div class="cell audioStats"> \nAudio Stats<div class="audioKiloBitsSentPerSecondRow">Bitrate out: <a href="javascript:;" data-type="audio" data-var="kiloBitsSentPerSecond" class="statsVar audioKiloBitsSentPerSecond"></a> kb/s<div class="avgAudioKiloBitsSentPerSecond"></div></div><div class="audioKiloBitsReceivedPerSecondRow">Bitrate in: <a href="javascript:;" data-type="audio" data-var="kiloBitsReceivedPerSecond" class="statsVar audioKiloBitsReceivedPerSecond"></a> kb/s<div class="avgAudioKiloBitsReceivedPerSecond"></div></div><div class="audioPacketsLostPerRow">Lost: <a href="javascript:;" data-type="audio" data-var="packetsLost" class="statsVar audioPacketsLost"></a> packets (<a href="javascript:;" data-type="audio" data-var="packetsLostPer" class="statsVar audioPacketsLostPer"></a> %)<div class="avgAudioPacketsLost"></div><div class="avgAudioPacketsLostPer"></div></div><div class="audioAudioInputLevelRow">Audio Level out: <a href="javascript:;" data-type="audio" data-var="audioInputLevel" class="statsVar audioAudioInputLevel"></a> in: <a href="javascript:;" data-type="audio" data-var="audioOutputLevel" class="statsVar audioAudioOutputLevel"></a><div class="avgAudioAudioInputLevel"></div><div class="avgAudioAudioOutputLevel"></div></div><div class="spacer"></div><div class="cell audioGoogJitterReceivedRow">Link</div><div class="audioGoogJitterReceivedRow"><span class="statsDelay">Delay: <a href="javascript:;" data-type="audio" data-var="googRtt" class="statsVar audioGoogRtt"></a></span> Jitter: <a href="javascript:;" data-type="audio" data-var="googJitterReceived" class="statsVar audioGoogJitterReceived"></a><div class="avgAudioGoogRtt"></div><div class="avgAudioGoogJitterReceived"></div></div></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1010:[function(require,module,exports){
var Utils = require('webrtc-core').utils;
var C = {};
module.exports = C;

C.keys = ['videoKiloBitsSentPerSecond', 'audioKiloBitsSentPerSecond',
    'videoKiloBitsReceivedPerSecond', 'audioKiloBitsReceivedPerSecond', 'videoPacketsLost', 'videoPacketsLostPer',
    'audioPacketsLost', 'audioPacketsLostPer', 'videoGoogFrameRateSent', 'videoGoogFrameRateReceived', 'audioAudioInputLevel',
    'audioAudioOutputLevel', 'videoGoogFrameWidthReceived', 'videoGoogFrameHeightReceived', 'videoGoogFrameWidthSent', 'videoGoogFrameHeightSent',
    'audioGoogRtt', 'audioGoogJitterReceived'];

C.keysAvg = C.keys.map(function(key){ return Utils.camelize('avg ' + key)});
C.hasKeys = C.keys.map(function(key){ return Utils.camelize('has ' + key)});
C.hasKeysAvg = C.keysAvg.map(function(key){ return Utils.camelize('has ' + key)});
C.STYLES = {
  statsColor: '#999999'
}
},{"webrtc-core":1016}],1011:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Stats, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;
var constants = require('../constants');

function Stats(eventbus, debug, sipstack, urlconfig) {
  var self = {};

  self.statsMod = require('../../js/stats')(self);

  self.props = ['classes', 'visible', 'statsContainerId', 'statSelected'].concat(constants.keys).concat(constants.keysAvg)
  .concat(constants.hasKeys).concat(constants.hasKeysAvg);

  self.bindings = {
    'classes': {
      stats: ['visible', 'enableCallStats', 'statSelected'].concat(constants.hasKeys).concat(constants.hasKeysAvg),
      sipstack: ['audioOnly', 'offerToReceiveVideo']
    }
  }

  var intervalId = null;

  var isSupported = function(){
    return Utils.isChrome() && Utils.majorVersion() >= 25
  };

  self.init = function() {
    // disable call stats if not supported
    if(!isSupported()) {
      self.enableCallStats = false;
    } else {
      self.enableCallStats = urlconfig.enableCallStats || self.enableCallStats;
    }
  };

  self.select = function(stat) {
    self.statSelected = stat;
  };

  var getElement = function(type, name, isAvg) {
    return self[Utils.camelize((isAvg ? 'Avg ' : '') + type + ' ' + name)];
  };

  self.getReportById = function(reports, id) {
    for (var i = 0; i < reports.length; i++) {
      if (reports[i].id === id) {
        return reports[i];
      }
    }
    return null;
  };

  self.processStats = function() {
    if(!sipstack.activeSession) {
      stop();
      return;
    }

    var peerConnection = sipstack.activeSession.rtcMediaHandler.peerConnection;

    peerConnection.getStats(function(stats) {
      var results = stats.result();
      var reports = [];
      for (var i = 0; i < results.length; ++i) {
        var res = results[i];
        var report = self.getReportById(reports, res.id);
        if (!report) {
          report = {};
          report.type = res.type;
          report.id = res.id;
        }

        var names = res.names();
        var values = [];
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          if (!name) {
            continue;
          }
          var value = res.stat(name);
          values.push(name);
          values.push(value);
        }
        var valueObj = {};
        valueObj.timestamp = res.timestamp;
        valueObj.values = values;
        report.stats = valueObj;
        reports.push(report);
      }
      var data = {
        "lid": 1,
        "pid": sipstack.getSessionId(),
        "reports": reports
      };
      self.statsMod.addStats(data);
    });
  };

  self.getDataSerie = function(type, label, sessionId) {
    var dataSeries = getDataSeriesByLabel(sessionId || sipstack.getSessionId(), type, label);
    var result;
    for (var i = 0; i < dataSeries.length; i++) {
      var dataSerie = dataSeries[i];
      if (!result || dataSerie.getAvg() > result.getAvg()) {
        result = dataSerie;
      }
    }
    return result;
  };

  self.setAllAvg = function(stats) {
    for(var i = 0; i < constants.keysAvg.length; i++) {
      var key = constants.keysAvg[i];
      self[key] = stats[key];
    };
  };

  self.getAll = function() {
    return Utils.pick(self, constants.keys);
  };

  self.getAllAvg = function() {
    return Utils.pick(self, constants.keysAvg);
  };

  self.getStatValues = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.dataPoints_.map(function(e) {
      return e.value;
    }) : null;
  };

  self.getStatAvg = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.getAvg() : null;
  };

  self.getValue = function(type, name) {
    return getElement(type, name);
  };

  self.getAvg = function(type, name) {
    return Math.round(getElement(type, name, true) * 100) / 100.0;
  };

  self.onAddStats = function(peerConnectionElement, reportType, reportId, statsData) {
    self.props.forEach(function(prop) {
      var match = prop.match(/(audio|video)(.*)/);
      if (!match) {
        return;
      }
      var label = Utils.lowercaseFirstLetter(match[2]);
      var type = match[1];
      if (self.statsMod.matchesType(label, type, statsData)) {
        var value = self.statsMod.getLastValue(peerConnectionElement, reportType, reportId, label);
        if (value != null) {
          self[prop] = value;
          var avg = self.statsMod.getAvgValue(peerConnectionElement, reportType, reportId, label);
          self[Utils.camelize('avg '+ prop)] = Math.round(avg * 100) / 100.0;
        } else {}
      }
    });
  };

  var start = function() {
    if (!intervalId && self.enableCallStats && Utils.isChrome()) {
      intervalId = setInterval(function() {
        self.processStats();
      }, 1000);
    }
  };

  var stop = function() {
    if (intervalId) {
      clearInterval(intervalId);
      intervalId = null;
    }
  };

  self.listeners = function(databinder) {
    databinder.onModelPropChange(constants.keys.concat(constants.keysAvg), function(value, name) {
      value = value+'';
      self[Utils.camelize('has '+name)] = value !== '' && value !== 'undefined' && value !== 'undefinedxundefined' && value !== 'NaN';
    });
    eventbus.on("ended", function(e) {
      stop();
    });
    eventbus.on("started", function(e) {
      self.statsContainerId = sipstack.getSessionId() + '-1';
      start();
    });
  };

  return self;
}
},{"../../js/config.js":1006,"../../js/stats":1007,"../constants":1010,"webrtc-core":1016}],1012:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(StatsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

var Utils = require('webrtc-core').utils;
var constants = require('../constants');

function StatsView(eventbus, stats) {
  var self = {};

  self.model = stats;
  
  self.bindings = {
    'statsContainerId': {
      stats: 'statsContainerId'
    }
  }

  self.elements = ['statsVar', 'statsContainer'].concat(constants.keys).concat(constants.keysAvg);

  self.updateStatsContainerId = function(value){
    self.statsContainer && self.statsContainer.attr('id', value);
  };

  self.listeners = function() {
    self.statsVar.click(function() {
      var selected = Utils.camelize(Utils.getElement(this).attr('data-type') + ' ' + Utils.getElement(this).attr('data-var'));
      stats.select(selected);
    });
    eventbus.on('started', function(){
      self.statsContainer && self.statsContainer.text('');
    });
  };

  return self;
}
},{"../../js/styles":1008,"../../js/templates":1009,"../constants":1010,"webrtc-core":1016}],1013:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1014:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1015:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1016:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1015,"./bdsft":1017,"./constants":1020,"./cookieconfig":1021,"./cookieprop":1022,"./dateformat":1025,"./debug":1026,"./element":1027,"./eventbus":1028,"./factory":1029,"./icon":1030,"./loader":1031,"./popup":1032,"./prop":1033,"./urlconfig":1035,"./utils":1036,"./visibleprop":1037,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1017:[function(require,module,exports){
module.exports=require(54)
},{"./app":1016,"./binding":1018,"./classesbinding":1019,"./databinder":1024,"./stylesmanager":1034,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1061}],1018:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1017,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1019:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1018,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1020:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1021:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1017,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1061,"jquery.cookie":1060}],1022:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1020,"./prop":1033,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1061,"jquery.cookie":1060}],1023:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1020,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1042}],1024:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1045}],1025:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1026:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1013,"./bdsft":1017,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1038,"stacktrace-js":1063}],1027:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1028:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1017,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1045}],1029:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1061}],1030:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1031:[function(require,module,exports){
module.exports=require(68)
},{"../":1016,"./constants":1020,"./factory":1029,"./stylesmanager":1034,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1041}],1032:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1061}],1033:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1062}],1034:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1014,"./constants":1020,"./css":1023,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1035:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1013,"./bdsft":1017,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1036:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1015,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1061}],1037:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1020,"./prop":1033,"./utils":1036,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1038:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1039,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1039:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1040}],1040:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1041:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1042:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1043,"./utils":1044,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1043:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1044:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1045:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1046,"es5-ext/object/valid-callable":1055}],1046:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1047,"es5-ext/object/is-callable":1050,"es5-ext/object/normalize-options":1054,"es5-ext/string/#/contains":1057}],1047:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1048,"./shim":1049,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1048:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1049:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1051,"../valid-value":1056,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1050:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1051:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1052,"./shim":1053,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1052:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1053:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1054:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1055:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1056:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1057:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1058,"./shim":1059,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1058:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1059:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1060:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1061}],1061:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1062:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1063:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1064:[function(require,module,exports){
module.exports = {view: require('./lib/views/timer'), model: require('./lib/models/timer')};
},{"./lib/models/timer":1069,"./lib/views/timer":1070}],1065:[function(require,module,exports){
module.exports = {
    enableCallTimer: true
};
},{}],1066:[function(require,module,exports){
module.exports = {"timer":".bdsft-webrtc .timer{position:absolute;top:3px;left:0;width:100%;text-align:center;font-family:arial;font-size:16px;top:11px;color:#fff}.bdsft-webrtc .timer .text{text-align:center}.bdsft-webrtc .timer.audioOnly:not(.offerToReceiveVideo){position:relative;margin-right:10px}.bdsft-webrtc .timer.enableCallTimer.started{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .timer:not(.started){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .timer{color:<%= timerColor %>}"}
},{}],1067:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // timer.jade compiled template
    templatizer["timer"] = function tmpl_timer() {
        return '<div class="bdsft-webrtc"><div class="timer fadeable classes"><div class="text"></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1068:[function(require,module,exports){
var C = {
  STYLES: {
    timerColor: '#FFFFFF'
  }
};

module.exports = C;
},{}],1069:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Timer, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;

function Timer(eventbus, debug, urlconfig, sipstack) {
  var self = {};

  self.callTimer = null;
  self.startTime = null;

  self.props = ['text', 'classes'];

  self.bindings = {
    classes: {
        timer: 'enableCallTimer',
        sipstack: ['callState', 'audioOnly', 'offerToReceiveVideo']
    },
    enableCallTimer: {
      urlconfig: 'enableCallTimer'
    }
  }

  self.init = function() {
    self.updateText();
  };

  self.listeners = function() {
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.start();
      }
    });
    eventbus.on(["disconnected", "ended"], function(e) {
      self.stop();
    });
  };

  self.start = function() {
    if (self.callTimer) {
      debug.log('timer ' + self.callTimer + ' already running');
      return;
    }

    var timer = self.runningTimer();
    timer();
    self.callTimer = setInterval(timer, 1000);
    debug.debug("started timer interval");
  };

  self.stop = function() {
    // Don't stop if there are active sessions still
    if(sipstack.sessions.length) {
      return;
    }
    self.startTime = null;
    clearInterval(self.callTimer);
    debug.debug("cleared timer interval");
    self.callTimer = null;
    self.updateText();
  };

  self.getSeconds = function() {
    return Math.round((new Date().getTime() - (self.startTime || new Date().getTime())) / 1000);
  };

  self.updateText = function() {
    var secs = self.getSeconds();
    self.text = Utils.format(secs);
  };

  // Display the timer on the screen
  self.runningTimer = function() {
    self.startTime = new Date().getTime();
    return function() {
      var secs = self.getSeconds();
      if (urlconfig.maxCallLength && secs >= urlconfig.maxCallLength) {
        eventbus.endCall();
        return;
      }
      self.updateText();
    };
  }

  return self;
}
},{"../../js/config.js":1065,"webrtc-core":1074}],1070:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(TimerView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  constants: require('../constants')
});

function TimerView(timer) {
  var self = {};

  self.model = timer;
  
  self.elements = ['text'];

  return self;
}
},{"../../js/styles":1066,"../../js/templates":1067,"../constants":1068,"webrtc-core":1074}],1071:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1072:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1073:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1074:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1073,"./bdsft":1075,"./constants":1078,"./cookieconfig":1079,"./cookieprop":1080,"./dateformat":1083,"./debug":1084,"./element":1085,"./eventbus":1086,"./factory":1087,"./icon":1088,"./loader":1089,"./popup":1090,"./prop":1091,"./urlconfig":1093,"./utils":1094,"./visibleprop":1095,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1075:[function(require,module,exports){
module.exports=require(54)
},{"./app":1074,"./binding":1076,"./classesbinding":1077,"./databinder":1082,"./stylesmanager":1092,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1119}],1076:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1075,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1077:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1076,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1078:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1079:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1075,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1119,"jquery.cookie":1118}],1080:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1078,"./prop":1091,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1119,"jquery.cookie":1118}],1081:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1078,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1100}],1082:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1103}],1083:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1084:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1071,"./bdsft":1075,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1096,"stacktrace-js":1121}],1085:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1086:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1075,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1103}],1087:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1119}],1088:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1089:[function(require,module,exports){
module.exports=require(68)
},{"../":1074,"./constants":1078,"./factory":1087,"./stylesmanager":1092,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1099}],1090:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1119}],1091:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1120}],1092:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1072,"./constants":1078,"./css":1081,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1093:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1071,"./bdsft":1075,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1094:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1073,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1119}],1095:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1078,"./prop":1091,"./utils":1094,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1096:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1097,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1097:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1098}],1098:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1099:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1100:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1101,"./utils":1102,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1101:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1102:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1103:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1104,"es5-ext/object/valid-callable":1113}],1104:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1105,"es5-ext/object/is-callable":1108,"es5-ext/object/normalize-options":1112,"es5-ext/string/#/contains":1115}],1105:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1106,"./shim":1107,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1106:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1107:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1109,"../valid-value":1114,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1108:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1109:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1110,"./shim":1111,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1110:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1111:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1112:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1113:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1114:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1115:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1116,"./shim":1117,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1116:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1117:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1118:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1119}],1119:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1120:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1121:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1122:[function(require,module,exports){
module.exports = {view: require('./lib/views/transfer'), model: require('./lib/models/transfer')};
},{"./lib/models/transfer":1126,"./lib/views/transfer":1127}],1123:[function(require,module,exports){
module.exports = {
    enableTransfer: true
};
},{}],1124:[function(require,module,exports){
module.exports = {"transfer":".bdsft-webrtc .transferPopup{color:#fff}.bdsft-webrtc .transferPopup .target{width:200px;line-height:30px;margin:5px;margin-left:0}.bdsft-webrtc .transferPopup .actions{padding:10px}.bdsft-webrtc .transferPopup .actions button{margin-right:10px}.bdsft-webrtc .transferPopup .reject{color:#f00}.bdsft-webrtc .transferPopup.enableTransfer.started.transfer-shown{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .transferPopup.enableTransfer:not(.transfer-shown){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}"}
},{}],1125:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // transfer.jade compiled template
    templatizer["transfer"] = function tmpl_transfer() {
        return '<div class="bdsft-webrtc"><div class="transferPopup fadeable popup classes centered"><div class="title">Transfer</div><div><input type="text" placeholder="To Target" class="target"/></div><div class="actions"><button type="button" class="accept button">Transfer</button><button type="button" class="reject button">Cancel</button></div></div></div>';
    };

    // transfercontrol.jade compiled template
    templatizer["transfercontrol"] = function tmpl_transfercontrol() {
        return '<div class="bdsft-webrtc"><div class="cell cell-transfer"><div class="transfer icon fadeable"><a href="" title="Transfer" class="icon-transfer"></a></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1126:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Transfer, {
  config: require('../../js/config.js')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function Transfer(sipstack, callcontrol, urlconfig) {
  var self = {};

  self.props = ['classes', 'target', 'visible'];

  self.bindings = {
    classes: {
        transfer: ['visible', 'enableTransfer'],
        sipstack: ['callState', 'audioOnly', 'offerToReceiveVideo']
    },
    enableTransfer: {
      urlconfig: 'enableTransfer'
    }
  }

  self.transfer = function() {
    var target = self.target;
    target = callcontrol.validateDestination(target);
    if (target) {
      self.visible = false;
      sipstack.transfer(target, false);
    }
  };

  return self;
}
},{"../../js/config.js":1123,"webrtc-core":1131}],1127:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(TransferView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function TransferView(sound, transfer) {
  var self = {};

  self.model = transfer;
  

  self.elements = ['accept', 'reject', 'target'];

  self.listeners = function(databinder) {
    databinder.onModelPropChange('visible', function(visible){
      visible && self.target.focus();
    });
    self.accept.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      transfer.transfer();
    });

    self.reject.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      transfer.visible = false;
    });
  };

  return self;
}
},{"../../js/styles":1124,"../../js/templates":1125,"webrtc-core":1131}],1128:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1129:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1130:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1131:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1130,"./bdsft":1132,"./constants":1135,"./cookieconfig":1136,"./cookieprop":1137,"./dateformat":1140,"./debug":1141,"./element":1142,"./eventbus":1143,"./factory":1144,"./icon":1145,"./loader":1146,"./popup":1147,"./prop":1148,"./urlconfig":1150,"./utils":1151,"./visibleprop":1152,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1132:[function(require,module,exports){
module.exports=require(54)
},{"./app":1131,"./binding":1133,"./classesbinding":1134,"./databinder":1139,"./stylesmanager":1149,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1176}],1133:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1132,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1134:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1133,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1135:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1136:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1132,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1176,"jquery.cookie":1175}],1137:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1135,"./prop":1148,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1176,"jquery.cookie":1175}],1138:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1135,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1157}],1139:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1160}],1140:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1141:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1128,"./bdsft":1132,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1153,"stacktrace-js":1178}],1142:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1143:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1132,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1160}],1144:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1176}],1145:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1146:[function(require,module,exports){
module.exports=require(68)
},{"../":1131,"./constants":1135,"./factory":1144,"./stylesmanager":1149,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1156}],1147:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1176}],1148:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1177}],1149:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1129,"./constants":1135,"./css":1138,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1150:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1128,"./bdsft":1132,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1151:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1130,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1176}],1152:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1135,"./prop":1148,"./utils":1151,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1153:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1154,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1154:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1155}],1155:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1156:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1157:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1158,"./utils":1159,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1158:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1159:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1160:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1161,"es5-ext/object/valid-callable":1170}],1161:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1162,"es5-ext/object/is-callable":1165,"es5-ext/object/normalize-options":1169,"es5-ext/string/#/contains":1172}],1162:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1163,"./shim":1164,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1163:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1164:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1166,"../valid-value":1171,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1165:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1166:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1167,"./shim":1168,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1167:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1168:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1169:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1170:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1171:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1172:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1173,"./shim":1174,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1173:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1174:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1175:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1176}],1176:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1177:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1178:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1179:[function(require,module,exports){
module.exports = {view: require('./lib/views/video'), model: require('./lib/models/video')};
},{"./lib/models/video":1184,"./lib/views/video":1185}],1180:[function(require,module,exports){
module.exports = {
	enableSelfView: true,
    selfViewLocation: "bl",
    selfViewSize: "1x",
	displayResolution: "640x480"
}

},{}],1181:[function(require,module,exports){
module.exports = {"videobg":"PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAxOC4xLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiDQoJIHZpZXdCb3g9IjAgMTY1LjkgNjEyIDQ2MC4zIiBlbmFibGUtYmFja2dyb3VuZD0ibmV3IDAgMTY1LjkgNjEyIDQ2MC4zIiB4bWw6c3BhY2U9InByZXNlcnZlIj4NCgkgPGRlZnM+DQoJCTxsaW5lYXJHcmFkaWVudCBpZD0iU1ZHSURfMV8iIHgxPSIwJSIgeTE9IjAlIiB4Mj0iMCUiIHkyPSIxMDAlIj4NCgkJCTxzdG9wIG9mZnNldD0iMCUiICAgc3R5bGU9InN0b3AtY29sb3I6IzAwMDAwMCIvPg0KCQkJPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojNDk0OTQ5Ii8+DQoJCTwvbGluZWFyR3JhZGllbnQ+DQoJPC9kZWZzPg0KCTxyZWN0IHk9IjE2NS45IiBmaWxsPSJ1cmwoI1NWR0lEXzFfKSIgd2lkdGg9IjYxMiIgaGVpZ2h0PSI0NjAuMyIvPg0KCTxnPg0KCQk8Zz4NCgkJCTxwYXRoIGZpbGw9IiMyODI4MjgiIGQ9Ik00MzIuNywzMTkuMnYxNTMuNWMwLDMuOS0xLjgsNi44LTUuNCw4LjRjLTEuMywwLjctMi41LDEtMy40LDFjLTIuNywwLTQuOC0xLTYuNC0zbC01Ni45LTU2Ljl2MjMuOA0KCQkJCWMwLDExLjItNCwyMC44LTEyLjEsMjguN2MtOC4xLDcuOS0xNy44LDExLjgtMjksMTEuOGgtOTkuNWMtMTEuMiwwLTIwLjgtMy45LTI4LjctMTEuOGMtNy45LTcuOS0xMS44LTE3LjUtMTEuOC0yOC43VjM0Ng0KCQkJCWMwLTExLjIsMy45LTIwLjgsMTEuOC0yOC43YzcuOS03LjksMTcuNS0xMS44LDI4LjctMTEuOGg5OS41YzExLjIsMCwyMC44LDMuOSwyOSwxMS44YzguMSw3LjksMTIuMSwxNy41LDEyLjEsMjguN3YyMy44DQoJCQkJbDU2LjktNTYuOWMxLjYtMiwzLjgtMyw2LjQtM2MxLDAsMi4xLDAuMywzLjQsMUM0MzAuOCwzMTIuNSw0MzIuNywzMTUuMyw0MzIuNywzMTkuMnoiLz4NCgkJPC9nPg0KCTwvZz4NCjwvc3ZnPg0K"}
},{}],1182:[function(require,module,exports){
module.exports = {"video":".bdsft-webrtc .video{position:relative;top:0;left:0;width:100%;height:auto;box-shadow:0 0 1px rgba(0,0,0,0.05);undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined undefined}.bdsft-webrtc .video .remote{display:none;position:absolute;top:0;left:0;width:100%;height:100%;backface-visibility:hidden;box-shadow:0 0 10px #000}.bdsft-webrtc .video .localVideo{position:absolute;top:auto;left:0;bottom:0;right:auto;width:25%;height:25%;background-color:transparent}.bdsft-webrtc .video .localVideo video{border-radius:0;box-shadow:none;background:#292929;border:1px solid #3c3c3c;cursor:move;width:100%;height:100%;position:absolute}.bdsft-webrtc .video .localVideo .inner{margin:5px;position:absolute;top:0;bottom:0;right:0;left:0}.bdsft-webrtc .video._960x720 .content,.bdsft-webrtc .video._640x480 .content,.bdsft-webrtc .video._320x240 .content{padding-bottom:75%}.bdsft-webrtc .video._1920x1080 .content,.bdsft-webrtc .video._1280x720 .content,.bdsft-webrtc .video._640x360 .content,.bdsft-webrtc .video._320x180 .content,.bdsft-webrtc .video.hd .content{padding-bottom:56.25%}.bdsft-webrtc .video._960x720{width:960px}.bdsft-webrtc .video._640x360,.bdsft-webrtc .video._640x480{width:640px}.bdsft-webrtc .video._320x180,.bdsft-webrtc .video._320x240{width:320px}.bdsft-webrtc .video._1280x720,.bdsft-webrtc .video.hd{width:1280px}.bdsft-webrtc .video._1920x1080{width:1920px}.bdsft-webrtc .video.fullscreen-shown{padding-bottom:0;bottom:40px;position:absolute;height:auto!important;width:100%}.bdsft-webrtc .video.started .remote{display:inline;box-shadow:0 0 1px rgba(0,0,0,0.1)}.bdsft-webrtc .video.bl .localVideo{top:auto;bottom:0;left:0;right:auto}.bdsft-webrtc .video.tl .localVideo{top:0;bottom:auto;left:0;right:auto}.bdsft-webrtc .video.tr .localVideo{top:0;bottom:auto;left:auto!important;right:0}.bdsft-webrtc .video.br .localVideo{top:auto;bottom:0;left:auto!important;right:0}.bdsft-webrtc .video._1x .localVideo{width:25%;height:25%}.bdsft-webrtc .video._2x .localVideo{width:50%;height:50%}.bdsft-webrtc .video:not(.showLocal):not(.showRemote){display:none!important}.bdsft-webrtc .video.started:not(.hasRemote):not(.hasLocal){animation:slowNoSize 1s;width:0;height:0}.bdsft-webrtc .video.enableSelfView.showRemote.hasRemote .remote{animation:slowShow 1s;opacity:1}.bdsft-webrtc .video.enableSelfView.showLocal:not(.started) .localVideo,.bdsft-webrtc .video.enableSelfView.started.showLocal.hasRemote.hasLocal .localVideo{animation:slowShow .5s;opacity:1}.bdsft-webrtc .video.enableSelfView.started.showLocal:not(.hasRemote).hasLocal .localVideo,.bdsft-webrtc .video.enableSelfView.started.showLocal:not(.showRemote).hasLocal .localVideo{animation:slowFullSize 1s,slowShow 1s;opacity:1;width:100%;height:100%}.bdsft-webrtc .video:not(.showRemote) .remote,.bdsft-webrtc .video.started:not(.hasRemote) .remote{animation:slowHide 1s;opacity:0}.bdsft-webrtc .video:not(.showLocal) .localVideo,.bdsft-webrtc .video.started:not(.hasLocal) .localVideo{animation:slowHide .5s;opacity:0}@-moz-keyframes slowShow{0%{opacity:0}90%{opacity:0}100%{opacity:1}}@-webkit-keyframes slowShow{0%{opacity:0}90%{opacity:0}100%{opacity:1}}@-o-keyframes slowShow{0%{opacity:0}90%{opacity:0}100%{opacity:1}}@keyframes slowShow{0%{opacity:0}90%{opacity:0}100%{opacity:1}}@-moz-keyframes slowHide{0%{opacity:1}90%{opacity:1}100%{opacity:0}}@-webkit-keyframes slowHide{0%{opacity:1}90%{opacity:1}100%{opacity:0}}@-o-keyframes slowHide{0%{opacity:1}90%{opacity:1}100%{opacity:0}}@keyframes slowHide{0%{opacity:1}90%{opacity:1}100%{opacity:0}}@-moz-keyframes slowNoSize{0%{width:auto;height:auto}90%{width:auto;height:auto}100%{width:0;height:0}}@-webkit-keyframes slowNoSize{0%{width:auto;height:auto}90%{width:auto;height:auto}100%{width:0;height:0}}@-o-keyframes slowNoSize{0%{width:auto;height:auto}90%{width:auto;height:auto}100%{width:0;height:0}}@keyframes slowNoSize{0%{width:auto;height:auto}90%{width:auto;height:auto}100%{width:0;height:0}}@-moz-keyframes slowFullSize{0%{width:25%;height:25%}90%{width:25%;height:25%}100%{width:100%;height:100%}}@-webkit-keyframes slowFullSize{0%{width:25%;height:25%}90%{width:25%;height:25%}100%{width:100%;height:100%}}@-o-keyframes slowFullSize{0%{width:25%;height:25%}90%{width:25%;height:25%}100%{width:100%;height:100%}}@keyframes slowFullSize{0%{width:25%;height:25%}90%{width:25%;height:25%}100%{width:100%;height:100%}}.bdsft-webrtc :-webkit-full-screen .remote{z-index:1}.bdsft-webrtc :-webkit-full-screen .localVideo{z-index:2}.bdsft-webrtc :-webkit-full-screen .remote,.bdsft-webrtc :-webkit-full-screen .localVideo{border:0;border-radius:0}.bdsft-webrtc .video{background:url('data:image/svg+xml;base64,<%= videobg %>') no-repeat left center;background-size:cover}"}
},{}],1183:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // video.jade compiled template
    templatizer["video"] = function tmpl_video() {
        return '<div class="bdsft-webrtc"><div class="video classes"><div class="content"><video autoplay="autoplay" class="remote"></video><div class="localVideo"><div class="inner"><video autoplay="autoplay" muted="true" class="local"></video></div></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1184:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Video, {
  config: require('../../js/config.js')
});

var Constants = require('webrtc-core').constants
function Video(eventbus, debug, urlconfig, cookieconfig, sipstack, fullscreen) {
  var self = {};

  self.updateShowLocal = function(audioOnly){
    self.showLocal = !audioOnly;
  };
  self.updateShowRemote = function(offerToReceiveVideo){
    self.showRemote = offerToReceiveVideo;
  };
  self.updateSipStackAudioOnly = function(showLocal){
    sipstack.audioOnly = !showLocal;
  };
  self.updateSipStackOfferTocReceiveVideo = function(showRemote){
    sipstack.offerToReceiveVideo = showRemote;
  };

  self.props = ['localStream', 'remoteStream', 'classes', 'hasRemote', 'hasLocal', 'showLocal', 'showRemote'];

  self.bindings = {
    'classes': {
      video: ['displayResolution', 'enableSelfView', 'selfViewLocation', 'selfViewSize', 'hasLocal', 'hasRemote', 'showLocal', 'showRemote'],
      fullscreen: 'visible',
      sipstack: 'callState',
      urlconfig: 'hd',
      cookieconfig: ['hd']
    },
    displayResolution: {
      cookieconfig: 'displayResolution'
    },
    enableSelfView: {
      cookieconfig: 'enableSelfView',
      urlconfig: 'enableSelfView'
    },
    showLocal: {
      sipstack: 'audioOnly'
    },
    showRemote: {
      sipstack: 'offerToReceiveVideo'
    },
    sipStackAudioOnly: {
      self: 'showLocal'
    },
    sipStackOfferTocReceiveVideo: {
      self: 'showRemote'
    }
  }

  self.validateUserMediaResolution = function(videoWidth, videoHeight) {
    var encodingWidth = sipstack.encodingResolutionWidth();
    var encodingHeight = sipstack.encodingResolutionHeight();
    debug.debug("validating video resolution " + videoWidth + "," + videoHeight + " to match selected encoding " + encodingWidth + "," + encodingHeight);
    if (!videoWidth && !videoHeight) {
      return;
    }

    if (encodingWidth !== videoWidth || encodingHeight !== videoHeight) {
      var msg = "Video resolution " + videoWidth + "," + videoHeight + " does not match selected encoding " + encodingWidth + "," + encodingHeight;
      debug.debug(msg);
    }
  };

  self.listeners = function() {
    eventbus.on("userMediaUpdated", function(e) {
      self.updateStreams([e && e.localStream], []);
    });
    eventbus.on(["iceconnected", "icecompleted"], function(e) {
      self.updateSessionStreams(e.sender);
    });
    eventbus.on('started', function(e) {
      self.hasRemote = e.sender.hasRemoteVideo();
      self.hasLocal = e.sender.hasLocalVideo();
    });
  };

  self.isMediaFlowing = function(streams) {
    if (!streams || streams.length === 0) {
      return false;
    }
    var tracks = streams.map(function(stream) {
      return stream && stream.getTracks && stream.getTracks();
    });
    if (!tracks) {
      return false;
    }
    tracks = [].concat.apply([], tracks);
    for (var i = 0; i < tracks.length; i++) {
      if (tracks[i] && tracks[i].readyState !== 'live') {
        debug.info('track is NOT live : ' + JSON.stringify(tracks[i]));
        return false;
      }
    }
    return true;
  };

  self.hasStream = function(streams) {
    return streams && streams.length > 0 && typeof(streams[0]) !== 'undefined' && !streams[0].ended;
  };

  var getVideoTrack = function(stream) {
    return stream && stream.getVideoTracks().length && stream.getVideoTracks()[0];
  };

  self.getRemoteVideoTrack = function() {
    return getVideoTrack(self.remoteStream);
  };

  self.getLocalVideoTrack = function() {
    return getVideoTrack(self.localStream);
  };

  self.updateSessionStreams = function(session) {
    session = session || sipstack.activeSession;
    if (session) {
      debug.debug("updating session streams : " + session.id);
      self.updateStreams(session.getLocalStreams(), session.getRemoteStreams());
    }
  };

  self.updateStreams = function(localStreams, remoteStreams) {
    debug.debug("updating video streams");
    self.setVideoStream('localStream', localStreams);
    self.setVideoStream('remoteStream', remoteStreams);
    if(self.remoteStream) {
      self.remoteStream.onactive = function(){
        debug.log('remoteStream.onactive');
      };
      self.remoteStream.onaddtrack = function(){
        debug.log('remoteStream.onaddtrack');
      };
      self.remoteStream.onended = function(){
        debug.log('remoteStream.onended');
      };
      self.remoteStream.oninactive = function(){
        debug.log('remoteStream.oninactive');
      };
      self.remoteStream.onremovetrack = function(){
        debug.log('remoteStream.onremovetrack');
      };
    }

    if(self.remoteStream && self.remoteStream.getVideoTracks().length > 0) {
      var videoTrack = self.remoteStream.getVideoTracks()[0];
      debug.log('adding listeners to remoteStream video track : '+videoTrack.id+', '+videoTrack.readyState);
      videoTrack.onstarted = function () {
        debug.log('remoteStream.onstarted');
        self.hasRemote = true;
      }
      videoTrack.onended = function () {
        debug.log('remoteStream.onended');
        self.hasRemote = false;
      }
      videoTrack.onmute = function () {
        debug.log('remoteStream.onmute');
        self.hasRemote = false;
      }
      videoTrack.onunmute = function () {
        debug.log('remoteStream.onunmute');
        self.hasRemote = true;
      }
    }
  };

  self.setVideoStream = function(localOrRemote, streams) {
    var mediaFlowing = self.isMediaFlowing(streams);
    if (!mediaFlowing) {
      debug.info('media is NOT flowing');
    }

    if (self.hasStream(streams)) {
      debug.log("setVideoStream : " + localOrRemote + " : " +streams[0].id);
      self[localOrRemote] = streams[0];
    } else {
      debug.log("setVideoStream : " + localOrRemote + " : end ");
      self[localOrRemote] = null;
    }
  };

  return self;
}
},{"../../js/config.js":1180,"webrtc-core":1189}],1185:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(VideoView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  image: require('../../js/images')
});

// require('jquery-ui/draggable');

function VideoView(eventbus, debug, video, sipstack) {
  var self = {}; 

  self.model = video;

  self.elements = ['local', 'remote'];

  self.init = function() {
    // Allow some windows to be draggable, required jQuery.UI
    // TODO - allow draggable window
    // if (configuration.enableWindowDrag) {
    //   self.localVideo.draggable && self.localVideo.draggable({
    //     snap: ".remoteVideo,.videoBar",
    //     containment: ".main",
    //     snapTolerance: 200,
    //     stop: function(event, ui) {
    //       settings.updateViewPositions();
    //     }
    //   });
    // }
  };

  self.listeners = function(databinder) {
    // TODO - implement without dependency on history
    // self.view.bind("click", function(e) {
    //   eventbus.viewChanged({visible: false, viewName: 'history'})
    // });
    databinder.onModelPropChange('localStream', function(stream){
      self.playOrEnd(self.localEl(), stream);
    });
    databinder.onModelPropChange('remoteStream', function(stream){
      self.playOrEnd(self.remoteEl(), stream);
    });
    self.local.bind("playing", function() {
      video.validateUserMediaResolution(self.localWidth(), self.localHeight());
    });
    self.remote.bind('progress', function(e) {
      video.hasRemote = video.getRemoteVideoTrack().readyState === 'live';
    });
    self.local.bind('progress', function(e) {
      video.hasLocal = video.getLocalVideoTrack().readyState === 'live';
    });
    // self.remote.bind('abort canplay canplaythrough durationchange emptied encrypted ended error interruptbegin interruptend loadeddata '+
    //   'loadedmetadata loadstart mozaudioavailable pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting', function(e) {
    //   debug.log('remote.'+e.type);
    // });
    eventbus.on("ended", function(e) {
      debug.debug('ending remote video');
      self.end(self.remoteEl());
      if(!sipstack.enableConnectLocalMedia) {
        debug.debug('ending local video');
        self.end(self.localEl());
      } 
    });
  };

  self.playOrEnd = function(videoEl, stream) {
    if(stream) {
      self.play(videoEl, stream);
    } else {
      self.end(videoEl);
    }
  };

  self.play = function(videoEl, stream) {
    if (videoEl && videoEl.mozSrcObject !== undefined) {
      videoEl.mozSrcObject = stream;
      videoEl.play();
    } else {
      var src = (window.URL && window.URL.createObjectURL(stream)) || stream;
      debug.debug('src : ' + src);
      videoEl.src = src;
    }
  };

  self.end = function(videoEl) {
    if (videoEl.mozSrcObject !== undefined) {
      videoEl.mozSrcObject = null;
    } else {
      videoEl.src = "";
    }
  };

  self.isVideoActive = function(videoEl) {
    return !(videoEl.readyState <= HTMLMediaElement.HAVE_CURRENT_DATA || videoEl.paused || videoEl.currentTime <= 0);
  };

  self.localEl = function() {
    return self.local[0];
  };

  self.remoteEl = function() {
    return self.remote[0];
  };

  self.localWidth = function() {
    return self.local[0].videoWidth;
  };

  self.localHeight = function() {
    return self.local[0].videoHeight;
  };

  return self;
}
},{"../../js/images":1181,"../../js/styles":1182,"../../js/templates":1183,"webrtc-core":1189}],1186:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1187:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1188:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1189:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1188,"./bdsft":1190,"./constants":1193,"./cookieconfig":1194,"./cookieprop":1195,"./dateformat":1198,"./debug":1199,"./element":1200,"./eventbus":1201,"./factory":1202,"./icon":1203,"./loader":1204,"./popup":1205,"./prop":1206,"./urlconfig":1208,"./utils":1209,"./visibleprop":1210,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1190:[function(require,module,exports){
module.exports=require(54)
},{"./app":1189,"./binding":1191,"./classesbinding":1192,"./databinder":1197,"./stylesmanager":1207,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1234}],1191:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1190,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1192:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1191,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1193:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1194:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1190,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1234,"jquery.cookie":1233}],1195:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1193,"./prop":1206,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1234,"jquery.cookie":1233}],1196:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1193,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1215}],1197:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1218}],1198:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1199:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1186,"./bdsft":1190,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1211,"stacktrace-js":1236}],1200:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1201:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1190,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1218}],1202:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1234}],1203:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1204:[function(require,module,exports){
module.exports=require(68)
},{"../":1189,"./constants":1193,"./factory":1202,"./stylesmanager":1207,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1214}],1205:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1234}],1206:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1235}],1207:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1187,"./constants":1193,"./css":1196,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1208:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1186,"./bdsft":1190,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1209:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1188,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1234}],1210:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1193,"./prop":1206,"./utils":1209,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1211:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1212,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1212:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1213}],1213:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1214:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1215:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1216,"./utils":1217,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1216:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1217:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1218:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1219,"es5-ext/object/valid-callable":1228}],1219:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1220,"es5-ext/object/is-callable":1223,"es5-ext/object/normalize-options":1227,"es5-ext/string/#/contains":1230}],1220:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1221,"./shim":1222,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1221:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1222:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1224,"../valid-value":1229,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1223:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1224:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1225,"./shim":1226,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1225:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1226:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1227:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1228:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1229:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1230:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1231,"./shim":1232,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1231:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1232:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1233:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1234}],1234:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1235:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1236:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1237:[function(require,module,exports){
module.exports = {view: require('./lib/views/videobar'), model: require('./lib/models/videobar')};
},{"./lib/models/videobar":1241,"./lib/views/videobar":1242}],1238:[function(require,module,exports){
module.exports = {
    enableHold: true
};
},{}],1239:[function(require,module,exports){
module.exports = {"videobar":".bdsft-webrtc .videoBar{position:relative;top:0;left:0;width:100%;height:40px;background:#000;background-image:-ms-linear-gradient(center top,#404040,#000);background-image:linear-gradient(to bottom,#404040,#000);background-image:-webkit-linear-gradient(#404040,#000);background-image:-moz-linear-gradient(top,#404040,#000);border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #000;margin-top:5px;background-image:none;border-radius:0;border:0;box-shadow:none;margin-top:0;background:#292929;border-top:1px solid #3c3c3c}.bdsft-webrtc .videoBar .icon{margin:0 2.5px;position:absolute}.bdsft-webrtc .videoBar .table{height:100%;margin:6px;margin:0}.bdsft-webrtc .videoBar .cell{position:relative;top:0;left:0;width:35px;width:36px}.bdsft-webrtc .videoBar .cell .icon{width:100%;text-align:center;margin-top:10px;margin-right:0;margin-left:0}.bdsft-webrtc .videoBar .cell .icon a{margin:0}.bdsft-webrtc .videoBar .cell:first-child{padding:0}.bdsft-webrtc .videoBar span{color:#808080}.bdsft-webrtc .videoBar .unmuteAudio{margin-top:-1px}.bdsft-webrtc .videoBar .leftSpacer{width:8px}.bdsft-webrtc .videoBar .cell-hangup{width:42px}.bdsft-webrtc .videoBar .subtitle{display:none}.bdsft-webrtc .videoBar .timerHolder{position:relative;top:0;left:0;width:auto}.bdsft-webrtc .videoBar .rightSpacer{width:8px}.bdsft-webrtc .videoBar._960x720{width:960px}.bdsft-webrtc .videoBar._640x360,.bdsft-webrtc .videoBar._640x480{width:640px}.bdsft-webrtc .videoBar._320x180,.bdsft-webrtc .videoBar._320x240{width:320px}.bdsft-webrtc .videoBar._1280x720,.bdsft-webrtc .videoBar.hd{width:1280px}.bdsft-webrtc .videoBar._1920x1080{width:1920px}.bdsft-webrtc .videoBar .hangup,.bdsft-webrtc .videoBar .fullScreen,.bdsft-webrtc .videoBar .selfView,.bdsft-webrtc .videoBar .mute,.bdsft-webrtc .videoBar .dialpadIcon,.bdsft-webrtc .videoBar .messages{top:0;left:0}.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo){display:inline-block;width:auto}.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo) .table{table-layout:auto;width:auto}.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo) .cell-hangup{width:35px!important}.bdsft-webrtc .videoBar.conference .cell-hangup{width:30px!important;top:2px}.bdsft-webrtc .videoBar.conference .cell .hangup{margin-top:0;width:140px;background-color:#f00;border-radius:5px;margin-left:10px;height:36px;line-height:14px}.bdsft-webrtc .videoBar.conference .hangup .subtitle{display:block!important;font-size:14px;color:#fff}.bdsft-webrtc .videoBar .icon,.bdsft-webrtc .videoBar a{font-size:20px;color:#808080;text-decoration:none}.bdsft-webrtc .videoBar .hold,.bdsft-webrtc .videoBar .resume{margin-top:-1px}.bdsft-webrtc .videoBar .settings{margin-top:12px!important}.bdsft-webrtc .videoBar .settings .icon-settings{margin:0;font-size:18px;color:#fff}.bdsft-webrtc .videoBar.fullscreen-shown{top:auto!important;bottom:0;position:absolute;width:100%}.bdsft-webrtc .videoBar.conference .icon-hangup:before,.bdsft-webrtc .videoBar.conference .icon-hangup:hover:before{color:#fff!important}.bdsft-webrtc .videoBar.conference .selfViewHide,.bdsft-webrtc .videoBar.conference .selfViewShow{text-align:right!important}.bdsft-webrtc .videoBar.conference .fullscreenExpand,.bdsft-webrtc .videoBar.conference .fullscreenContract{text-align:left!important}.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo) .fullscreenExpand,.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo) .fullscreenContract,.bdsft-webrtc .videoBar.audioOnly:not(.offerToReceiveVideo) .fullscreenHolder{display:none!important}.bdsft-webrtc .videoBar.selfViewShow a,.bdsft-webrtc .videoBar.dialpadHide a,.bdsft-webrtc .videoBar.unmuteAudio a,.bdsft-webrtc .videoBar.fullscreenContract a{color:#04aff0!important}.bdsft-webrtc .videoBar.started .hangup,.bdsft-webrtc .videoBar.calling .hangup,.bdsft-webrtc .videoBar:not(.held).enableHold.started .hold,.bdsft-webrtc .videoBar.enableHold.held .resume,.bdsft-webrtc .videoBar.enableSettings .settings,.bdsft-webrtc .videoBar.enableSelfView:not(.showLocal) .selfViewShow,.bdsft-webrtc .videoBar.enableSelfView.showLocal .selfViewHide,.bdsft-webrtc .videoBar.enableTransfer.started .transfer,.bdsft-webrtc .videoBar.enableCallControl.callcontrol-shown .dialpadHide,.bdsft-webrtc .videoBar.enableCallControl:not(.callcontrol-shown) .dialpadShow{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .videoBar.connected .hangup,.bdsft-webrtc .videoBar.disconnected .hangup,.bdsft-webrtc .videoBar.held .hold,.bdsft-webrtc .videoBar:not(.started) .hold,.bdsft-webrtc .videoBar:not(.started) .resume,.bdsft-webrtc .videoBar:not(.held) .resume,.bdsft-webrtc .videoBar:not(.enableSettings) .settings,.bdsft-webrtc .videoBar.enableSelfView.showLocal .selfViewShow,.bdsft-webrtc .videoBar.enableSelfView:not(.showLocal) .selfViewHide,.bdsft-webrtc .videoBar.enableTransfer.connected .transfer,.bdsft-webrtc .videoBar.enableTransfer.disconnected .transfer,.bdsft-webrtc .videoBar.enableCallControl:not(.callcontrol-shown) .dialpadHide,.bdsft-webrtc .videoBar.enableCallControl.callcontrol-shown .dialpadShow{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}.bdsft-webrtc .videoBar:not(.enableTransfer) .cell-transfer,.bdsft-webrtc .videoBar:not(.enableHold) .cell-hold,.bdsft-webrtc .videoBar:not(.enableCallTimer) .cell-timer,.bdsft-webrtc .videoBar:not(.enableSelfView) .cell-selfView,.bdsft-webrtc .videoBar:not(.enableSettings) .cell-settings,.bdsft-webrtc .videoBar:not(.enableCallControl) .cell-dialpad,.bdsft-webrtc .videoBar:not(.enableMute) .muteHolder,.bdsft-webrtc .videoBar:not(.enableCallTimer) .timerHolder,.bdsft-webrtc .videoBar:not(.enableFullscreen) .fullscreenHolder{display:none!important}"}
},{}],1240:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // videobar.jade compiled template
    templatizer["videobar"] = function tmpl_videobar() {
        return '<div class="bdsft-webrtc"><div class="videoBar classes"><div class="table fixed collapse"><div class="cell leftSpacer"></div><div class="cell cell-selfView"><div class="selfViewHide icon fadeable"><a href="" title="Disable Video" class="icon-selfViewHide"></a></div><div class="selfViewShow icon fadeable"><a href="" title="Enable Video" class="icon-selfViewShow"></a></div></div><div class="cell cell-dialpad"><div class="dialpadShow icon fadeable"><a href="" title="Show Dialpad" class="icon-dialpadShow"></a></div><div class="dialpadHide icon fadeable"><a href="" title="Hide Dialpad" class="icon-dialpadHide"></a></div></div><div class="cell"><div class="icon xmppHolder xmpp"></div></div><div class="cell muteHolder"></div><div class="cell cell-hold"><div class="hold icon fadeable"><a href="" title="Hold Call" class="icon-hold"></a></div><div class="resume icon fadeable"><a href="" title="Resume Call" class="icon-resume"></a></div></div><div class="cell cell-hangup"><div class="hangup icon fadeable"><a href="" title="Hangup" class="icon-hangup"></a><div class="subtitle">End Conference</div></div></div><div class="cell cell-transfer"><div class="transfer icon fadeable"><a href="" title="Transfer" class="icon-transfer"></a></div></div><div class="cell timerHolder"></div><div class="cell cell-settings"><div class="settings icon fadeable"><a href="" title="Settings" class="icon-settings"></a></div></div><div class="cell fullscreenHolder"></div><div class="cell rightSpacer"></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1241:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Videobar, {
  config: require('../../js/config.js')
});

var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function Videobar(sipstack, sound, video, callcontrol, fullscreen, transfer, timer, settings, urlconfig, cookieconfig, audio) {
  var self = {};

  self.props = ['classes'];

  self.bindings = {
    classes: {
        audio: 'enableMute',
        videobar: ['enableHold'],
        sipstack: ['callState', 'audioOnly', 'offerToReceiveVideo'],
        fullscreen: ['visible', 'enableFullscreen'],
        video: ['displayResolution', 'enableSelfView', 'showLocal'],
        callcontrol: ['visible', 'enableCallControl'],
        transfer: 'enableTransfer',
        timer: 'enableCallTimer',
        settings: 'enableSettings',
        urlconfig: ['hd'],
        cookieconfig: 'hd'
    },
    enableHold: {
      urlconfig: 'enableHold'
    }
  };

  return self;
}
},{"../../js/config.js":1238,"webrtc-core":1246}],1242:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(VideobarView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles')
});

var Icon = require('webrtc-core').icon;
var Constants = require('webrtc-core').constants;
var Utils = require('webrtc-core').utils;

function VideobarView(eventbus, sipstack, sound, timerView, videobar, callcontrol, video, settings, fullscreenView, audioView, transfer, 
  urlconfig, xmppHandleView) {
  var self = {};

  self.elements = ['transfer', 'settings', 'dialpadShow', 'dialpadHide', 'timerHolder', 'fullscreenHolder', 'muteHolder', 'hangup', 'selfViewShow', 'selfViewHide',
   'hold', 'resume', 'cell', 'xmppHolder'
  ];

  var clickHander = function(callback){
    return function(e) {
      e.preventDefault();
      sound.playClick();
      callback();
    }
  }

  self.insertView = function(view, position) {
    view.view.insertAfter(self.cell[position]);
  };

  self.init = function() {
    fullscreenView.view.appendTo(self.fullscreenHolder);
    audioView.view.appendTo(self.muteHolder);
    timerView.view.appendTo(self.timerHolder);
    xmppHandleView.view.appendTo(self.xmppHolder);
  };

  self.listeners = function() {
    self.hold = new Icon(self.hold, sound);
    self.resume = new Icon(self.resume, sound);

    eventbus.on(['held', 'resumed'], function(e) {
      self.hold.enable();
      self.resume.enable();
    });
    self.transfer.bind('click', clickHander(function() {
      transfer.toggle();
    }));
    self.settings.bind('click', clickHander(function() {
      settings.toggle();
    }));
    self.dialpadShow.bind('click', clickHander(function() {
      callcontrol.show();
    }));
    self.dialpadHide.bind('click', clickHander(function() {
      callcontrol.hide();
    }));
    self.selfViewHide.bind('click', clickHander(function() {
      video.showLocal = false;
    }));
    self.selfViewShow.bind('click', clickHander(function() {
      video.showLocal = true;
      video.showRemote = true;
    }));
    self.hold.onClick(function(e) {
      self.hold.disable();
      sipstack.hold();
    });
    self.resume.onClick(function(e) {
      self.resume.disable();
      sipstack.unhold();
    });
    self.hangup.bind('click', clickHander(function() {
      eventbus.endCall();
    }));

  };

  return self;
}
},{"../../js/styles":1239,"../../js/templates":1240,"webrtc-core":1246}],1243:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1244:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1245:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1246:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1245,"./bdsft":1247,"./constants":1250,"./cookieconfig":1251,"./cookieprop":1252,"./dateformat":1255,"./debug":1256,"./element":1257,"./eventbus":1258,"./factory":1259,"./icon":1260,"./loader":1261,"./popup":1262,"./prop":1263,"./urlconfig":1265,"./utils":1266,"./visibleprop":1267,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1247:[function(require,module,exports){
module.exports=require(54)
},{"./app":1246,"./binding":1248,"./classesbinding":1249,"./databinder":1254,"./stylesmanager":1264,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1291}],1248:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1247,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1249:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1248,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1250:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1251:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1247,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1291,"jquery.cookie":1290}],1252:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1250,"./prop":1263,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1291,"jquery.cookie":1290}],1253:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1250,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1272}],1254:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1275}],1255:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1256:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1243,"./bdsft":1247,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1268,"stacktrace-js":1293}],1257:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1258:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1247,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1275}],1259:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1291}],1260:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1261:[function(require,module,exports){
module.exports=require(68)
},{"../":1246,"./constants":1250,"./factory":1259,"./stylesmanager":1264,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1271}],1262:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1291}],1263:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1292}],1264:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1244,"./constants":1250,"./css":1253,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1265:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1243,"./bdsft":1247,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1266:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1245,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1291}],1267:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1250,"./prop":1263,"./utils":1266,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1268:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1269,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1269:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1270}],1270:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1271:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1272:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1273,"./utils":1274,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1273:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1274:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1275:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1276,"es5-ext/object/valid-callable":1285}],1276:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1277,"es5-ext/object/is-callable":1280,"es5-ext/object/normalize-options":1284,"es5-ext/string/#/contains":1287}],1277:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1278,"./shim":1279,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1278:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1279:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1281,"../valid-value":1286,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1280:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1281:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1282,"./shim":1283,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1282:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1283:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1284:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1285:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1286:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1287:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1288,"./shim":1289,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1288:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1289:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1290:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1291}],1291:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1292:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1293:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}],1294:[function(require,module,exports){
module.exports = {
	view: require('./lib/views/xmpp'), 
	model: require('./lib/models/xmpp'), 
	addcontact: require('./lib/models/addcontact'), 
	addcontactview: require('./lib/views/addcontact'), 
	chat: require('./lib/models/chat'),
	chatview: require('./lib/views/chat'),
	chats: require('./lib/models/chats'),
	chatsview: require('./lib/views/chats'),
	chattab: require('./lib/models/chattab'),
	chattabview: require('./lib/views/chattab'),
	contact: require('./lib/models/contact'),
	contactview: require('./lib/views/contact'),
	contacts: require('./lib/models/contacts'),
	contactsview: require('./lib/views/contacts'),
	handle: require('./lib/models/handle'),
	handleview: require('./lib/views/handle'), 
	message: require('./lib/models/message'),
	messageview: require('./lib/views/message'),
	mycontact: require('./lib/models/mycontact'),
	mycontactview: require('./lib/views/mycontact'),
	subscription: require('./lib/models/subscription'),
	subscriptionview: require('./lib/views/subscription'),
	subscriptions: require('./lib/models/subscriptions'),
	subscriptionsview: require('./lib/views/subscriptions'),
	client: require('./lib/client'),
	eventbus: require('webrtc-core').eventbus
};
},{"./lib/client":1298,"./lib/models/addcontact":1300,"./lib/models/chat":1301,"./lib/models/chats":1302,"./lib/models/chattab":1303,"./lib/models/contact":1304,"./lib/models/contacts":1305,"./lib/models/handle":1306,"./lib/models/message":1307,"./lib/models/mycontact":1308,"./lib/models/subscription":1309,"./lib/models/subscriptions":1310,"./lib/models/xmpp":1311,"./lib/views/addcontact":1312,"./lib/views/chat":1313,"./lib/views/chats":1314,"./lib/views/chattab":1315,"./lib/views/contact":1316,"./lib/views/contacts":1317,"./lib/views/handle":1318,"./lib/views/message":1319,"./lib/views/mycontact":1320,"./lib/views/subscription":1321,"./lib/views/subscriptions":1322,"./lib/views/xmpp":1323,"webrtc-core":1609}],1295:[function(require,module,exports){
module.exports = {
    enableXMPP: false,
    boshURL: 'https://ums.broadsoftlabs.com:5281',
    removeContactFailed: 'Could not Remove Contact'
};
},{}],1296:[function(require,module,exports){
module.exports = {"addcontact":".bdsft-webrtc .addcontact{margin-bottom:14px;padding:8px;background-color:#e6e6e6;border-top:1px solid #d8d8d8;border-bottom:1px solid #d8d8d8}.bdsft-webrtc .addcontact .addLink{border:0;border-radius:4px;padding:5px 10px;font-size:13px;color:#fff;background-color:#737373;text-align:center;display:inline-block;text-decoration:none}.bdsft-webrtc .addcontact .addLink i{margin-right:6px}.bdsft-webrtc .addcontact .addLink:hover{background:#616161}.bdsft-webrtc .addcontact .cancelLink{display:none}.bdsft-webrtc .addcontact .form{display:none}.bdsft-webrtc .addcontact .form input{display:block;background:#fff;border:1px solid #d6d6d6;color:#606060;font-size:14px;padding:8px;border-radius:0;margin-bottom:8px;width:100%;box-sizing:border-box}.bdsft-webrtc .addcontact .form input::-webkit-input-placeholder{color:#d3d3d3}.bdsft-webrtc .addcontact .form input:-moz-placeholder{color:#d3d3d3}.bdsft-webrtc .addcontact .form input::-moz-placeholder{color:#d3d3d3}.bdsft-webrtc .addcontact .form input:-ms-input-placeholder{color:#d3d3d3}.bdsft-webrtc .addcontact .form .form-row button{border:0;border-radius:4px;padding:5px 10px;font-size:13px;color:#fff;background-color:#737373;text-align:center;display:inline-block;text-decoration:none;margin-left:6px}.bdsft-webrtc .addcontact .form .form-row button:hover{box-shadow:none;background:#616161}.bdsft-webrtc .addcontact .form .form-row:last-child{text-align:right}.bdsft-webrtc .addcontact.addcontact-shown .cancelLink,.bdsft-webrtc .addcontact.addcontact-shown .form{display:block}.bdsft-webrtc .addcontact.addcontact-shown .addLink{display:none}","chat":".bdsft-webrtc .chatXmpp{display:none;height:477px;position:relative}.bdsft-webrtc .chatXmpp .name{background-color:#fbfbfb;padding:8px;font-weight:bold;color:#616161;border-bottom:3px solid #03afef}.bdsft-webrtc .chatXmpp .input{position:absolute;bottom:0;width:100%;height:100px;background:#fff;border:1px solid #d6d6d6;color:#606060;font-size:14px;padding:8px;border-radius:0;box-sizing:border-box;border-right:0;border-left:0}.bdsft-webrtc .chatXmpp .input::-webkit-input-placeholder{color:#d3d3d3}.bdsft-webrtc .chatXmpp .input:-moz-placeholder{color:#d3d3d3}.bdsft-webrtc .chatXmpp .input::-moz-placeholder{color:#d3d3d3}.bdsft-webrtc .chatXmpp .input:-ms-input-placeholder{color:#d3d3d3}.bdsft-webrtc .chatXmpp.selected{display:block}","chats":".bdsft-webrtc .chatsView{display:none;position:absolute;top:0;left:285px;min-width:323px;min-height:250px;background-color:#f3f3f3;border:1px solid #d6d6d6}.bdsft-webrtc .chatsView .chatsContent{position:relative}.bdsft-webrtc .chatsView.contactSelected{display:block}","chattab":".bdsft-webrtc .chatTab{background-color:#e0e0e0}.bdsft-webrtc .chatTab .chatTabContent .contact{display:inline-block;border:0;width:140px;background-color:#f5f5f5;border-right:1px solid #d6d6d6;vertical-align:top}.bdsft-webrtc .chatTab .chatTabContent .contact:hover{background-color:#eee}.bdsft-webrtc .chatTab .chatTabContent .contact.selected{-webkit-box-shadow:inset 0 3px 0 0 #03afef;-moz-box-shadow:inset 0 3px 0 0 #03afef;box-shadow:inset 0 3px 0 0 #03afef}.bdsft-webrtc .chatTab .chatTabContent .contact .presence{position:static;margin-top:15px;margin-left:10px;display:inline-block;text-decoration:none;font-size:14px;color:#989898;background:0;width:14px;height:14px;margin-right:0}.bdsft-webrtc .chatTab .chatTabContent .contact .remove{display:none}.bdsft-webrtc .chatTab .chatTabContent .contact .name{position:static;font-size:13px;font-weight:bold;color:#606060;margin-left:8px;display:inline-block;line-height:15px;vertical-align:bottom;width:100px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;cursor:pointer}.bdsft-webrtc .chatTab .chatTabContent .contact .close{display:none;margin-top:15px;margin-left:10px;text-decoration:none;font-size:14px;color:#989898;width:14px;height:14px}.bdsft-webrtc .chatTab .chatTabContent .contact .close:hover{color:#666}.bdsft-webrtc .chatTab .chatTabContent .contact:hover .close{display:inline-block}.bdsft-webrtc .chatTab .chatTabContent .contact:hover .presence{display:none}.bdsft-webrtc .chatTab .chatTabContent .contact.available .presence{color:#8bc34a}.bdsft-webrtc .chatTab .chatTabContent .contact.dnd .presence{color:#b71c1c}.bdsft-webrtc .chatTab .chatTabContent .contact.away .presence{color:#e65100}.bdsft-webrtc .chatTab .chatTabContent .contact.unavailable .presence{color:#212121}","contact":".bdsft-webrtc .contact{cursor:pointer;height:42px;background-color:#fbfbfb;border-top:1px solid #ddd;position:relative}.bdsft-webrtc .contact:last-child{border-bottom:1px solid #ddd}.bdsft-webrtc .contact .name{display:inline-block;font-weight:bold;color:#606060;cursor:pointer;vertical-align:bottom;line-height:11px;width:220px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden}.bdsft-webrtc .contact .presence{width:12px;height:12px;display:inline-block;cursor:pointer;vertical-align:top;margin-left:10px;margin-right:12px;margin-top:14px}.bdsft-webrtc .contact.available .presence{color:#8bc34a}.bdsft-webrtc .contact.dnd .presence{color:#b71c1c}.bdsft-webrtc .contact.away .presence{color:#e65100}.bdsft-webrtc .contact.unavailable .presence{color:#212121}.bdsft-webrtc .contact .close{display:none}.bdsft-webrtc .contact .remove{display:none;text-decoration:none;float:right;font-size:16px;color:#989898;margin-top:14px;margin-right:10px}.bdsft-webrtc .contact .remove:hover{color:#666}.bdsft-webrtc .contact:hover{background:#eee}.bdsft-webrtc .contact:hover .remove{display:inline-block}","contacts":".bdsft-webrtc .contactsView{border:1px solid #000;position:absolute;top:0;left:2px;min-width:280px;min-height:519px;background-color:#f3f3f3;border:1px solid #d6d6d6}.bdsft-webrtc .contactsView .removeContactFailed{display:none}.bdsft-webrtc .contactsView .error{color:#f00}","handle":".bdsft-webrtc .xmppHandle{text-align:center}.bdsft-webrtc .xmppHandle .toggleVisibility{text-decoration:none}.bdsft-webrtc .xmppHandle.enableXMPP{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:20}.bdsft-webrtc .xmppHandle:not(.enableXMPP){transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}","jquery.ui.resizable":".ui-resizable{position:absolute!important}.ui-resizable-handle{position:absolute;font-size:.1px;display:block}.ui-resizable-disabled .ui-resizable-handle,.ui-resizable-autohide .ui-resizable-handle{display:none}.ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}","message":".bdsft-webrtc .message{margin-top:10px;margin-bottom:10px;-webkit-filter:drop-shadow(1px 1px 1px rgba(0,0,4,0.1));filter:drop-shadow(1px 1px 1px rgba(0,0,4,0.1))}.bdsft-webrtc .message .body{font-size:13px;background-color:#2196f3;display:block;width:190px;padding:8px;margin-left:14px;position:relative;border-radius:4px;color:#fff}.bdsft-webrtc .message .body:after{content:\"\";position:absolute;width:0;height:0;border-width:10px;border-style:solid;border-color:transparent #2196f3 transparent transparent;bottom:0;left:-18px;border-bottom-width:0}.bdsft-webrtc .message.incoming{text-align:right}.bdsft-webrtc .message.incoming .body{background-color:#8bc34a;margin-right:14px;display:inline-block}.bdsft-webrtc .message.incoming .body:after{border-color:transparent transparent transparent #8bc34a;bottom:0;right:-8px;left:auto;border-right-width:0}","mycontact":".bdsft-webrtc .mycontact{margin:10px;padding-top:6px;padding-bottom:6px}.bdsft-webrtc .mycontact .presence{background:#607d8b;box-shadow:rgba(96,125,139,0.5) 0 0 0 3px;width:42px;height:42px;border-radius:42px;display:inline-block;margin-right:10px;vertical-align:top;margin-left:4px}.bdsft-webrtc .mycontact .presence i{display:inline-block;width:100%;text-align:center;margin-top:8px;font-size:22px;color:#fff}.bdsft-webrtc .mycontact.available .presence{background:#8bc34a;box-shadow:rgba(139,195,74,0.5) 0 0 0 3px}.bdsft-webrtc .mycontact.dnd .presence{background:#b71c1c;box-shadow:rgba(183,28,28,0.5) 0 0 0 3px}.bdsft-webrtc .mycontact.away .presence{background:#e65100;box-shadow:rgba(230,81,0,0.5) 0 0 0 3px}.bdsft-webrtc .mycontact.unavailable .presence{background:#212121;box-shadow:rgba(33,33,33,0.5) 0 0 0 3px}.bdsft-webrtc .mycontact .name-container{display:inline-block;margin-top:-2px}.bdsft-webrtc .mycontact .name-container .name{font-weight:bold;margin:0 5px;font-size:16px;color:#616161;display:block;width:192px;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;margin-bottom:3px}.bdsft-webrtc .mycontact .name-container .presenceSelect{display:block;width:77px;background-color:rgba(0,0,0,0);border:0;font-size:12px}.bdsft-webrtc .mycontact .name-container .presenceSelect:focus{outline:0}","subscription":".bdsft-webrtc .subscription .name{font-weight:bold}.bdsft-webrtc .subscription .accept,.bdsft-webrtc .subscription .deny{margin:0 5px}.bdsft-webrtc .subscription.accepted,.bdsft-webrtc .subscription.denied{display:none}","subscriptions":".bdsft-webrtc .subscriptionsView{display:none;border:1px solid #000;position:absolute;top:160px;left:10px;min-width:150px;min-height:150px}.bdsft-webrtc .subscriptionsView.hasSubscriptions{display:block}","xmpp-icons":"@font-face{font-family:'xmpp-icons';src:url(\"../fonts/xmpp-icons.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'xmpp-icons';src:url(\"data:application/font-woff;base64,d09GRgABAAAAABZ8AAsAAAAAFjAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIOM2NtYXAAAAFoAAAAdAAAAHT8YK9KZ2FzcAAAAdwAAAAIAAAACAAAABBnbHlmAAAB5AAAEaAAABGgrbW0r2hlYWQAABOEAAAANgAAADYHcM8JaGhlYQAAE7wAAAAkAAAAJAhCBF5obXR4AAAT4AAAAHQAAAB0aoAD1mxvY2EAABRUAAAAPAAAADw17DpkbWF4cAAAFJAAAAAgAAAAIAAlAH9uYW1lAAAUsAAAAaoAAAGq3xoC8HBvc3QAABZcAAAAIAAAACAAAwAAAAMD8QGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA8RgDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEAFgAAAASABAAAwACAAEAIOYU8OXxDPER8Rj//f//AAAAAAAg5gDw5fEM8RHxGP/9//8AAf/jGgQPNA8ODwoPBAADAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABAAD/wAPAA4AAKgAAAQ4BIyImJy4BNTQ2NzYuAiMiDgIxFB4CFx4DMzA+AjU0LgIHAsAwIDAwYDAwUFAwGCRIVBgYQjwqLUlbLy+HkYkwPEg8PlRWGAFAMFBQMDBgMDAgMBhWVD48SDwwiZGHLy9bSS0qPEIYGFRIJBgAAQAHAOAD+QKAADoAAAEeAQcOAS4BNTQ2Jy4BIyIGBwYWFRQOASYnJjY3PgE3OAExPgMzMToBMzoBMzEyHgIXOAExHgEXA/kGARIQYmlTIR8fZj09Zh8fIVNpYhASAQYEHiUcSWaIWwECAQECAVuIZkkcJR4EAYAqYRUSEQkmJCQ4JCMNDSMkOCQkJgkREhVhKhw+JhouIxUVIy4aJj4cAAcAQP/AA8ADwAAEABIAHgAjACgALQAyAAATESERIQEyFhUUBiMiJjU0NjMxEyE1NDYzMTMyFh0BATMVIzURMxUjNREzFSM1ETMVIzXAAwD9AAGANUtLNTVLSzXA/oBLNYA1S/1AYGBgYGBgYGADwPwABAD/AEs1NUtLNTVL/gBANUtLNUACwMDA/wDAwP8AwMD/AMDAAAAAAQB+AB4DXQN9AEgAAAEnAQYUFxYyNwE+ATQmJy4BIgYHAQYwMQ4BFBYXHgEyNjc4ATcxAScBBjAxDgEiJicuATQ2NzgBNzEBNjIXFhQHAQYiJyY0NwECmkH+uygoKHMoAYYhIiIhIlVYVCL+ZwEvLy8vL3Z7di8BARdB/ukBIlRYVCEiISEiAQGZKHIpKCj+eg0nDQ0NAUUCeUH+uyhyKSgoAYYiVFhVIiEiIiH+ZwEvdnt2Ly8vLy8BARdB/ukBIiEhIiFUWFQiAQGZKCgpcij+eg0NDiYNAUUAAAIAAAAABAADVQAFAAsAAAEDNxcTAQkBFxMDAQHMIcvDx/3MAjT8APK5hgLbAUr+tvtXArH99QIL/lsw/oABgAHVAAAAAgAA/80D3wPHADkARgAABTQuAicuATU0Njc2Fjc0JjEwNjc2JicuATcmBgcOARceATEwBhUWNhceARUUBgcOARcUBjEhMDQ1EScHFwcXNxc3JzcnBwMzJz5PKVI+JQsFIAQQCQIDL0oMAydWRi4nGgEDCRAEIAULJSZSUj0BAQMzdjZ7ezd1djZ7ezZ2ByxCNCkSI0hAJhNGHQdCGhI+Hh9rFA0nFQRGIR1PGB4+EhpCBhxGEyZAPSMkclIYFBQYAdJ7N3V2Nnp6NnZ1N3sAAAIAAP/NBAADxwA5AEYAAAU0LgInLgE1NDY3NhY3NCYxMDY3NiYnLgE3JgYHDgEXHgExMAYVFjYXHgEVFAYHDgEXFAYxITA0NRM1IxUjFTMVMzUzNSMDMyY/TylSPiULBSAEEAkCAy9KDAMnVkYuJxoBAwkQBCAFCyUmUlI9AQEDMzNmmppmmpoHKUI2KhIjSEAmE0YdB0IaEj4eH2sUDScVBEYhHU8YHj4SGkIGHEYTJkA9IyRyUhgUFBgB1JmZZ5mZZwABADP/zQPNA8IANwAAAQ4BFx4BMTAGFRY2Fx4BFRQGBw4DHQEhNTQuAicuATU0Njc2Fjc0JjEwNjc2JicuATcmBgcBjCcbAgMIEAUgBAslPlEpUD4nA5onPlApUT4lCwQgBRAIAwIvSQ0CJ1ZHLQNfHU8ZHj0SGkIGHUUUJj9IIxIpMj4mMzMmPjIpESRIPyYURR0GQhoRPh4gahUNJxUERiEAAAIAAP/NBAADxwA5AG0AAAU0LgInLgE1NDY3NhY3NCYxMDY3NiYnLgE3JgYHDgEXHgExMAYVFjYXHgEVFAYHDgEXFAYxITA0NRMuATU0Njc2Fjc0JjEwNjc2JiMiBhceATEwBhUWNhceARUUBgcOAQceAxczMDQ1NCYnAzMnPk8pUj4lCwUgBBAJAgMvSgwDJ1ZGLicaAQMJEAQgBQslJlJSPQEBAzOCLCcYBwMVAwsGAgItSUktAQIGCgIVAwcYKDUCBQIfTUc5DIcdLgcsQjQpEiNIQCYTRh0HQhoSPh4faxQNJxUERiEdTxgePhIaQgYcRhMmQD0jJHJSGBQUGAEoES8pGQwtEwQqEQwoExhbWxgTKAwRKgQTLQwZKS4XAQMBDiY3STBnECY+EwAAAAADAGAAIAOgA2AAFQAqAD8AAAEnJiIPAScmIg8BBhQfARYyPwE2NCcDIg4CFRQeAjMyPgI1NC4CIxEiLgI1ND4CMzIeAhUUDgIjArogBA0EwVsFDAUgBASHBAwF6wUFulaYcUFBcZhWVphxQUFxmFZCdVcyMld1QkJ1VzIyV3VCAh8gBQXAXAQEIAUMBYcEBOwEDQQBQUFxmFZWmHFBQXGYVlaYcUH9IDJXdUJCdVcyMld1QkJ1VzIAAwBgACADoANgABQAKQBOAAAlIi4CNTQ+AjMyHgIVFA4CIxEiDgIVFB4CMzI+AjU0LgIjEwcGIi8BBwYiLwEmND8BJyY0PwE2Mh8BNzYyHwEWFA8BFxYUBwIAVphxQUFxmFZWmHFBQXGYVkJ1VzIyV3VCQnVXMjJXdUKRIAUMBVxcBA0EIQQEXFwEBCEEDQRcXAUMBSAFBVxcBQUgQXGYVlaYcUFBcZhWVphxQQLgMld1QkJ1VzIyV3VCQnVXMv5PIQQEXFwEBCEEDQRcXAUMBSAFBVxcBQUgBQwFXFwEDQQAAAAABABAAAADoANgABQAKQA4AEUAAAEiDgIVFB4CMzI+AjU0LgIjESIuAjU0PgIzMh4CFRQOAiMRIgYdARQWMzI2PQE0JiMRIgYVFBYzMjY1NCYjAfBZnnVERHWeWVmedUREdZ5ZRnpbNTVbekZGels1NVt6RhQcHBQUHBwUFBwcFBQcHBQDYER1nllZnnVERHWeWVmedUT9ADVbekZGels1NVt6RkZ6WzUCIBwUohQcHBSiFBz+wBwUFBwcFBQcAAAAAQAA/8AEAAOAACMAAAEyHgIVFA4CIyImJw4DBzU+ATU0JicuAzU0PgIzAgBqu4tQUIu7ahQoFClaXWAwM00BASxGMRtQi7tqA4BBcZhWVphxQQMCKTMdCgIbGlc0Bw8HHEhSXDFWmHFBAAAAAgAA/8AEgAPAACQASQAAATEyHgIVFA4CIyImJw4DBzU+ATU0JicuAzU0PgIzARQWFxUuAScOASMiJicyPgI3PgE3PgE1NCY1HgEVFAYHDgEVAeBjr4NLS4OvYxMmEiZTV1gtMEQBASlCLhlLg69jAgQyKk2PQxAgEUiBNTdoYlknJz4WFxcBNj9URgEBA8A9aY5QUY1qPQIDJy8bCgEZGFExBw0HGkNNVi5Qjmk9/JkqRRQWAiZCAgIlIBIhMCAfSyksXjEHEAgtd0ROhy4FDAYAAAACAFIAHwOuA3sAFAAhAAABIg4CFRQeAjMyPgI1NC4CIxMHJwcnNyc3FzcXBxcCAFmddEREdJ1ZWZ10RER0nVn1WJ2dWJ2dWJ2dWJ2dA3tEdJ1ZWZ11Q0N1nVlZnXRE/bVYnJxYnZ1YnZ1YnZ0AAAAAAgBSAB8DrgN7ABQAGQAAASIOAhUUHgIzMj4CNTQuAiMBITUhFQIAWZ10RER0nVlZnXRERHSdWQEA/gACAAN7RHSdWVmddUNDdZ1ZWZ10RP4fZmYAAgBSAB8DrgN7ABQAIQAAASIOAhUUHgIzMj4CNTQuAiMBIxUjNSM1MzUzFTMVAgBZnXRERHSdWVmddEREdJ1ZAQDNZs3NZs0De0R0nVlZnXVDQ3WdWVmddET+H83NZs3NZgAAAAMAFP/hA+wDuAAUACMAWwAAASIOAhUUHgIzMj4CNTQuAiMDIy4BNzQ2OwEeARUOASMTDgEPAQ4BBw4BBxUjNT4BNz4BNz4BNz4BNTQmJy4BIyIGBw4BHQEjNT4BNz4BMzIWFx4BFRQGBwIAZrOFTk6Fs2Zms4VOToWzZggCHiYBJx0DHyUBJx6pBx4THQwOAwICAW0BBQwTPQIGCgMJCAcIBxsUFBsICAlxAiUjFTYfKUUcGxwODQO4TYWzZmazhU5OhbNmZrOFTfz2ASgdHSYBJx8dJQFPChoPFAkRCQcJDQUJHSUOFSsBBQoFDBQJDRcLCgoMDQ0cDgUFNEsWDg4UFBQ7JxYpEgAAAAADABT/4QPsA7gAFAAhAD4AAAEiDgIVFB4CMzI+AjU0LgIjFzIWFRQGIyImNzQ2MwMiJj8BPgEjIgYHJz4BMzIWDwEGFjMyNjcXDgEjAgBms4VOToWzZmazhU5OhbNmLiQaLSkiIQErL3sYGxEmBQEGBzQTEDx5HRkKDSsFAwYHKhgTOnAZA7hNhbNmZrOGTU2Gs2Zms4VNsSQYHS8gHBg0/Z8qQpoTEBUNGzI4Ni2jFRESEhg6MgAAAgBgACADoANgABQALAAAASIOAhUUHgIzMj4CNTQuAiMTAQYiLwExJyY0PwE2Mh8BNzYyHwEWFAcCAFaYcUFBcZhWVphxQUFxmFbo/tEGEAYGpwYGKQYQBnb4BhAGKQYGA2BBcZhWVphxQUFxmFZWmHFB/tb+0QYGBqgGEAYpBgZ3+AYGKQYQBgAAAAACAGAAIAOgA2AAFAA5AAAlIi4CNTQ+AjMyHgIVFA4CIxM2NC8BJiIPAScmIg8BBhQfAQcGFB8BFjI/ARcWMj8BNjQvATcCAFaYcUFBcZhWVphxQUFxmFa/BgYrBhAGeHkGEAYrBQV5eQUFKwYQBnl4BhAGKwYGeXkgQXGYVlaYcUFBcZhWVphxQQIZBhEGKgYGeHgGBioGEQZ4eAYRBioGBnh4BgYqBhEGeHgAAgAA/7cEAAMlACAAWgAAASIHBgcGFRQXFh8BBwYHNj8BFxYzMjc2NzY1NCcmJyYjARQHBgcGIyInBgcGByMiJyYnMSY3NjUmPwExNzYxNjc2NzY3Njc2NzY3JicmNTQ3Njc2MzIXFhcWFQIAdWVlPDwpKUoyEA0bV0cYIScjdWVlPDw8PGVldQIARUR2dosoK3GWHCUDCAcHAgIBAgEDBAQEBA4OBgYLDAcHCAkGWjM0RUR2douLdnZERQLbJyhDRE5AOjoqHTc0LiQ+FQMFKChDRE5OREMoJ/7cZFRUMTEFZCcIBAYGCgIFBQEBBAUFBQUPDwcGEBANDhQVFzJLS1ZjVVQxMTExVFVjAAIAAAAAA24DbgAYADEAAAEiBwYHBhUUFxYXFjMyNzY3NjU0JyYnJiMBFAcGBwYjIicmJyY1NDc2NzYzMhcWFxYVAbdVR0gpKiopSEdVVEhHKioqKkdIVAG3OztlZXd4ZGU7Ozs7ZWR4d2VlOzsC7ioqR0hUVUdIKSoqKUhHVVRIRyoq/sl4ZGU7Ozs7ZWR4d2VlOzs7O2VldwAAAAEAAAAAA24DbgAYAAABFAcGBwYjIicmJyY1NDc2NzYzMhcWFxYVA247O2Vld3hkZTs7OztlZHh3ZWU7OwG3eGRlOzs7O2VkeHdlZTs7OztlZXcAAAUAAAAAA24DbgAgADEAQgBjAHwAAAEGBwYjIicmJyY3Njc2FxYXFhcWMzI3Njc2NzYXFhcWByUUBwYjIicmNTQ3NjMyFxYVIRQHBiMiJyY1NDc2MzIXFhUXNCcmJyYnJiMiBwYHBgcGFRQXFhcWFxYzMjc2NzY3NjUzFAcGBwYjIicmJyY1NDc2NzYzMhcWFxYVAogVOjpISTk6FQUHBw8ODQ4EDyYnMDAmJw4FDg0PDgcHBf7mFhUeHxUWFhUfHhUWASQVFh4eFhUVFh4eFhWTHh0xMERESkpERDExHR0dHTExRERKSkREMDEdHkk7O2Vld3hkZTs7OztlZHh3ZWU7OwFRRioqKipGDg0OBAUHBw8tHRwcHS0PBwcFBA4NDvgeFhUVFh4eFhUVFh4eFhUVFh4eFhUVFh6SSkREMDEdHh4dMTBEREpKREQxMR0dHR0xMURESnhkZTs7OztlZHh3ZWU7Ozs7ZWV3AAABAAAAAQAArSKDp18PPPUACwQAAAAAANHoxUcAAAAA0ejFRwAA/7cEgAPHAAAACAACAAAAAAAAAAEAAAPA/8AAAASAAAAAAASAAAEAAAAAAAAAAAAAAAAAAAAdBAAAAAAAAAAAAAAAAgAAAAQAAAAEAAAHBAAAQAQAAH4EAAAABAAAAAQAAAAEAAAzBAAAAAQAAGAEAABgBAAAQAQAAAAEgAAABAAAUgQAAFIEAABSBAAAFAQAABQEAABgBAAAYAQAAAAEAAAABAAAAAQAAAAAAAAAAAoAFAAeAFwArAD4AWYBiAHwAlICpAM8A5gECgRqBKAFCgVCBWwFngYkBoAGxgccB6IH8AgaCNAAAQAAAB0AfQAHAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAA4ArgABAAAAAAABAAoAAAABAAAAAAACAAcAewABAAAAAAADAAoAPwABAAAAAAAEAAoAkAABAAAAAAAFAAsAHgABAAAAAAAGAAoAXQABAAAAAAAKABoArgADAAEECQABABQACgADAAEECQACAA4AggADAAEECQADABQASQADAAEECQAEABQAmgADAAEECQAFABYAKQADAAEECQAGABQAZwADAAEECQAKADQAyHhtcHAtaWNvbnMAeABtAHAAcAAtAGkAYwBvAG4Ac1ZlcnNpb24gMS4wAFYAZQByAHMAaQBvAG4AIAAxAC4AMHhtcHAtaWNvbnMAeABtAHAAcAAtAGkAYwBvAG4Ac3htcHAtaWNvbnMAeABtAHAAcAAtAGkAYwBvAG4Ac1JlZ3VsYXIAUgBlAGcAdQBsAGEAcnhtcHAtaWNvbnMAeABtAHAAcAAtAGkAYwBvAG4Ac0ZvbnQgZ2VuZXJhdGVkIGJ5IEljb01vb24uAEYAbwBuAHQAIABnAGUAbgBlAHIAYQB0AGUAZAAgAGIAeQAgAEkAYwBvAE0AbwBvAG4ALgAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/xmpp-icons.svg#xmpp-icons\") format(\"svg\");font-weight:normal;font-style:normal}.bdsft-webrtc .xmpp [class^=\"icon-im-\"],.bdsft-webrtc .xmpp [class*=\" icon-im-\"]{font-family:'xmpp-icons';speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.bdsft-webrtc .xmpp .icon-im-comment-o:before{content:\"\\f0e5\"}.bdsft-webrtc .xmpp .icon-im-circle-o:before{content:\"\\f10c\"}.bdsft-webrtc .xmpp .icon-im-circle:before{content:\"\\f111\"}.bdsft-webrtc .xmpp .icon-im-smile-o:before{content:\"\\f118\"}.bdsft-webrtc .xmpp .icon-im-phone:before{content:\"\\e600\"}.bdsft-webrtc .xmpp .icon-im-phone-hang-up:before{content:\"\\e601\"}.bdsft-webrtc .xmpp .icon-im-address-book:before{content:\"\\e602\"}.bdsft-webrtc .xmpp .icon-im-attachment:before{content:\"\\e603\"}.bdsft-webrtc .xmpp .icon-im-bubble:before{content:\"\\e60c\"}.bdsft-webrtc .xmpp .icon-im-bubbles2:before{content:\"\\e60d\"}.bdsft-webrtc .xmpp .icon-im-email:before{content:\"\\e604\"}.bdsft-webrtc .xmpp .icon-im-remove-user:before{content:\"\\e605\"}.bdsft-webrtc .xmpp .icon-im-add-user:before{content:\"\\e606\"}.bdsft-webrtc .xmpp .icon-im-user:before{content:\"\\e607\"}.bdsft-webrtc .xmpp .icon-im-users:before{content:\"\\e608\"}.bdsft-webrtc .xmpp .icon-im-circle-with-cross:before{content:\"\\e60e\"}.bdsft-webrtc .xmpp .icon-im-circle-with-minus:before{content:\"\\e60f\"}.bdsft-webrtc .xmpp .icon-im-circle-with-plus:before{content:\"\\e610\"}.bdsft-webrtc .xmpp .icon-im-help-with-circle:before{content:\"\\e611\"}.bdsft-webrtc .xmpp .icon-im-info-with-circle:before{content:\"\\e612\"}.bdsft-webrtc .xmpp .icon-im-checkmark:before{content:\"\\e609\"}.bdsft-webrtc .xmpp .icon-im-cancel:before{content:\"\\e60a\"}.bdsft-webrtc .xmpp .icon-im-notice:before{content:\"\\e60b\"}.bdsft-webrtc .xmpp .icon-im-checkmark2:before{content:\"\\e613\"}.bdsft-webrtc .xmpp .icon-im-cancel2:before{content:\"\\e614\"}","xmpp":"@font-face{font-family:'xmpp-icons';src:url(\"../fonts/xmpp-icons.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'xmpp-icons';src:url(\"data:application/font-woff;base64,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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/xmpp-icons.svg#xmpp-icons\") format(\"svg\");font-weight:normal;font-style:normal}.bdsft-webrtc .xmpp [class^=\"icon-im-\"],.bdsft-webrtc .xmpp [class*=\" icon-im-\"]{font-family:'xmpp-icons';speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.bdsft-webrtc .xmpp .icon-im-comment-o:before{content:\"\\f0e5\"}.bdsft-webrtc .xmpp .icon-im-circle-o:before{content:\"\\f10c\"}.bdsft-webrtc .xmpp .icon-im-circle:before{content:\"\\f111\"}.bdsft-webrtc .xmpp .icon-im-smile-o:before{content:\"\\f118\"}.bdsft-webrtc .xmpp .icon-im-phone:before{content:\"\\e600\"}.bdsft-webrtc .xmpp .icon-im-phone-hang-up:before{content:\"\\e601\"}.bdsft-webrtc .xmpp .icon-im-address-book:before{content:\"\\e602\"}.bdsft-webrtc .xmpp .icon-im-attachment:before{content:\"\\e603\"}.bdsft-webrtc .xmpp .icon-im-bubble:before{content:\"\\e60c\"}.bdsft-webrtc .xmpp .icon-im-bubbles2:before{content:\"\\e60d\"}.bdsft-webrtc .xmpp .icon-im-email:before{content:\"\\e604\"}.bdsft-webrtc .xmpp .icon-im-remove-user:before{content:\"\\e605\"}.bdsft-webrtc .xmpp .icon-im-add-user:before{content:\"\\e606\"}.bdsft-webrtc .xmpp .icon-im-user:before{content:\"\\e607\"}.bdsft-webrtc .xmpp .icon-im-users:before{content:\"\\e608\"}.bdsft-webrtc .xmpp .icon-im-circle-with-cross:before{content:\"\\e60e\"}.bdsft-webrtc .xmpp .icon-im-circle-with-minus:before{content:\"\\e60f\"}.bdsft-webrtc .xmpp .icon-im-circle-with-plus:before{content:\"\\e610\"}.bdsft-webrtc .xmpp .icon-im-help-with-circle:before{content:\"\\e611\"}.bdsft-webrtc .xmpp .icon-im-info-with-circle:before{content:\"\\e612\"}.bdsft-webrtc .xmpp .icon-im-checkmark:before{content:\"\\e609\"}.bdsft-webrtc .xmpp .icon-im-cancel:before{content:\"\\e60a\"}.bdsft-webrtc .xmpp .icon-im-notice:before{content:\"\\e60b\"}.bdsft-webrtc .xmpp .icon-im-checkmark2:before{content:\"\\e613\"}.bdsft-webrtc .xmpp .icon-im-cancel2:before{content:\"\\e614\"}.bdsft-webrtc .xmpp{border-spacing:5px;padding:0;position:absolute}.bdsft-webrtc .xmpp .ui-resizable{position:absolute!important}.bdsft-webrtc .xmpp .ui-resizable-handle{position:absolute;font-size:.1px;display:block}.bdsft-webrtc .xmpp .ui-resizable-disabled .ui-resizable-handle,.bdsft-webrtc .xmpp .ui-resizable-autohide .ui-resizable-handle{display:none}.bdsft-webrtc .xmpp .ui-resizable-n{cursor:n-resize;height:7px;width:100%;top:-5px;left:0}.bdsft-webrtc .xmpp .ui-resizable-s{cursor:s-resize;height:7px;width:100%;bottom:-5px;left:0}.bdsft-webrtc .xmpp .ui-resizable-e{cursor:e-resize;width:7px;right:-5px;top:0;height:100%}.bdsft-webrtc .xmpp .ui-resizable-w{cursor:w-resize;width:7px;left:-5px;top:0;height:100%}.bdsft-webrtc .xmpp .ui-resizable-se{cursor:se-resize;width:12px;height:12px;right:1px;bottom:1px}.bdsft-webrtc .xmpp .ui-resizable-sw{cursor:sw-resize;width:9px;height:9px;left:-5px;bottom:-5px}.bdsft-webrtc .xmpp .ui-resizable-nw{cursor:nw-resize;width:9px;height:9px;left:-5px;top:-5px}.bdsft-webrtc .xmpp .ui-resizable-ne{cursor:ne-resize;width:9px;height:9px;right:-5px;top:-5px}.bdsft-webrtc .xmpp .loginView{padding:14px;background-color:#f3f3f3;border:1px solid #d6d6d6;width:254px;height:491px}.bdsft-webrtc .xmpp .loginView .logo-container{text-align:center;margin-bottom:30px}.bdsft-webrtc .xmpp .loginView .logo-container i{font-size:60px;color:#737373}.bdsft-webrtc .xmpp .loginView .form{width:200px;margin:0 auto;margin-top:90px}.bdsft-webrtc .xmpp .loginView label{display:block;font-weight:bolder;color:#606060;margin-bottom:2px;font-size:13px}.bdsft-webrtc .xmpp .loginView input{display:block;background:#fff;border:1px solid #d6d6d6;color:#606060;font-size:14px;padding:8px;border-radius:0;width:100%;box-sizing:border-box}.bdsft-webrtc .xmpp .loginView input::-webkit-input-placeholder{color:#d3d3d3}.bdsft-webrtc .xmpp .loginView input:-moz-placeholder{font-style:italic;color:#d3d3d3}.bdsft-webrtc .xmpp .loginView input::-moz-placeholder{color:#d3d3d3}.bdsft-webrtc .xmpp .loginView input:-ms-input-placeholder{color:#d3d3d3}.bdsft-webrtc .xmpp .loginView button{border:0;border-radius:0;padding:5px 10px;font-size:14px;color:#fff;background-color:#737373;text-align:center;display:inline-block;width:100%;line-height:25px;box-sizing:border-box;border-radius:4px}.bdsft-webrtc .xmpp .loginView .form-row{margin-bottom:6px}.bdsft-webrtc .xmpp .loginView .form-row:last-child{margin-top:10px;margin-bottom:0;text-align:center}.bdsft-webrtc .xmpp .contentView{position:relative}.bdsft-webrtc .xmpp a{text-decoration:underline}.bdsft-webrtc .xmpp.connected .contentView,.bdsft-webrtc .xmpp:not(.connected) .loginView{display:block}.bdsft-webrtc .xmpp.connected .loginView,.bdsft-webrtc .xmpp:not(.connected) .contentView{display:none}.bdsft-webrtc .enableXMPP.xmpp-shown.xmpp{transition:opacity 1s linear,z-index 1s linear;opacity:1;z-index:100}.bdsft-webrtc .enableXMPP.xmpp-hidden.xmpp{transition:opacity 1s linear,z-index 1s linear;opacity:0;z-index:-1}"}
},{}],1297:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function n(n){return null!=n&&""!==n}function t(e){return(Array.isArray(e)?e.map(t):e&&"object"==typeof e?Object.keys(e).filter(function(n){return e[n]}):[e]).filter(n).join(" ")}function e(n){return i[n]||n}function r(n){var t=String(n).replace(o,e);return t===""+n?n:t}var a={};a.merge=function s(t,e){if(1===arguments.length){for(var r=t[0],a=1;a<t.length;a++)r=s(r,t[a]);return r}var i=t["class"],o=e["class"];(i||o)&&(i=i||[],o=o||[],Array.isArray(i)||(i=[i]),Array.isArray(o)||(o=[o]),t["class"]=i.concat(o).filter(n));for(var f in e)"class"!=f&&(t[f]=e[f]);return t},a.joinClasses=t,a.cls=function(n,e){for(var r=[],i=0;i<n.length;i++)e&&e[i]?r.push(a.escape(t([n[i]]))):r.push(t(n[i]));var o=t(r);return o.length?' class="'+o+'"':""},a.style=function(n){return n&&"object"==typeof n?Object.keys(n).map(function(t){return t+":"+n[t]}).join(";"):n},a.attr=function(n,t,e,r){return"style"===n&&(t=a.style(t)),"boolean"==typeof t||null==t?t?" "+(r?n:n+'="'+n+'"'):"":0==n.indexOf("data")&&"string"!=typeof t?(-1!==JSON.stringify(t).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),t&&"function"==typeof t.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+n+"='"+JSON.stringify(t).replace(/'/g,"&apos;")+"'"):e?(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+a.escape(t)+'"'):(t&&"function"==typeof t.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+n+'="'+t+'"')},a.attrs=function(n,e){var r=[],i=Object.keys(n);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],f=n[s];"class"==s?(f=t(f))&&r.push(" "+s+'="'+f+'"'):r.push(a.attr(s,f,!1,e))}return r.join("")};var i={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;"},o=/[&<>"]/g;return a.escape=r,a.rethrow=function f(n,t,e,r){if(!(n instanceof Error))throw n;if(!("undefined"==typeof window&&t||r))throw n.message+=" on line "+e,n;try{r=r||require("fs").readFileSync(t,"utf8")}catch(a){f(n,null,e)}var i=3,o=r.split("\n"),s=Math.max(e-i,0),l=Math.min(o.length,e+i),i=o.slice(s,l).map(function(n,t){var r=t+s+1;return(r==e?"  > ":"    ")+r+"| "+n}).join("\n");throw n.path=t,n.message=(t||"Jade")+":"+e+"\n"+i+"\n\n"+n.message,n},a.DebugItem=function(n,t){this.lineno=n,this.filename=t},a}();

    var templatizer = {};


    // addcontact.jade compiled template
    templatizer["addcontact"] = function tmpl_addcontact() {
        return '<div class="addcontact"><div class="controls"><a class="addLink"> <i class="icon-im-add-user"></i>Add Contact</a></div><div class="form"><div class="form-row"><input type="text" placeholder="Account ID" class="cell jid"/></div><div class="form-row"><input type="text" placeholder="Name" class="cell name"/></div><div class="form-row"><button class="cancelLink">Cancel</button><button class="button add">Add</button></div></div></div>';
    };

    // chat.jade compiled template
    templatizer["chat"] = function tmpl_chat() {
        return '<div class="bdsft-webrtc"><div class="chatXmpp classes"><div class="name"></div><div class="messagesContent"></div><textarea placeholder="Type a message here" class="input"></textarea></div></div>';
    };

    // chats.jade compiled template
    templatizer["chats"] = function tmpl_chats() {
        return '<div class="chatsView"><div class="chatsContent"></div><div class="chatTabHolder"></div></div>';
    };

    // chattab.jade compiled template
    templatizer["chattab"] = function tmpl_chattab() {
        return '<div class="chatTab"><div class="chatTabContent"></div></div>';
    };

    // contact.jade compiled template
    templatizer["contact"] = function tmpl_contact() {
        return '<div class="contact classes"><a class="close"><i class="icon-im-cancel2"></i></a><span class="presence icon-im-circle"></span><span class="name"></span><a class="remove"><i class="icon-im-cancel2"></i></a></div>';
    };

    // contacts.jade compiled template
    templatizer["contacts"] = function tmpl_contacts() {
        return '<div class="contactsView"><div class="removeContactFailed error"></div><div class="myContactHolder"></div><div class="addContactHolder"></div><div class="contactsContent"></div></div>';
    };

    // handle.jade compiled template
    templatizer["handle"] = function tmpl_handle() {
        return '<div class="bdsft-webrtc"><div class="xmppHandle classes"><a class="toggleVisibility icon-im-bubble"></a></div></div>';
    };

    // message.jade compiled template
    templatizer["message"] = function tmpl_message() {
        return '<div class="message classes"><p class="body"></p></div>';
    };

    // mycontact.jade compiled template
    templatizer["mycontact"] = function tmpl_mycontact() {
        return '<div class="mycontact"><span class="presence"><i class="icon-im-user"></i></span><div class="name-container"><span class="name"></span><select class="presenceSelect"></select></div></div>';
    };

    // subscription.jade compiled template
    templatizer["subscription"] = function tmpl_subscription() {
        return '<div class="subscription"><span class="name"></span><button class="accept button">Accept</button><button class="deny button">Deny</button></div>';
    };

    // subscriptions.jade compiled template
    templatizer["subscriptions"] = function tmpl_subscriptions() {
        return '<div class="subscriptionsView classes"><div class="subscriptionsContent"></div></div>';
    };

    // xmpp.jade compiled template
    templatizer["xmpp"] = function tmpl_xmpp() {
        return '<div class="bdsft-webrtc"><div class="xmpp fadeable classes topright"><div class="loginView"><div class="form"><div class="logo-container"><i class="icon-im-bubbles2"></i></div><div class="form-row"><input type="text" name="name" placeholder="Email" class="name"/></div><div class="form-row"><input type="password" name="password" placeholder="Password" class="password"/></div><div class="form-row"><button type="button" class="login button">Connect</button></div></div></div><div class="contentView"><div class="contactsHolder"></div><div class="chatsHolder"></div><div class="subscriptionsHolder"></div></div></div></div>';
    };

    return templatizer;
}));
},{"fs":7}],1298:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Client);

function Client() {
	var self = {};

	var opts = {
		useStreamManagement: false,
		transports: ['bosh'],
		wait: 30
		// sasl: 'anonymous'
	};

	var client = require('stanza.io').createClient(opts);

	Object.defineProperties(self, {
		jid: {
			get: function(){
				return client.jid;
			}
		}
	});

	self.busy = function() {
		client.sendPresence({
			show: 'dnd'
		});
	};

	self.ping = function(jid, cb) {
		return client.ping(jid, cb);
	};

	self.getCurrentCaps = function() {
		client.getCurrentCaps();
	};

	self.getDiscoInfo = function(jid, node, cb) {
		client.getDiscoInfo(jid, node, cb);
	};

	self.getDiscoItems = function(jid, node, cb) {
		client.getDiscoItems(jid, node, cb);
	};

	self.active = function() {
		client.sendPresence();
	};

	self.connect = function(credentials) {
		client.connect(credentials);
	};

	self.disconnect = function() {
		client.disconnect();
	};

	self.releaseGroup = function(name) {
		client.releaseGroup(name);
	};

	self.sendPresence = function(item) {
		client.sendPresence(item);
	};

	self.on = function(name, group, callback) {
		if(arguments.length === 3) {
			client.on(name, group, callback);
		} else {
			client.on(name, group);
		}
	};

	self.once = function(name, group, callback) {
		if(arguments.length === 3) {
			client.once(name, group, callback);
		} else {
			client.once(name, group);
		}
	};

	self.boshURL = function(url) {
	    client.config.boshURL = url;
	};

	self.getRoster = function(callback) {
	    client.getRoster(callback);
	};

	self.updateRosterItem = function(item, callback) {
	    client.updateRosterItem(item, callback);
	};

	self.subscribe = function(jid, callback) {
	    client.subscribe(jid, callback);
	};

	self.unsubscribe = function(jid, callback) {
	    client.unsubscribe(jid, callback);
	};

	self.sendMessage = function(msg) {
	    client.sendMessage(msg);
	};

	self.removeRosterItem = function(jid, callback) {
	    client.removeRosterItem(jid, callback);
	};

	self.acceptSubscription = function(jid) {
	    client.acceptSubscription(jid);
	};

	self.denySubscription = function(jid) {
	    client.denySubscription(jid);
	};

	return self;
};

},{"stanza.io":1332,"webrtc-core":1609}],1299:[function(require,module,exports){
var C = {};
module.exports = C;

C.PRESENCES = {
  'Available': 'available',
  'Busy': 'dnd',
  'Away': 'away'
};

},{}],1300:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(AddContact);

var Contact = require('../models/contact');

function AddContact(eventbus, client) {
	var self = {};

	self.props = ['name', 'jid', 'classes', 'visible'];

	self.bindings = {
		classes: {
			self: ['visible']
		}
	};

	var addContact = function(contact) {
		client.updateRosterItem({
			jid: contact.id,
			name: contact.name
		}, function(e) {
			// debug.log('updateRosterItem : ' + JSON.stringify(e));
			if (e && e.error) {
				eventbus.emit('addContactFailed', e.error);
			}
		});
		client.subscribe(contact.id, function(e) {
			// debug.log('subscribe : ' + JSON.stringify(e));
		});
		client.on('subscribe', 'addContact', function(msg) {
			if (msg.from.bare === contact.id) {
			    client.acceptSubscription(contact.id);
				client.releaseGroup('addContact');
			}
		});
		eventbus.emit('addContact', contact);
	};

	self.cancel = function() {
		self.visible = false;
	};

	self.show = function() {
		self.name = '';
		self.jid = '';
		self.visible = true;
	};

	self.add = function() {
		var jid = self.jid;
		var name = self.name;
		if (self.jid) {
			var contact = Contact.create([{
				bare: self.jid,
				local: self.name
			}, eventbus, client]);
			addContact(contact);
			self.visible = false;
		}
	};

	return self;
}
},{"../models/contact":1304,"webrtc-core":1609}],1301:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Chat);

function Chat(contact, client) {
	var self = {};

	self.props = ['name', 'messages', 'input', 'selected', 'classes'];

	self.bindings = {
		classes: {
			self: 'selected'
		},
		name: {
			contact: 'name'
		},
		messages: {
			contact: 'messages'
		},
		selected: {
			contact: 'selected'
		}
	}

	self.sendMessage = function(msg) {
		var msg = {
			type: 'chat',
			to: contact.id,
			body: msg,
			chatState: 'active'
		};
		// debug.log('sendMessage : ' + JSON.stringify(msg));
		client.sendMessage(msg);
	};

	return self;
}
},{"webrtc-core":1609}],1302:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Chats);

var Chat = require('./chat');

function Chats(eventbus, client) {
	var self = {};

	self.props = ['classes', 'items', 'contactSelected'];

	self.bindings = {
		classes: {
			self: 'contactSelected'
		}
	};

	self.init = function() {
		self.items = {};
	};

	self.listeners = function() {
		eventbus.on('selectContact', function(contact) {
			self.contactSelected = !!contact;
			if(contact) {
				self.items[contact.id] = Chat.create([contact, client]);
			}
		});
		eventbus.on('closeContact', function(contact) {
			delete self.items[contact.id];
			if(contact.selected) {
				self.contactSelected = false;
			}
		});
	}

	return self;
}
},{"./chat":1301,"webrtc-core":1609}],1303:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(ChatTab);

function ChatTab(eventbus, client) {
	var self = {};

	var adjacentContact = function(contact) {
		var ids = Object.keys(self.contacts);
		var result = undefined;
		ids.forEach(function(id, index) {
			if (contact.id === id) {
				if (index > 0) {
					result = self.contacts[ids[index - 1]];
				} else if (index < ids.length) {
					result = self.contacts[ids[index + 1]];
				}
			}
		});
		return result;
	}

	self.props = ['contacts'];

	self.init = function() {
		self.contacts = {};
	}

	self.listeners = function() {
		eventbus.on('selectContact', function(contact) {
			if(contact) {
				self.contacts[contact.id] = contact;
			}
		});
		eventbus.on('closeContact', function(contact) {
			if (self.contacts[contact.id]) {
				// select adjacent tab if closed tab === current tab
				if (contact.selected) {
					var nextContact = adjacentContact(contact);
					if (nextContact) {
						nextContact.select();
					}
				}
				delete self.contacts[contact.id];
			}
		});
	};

	return self;
}
},{"webrtc-core":1609}],1304:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Contact);

var Message = require('./message');

function Contact(item, eventbus, client) {
	var self = {};

	self.props = ['id', 'name', 'messages', 'presence', 'subscription', 'classes', 'selected'];

	self.bindings = {
		classes: {
			contact: ['presence', 'selected', 'subscription']
		}
	};

	self.init = function() {
		self.id = item.jid && item.jid.bare || item.bare;
		self.name = item.name || (item.jid && item.jid.local) || item.local;
		self.presence = 'unavailable';
		self.subscription = item.subscription;
		self.messages = [];
	};

	self.listeners = function() {
		client.on('available', function(msg) {
			if (msg.from.bare === self.id) {
				self.available();
			}
		});

		client.on('unavailable', function(msg) {
			if (msg.from.bare === self.id) {
				self.unavailable();
			}
		});

		client.on('chat', function(msg) {
			var message = Message.create([msg, 'incoming']);
			if (message.from === self.id) {
				self.addMessage(message);
				self.select();
			}
		});

		client.on('message:sent', function(msg) {
			if (!msg.body) {
				return;
			}

			msg.from = client.jid.bare;
			var message = Message.create([msg, 'outgoing']);
			if(message.to === self.id) {
				self.addMessage(message);
			}
		});

		client.on('presence', function(msg) {
			if(msg.from.bare === self.id) {
				self.presence = msg.show || msg.type || 'available';
			}
		});

		eventbus.on('selectContact', function(contact) {
			self.selected = contact.id === self.id;
		})
	};

	self.addMessage = function(message) {
		self.messages = self.messages.concat([message]);
	};

	self.select = function() {
		self.selected = true;
		eventbus.emit('selectContact', self);
	};

	self.deselect = function() {
		self.selected = false;
		eventbus.emit('deselectContact', self);
	};

	self.available = function() {
		self.presence = 'available';
	};

	self.unavailable = function() {
		self.presence = 'unavailable';
	};

	self.remove = function() {
		client.removeRosterItem(self.id, function(e) {
			if (e && e.error) {
				eventbus.emit('removeContactFailed', self);
			}
		});
		client.unsubscribe(self.id, function(e) {
		});
		eventbus.emit('removeContact', self);
	};


	self.close = function() {
		eventbus.emit('closeContact', self);
		self.selected = false;
	};



	return self;
}
},{"./message":1307,"webrtc-core":1609}],1305:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Contacts);

var Contact = require('./contact');

function Contacts(eventbus, client) {
	var self = {};

	self.props = ['classes', 'items'];

	self.init = function(){
		self.items = {};
	};

	self.listeners = function() {
	    client.on('roster:update', function(msg){
	    	var items = msg.roster && msg.roster.items || [];
	    	items.forEach(function(item){
	    		var contact = self.items[item.jid.bare];
	    		if(!contact) {
	    			contact = Contact.create([item, eventbus, client]);
	    			self.items[contact.id] = contact;
	    		} else {
		    		contact.name = item.name;
		    		contact.subscription = item.subscription;
	    		}
	    	});
	    });

		client.on('session:started', function() {
			client.getRoster(function(err, res) {
				if(res.roster && res.roster.items) {
					self.items = res.roster.items.map(function(item) {
						return Contact.create([item, eventbus, client]);
					}).reduce(function(obj, contact) {
						obj[contact.id] = contact;
						return obj;
					}, {});
				}
			});

			client.sendPresence();
		});
	}

	self.onRemoveContactFailed = function(callback) {
		eventbus.on('removeContactFailed', callback);
	};

	return self;
}
},{"./contact":1304,"webrtc-core":1609}],1306:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Handle);

function Handle(xmpp) {
	var self = {};

	self.props = ['classes'];

	self.bindings = {
		classes: {
			xmpp: ['visible', 'enableXMPP']
		}
	};

	self.toggle = function(){
      xmpp.visible = !xmpp.visible;
	};

	return self;
}
},{"webrtc-core":1609}],1307:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Message);

function Message(msg, direction) {
	var self = {};

	self.props = ['to', 'from', 'body', 'chatState', 'time', 'direction', 'classes'];

	self.bindings = {
		classes: {
			self: 'direction'
		}
	};
	
	self.init = function(){
		self.id = msg.id;
		self.to = msg.to.bare;
		self.from = msg.from.bare;
		self.body = msg.body;
		self.chatState = msg.chatState;
		self.direction = direction;
		self.time = new Date();
	};

	return self;
}

},{"webrtc-core":1609}],1308:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(MyContact);

var Contact = require('./contact');

function MyContact(eventbus, client) {
	var self = {};

	self.props = ['id', 'name', 'presence', 'presenceSelect', 'classes'];

	self.bindings = {
		classes: {
			self: 'presence'
		},
		presenceSelect: {
			self: 'presence'
		}
	};

	self.listeners = function() {
		client.on('session:started', function() {
			self.name = client.jid.local;
			self.id = client.jid.bare;
			self.sendPresence();
		});
		client.on('available', function(msg) {
			if (msg.from.bare === self.id) {
				self.presence = 'available';
			}
		});
		client.on('unavailable', function(msg) {
			if (msg.from.bare === self.id) {
				self.presence = 'unavailable';
			}
		});
		client.on('presence', function(msg) {
			if(msg.from.bare === self.id) {
				self.presence = msg.show || msg.type || 'available';
			}
		});
	}

	self.sendPresence = function(presence) {
		if (!presence || presence === 'available') {
			client.sendPresence();
		} else {
			client.sendPresence({
				show: presence
			});
		}
	};

	return self;
}
},{"./contact":1304,"webrtc-core":1609}],1309:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Subscription);

function Subscription(item, eventbus, client) {
	var self = {};

	self.props = ['id', 'name', 'accepted', 'denied', 'classes'];

	self.bindings = {
		classes: {
			self: ['accepted', 'denied']
		}
	};

	self.init = function() {
		self.id = item.bare;
		self.name = item.local;
	};

	self.accept = function() {
		client.acceptSubscription(self.id);
		client.updateRosterItem({
			jid: self.id
		}, function(e) {
			if (e && e.error) {
				emitter.emit('acceptSubscriptionFailed', e.error);
				self.accepted = false;
			}
		});
		client.subscribe(self.id, function(e) {
		});
		self.accepted = true;
	};

	self.deny = function() {
		client.denySubscription(self.id);
		self.denied = true;
	};

	return self;
}
},{"webrtc-core":1609}],1310:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(Subscriptions);

var Subscription = require('./subscription');

function Subscriptions(eventbus, client) {
	var self = {};

	self.updateHasSubscriptions = function(items) {
		var length = Object.keys(items).filter(function(id){
			var item = items[id];
			return !item.accepted && !item.denied;
		}).length;
		self.hasSubscriptions = !!length;
	}

	self.props = ['items', 'hasSubscriptions', 'classes'];

	self.bindings = {
		classes: {
			self: ['hasSubscriptions']
		},
		hasSubscriptions: {
			self: 'items'
		}
	}

	self.init = function() {
		self.items = {};
	}

	self.listeners = function() {
		client.on('subscribe', function(msg) {
			var subscription = Subscription.create([msg.from, eventbus, client]);
			subscription.databinder.onModelPropChange(['accepted', 'denied'], function(){
				self.updateHasSubscriptions(self.items);
			})
			self.items[subscription.id] = subscription;
		});

		client.on('unsubscribe', function(msg) {
			delete self.items[msg.from.bare];
		});
	};

	return self;
}
},{"./subscription":1309,"webrtc-core":1609}],1311:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.Model(XMPP, {
  config: require('../../js/config.js')
});

var Q = require('q');
var extend = require('extend');

function XMPP(debug, eventbus, dms, cookieconfig, client) {
  var self = {};

  self.props = ['classes', 'visible', 'connected', 'connecting', 'disconnecting'];

  self.client = client;

  self.bindings = {
    classes: {
      xmpp: ['visible', 'enableXMPP', 'connected']
    }
  }

  self.disconnect = function() {
    if(!self.connected || self.disconnecting) {
      return Q();
    }
    var deferred = Q.defer();
    self.disconnecting = true;
    debug.log('disconnecting...');
    client.disconnect();
    client.on('disconnected', 'disconnect', function(msg, err){
        debug.log('disconnected');
        self.disconnecting = false;
        self.connected = false;
        client.releaseGroup('disconnect');
        deferred.resolve();
    });
    client.once('stream:error', 'disconnect', function(msg, err){
        debug.error('disconnected failed : '+ JSON.stringify(err || msg));
        self.disconnecting = false;
        client.releaseGroup('disconnect');
        deferred.reject(JSON.stringify(err || msg));
    });

    return deferred.promise;
  };

  self.connect = function(jid, password) {
    if(self.connecting) {
      return Q();
    }
    var deferred = Q.defer();
    var promise = Q.reject();
    if(self.enableXMPP && !self.connected) {
      if(dms.enabled && (!jid || !password) && cookieconfig.userid && cookieconfig.password) {
        self.connecting = true;
        debug.log('retrieve credentials through DMS... : '+cookieconfig.userid);

        promise = dms.requestConfig(cookieconfig.userid, cookieconfig.password).then(function(dmsConfig){
          var xmppConfig = dmsConfig.protocols.xmpp;
          if(!xmppConfig || !xmppConfig.credentials) {
            debug.error('no XMPP service enabled for '+dms.deviceType+' and user : ' + cookieconfig.userid);
            return;
          }
          debug.log('credentials retrieved : '+xmppConfig.credentials.username);
          return {jid: xmppConfig.credentials.username, password: xmppConfig.credentials.password};
        });
      } else if(jid && password) {
        self.connecting = true;
        promise = Q({
            jid: jid,
            password: password
        });
      }
    }
    promise.then(function(credentials){
      debug.log('connecting... : '+JSON.stringify(credentials)+' : '+JSON.stringify(client.config));
      client.connect(credentials);
      // client.connect({
      //       jid: 'anonymous@broadsoftlabs.com',
      //       password: 'anonymous'
      //   });
      client.once('auth:success', 'connect', function(msg, err){
          debug.log('connected');
          self.connecting = false;
          self.connected = true;
          client.releaseGroup('connect');
          deferred.resolve();
      });
      client.once('stream:error', 'connect', function(msg, err){
          debug.error('connecting failed : '+ JSON.stringify(err || msg));
          self.connecting = false;
          self.connected = true;
          client.releaseGroup('connect');
          deferred.reject(JSON.stringify(err || msg));
      });
    });
    return deferred.promise;
  };

  self.init = function() {
    client.boshURL(self.boshURL);
    self.connect();
  };

  self.listeners = function(cookieconfigDatabinder, databinder) {
    cookieconfigDatabinder.onModelPropChange(['userid', 'password'], function(value, name){
      if(!value) {
        self.disconnect();
      } else {
        self.connect();
      }
    });
    databinder.onModelPropChange('enableXMPP', function(value){
      if(value) {
        self.connect();
      } else {
        self.disconnect();
      }
    });


    client.on('*', function (msg, obj) {
      function censor(censor) {
        var i = 0;

        return function(key, value) {
          if(i !== 0 && typeof(censor) === 'object' && typeof(value) == 'object' && censor == value) 
            return '[Circular]'; 

          if(i >= 29) // seems to be a harded maximum of 30 serialized objects?
            return '[Unknown]';

          ++i; // so we know we aren't using the original object anymore

          return value;  
        }
      }
      debug.log('------ '+msg+' : '+JSON.stringify(obj, censor(obj)));
    });

    eventbus.on("started", function() {
      client.busy();
    });
    eventbus.on("ended", function() {
      client.active();
    });
  };

  return self;
}
},{"../../js/config.js":1295,"extend":1324,"q":1331,"webrtc-core":1609}],1312:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(AddContactView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

function AddContactView(addcontact) {
  var self = {};

  self.elements = ['name', 'jid', 'add', 'addLink', 'cancelLink', 'form'];

  self.listeners = function() {
    self.add.on('click', function(e) {
      addcontact.add();
    });
    self.cancelLink.on('click', function(e) {
      addcontact.cancel();
    });
    self.addLink.on('click', function(e) {
      addcontact.show();
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1313:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ChatView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var MessageView = require('./message');

function ChatView(chat) {
  var self = {};

  self.updateMessagesContent = function(messages) {
    self.updateContentView(self.messagesContent, messages, function(message){
      return MessageView.create([message]);
    });
  }

  self.elements = ['messagesContent', 'input', 'name'];

  self.bindings = {
    messagesContent: {
      chat: 'messages'
    }
  };

  self.listeners = function() {
    self.input.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        chat.sendMessage(self.input.val());
        self.input.val('');
      }
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"./message":1319,"webrtc-core":1609}],1314:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ChatsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var ChatView = require('./chat');
var jQuery = jquery = $ = require('jquery');
require('jquery-ui/resizable');
require('jquery-ui/draggable');

function ChatsView(chats, chattabView) {
  var self = {};

  self.updateChatsContent = function(items){
    self.updateContentView(self.chatsContent, items, function(chat){
      return ChatView.create([chat]);
    });
  };

  self.elements = ['chatsContent', 'chatTabHolder'];

  self.bindings = {
    chatsContent: {
      chats: 'items'
    }
  };

  self.init = function() {
    jQuery(self.view).resizable({
      direction: ['bottom', 'left']
    }).draggable();
    self.chatTabHolder.replaceWith(chattabView.view);
  };

  return self;
}
},{"../../js/styles":1296,"../../js/templates":1297,"./chat":1313,"jquery":1330,"jquery-ui/draggable":1326,"jquery-ui/resizable":1328,"webrtc-core":1609}],1315:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ChatTabView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var ContactView = require('./contact');

function ChatTabView(chattab) {
  var self = {};

  self.updateChatTabContent = function(contacts){
    self.updateContentView(self.chatTabContent, contacts, function(contact){
      return ContactView.create([contact]);
    });
  }

  self.bindings = {
    chatTabContent: {
      chattab: 'contacts' 
    }
  }

  self.elements = ['chatTabContent'];

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"./contact":1316,"webrtc-core":1609}],1316:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ContactView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

function ContactView(contact) {
  var self = {};

  self.elements = ['name', 'remove', 'close'];

  self.listeners = function() {
    self.view.on('click', function(e){
      e.preventDefault();
      contact.select();
    });
    self.remove.on('click', function(e){
      e.preventDefault();
      e.stopPropagation();
      if(confirm("Are you sure you want to remove the contact?")) {
        contact.remove();  
      }
    });
    self.close.on('click', function(e){
      e.preventDefault();
      contact.close();
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1317:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(ContactsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var ContactView = require('./contact');
var jQuery = jquery = $ = require('jquery');
require('jquery-ui/resizable');
require('jquery-ui/draggable');

function ContactsView(contacts, addcontactView, mycontactView) {
  var self = {};

  self.updateContactsContent = function(items){
    self.updateContentView(self.contactsContent, items, function(contact){
      return ContactView.create([contact]);
    });
  };

  self.elements = ['contactsContent', 'removeContactFailed', 'myContactHolder', 'addContactHolder'];

  self.bindings = {
    contactsContent: {
      contacts: 'items'
    }
  }
  self.init = function() {
    jQuery(self.view).resizable({
      direction: ['bottom', 'left']
    }).draggable();
    self.addContactHolder.replaceWith(addcontactView.view);
    self.myContactHolder.replaceWith(mycontactView.view);
  };

  self.listeners = function() {
    contacts.onRemoveContactFailed(function(error){
      self.removeContactFailed.fadeIn(10).fadeOut(3000);
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"./contact":1316,"jquery":1330,"jquery-ui/draggable":1326,"jquery-ui/resizable":1328,"webrtc-core":1609}],1318:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(HandleView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

function HandleView(sound, xmppHandle) {
  var self = {};

  self.listeners = function() {
    self.view.on('click', function(e) {
      e.preventDefault();
      sound.playClick();
      xmppHandle.toggle();
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1319:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MessageView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

function MessageView(message) {
  var self = {};

  self.elements = ['body'];

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1320:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(MyContactView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var Utils = require('webrtc-core').utils;
var constants = require('../constants');

function MyContactView(mycontact) {
  var self = {};

  self.elements = ['name', 'presenceSelect'];

  self.init = function(){
    Utils.addSelectOptions(constants.PRESENCES, self.presenceSelect);
  };

  self.listeners = function() {
    self.presenceSelect.on('change', function(e) {
      mycontact.sendPresence(self.presenceSelect.val());
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"../constants":1299,"webrtc-core":1609}],1321:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(SubscriptionView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

function SubscriptionView(subscription) {
  var self = {};

  self.elements = ['name', 'accept', 'deny'];

  self.listeners = function() {
    self.accept.on('click', function(e){
      e.preventDefault();
      subscription.accept();
    });
    self.deny.on('click', function(e){
      e.preventDefault();
      subscriptions.deny();
    });
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1322:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(SubscriptionsView, {
  template: require('../../js/templates'), 
  style: require('../../js/styles'),
  module: 'xmpp'
})

var SubscriptionView = require('./subscription');
var jQuery = jquery = $ = require('jquery');
require('jquery-ui/resizable');
require('jquery-ui/draggable');

function SubscriptionsView(subscriptions) {
  var self = {};

  self.updateSubscriptionsContent = function(items){
      self.updateContentView(self.subscriptionsContent, items, function(contact) {
        return SubscriptionView.create([contact, subscriptions]);
      });
  };

  self.elements = ['subscriptionsContent'];

  self.bindings = {
    subscriptionsContent: {
      subscriptions: 'items'
    }
  }
  self.init = function() {
    jQuery(self.view).resizable({
      direction: ['bottom', 'left']
    }).draggable();
  };

  return self;

}
},{"../../js/styles":1296,"../../js/templates":1297,"./subscription":1321,"jquery":1330,"jquery-ui/draggable":1326,"jquery-ui/resizable":1328,"webrtc-core":1609}],1323:[function(require,module,exports){
module.exports = require('webrtc-core').bdsft.View(XMPPView, {
  template: require('../../js/templates'),
  style: require('../../js/styles')
});

var Utils = require('webrtc-core').utils;
var Constants = require('webrtc-core').constants;

function XMPPView(sound, xmpp, subscriptionsView, contactsView, chatsView) {
  var self = {};

  self.elements = ['name', 'password', 'login', 'chatsHolder', 'subscriptionsHolder', 'contactsHolder'];

  self.model = xmpp;
  
  self.init = function() {
    self.subscriptionsHolder.replaceWith(subscriptionsView.view)
    self.contactsHolder.replaceWith(contactsView.view)
    self.chatsHolder.replaceWith(chatsView.view)
  };

  self.listeners = function(databinder) {
    self.login.on('click', function(e) {
      sound.playClick();
      xmpp.connect(self.name.val(), self.password.val());
    });
  };

  return self;
}
},{"../../js/styles":1296,"../../js/templates":1297,"webrtc-core":1609}],1324:[function(require,module,exports){
'use strict';

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {/**/}

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

module.exports = function extend() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						target[name] = extend(deep, clone, copy);

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						target[name] = copy;
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],1325:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{"jquery":1330}],1326:[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Draggable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

},{"./core":1325,"./mouse":1327,"./widget":1329,"jquery":1330}],1327:[function(require,module,exports){
var jQuery = require('jquery');
require('./widget');

/*!
 * jQuery UI Mouse 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

},{"./widget":1329,"jquery":1330}],1328:[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Resizable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

function num(v) {
	return parseInt(v, 10) || 0;
}

function isNumber(value) {
	return !isNaN(parseInt(value, 10));
}

$.widget("ui.resizable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},
	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"ui-resizable", this.element.data("ui-resizable")
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
		if(this.handles.constructor === String) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for(i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-"+handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				//Insert into internal handles object and append to element
				this.handles[handle] = ".ui-resizable-"+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = $(this.handles[i], this.element).show();
				}

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(".ui-resizable-handle", this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
			};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			iniPos = this.element.position(),
			el = this.element;

		this.resizing = true;

		// bugfix for http://dev.jquery.com/ticket/1749
		if ( (/absolute/).test( el.css("position") ) ) {
			el.css({ position: "absolute", top: el.css("top"), left: el.css("left") });
		} else if (el.is(".ui-draggable")) {
			el.css({ position: "absolute", top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		curleft = num(this.helper.css("left"));
		curtop = num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			prevTop = this.position.top,
			prevLeft = this.position.left,
			prevWidth = this.size.width,
			prevHeight = this.size.height,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		if (!trigger) {
			return false;
		}

		// Calculate the attrs that will be change
		data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		if (this.position.top !== prevTop) {
			props.top = this.position.top + "px";
		}
		if (this.position.left !== prevLeft) {
			props.left = this.position.left + "px";
		}
		if (this.size.width !== prevWidth) {
			props.width = this.size.width + "px";
		}
		if (this.size.height !== prevHeight) {
			props.height = this.size.height + "px";
		}
		el.css(props);

		if (!this._helper && this._proportionallyResizeElements.length) {
			this._proportionallyResize();
		}

		// Call the user callback if the element was resized
		if ( ! $.isEmptyObject(props) ) {
			this._trigger("resize", event, this.ui());
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
				paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

				for ( j = 0; j < borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left +"px",
				top: this.elementOffset.top +"px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && $.ui.hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $(this).data("ui-resizable"),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;

		if (!ce) {
			return;
		}

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc === document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			element = $(ce);
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw );
			height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset, cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] !== document && (/static/).test(ce.css("position"))) {
			cop = co;
		}

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width );
		hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		isParent = that.containerElement.get(0) === that.element.parent().get(0);
		isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));

		if ( isParent && isOffsetRelative ) {
			woset -= Math.abs( that.parentData.left );
		}

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) {
				that.size.height = that.size.width / that.aspectRatio;
			}
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) {
				that.size.width = that.size.height * that.aspectRatio;
			}
		}
	},

	stop: function(){
		var that = $(this).data("ui-resizable"),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $(that.helper),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

		if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });
		}

	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).data("ui-resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).data("ui-resizable");
		if (that.ghost) {
			that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).data("ui-resizable");
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var that = $(this).data("ui-resizable"),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				that.size.height = gridY;
				that.position.top = op.top + os.height - gridY;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				that.size.width = gridX;
				that.position.left = op.left + os.width - gridX;
			}
		}
	}

});

})(jQuery);

},{"./core":1325,"./mouse":1327,"./widget":1329,"jquery":1330}],1329:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{"jquery":1330}],1330:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1331:[function(require,module,exports){
module.exports=require(442)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-dms/node_modules/q/q.js":442,"_process":22}],1332:[function(require,module,exports){
'use strict';

exports.VERSION = '7.0.6';

exports.JID = require('xmpp-jid').JID;
exports.Client = require('./lib/client');


exports.createClient = function (opts) {
    var client = new exports.Client(opts);
    client.use(require('./lib/plugins'));

    return client;
};

},{"./lib/client":1333,"./lib/plugins":1356,"xmpp-jid":1604}],1333:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var jxt = require('jxt');
var WildEmitter = require('wildemitter');
var util = require('util');
var BPromise = require('bluebird');
var uuid = require('node-uuid');
var JID = require('xmpp-jid').JID;
var StreamManagement = require('./sm');
var getHostMeta = require('hostmeta');
var SASLFactory = require('saslmechanisms');


var SASL_MECHS = {
    external: require('sasl-external'),
    'scram-sha-1': require('sasl-scram-sha-1'),
    'digest-md5': require('alt-sasl-digest-md5'),
    plain: require('sasl-plain'),
    anonymous: require('sasl-anonymous')
};


function Client(opts) {
    var self = this;

    WildEmitter.call(this);

    opts = opts || {};
    this._initConfig(opts);

    this.stanzas = jxt.getGlobalJXT();

    this.jid = new JID();

    this.stanzas = jxt.createRegistry();
    this.stanzas.use(require('jxt-xmpp-types'));
    this.stanzas.use(require('./stanza/message'));
    this.stanzas.use(require('./stanza/presence'));
    this.stanzas.use(require('./stanza/iq'));
    this.stanzas.use(require('./stanza/error'));
    this.stanzas.use(require('./stanza/streamError'));

    this.use(require('./plugins/features'));
    this.use(require('./plugins/sasl'));
    this.use(require('./plugins/smacks'));
    this.use(require('./plugins/bind'));
    this.use(require('./plugins/session'));

    this.sm = new StreamManagement(this);

    this.transports = {};

    this.use(require('./plugins/websocket'));
    this.use(require('./plugins/oldwebsocket'));
    this.use(require('./plugins/bosh'));


    this.on('stream:data', function (data) {
        var json = data.toJSON();

        if (data._name === 'iq') {
            json._xmlChildCount = 0;
            _.each(data.xml.childNodes, function (child) {
                if (child.nodeType === 1) {
                    json._xmlChildCount += 1;
                }
            });
        }

        self.emit(data._eventname || data._name, json);
        if (data._name === 'message' || data._name === 'presence' || data._name === 'iq') {
            self.sm.handle(json);
            self.emit('stanza', json);
        } else if (data._name === 'smAck') {
            return self.sm.process(json);
        } else if (data._name === 'smRequest') {
            return self.sm.ack();
        }

        if (json.id) {
            self.emit('id:' + json.id, json);
            self.emit(data._name + ':id:' + json.id, json);
        }
    });

    this.on('disconnected', function () {
        if (self.transport) {
            self.transport.off('*');
            delete self.transport;
        }
        self.releaseGroup('connection');
    });

    this.on('iq', function (iq) {
        var iqType = iq.type;
        var xmlChildCount = iq._xmlChildCount;
        delete iq._xmlChildCount;

        var exts = Object.keys(iq);

        if (iq.type === 'get' || iq.type === 'set') {
            // Invalid request
            if (xmlChildCount !== 1) {
                return self.sendIq(iq.errorReply({
                    error: {
                        type: 'modify',
                        condition: 'bad-request'
                    }
                }));
            }

            // Valid request, but we don't have support for the
            // payload data.
            if (!exts.length) {
                return self.sendIq(iq.errorReply({
                    error: {
                        type: 'cancel',
                        condition: 'feature-not-implemented'
                    }
                }));
            }

            var iqEvent = 'iq:' + iqType + ':' + exts[0];
            if (self.callbacks[iqEvent]) {
                self.emit(iqEvent, iq);
            } else {
                // We support the payload data, but there's
                // nothing registered to handle it.
                self.sendIq(iq.errorReply({
                    error: {
                        type: 'cancel',
                        condition: 'feature-not-implemented'
                    }
                }));
            }
        }
    });

    this.on('message', function (msg) {
        if (Object.keys(msg.$body || {}).length) {
            if (msg.type === 'chat' || msg.type === 'normal') {
                self.emit('chat', msg);
            } else if (msg.type === 'groupchat') {
                self.emit('groupchat', msg);
            }
        }
        if (msg.type === 'error') {
            self.emit('message:error', msg);
        }
    });

    this.on('presence', function (pres) {
        var presType = pres.type || 'available';
        if (presType === 'error') {
            presType = 'presence:error';
        }
        self.emit(presType, pres);
    });
}

util.inherits(Client, WildEmitter);

Object.defineProperty(Client.prototype, 'stream', {
    get: function () {
        return this.transport ? this.transport.stream : undefined;
    }
});

Client.prototype._initConfig = function (opts) {
    var self = this;
    var currConfig = this.config || {};

    this.config = _.extend({
        useStreamManagement: true,
        transports: ['websocket', 'bosh'],
        sasl: ['external', 'scram-sha-1', 'digest-md5', 'plain', 'anonymous']
    }, currConfig, opts);

    // Enable SASL authentication mechanisms (and their preferred order)
    // based on user configuration.
    if (!_.isArray(this.config.sasl)) {
        this.config.sasl = [this.config.sasl];
    }

    this.SASLFactory = new SASLFactory();
    this.config.sasl.forEach(function (mech) {
        if (typeof mech === 'string') {
            var existingMech = SASL_MECHS[mech.toLowerCase()];
            if (existingMech) {
                self.SASLFactory.use(existingMech);
            }
        } else {
            self.SASLFactory.use(mech);
        }
    });

    this.config.jid = new JID(this.config.jid);

    if (!this.config.server) {
        this.config.server = this.config.jid.domain;
    }

    if (this.config.password) {
        this.config.credentials = this.config.credentials || {};
        this.config.credentials.password = this.config.password;
        delete this.config.password;
    }

    if (this.config.transport) {
        this.config.transports = [this.config.transport];
    }

    if (!_.isArray(this.config.transports)) {
        this.config.transports = [this.config.transports];
    }
};

Client.prototype.use = function (pluginInit) {
    pluginInit(this, this.stanzas, this.config);
};

Client.prototype.nextId = function () {
    return uuid.v4();
};

Client.prototype.discoverBindings = function (server, cb) {
    getHostMeta(server, function (err, data) {
        if (err) {
            return cb(err, []);
        }

        var results = {
            websocket: [],
            bosh: []
        };
        var links = data.links || [];

        links.forEach(function (link) {
            if (link.href && link.rel === 'urn:xmpp:alt-connections:websocket') {
                results.websocket.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:altconnect:websocket') {
                results.websocket.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:alt-connections:xbosh') {
                results.bosh.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:altconnect:bosh') {
                results.bosh.push(link.href);
            }
        });

        cb(false, results);
    });
};

Client.prototype.getCredentials = function () {
    var creds = this.config.credentials || {};
    var requestedJID = new JID(this.config.jid);

    var username = creds.username || requestedJID.local;
    var server = creds.server || requestedJID.domain;

    var defaultCreds = {
        username: username,
        password: this.config.password,
        server: server,
        host: server,
        realm: server,
        serviceType: 'xmpp',
        serviceName: server
    };

    var result = _.extend(defaultCreds, creds);
    return result;
};

Client.prototype.connect = function (opts, transInfo) {
    var self = this;

    this._initConfig(opts);

    if (transInfo && transInfo.name && transInfo.url) {
        var trans = self.transport = new self.transports[transInfo.name](self.sm, self.stanzas);
        trans.on('*', function (event, data) {
            self.emit(event, data);
        });
        return trans.connect(self.config);
    }

    if (!transInfo && self.config.transports.length === 1) {
        transInfo = {};
        transInfo.name = self.config.transports[0];
        if (transInfo.name === 'websocket' || transInfo.name === 'old-websocket') {
            transInfo.url = self.config.wsURL;
        }
        if (transInfo.name === 'bosh') {
            transInfo.url = self.config.boshURL;
        }
        if (transInfo.name && transInfo.url) {
            return self.connect(null, transInfo);
        }
    }

    return self.discoverBindings(self.config.server, function (err, endpoints) {
        if (err) {
            console.error('Could not find https://' + self.config.server + '/.well-known/host-meta file to discover connection endpoints for the requested transports.');
            return self.disconnect();
        }

        for (var t = 0, tlen = self.config.transports.length; t < tlen; t++) {
            var transport = self.config.transports[t];
            console.log('Checking for %s endpoints', transport);
            for (var i = 0, len = (endpoints[transport] || []).length; i < len; i++) {
                var uri = endpoints[transport][i];
                if (uri.indexOf('wss://') === 0 || uri.indexOf('https://') === 0) {
                    if (transport === 'websocket') {
                        self.config.wsURL = uri;
                    } else {
                        self.config.boshURL = uri;
                    }
                    console.log('Using %s endpoint: %s', transport, uri);
                    return self.connect(null, {
                        name: transport,
                        url: uri
                    });
                } else {
                    console.warn('Discovered unencrypted %s endpoint (%s). Ignoring', transport, uri);
                }
            }
        }
        console.error('No endpoints found for the requested transports.');
        return self.disconnect();
    });
};

Client.prototype.disconnect = function () {
    if (this.sessionStarted) {
        this.releaseGroup('session');
        if (!this.sm.started) {
            // Only emit session:end if we had a session, and we aren't using
            // stream management to keep the session alive.
            this.emit('session:end');
        }
    }
    this.sessionStarted = false;
    this.releaseGroup('connection');
    if (this.transport) {
        this.transport.disconnect();
    } else {
        this.emit('disconnected');
    }
};

Client.prototype.send = function (data) {
    this.sm.track(data);
    if (this.transport) {
        this.transport.send(data);
    }
};

Client.prototype.sendMessage = function (data) {
    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }

    var Message = this.stanzas.getMessage();
    var msg = new Message(data);

    this.emit('message:sent', msg.toJSON());
    this.send(msg);

    return data.id;
};

Client.prototype.sendPresence = function (data) {
    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }
    var Presence = this.stanzas.getPresence();
    this.send(new Presence(data));

    return data.id;
};

Client.prototype.sendIq = function (data, cb) {
    var result, respEvent, allowed, dest;
    var self = this;

    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }

    var Iq = this.stanzas.getIq();
    var iq = (!data.toJSON) ? new Iq(data) : data;

    if (data.type === 'error' || data.type === 'result') {
        this.send(iq);
        return;
    }

    dest = new JID(data.to);
    allowed = {};
    allowed[''] = true;
    allowed[dest.full] = true;
    allowed[dest.bare] = true;
    allowed[dest.domain] = true;
    allowed[self.jid.bare] = true;
    allowed[self.jid.domain] = true;

    respEvent = 'iq:id:' + data.id;
    result = new BPromise(function (resolve, reject) {
        var handler = function (res) {
            // Only process result from the correct responder
            if (!allowed[res.from.full]) {
                return;
            }

            // Only process result or error responses, if the responder
            // happened to send us a request using the same ID value at
            // the same time.
            if (res.type !== 'result' && res.type !== 'error') {
                return;
            }

            self.off(respEvent, handler);
            if (!res.error) {
                resolve(res);
            } else {
                reject(res);
            }
        };
        self.on(respEvent, 'session', handler);
    });

    this.send(iq);

    return result.timeout(self.config.timeout * 1000 || 15000)
        .catch(BPromise.TimeoutError, function () {
            throw {
                id: data.id,
                type: 'error',
                error: {
                    condition: 'timeout'
                }
            };
        })
        .nodeify(cb);
};

Client.prototype.sendStreamError = function (data) {
    data = data || {};

    var StreamError = this.stanzas.getStreamError();
    var error = new StreamError(data);

    this.emit('stream:error', error.toJSON());
    this.send(error);
    this.disconnect();
};


module.exports = Client;

},{"./plugins/bind":1336,"./plugins/bosh":1340,"./plugins/features":1351,"./plugins/oldwebsocket":1367,"./plugins/sasl":1378,"./plugins/session":1379,"./plugins/smacks":1381,"./plugins/websocket":1385,"./sm":1386,"./stanza/error":1400,"./stanza/iq":1409,"./stanza/message":1415,"./stanza/presence":1421,"./stanza/streamError":1439,"alt-sasl-digest-md5":1448,"bluebird":1464,"hostmeta":1466,"jxt":1560,"jxt-xmpp-types":1559,"node-uuid":1573,"sasl-anonymous":1575,"sasl-external":1577,"sasl-plain":1579,"sasl-scram-sha-1":1580,"saslmechanisms":1601,"underscore":1602,"util":43,"wildemitter":1603,"xmpp-jid":1604}],1334:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:attention:0');


    client.getAttention = function (jid, opts) {
        opts = opts || {};
        opts.to = jid;
        opts.type = 'headline';
        opts.attention = true;
        client.sendMessage(opts);
    };

    client.on('message', function (msg) {
        if (msg.attention) {
            client.emit('attention', msg);
        }
    });
};

},{}],1335:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/avatar'));

    client.disco.addFeature('urn:xmpp:avatar:metadata+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'urn:xmpp:avatar:metadata') {
            return;
        }

        client.emit('avatar', {
            jid: msg.from,
            source: 'pubsub',
            avatars: msg.event.updated.published[0].avatars
        });
    });

    client.on('presence', function (pres) {
        if (pres.avatarId) {
            client.emit('avatar', {
                jid: pres.from,
                source: 'vcard',
                avatars: [{
                    id: pres.avatarId
                }]
            });
        }
    });

    client.publishAvatar = function (id, data, cb) {
        return this.publish('', 'urn:xmpp:avatar:data', {
            id: id,
            avatarData: data
        }, cb);
    };

    client.useAvatars = function (info, cb) {
        return this.publish('', 'urn:xmpp:avatar:metadata', {
            id: 'current',
            avatars: info
        }, cb);
    };

    client.getAvatar = function (jid, id, cb) {
        return this.getItem(jid, 'urn:xmpp:avatar:data', id, cb);
    };
};

},{"../stanza/avatar":1387}],1336:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas, config) {
    stanzas.use(require('../stanza/bind'));

    client.registerFeature('bind', 300, function (features, cb) {
        var self = this;

        self.sendIq({
            type: 'set',
            bind: {
                resource: config.resource
            }
        }, function (err, resp) {
            if (err) {
                self.emit('session:error', err);
                return cb('disconnect', 'JID binding failed');
            }

            self.features.negotiated.bind = true;
            self.jid = new JID(resp.bind.jid);
            self.emit('session:bound', self.jid);

            var canStartSession = !features.session || (features.session && features.session.optional);
            if (!self.sessionStarted && canStartSession) {
                self.sessionStarted = true;
                self.emit('session:started', self.jid);
            }
            return cb();
        });
    });

    client.on('disconnected', function () {
        client.sessionStarted = false;
        client.features.negotiated.bind = false;
    });
};

},{"../stanza/bind":1388,"xmpp-jid":1604}],1337:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/blocking'));

    client.disco.addFeature('urn:xmpp:blocking');

    client.block = function (jid, cb) {
        return client.sendIq({
            type: 'set',
            block: {
                jids: [jid]
            }
        }, cb);
    };

    client.unblock = function (jid, cb) {
        return client.sendIq({
            type: 'set',
            unblock: {
                jids: [jid]
            }
        }, cb);
    };

    client.getBlocked = function (cb) {
        return client.sendIq({
            type: 'get',
            blockList: true
        }, cb);
    };

    client.on('iq:set:block', function (iq) {
        client.emit('block', {
            jids: iq.block.jids || []
        });
        client.sendIq(iq.resultReply());
    });

    client.on('iq:set:unblock', function (iq) {
        client.emit('unblock', {
            jids: iq.unblock.jids || []
        });
        client.sendIq(iq.resultReply());
    });
};

},{"../stanza/blocking":1389}],1338:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bob'));

    client.disco.addFeature('urn:xmpp:bob');

    client.getBits = function (jid, cid, cb) {
        return client.sendIq({
            to: jid,
            type: 'get',
            bob: {
                cid: cid
            }
        }, cb);
    };
};

},{"../stanza/bob":1390}],1339:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bookmarks'));

    client.getBookmarks = function (cb) {
        return this.getPrivateData({bookmarks: true}, cb);
    };

    client.setBookmarks = function (opts, cb) {
        return this.setPrivateData({bookmarks: opts}, cb);
    };

    client.addBookmark = function (bookmark, cb) {
        bookmark.jid = new JID(bookmark.jid);

        return this.getBookmarks().then(function (res) {
            var bookmarks = res.privateStorage.bookmarks.conferences || [];
            var existing = _.filter(bookmarks, function (bm) {
                return bm.jid.bare === bookmark.jid.bare;
            });

            if (existing.length) {
                _.extend(existing[0], bookmark);
            } else {
                bookmarks.push(bookmark);
            }

            return client.setBookmarks({conferences: bookmarks});
        }).nodeify(cb);
    };

    client.removeBookmark = function (jid, cb) {
        jid = new JID(jid);
        return this.getBookmarks().then(function (res) {
            var bookmarks = res.privateStorage.bookmarks.conferences || [];
            bookmarks = _.filter(bookmarks, function (bm) {
                return jid.bare !== bm.jid.bare;
            });
            return client.setBookmarks({conferences: bookmarks});
        }).nodeify(cb);
    };
};

},{"../stanza/bookmarks":1391,"underscore":1602,"xmpp-jid":1604}],1340:[function(require,module,exports){
'use strict';

var BOSHConnection = require('../transports/bosh');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bosh'));

    client.transports.bosh = BOSHConnection;
};

},{"../stanza/bosh":1392,"../transports/bosh":1445}],1341:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/carbons'));

    client.disco.addFeature('urn:xmpp:carbons:2');

    client.enableCarbons = function (cb) {
        return this.sendIq({
            type: 'set',
            enableCarbons: true
        }, cb);
    };

    client.disableCarbons = function (cb) {
        return this.sendIq({
            type: 'set',
            disableCarbons: true
        }, cb);
    };

    client.on('message', function (msg) {
        if (msg.carbonSent) {
            return client.emit('carbon:sent', msg);
        }
        if (msg.carbonReceived) {
            return client.emit('carbon:received', msg);
        }
    });

    client.on('carbon:*', function (name, carbon) {
        var dir = name.split(':')[1];

        if (carbon.from.bare !== client.jid.bare) {
            return;
        }

        var msg, delay;
        if (dir === 'received') {
            msg = carbon.carbonReceived.forwarded.message;
            delay = carbon.carbonReceived.forwarded.delay;
        } else {
            msg = carbon.carbonSent.forwarded.message;
            delay = carbon.carbonSent.forwarded.delay;
        }

        if (!msg.delay) {
            if (delay) {
                msg.delay.stamp = delay.stamp;
            } else {
                msg.delay = {
                    stamp: new Date(Date.now())
                };
            }
        }

        msg.carbon = true;

        // Treat the carbon copied message however we would
        // have originally treated it ourself.
        if (msg.from.bare === client.jid.bare) {
            client.emit('message:sent', msg);
        } else {
            client.emit('message', msg);
        }
    });
};

},{"../stanza/carbons":1394}],1342:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('http://jabber.org/protocol/chatstates');

    client.on('message', function (msg) {
        if (msg.chatState) {
            client.emit('chat:state', {
                to: msg.to,
                from: msg.from,
                chatState: msg.chatState
            });
            client.emit('chatState', {
                to: msg.to,
                from: msg.from,
                chatState: msg.chatState
            });
        }
    });
};

},{}],1343:[function(require,module,exports){
'use strict';


var NS = 'http://jabber.org/protocol/commands';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/command'));

    client.disco.addFeature(NS);
    client.disco.addItem({
        name: 'Ad-Hoc Commands',
        node: NS
    });


    client.getCommands = function (jid, cb) {
        return client.getDiscoItems(jid, NS, cb);
    };
};

},{"../stanza/command":1395}],1344:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:message-correct:0');

    client.on('message', function (msg) {
        if (msg.replace) {
            client.emit('replace', msg);
            client.emit('replace:' + msg.id, msg);
        }
    });
};

},{}],1345:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/csi'));

    var Active = stanzas.getDefinition('active', 'urn:xmpp:csi');
    var Inactive = stanzas.getDefinition('inactive', 'urn:xmpp:csi');


    client.registerFeature('clientStateIndication', 400, function (features, cb) {
        this.features.negotiated.clientStateIndication = true;
        cb();
    });

    client.markActive = function () {
        if (this.features.negotiated.clientStateIndication) {
            this.send(new Active());
        }
    };

    client.markInactive = function () {
        if (this.features.negotiated.clientStateIndication) {
            this.send(new Inactive());
        }
    };
};

},{"../stanza/csi":1396}],1346:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/dataforms'));

    client.disco.addFeature('jabber:x:data');
    client.disco.addFeature('urn:xmpp:media-element');
    client.disco.addFeature('http://jabber.org/protocol/xdata-validate');
    client.disco.addFeature('http://jabber.org/protocol/xdata-layout');

    client.on('message', function (msg) {
        if (msg.form) {
            client.emit('dataform', msg);
        }
    });
};

},{"../stanza/dataforms":1397}],1347:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/delayed'));
    client.disco.addFeature('urn:xmpp:delay');
};

},{"../stanza/delayed":1398}],1348:[function(require,module,exports){
(function (Buffer){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;
var hashes = require('iana-hashes');


function generateVerString(info, hash) {
    var S = '';
    var features = info.features.sort();
    var identities = [];
    var formTypes = {};
    var formOrder = [];

    _.forEach(info.identities, function (identity) {
        identities.push([
            identity.category || '',
            identity.type || '',
            identity.lang || '',
            identity.name || ''
        ].join('/'));
    });

    identities.sort();

    var idLen = identities.length;
    var featureLen = features.length;

    identities = _.unique(identities, true);
    features = _.unique(features, true);

    if (featureLen !== features.length || idLen !== identities.length) {
        return false;
    }


    S += identities.join('<') + '<';
    S += features.join('<') + '<';


    var illFormed = false;
    _.forEach(info.extensions, function (ext) {
        var fields = ext.fields;
        for (var i = 0, len = fields.length; i < len; i++) {
            if (fields[i].name === 'FORM_TYPE' && fields[i].type === 'hidden') {
                var name = fields[i].value;
                if (formTypes[name]) {
                    illFormed = true;
                    return;
                }
                formTypes[name] = ext;
                formOrder.push(name);
                return;
            }
        }
    });
    if (illFormed) {
        return false;
    }

    formOrder.sort();

    _.forEach(formOrder, function (name) {
        var ext = formTypes[name];
        var fields = {};
        var fieldOrder = [];

        S += '<' + name;

        _.forEach(ext.fields, function (field) {
            var fieldName = field.name;
            if (fieldName !== 'FORM_TYPE') {
                var values = field.value || '';
                if (typeof values !== 'object') {
                    values = values.split('\n');
                }
                fields[fieldName] = values.sort();
                fieldOrder.push(fieldName);
            }
        });

        fieldOrder.sort();

        _.forEach(fieldOrder, function (fieldName) {
            S += '<' + fieldName;
            _.forEach(fields[fieldName], function (val) {
                S += '<' + val;
            });
        });
    });

    var ver = hashes.createHash(hash).update(new Buffer(S, 'utf8')).digest('base64');
    var padding = 4 - ver.length % 4;
    if (padding === 4) {
        padding = 0;
    }

    for (var i = 0; i < padding; i++) {
        ver += '=';
    }
    return ver;
}

function verifyVerString(info, hash, check) {
    var computed = generateVerString(info, hash);
    return computed && computed === check;
}


function Disco() {
    this.features = {};
    this.identities = {};
    this.extensions = {};
    this.items = {};
    this.caps = {};
}

Disco.prototype = {
    constructor: {
        value: Disco
    },
    addFeature: function (feature, node) {
        node = node || '';
        if (!this.features[node]) {
            this.features[node] = [];
        }
        this.features[node].push(feature);
    },
    addIdentity: function (identity, node) {
        node = node || '';
        if (!this.identities[node]) {
            this.identities[node] = [];
        }
        this.identities[node].push(identity);
    },
    addItem: function (item, node) {
        node = node || '';
        if (!this.items[node]) {
            this.items[node] = [];
        }
        this.items[node].push(item);
    },
    addExtension: function (form, node) {
        node = node || '';
        if (!this.extensions[node]) {
            this.extensions[node] = [];
        }
        this.extensions[node].push(form);
    }
};

module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/disco'));
    stanzas.use(require('../stanza/caps'));
    stanzas.use(require('../stanza/rsm'));


    client.disco = new Disco(client);

    client.disco.addFeature('http://jabber.org/protocol/disco#info');
    client.disco.addFeature('http://jabber.org/protocol/disco#items');
    client.disco.addIdentity({
        category: 'client',
        type: 'web'
    });

    client.registerFeature('caps', 100, function (features, cb) {
        this.emit('disco:caps', {
            from: new JID(this.jid.domain),
            caps: features.caps
        });
        this.features.negotiated.caps = true;
        cb();
    });

    client.getDiscoInfo = function (jid, node, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            discoInfo: {
                node: node
            }
        }, cb);
    };

    client.getDiscoItems = function (jid, node, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            discoItems: {
                node: node
            }
        }, cb);
    };

    client.updateCaps = function () {
        var node = this.config.capsNode || 'https://stanza.io';
        var data = JSON.parse(JSON.stringify({
            identities: this.disco.identities[''],
            features: this.disco.features[''],
            extensions: this.disco.extensions['']
        }));

        var ver = generateVerString(data, 'sha-1');

        this.disco.caps = {
            node: node,
            hash: 'sha-1',
            ver: ver
        };

        node = node + '#' + ver;
        this.disco.features[node] = data.features;
        this.disco.identities[node] = data.identities;
        this.disco.extensions[node] = data.extensions;

        return client.getCurrentCaps();
    };

    client.getCurrentCaps = function () {
        var caps = client.disco.caps;
        if (!caps.ver) {
            return {ver: null, discoInfo: null};
        }

        var node = caps.node + '#' + caps.ver;
        return {
            ver: caps.ver,
            discoInfo: {
                identities: client.disco.identities[node],
                features: client.disco.features[node],
                extensions: client.disco.extensions[node]
            }
        };
    };

    client.on('presence', function (pres) {
        if (pres.caps) {
            client.emit('disco:caps', pres);
        }
    });

    client.on('iq:get:discoInfo', function (iq) {
        var node = iq.discoInfo.node || '';
        var reportedNode = iq.discoInfo.node || '';

        if (node === client.disco.caps.node + '#' + client.disco.caps.ver) {
            reportedNode = node;
            node = '';
        }

        client.sendIq(iq.resultReply({
            discoInfo: {
                node: reportedNode,
                identities: client.disco.identities[node] || [],
                features: client.disco.features[node] || [],
                extensions: client.disco.extensions[node] || []
            }
        }));
    });

    client.on('iq:get:discoItems', function (iq) {
        var node = iq.discoItems.node;
        client.sendIq(iq.resultReply({
            discoItems: {
                node: node,
                items: client.disco.items[node] || []
            }
        }));
    });

    client.verifyVerString = verifyVerString;
    client.generateVerString = generateVerString;

    // Ensure we always have some caps data
    client.updateCaps();
};

}).call(this,require("buffer").Buffer)
},{"../stanza/caps":1393,"../stanza/disco":1399,"../stanza/rsm":1431,"buffer":9,"iana-hashes":1469,"underscore":1602,"xmpp-jid":1604}],1349:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('jid\\20escaping');
};

},{}],1350:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/extdisco'));

    client.disco.addFeature('urn:xmpp:extdisco:1');

    client.getServices = function (jid, type, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            services: {
                type: type
            }
        }, cb);
    };

    client.getServiceCredentials = function (jid, host, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            credentials: {
                service: {
                    host: host
                }
            }
        }, cb);
    };
};

},{"../stanza/extdisco":1401}],1351:[function(require,module,exports){
'use strict';

var async = require('async');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/streamFeatures'));

    client.features = {
        negotiated: {},
        order: [],
        handlers: {}
    };

    client.registerFeature = function (name, priority, handler) {
        this.features.order.push({
            priority: priority,
            name: name
        });
        this.features.order.sort(function (a, b) {
            if (a.priority < b.priority) {
                return -1;
            }
            if (a.priority > b.priority) {
                return 1;
            }
            return 0;
        });
        this.features.handlers[name] = handler.bind(client);
    };

    client.on('streamFeatures', function (features) {
        var series = [];
        var negotiated = client.features.negotiated;
        var handlers = client.features.handlers;

        client.features.order.forEach(function (feature) {
            var name = feature.name;
            if (features[name] && handlers[name] && !negotiated[name]) {
                series.push(function (cb) {
                    if (!negotiated[name]) {
                        handlers[name](features, cb);
                    } else {
                        cb();
                    }
                });
            }
        });

        async.series(series, function (cmd, msg) {
            if (cmd === 'restart') {
                client.transport.restart();
            } else if (cmd === 'disconnect') {
                client.emit('stream:error', {
                    condition: 'policy-violation',
                    text: 'Failed to negotiate stream features: ' + msg
                });
                client.disconnect();
            }
        });
    });
};

},{"../stanza/streamFeatures":1440,"async":1463}],1352:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/forwarded'));

    client.disco.addFeature('urn:xmpp:forward:0');
};

},{"../stanza/forwarded":1403}],1353:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/geoloc'));

    client.disco.addFeature('http://jabber.org/protocol/geoloc');
    client.disco.addFeature('http://jabber.org/protocol/geoloc+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'http://jabber.org/protocol/geoloc') {
            return;
        }

        client.emit('geoloc', {
            jid: msg.from,
            geoloc: msg.event.updated.published[0].geoloc
        });
    });

    client.publishGeoLoc = function (data, cb) {
        return this.publish('', 'http://jabber.org/protocol/geoloc', {
            geoloc: data
        }, cb);
    };
};

},{"../stanza/geoloc":1405}],1354:[function(require,module,exports){
'use strict';

var hashes = require('iana-hashes');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/hash'));

    client.disco.addFeature('urn:xmpp:hashes:1');

    var names = hashes.getHashes();
    names.forEach(function (name) {
        client.disco.addFeature('urn:xmpp:hash-function-text-names:' + name);
    });
};

},{"../stanza/hash":1406,"iana-hashes":1469}],1355:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:idle:1');
};

},{}],1356:[function(require,module,exports){
'use strict';

module.exports = function (client) {
    // We always need this one first
    client.use(require('./disco'));

    client.use(require('./attention'));
    client.use(require('./avatar'));
    client.use(require('./blocking'));
    client.use(require('./bob'));
    client.use(require('./bookmarks'));
    client.use(require('./carbons'));
    client.use(require('./chatstates'));
    client.use(require('./command'));
    client.use(require('./correction'));
    client.use(require('./csi'));
    client.use(require('./dataforms'));
    client.use(require('./delayed'));
    client.use(require('./escaping'));
    client.use(require('./extdisco'));
    client.use(require('./forwarding'));
    client.use(require('./geoloc'));
    client.use(require('./hashes'));
    client.use(require('./idle'));
    client.use(require('./invisible'));
    client.use(require('./jidprep'));
    client.use(require('./jingle'));
    client.use(require('./json'));
    client.use(require('./keepalive'));
    client.use(require('./logging'));
    client.use(require('./mam'));
    client.use(require('./muc'));
    client.use(require('./mood'));
    client.use(require('./nick'));
    client.use(require('./oob'));
    client.use(require('./ping'));
    client.use(require('./private'));
    client.use(require('./psa'));
    client.use(require('./pubsub'));
    client.use(require('./reach'));
    client.use(require('./receipts'));
    client.use(require('./register'));
    client.use(require('./roster'));
    client.use(require('./rtt'));
    client.use(require('./shim'));
    client.use(require('./time'));
    client.use(require('./vcard'));
    client.use(require('./version'));
};

},{"./attention":1334,"./avatar":1335,"./blocking":1337,"./bob":1338,"./bookmarks":1339,"./carbons":1341,"./chatstates":1342,"./command":1343,"./correction":1344,"./csi":1345,"./dataforms":1346,"./delayed":1347,"./disco":1348,"./escaping":1349,"./extdisco":1350,"./forwarding":1352,"./geoloc":1353,"./hashes":1354,"./idle":1355,"./invisible":1357,"./jidprep":1358,"./jingle":1359,"./json":1360,"./keepalive":1361,"./logging":1362,"./mam":1363,"./mood":1364,"./muc":1365,"./nick":1366,"./oob":1368,"./ping":1369,"./private":1370,"./psa":1371,"./pubsub":1372,"./reach":1373,"./receipts":1374,"./register":1375,"./roster":1376,"./rtt":1377,"./shim":1380,"./time":1382,"./vcard":1383,"./version":1384}],1357:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/visibility'));

    client.goInvisible = function (cb) {
        return this.sendIq({
            type: 'set',
            invisible: true
        }, cb);
    };

    client.goVisible = function (cb) {
        return this.sendIq({
            type: 'set',
            visible: true
        }, cb);
    };
};

},{"../stanza/visibility":1444}],1358:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/jidprep'));

    client.prepJID = function (jid, cb) {
        return client.sendIq({
            to: client.jid.domain,
            type: 'get',
            jidPrep: jid
        }, cb);
    };
};

},{"../stanza/jidprep":1410}],1359:[function(require,module,exports){
'use strict';

var Jingle = require('jingle');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/jingle'));
    stanzas.use(require('../stanza/rtp'));
    stanzas.use(require('../stanza/iceUdp'));
    stanzas.use(require('../stanza/file'));


    var jingle = client.jingle = new Jingle();

    jingle.capabilities.forEach(function (cap) {
        client.disco.addFeature(cap);
    });

    var mappedEvents = [
        'outgoing', 'incoming', 'accepted', 'terminated',
        'ringing', 'mute', 'unmute', 'hold', 'resumed'
    ];
    mappedEvents.forEach(function (event) {
        jingle.on(event, function (session, arg1) {
            client.emit('jingle:' + event, session, arg1);
        });
    });

    jingle.on('createdSession', function (session) {
        client.emit('jingle:created', session);
    });

    jingle.on('peerStreamAdded', function (session, stream) {
        client.emit('jingle:remotestream:added', session, stream);
    });

    jingle.on('peerStreamRemoved', function (session, stream) {
        client.emit('jingle:remotestream:removed', session, stream);
    });

    jingle.on('send', function (data) {
        client.sendIq(data, function (err) {
            if (err) {
                client.emit('jingle:error', err);
            }
        });
    });

    client.on('session:bound', function (jid) {
        jingle.jid = jid;
        jingle.selfID = jid.full;
    });

    client.on('iq:set:jingle', function (data) {
        jingle.process(data);
    });

    client.on('unavailable', function (pres) {
        var peer = pres.from.full;
        jingle.endPeerSessions(peer, true);
    });

    client.discoverICEServers = function (cb) {
        return this.getServices(client.config.server).then(function (res) {
            var services = res.services.services;
            var discovered = [];

            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                var ice = {};
                if (service.type === 'stun' || service.type === 'stuns') {
                    ice.url = service.type + ':' + service.host;
                    if (service.port) {
                        ice.url += ':' + service.port;
                    }
                    discovered.push(ice);
                    client.jingle.addICEServer(ice);
                } else if (service.type === 'turn' || service.type === 'turns') {
                    ice.url = service.type + ':' + service.host;
                    if (service.port) {
                        ice.url += ':' + service.port;
                    }
                    if (service.transport && service.transport !== 'udp') {
                        ice.url += '?transport=' + service.transport;
                    }

                    if (service.username) {
                        ice.username = service.username;
                    }
                    if (service.password) {
                        ice.credential = service.password;
                    }
                    discovered.push(ice);
                    client.jingle.addICEServer(ice);
                }
            }

            return discovered;
        }).nodeify(cb);
    };
};

},{"../stanza/file":1402,"../stanza/iceUdp":1408,"../stanza/jingle":1411,"../stanza/rtp":1432,"jingle":1486}],1360:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/json'));
    client.disco.addFeature('urn:xmpp:json:0');
};

},{"../stanza/json":1412}],1361:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');


function checkConnection(client, timeout) {
    return new BPromise(function (resolve, reject) {
        if (client.sm.started) {
            client.once('stream:management:ack', resolve);
            client.sm.request();
        } else {
            client.ping().then(resolve).catch(function (err) {
                if (err.error && err.error.condition !== 'timeout') {
                    resolve();
                } else {
                    reject();
                }
            });
        }
    }).timeout(timeout * 1000 || 15000);
}


module.exports = function (client) {
    client.enableKeepAlive = function (opts) {
        opts = opts || {};

        // Ping every 5 minutes
        opts.interval = opts.interval || 300;

        // Disconnect if no response in 15 seconds
        opts.timeout = opts.timeout || 15;

        function keepalive() {
            if (client.sessionStarted) {
                checkConnection(client, opts.timeout).catch(function () {
                    client.sendStreamError({
                        condition: 'connection-timeout'
                    });
                });
            }
        }

        client._keepAliveInterval = setInterval(keepalive, opts.interval * 1000);
    };

    client.disableKeepAlive = function () {
        if (client._keepAliveInterval) {
            clearInterval(client._keepAliveInterval);
            delete client._keepAliveInterval;
        }
    };

    client.on('disconnected', function () {
        client.disableKeepAlive();
    });
};

},{"bluebird":1464}],1362:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/logging'));

    client.disco.addFeature('', 'urn:xmpp:eventlog');

    client.sendLog = function (jid, logData) {
        client.sendMessage({
            to: jid,
            type: 'normal',
            log: logData
        });
    };
};

},{"../stanza/logging":1413}],1363:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/mam'));

    client.disco.addFeature('urn:xmpp:mam:0');

    client.getHistorySearchForm = function (jid, cb) {
        return client.sendIq({
            to: jid,
            type: 'get',
            mam: true
        }, cb);
    };

    client.searchHistory = function (opts, cb) {
        var self = this;
        var queryid = this.nextId();

        opts = opts || {};
        opts.queryid = queryid;

        var to = opts.jid || opts.to || '';
        delete opts.jid;
        delete opts.to;

        if (!opts.form) {
            opts.form = {};
        }
        opts.form.type = 'submit';
        var fields = opts.form.fields = opts.form.fields || [];

        var defaultFields = ['FORM_TYPE', 'with', 'start', 'end'];
        defaultFields.forEach(function (name) {
            if (opts[name] || name === 'FORM_TYPE') {
                var val = opts[name];
                var isDate = (name === 'start' || name === 'end');
                if (isDate && typeof val !== 'string') {
                    val = val.toISOString();
                }
                if (name === 'FORM_TYPE') {
                    val = 'urn:xmpp:mam:0';
                }

                var existing = false;
                for (var i = 0, len = fields.length; i < len; i++) {
                    if (fields[i].name === name) {
                        continue;
                    }
                }

                if (!existing) {
                    fields.push({
                        name: name,
                        value: val
                    });
                }

                delete opts[name];
            }
        });

        var dest = new JID(to || client.jid.bare);
        var allowed = {};
        allowed[''] = true;
        allowed[dest.full] = true;
        allowed[dest.bare] = true;
        allowed[dest.domain] = true;
        allowed[client.jid.bare] = true;
        allowed[client.jid.domain] = true;

        var results = [];

        this.on('mam:item:' + queryid, 'session', function (msg) {
            if (!allowed[msg.from.full]) {
                return;
            }
            results.push(msg.mamItem);
        });

        var collectResults = new BPromise(function (resolve) {
            self.once('mam:result:' + queryid, 'session', function (msg) {
                if (!allowed[msg.from.full]) {
                    return;
                }
                msg.mamResult.items = results;
                resolve(msg);
            });
        });

        var mamQuery = this.sendIq({
            type: 'set',
            to: to,
            id: queryid,
            mam: opts
        });

        return BPromise.all([mamQuery, collectResults])
            .spread(function (iqRes, mamRes) {
                return mamRes;
            })
            .timeout(self.config.timeout * 1000 || 15000)
            .catch(BPromise.TimeoutError, function () {
                throw {
                    id: queryid,
                    type: 'error',
                    error: {
                        condition: 'timeout'
                    }
                };
            })
            .finally(function () {
                self.off('mam:item:' + queryid);
                self.off('mam:result:' + queryid);
            })
            .nodeify(cb);
    };

    client.getHistoryPreferences = function (cb) {
        return this.sendIq({
            type: 'get',
            mamPrefs: true
        }, cb);
    };

    client.setHistoryPreferences = function (opts, cb) {
        return this.sendIq({
            type: 'set',
            mamPrefs: opts
        }, cb);
    };

    client.on('message', function (msg) {
        if (msg.mamItem) {
            client.emit('mam:item:' + msg.mamItem.queryid, msg);
        }
        if (msg.mamResult) {
            client.emit('mam:result:' + msg.mamResult.queryid, msg);
        }
    });
};

},{"../stanza/mam":1414,"bluebird":1464,"xmpp-jid":1604}],1364:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/mood';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/mood'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }

        if (msg.event.updated.node !== NS) {
            return;
        }

        client.emit('mood', {
            jid: msg.from,
            mood: msg.event.updated.published[0].mood
        });
    });

    client.publishMood = function (mood, text, cb) {
        return this.publish('', NS, {
            mood: {
                value: mood,
                text: text
            }
        }, cb);
    };
};

},{"../stanza/mood":1416}],1365:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/muc'));
    stanzas.use(require('../stanza/hats'));

    client.disco.addFeature('http://jabber.org/protocol/muc');
    client.disco.addFeature('jabber:x:conference');
    client.disco.addFeature('urn:xmpp:hats:0');

    client.joinedRooms = {};

    function rejoinRooms() {
        _.each(client.joinedRooms, function (nick, room) {
            client.joinedRooms[room] = false;
            client.joinRoom(room, nick);
        });
    }
    client.on('session:started', rejoinRooms);
    client.on('stream:management:resumed', rejoinRooms);

    client.on('message', function (msg) {
        if (msg.muc) {
            if (msg.muc.invite) {
                client.emit('muc:invite', {
                    from: msg.muc.invite.from,
                    room: msg.from,
                    reason: msg.muc.invite.reason,
                    password: msg.muc.password,
                    thread: msg.muc.invite.thread,
                    type: 'mediated'
                });
            }
            if (msg.muc.destroyed) {
                client.emit('muc:destroyed', {
                    room: msg.from,
                    newRoom: msg.muc.destroyed.jid,
                    reason: msg.muc.destroyed.reason,
                    password: msg.muc.password
                });
            }
            if (msg.muc.decline) {
                client.emit('muc:declined', {
                    room: msg.from,
                    from: msg.muc.decline.from,
                    reason: msg.muc.decline.reason
                });
            }
        } else if (msg.mucInvite) {
            client.emit('muc:invite', {
                from: msg.from,
                room: msg.mucInvite.jid,
                reason: msg.mucInvite.reason,
                password: msg.mucInvite.password,
                thread: msg.mucInvite.thread,
                type: 'direct'
            });
        }

        if (msg.type === 'groupchat' && msg.subject) {
            client.emit('muc:subject', msg);
        }
    });

    client.on('presence', function (pres) {
        if (pres.joinMuc && pres.type === 'error') {
            client.emit('muc:error', pres);
        } else if (pres.muc) {
            var isSelf = pres.muc.codes && pres.muc.codes.indexOf('110') >= 0;
            if (pres.type === 'error') {
                client.emit('muc:error', pres);
            } else if (pres.type === 'unavailable') {
                client.emit('muc:unavailable', pres);
                if (isSelf) {
                    client.emit('muc:leave', pres);
                    delete client.joinedRooms[pres.from.bare];
                }
            } else {
                client.emit('muc:available', pres);
                if (isSelf && !client.joinedRooms[pres.from.bare]) {
                    client.emit('muc:join', pres);
                    client.joinedRooms[pres.from.bare] = pres.from.resource;
                }
            }
        }
    });

    client.joinRoom = function (room, nick, opts) {
        opts = opts || {};
        opts.to = room + '/' + nick;
        opts.caps = this.disco.caps;
        opts.joinMuc = opts.joinMuc || {};

        this.sendPresence(opts);
    };

    client.leaveRoom = function (room, nick, opts) {
        opts = opts || {};
        opts.to = room + '/' + nick;
        opts.type = 'unavailable';
        this.sendPresence(opts);
    };

    client.ban = function (room, jid, reason, cb) {
        client.setRoomAffiliation(room, jid, 'outcast', reason, cb);
    };

    client.kick = function (room, nick, reason, cb) {
        client.setRoomRole(room, nick, 'none', reason, cb);
    };

    client.invite = function (room, opts) {
        client.sendMessage({
            to: room,
            muc: {
                invites: opts
            }
        });
    };

    client.directInvite = function (room, opts) {
        opts.jid = room;
        client.sendMessage({
            to: opts.to,
            mucInvite: opts
        });
    };

    client.declineInvite = function (room, sender, reason) {
        client.sendMessage({
            to: room,
            muc: {
                decline: {
                    to: sender,
                    reason: reason
                }
            }
        });
    };

    client.changeNick = function (room, nick) {
        client.sendPresence({
            to: (new JID(room)).bare + '/' + nick
        });
    };

    client.setSubject = function (room, subject) {
        client.sendMessage({
            to: room,
            type: 'groupchat',
            subject: subject
        });
    };

    client.discoverReservedNick = function (room, cb) {
        client.getDiscoInfo(room, 'x-roomuser-item', function (err, res) {
            if (err) {
                return cb(err);
            }
            var ident = res.discoInfo.identities[0] || {};
            cb(null, ident.name);
        });
    };

    client.requestRoomVoice = function (room) {
        client.sendMessage({
            to: room,
            form: {
                fields: [
                    {
                        name: 'FORM_TYPE',
                        value: 'http://jabber.org/protocol/muc#request'
                    },
                    {
                        name: 'muc#role',
                        type: 'text-single',
                        value: 'participant'
                    }
                ]
            }
        });
    };

    client.setRoomAffiliation = function (room, jid, affiliation, reason, cb) {
        return this.sendIq({
            type: 'set',
            to: room,
            mucAdmin: {
                jid: jid,
                affiliation: affiliation,
                reason: reason
            }
        }, cb);
    };

    client.setRoomRole = function (room, nick, role, reason, cb) {
        return this.sendIq({
            type: 'set',
            to: room,
            mucAdmin: {
                nick: nick,
                role: role,
                reason: reason
            }
        }, cb);
    };

    client.getRoomMembers = function (room, opts, cb) {
        return this.sendIq({
            type: 'get',
            to: room,
            mucAdmin: opts
        }, cb);
    };

    client.getRoomConfig = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            mucOwner: true
        }, cb);
    };

    client.configureRoom = function (jid, form, cb) {
        if (!form.type) {
            form.type = 'submit';
        }
        return this.sendIq({
            to: jid,
            type: 'set',
            mucOwner: {
                form: form
            }
        }, cb);
    };

    client.getUniqueRoomName = function (jid, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            mucUnique: true
        }, cb);
    };
};

},{"../stanza/hats":1407,"../stanza/muc":1417,"underscore":1602,"xmpp-jid":1604}],1366:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/nick';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/nick'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== NS) {
            return;
        }

        client.emit('nick', {
            jid: msg.from,
            nick: msg.event.updated.published[0].nick
        });
    });

    client.publishNick = function (nick, cb) {
        return this.publish('', NS, {
            nick: nick
        }, cb);
    };
};

},{"../stanza/nick":1418}],1367:[function(require,module,exports){
'use strict';

var OldWSConnection = require('../transports/old-websocket');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/stream'));

    client.transports['old-websocket'] = OldWSConnection;
};

},{"../stanza/stream":1438,"../transports/old-websocket":1446}],1368:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/oob'));
    client.disco.addFeature('jabber:x:oob');
};

},{"../stanza/oob":1419}],1369:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/ping'));

    client.disco.addFeature('urn:xmpp:ping');

    client.on('iq:get:ping', function (iq) {
        client.sendIq(iq.resultReply());
    });

    client.ping = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            ping: true
        }, cb);
    };
};

},{"../stanza/ping":1420}],1370:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/private'));

    client.getPrivateData = function (opts, cb) {
        return this.sendIq({
            type: 'get',
            privateStorage: opts
        }, cb);
    };

    client.setPrivateData = function (opts, cb) {
        return this.sendIq({
            type: 'set',
            privateStorage: opts
        }, cb);
    };
};

},{"../stanza/private":1422}],1371:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/psa'));
    client.disco.addFeature('urn:xmpp:psa');
};

},{"../stanza/psa":1423}],1372:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/pubsub'));
    stanzas.use(require('../stanza/pubsubOwner'));
    stanzas.use(require('../stanza/pubsubEvents'));
    stanzas.use(require('../stanza/pubsubError'));

    client.on('message', function (msg) {
        if (msg.event) {
            client.emit('pubsub:event', msg);
            client.emit('pubsubEvent', msg);

            if (msg.event.updated) {
                var published = msg.event.updated.published;
                var retracted = msg.event.updated.retracted;


                if (published && published.length) {
                    client.emit('pubsub:published', msg);
                }

                if (retracted && retracted.length) {
                    client.emit('pubsub:retracted', msg);
                }
            }

            if (msg.event.purged) {
                client.emit('pubsub:purged', msg);
            }

            if (msg.event.deleted) {
                client.emit('pubsub:deleted', msg);
            }

            if (msg.event.subscriptionChanged) {
                client.emit('pubsub:subscription', msg);
            }

            if (msg.event.configurationChanged) {
                client.emit('pubsub:config', msg);
            }
        }

        if (msg.pubsub && msg.pubsub.affiliations) {
            client.emit('pubsub:affiliation', msg);
        }
    });

    client.subscribeToNode = function (jid, opts, cb) {
        if (typeof opts === 'string') {
            opts = {
                node: opts
            };
        }
        opts.jid = opts.jid || client.jid;

        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                subscribe: opts
            }
        }, cb);
    };

    client.unsubscribeFromNode = function (jid, opts, cb) {
        if (typeof opts === 'string') {
            opts = {
                node: opts
            };
        }
        opts.jid = opts.jid || client.jid.bare;

        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                unsubscribe: opts
            }
        }, cb);
    };

    client.publish = function (jid, node, item, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                publish: {
                    node: node,
                    item: item
                }
            }
        }, cb);
    };

    client.getItem = function (jid, node, id, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                retrieve: {
                    node: node,
                    item: id
                }
            }
        }, cb);
    };

    client.getItems = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;
        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                retrieve: {
                    node: node,
                    max: opts.max
                },
                rsm: opts.rsm
            }
        }, cb);
    };

    client.retract = function (jid, node, id, notify, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                retract: {
                    node: node,
                    notify: notify,
                    id: id
                }
            }
        }, cb);
    };

    client.purgeNode = function (jid, node, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                purge: node
            }
        }, cb);
    };

    client.deleteNode = function (jid, node, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                del: node
            }
        }, cb);
    };

    client.createNode = function (jid, node, config, cb) {
        var cmd = {
            type: 'set',
            to: jid,
            pubsubOwner: {
                create: node
            }
        };

        if (config) {
            cmd.pubsubOwner.config = {form: config};
        }

        return this.sendIq(cmd, cb);
    };

    client.getSubscriptions = function (jid, opts, cb) {
        opts = opts || {};

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                subscriptions: opts
            }
        }, cb);
    };

    client.getAffiliations = function (jid, opts, cb) {
        opts = opts || {};

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                affiliations: opts
            }
        }, cb);
    };

    client.getNodeSubscribers = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsubOwner: {
                subscriptions: opts
            }
        }, cb);
    };

    client.updateNodeSubscriptions = function (jid, node, delta, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                subscriptions: {
                    node: node,
                    list: delta
                }
            }
        }, cb);
    };

    client.getNodeAffiliations = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsubOwner: {
                affiliations: opts
            }
        }, cb);
    };

    client.updateNodeAffiliations = function (jid, node, delta, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                affiliations: {
                    node: node,
                    list: delta
                }
            }
        }, cb);
    };
};

},{"../stanza/pubsub":1424,"../stanza/pubsubError":1425,"../stanza/pubsubEvents":1426,"../stanza/pubsubOwner":1427}],1373:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/reach'));

    client.disco.addFeature('urn:xmpp:reach:0');
    client.disco.addFeature('urn:xmpp:reach:0+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'urn:xmpp:reach:0') {
            return;
        }

        client.emit('reachability', {
            jid: msg.from,
            addresses: msg.event.updated.published[0].reach
        });
    });

    client.on('presence', function (pres) {
        if (!pres.reach || !pres.reach.length) {
            return;
        }

        client.emit('reachability', {
            jid: pres.from,
            addresses: pres.reach
        });
    });

    client.publishReachability = function (data, cb) {
        return this.publish('', 'urn:xmpp:reach:0', {
            reach: data
        }, cb);
    };
};

},{"../stanza/reach":1428}],1374:[function(require,module,exports){
'use strict';

module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:receipts');

    client.on('message', function (msg) {
        var ackTypes = {
            normal: true,
            chat: true,
            headline: true
        };
        if (ackTypes[msg.type] && msg.requestReceipt && !msg.receipt) {
            client.sendMessage({
                to: msg.from,
                receipt: msg.id,
                id: msg.id
            });
        }
        if (msg.receipt) {
            client.emit('receipt', msg);
            client.emit('receipt:' + msg.receipt);
        }
    });
};

},{}],1375:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/register'));

    client.getAccountInfo = function (jid, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            register: true
        }, cb);
    };

    client.updateAccount = function (jid, data, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            register: data
        }, cb);
    };

    client.deleteAccount = function (jid, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            register: {
                remove: true
            }
        }, cb);
    };
};

},{"../stanza/register":1429}],1376:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/roster'));

    client.on('iq:set:roster', function (iq) {
        var allowed = {};
        allowed[''] = true;
        allowed[client.jid.bare] = true;
        allowed[client.jid.domain] = true;

        if (!allowed[iq.from.full]) {
            return client.sendIq(iq.errorReply({
                error: {
                    type: 'cancel',
                    condition: 'service-unavailable'
                }
            }));
        }

        client.emit('roster:update', iq);
        client.sendIq({
            id: iq.id,
            type: 'result'
        });
    });

    client.getRoster = function (cb) {
        var self = this;
        cb = cb || function () {};

        return client.sendIq({
            type: 'get',
            roster: {
                ver: self.config.rosterVer
            }
        }).then(function (resp) {
            if (resp.roster) {
                var ver = resp.roster.ver;
                if (ver) {
                    self.config.rosterVer = ver;
                    self.emit('roster:ver', ver);
                }
            }
            return resp;
        }).nodeify(cb);
    };

    client.updateRosterItem = function (item, cb) {
        return client.sendIq({
            type: 'set',
            roster: {
                items: [item]
            }
        }, cb);
    };

    client.removeRosterItem = function (jid, cb) {
        return client.updateRosterItem({jid: jid, subscription: 'remove'}, cb);
    };

    client.subscribe = function (jid) {
        client.sendPresence({type: 'subscribe', to: jid});
    };

    client.unsubscribe = function (jid) {
        client.sendPresence({type: 'unsubscribe', to: jid});
    };

    client.acceptSubscription = function (jid) {
        client.sendPresence({type: 'subscribed', to: jid});
    };

    client.denySubscription = function (jid) {
        client.sendPresence({type: 'unsubscribed', to: jid});
    };
};

},{"../stanza/roster":1430}],1377:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/rtt'));

    client.disco.addFeature('urn:xmpp:rtt:0');

    client.on('message', function (msg) {
        if (msg.rtt) {
            client.emit('rtt', msg);
            client.emit('rtt:' + msg.rtt.event, msg);
        }
    });
};

},{"../stanza/rtt":1433}],1378:[function(require,module,exports){
(function (Buffer){
'use strict';


var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/sasl'));

    var Auth = stanzas.getDefinition('auth', NS);
    var Response = stanzas.getDefinition('response', NS);

    client.registerFeature('sasl', 100, function (features, cb) {
        var self = this;

        var mech = self.SASLFactory.create(features.sasl.mechanisms);
        if (!mech) {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            return cb('disconnect', 'authentication failed');
        }

        self.on('sasl:success', 'sasl', function () {
            self.features.negotiated.sasl = true;
            self.releaseGroup('sasl');
            self.emit('auth:success', self.config.credentials);
            cb('restart');
        });

        self.on('sasl:challenge', 'sasl', function (challenge) {
            mech.challenge(challenge.value);
            self.send(new Response({
                value: mech.response(self.getCredentials())
            }));

            if (mech.cache) {
                Object.keys(mech.cache).forEach(function (key) {
                    if (!mech.cache[key]) {
                        return;
                    }

                    self.config.credentials[key] = new Buffer(mech.cache[key]);
                });

                self.emit('credentials:update', self.config.credentials);
            }
        });

        self.on('sasl:failure', 'sasl', function () {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            cb('disconnect', 'authentication failed');
        });

        self.on('sasl:abort', 'sasl', function () {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            cb('disconnect', 'authentication failed');
        });

        var auth = {
            mechanism: mech.name
        };

        if (mech.clientFirst) {
            auth.value = mech.response(self.getCredentials());
        }

        self.send(new Auth(auth));
    });

    client.on('disconnected', function () {
        client.features.negotiated.sasl = false;
    });
};

}).call(this,require("buffer").Buffer)
},{"../stanza/sasl":1434,"buffer":9}],1379:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/session'));

    client.registerFeature('session', 1000, function (features, cb) {
        var self = this;

        if (features.session.optional || self.sessionStarted) {
            self.features.negotiated.session = true;
            return cb();
        }

        self.sendIq({
            type: 'set',
            session: {}
        }, function (err) {
            if (err) {
                return cb('disconnect', 'session request failed');
            }

            self.features.negotiated.session = true;
            if (!self.sessionStarted) {
                self.sessionStarted = true;
                self.emit('session:started', self.jid);
            }
            cb();
        });
    });

    client.on('disconnected', function () {
        client.sessionStarted = false;
        client.features.negotiated.session = false;
    });
};

},{"../stanza/session":1435}],1380:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/shim';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/shim'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '#SubID', NS);
};

},{"../stanza/shim":1436}],1381:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas, config) {
    stanzas.use(require('../stanza/sm'));

    var smacks = function (features, cb) {
        var self = this;

        if (!config.useStreamManagement) {
            return cb();
        }

        self.on('stream:management:enabled', 'sm', function (enabled) {
            self.sm.enabled(enabled);
            self.features.negotiated.streamManagement = true;
            self.releaseGroup('sm');
            cb();
        });

        self.on('stream:management:resumed', 'sm', function (resumed) {
            self.sm.resumed(resumed);
            self.features.negotiated.streamManagement = true;
            self.features.negotiated.bind = true;
            self.sessionStarted = true;
            self.releaseGroup('sm');
            cb('break'); // Halt further processing of stream features
        });

        self.on('stream:management:failed', 'sm', function () {
            self.sm.failed();
            self.emit('session:end');
            self.releaseGroup('session');
            self.releaseGroup('sm');
            cb();
        });

        if (!self.sm.id) {
            if (self.features.negotiated.bind) {
                self.sm.enable();
            } else {
                cb();
            }
        } else if (self.sm.id && self.sm.allowResume) {
            self.sm.resume();
        } else {
            cb();
        }
    };

    client.on('disconnected', function () {
        client.features.negotiated.streamManagement = false;
    });

    client.registerFeature('streamManagement', 200, smacks);
    client.registerFeature('streamManagement', 500, smacks);
};

},{"../stanza/sm":1437}],1382:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/time'));

    client.disco.addFeature('urn:xmpp:time');

    client.getTime = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            time: true
        }, cb);
    };

    client.on('iq:get:time', function (iq) {
        var time = new Date();
        client.sendIq(iq.resultReply({
            time: {
                utc: time,
                tzo: time.getTimezoneOffset()
            }
        }));
    });
};

},{"../stanza/time":1441}],1383:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/vcard'));

    client.disco.addFeature('vcard-temp');

    client.getVCard = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            vCardTemp: true
        }, cb);
    };

    client.publishVCard = function (vcard, cb) {
        return this.sendIq({
            type: 'set',
            vCardTemp: vcard
        }, cb);
    };
};

},{"../stanza/vcard":1442}],1384:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/version'));

    client.disco.addFeature('jabber:iq:version');

    client.on('iq:get:version', function (iq) {
        client.sendIq(iq.resultReply({
            version: client.config.softwareVersion || {
                name: 'stanza.io'
            }
        }));
    });

    client.getSoftwareVersion = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            version: true
        }, cb);
    };
};

},{"../stanza/version":1443}],1385:[function(require,module,exports){
'use strict';

var WSConnection = require('../transports/websocket');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/framing'));

    client.transports.websocket = WSConnection;
};

},{"../stanza/framing":1404,"../transports/websocket":1447}],1386:[function(require,module,exports){
'use strict';

var MAX_SEQ = Math.pow(2, 32);


function mod(v, n) {
    return ((v % n) + n) % n;
}


function StreamManagement(client) {
    this.client = client;
    this.id = false;
    this.allowResume = true;
    this.started = false;
    this.inboundStarted = false;
    this.outboundStarted = false;
    this.lastAck = 0;
    this.handled = 0;
    this.windowSize = 1;
    this.unacked = [];
    this.pendingAck = false;

    var NS = 'urn:xmpp:sm:3';
    this.stanzas = {
        Enable: client.stanzas.getDefinition('enable', NS),
        Resume: client.stanzas.getDefinition('resume', NS),
        Ack: client.stanzas.getDefinition('a', NS),
        Request: client.stanzas.getDefinition('r', NS)
    };
}

StreamManagement.prototype = {
    constructor: {
        value: StreamManagement
    },
    enable: function () {
        var enable = new this.stanzas.Enable();
        enable.resume = this.allowResume;
        this.client.send(enable);
        this.handled = 0;
        this.outboundStarted = true;
    },
    resume: function () {
        var resume = new this.stanzas.Resume({
            h: this.handled,
            previd: this.id
        });
        this.client.send(resume);
        this.outboundStarted = true;
    },
    enabled: function (resp) {
        this.id = resp.id;
        this.handled = 0;
        this.inboundStarted = true;
    },
    resumed: function (resp) {
        this.id = resp.previd;
        if (resp.h) {
            this.process(resp, true);
        }
        this.inboundStarted = true;
    },
    failed: function () {
        this.inboundStarted = false;
        this.outboundStarted = false;
        this.id = false;
        this.lastAck = 0;
        this.handled = 0;
        this.unacked = [];
    },
    ack: function () {
        this.client.send(new this.stanzas.Ack({
            h: this.handled
        }));
    },
    request: function () {
        this.pendingAck = true;
        this.client.send(new this.stanzas.Request());
    },
    process: function (ack, resend) {
        var self = this;
        var numAcked = mod(ack.h - this.lastAck, MAX_SEQ);

        this.pendingAck = false;

        for (var i = 0; i < numAcked && this.unacked.length > 0; i++) {
            this.client.emit('stanza:acked', this.unacked.shift());
        }
        this.lastAck = ack.h;

        if (resend) {
            var resendUnacked = this.unacked;
            this.unacked = [];
            resendUnacked.forEach(function (stanza) {
                self.client.send(stanza);
            });
        }

        if (this.needAck()) {
            this.request();
        }
    },
    track: function (stanza) {
        var name = stanza._name;
        var acceptable = {
            message: true,
            presence: true,
            iq: true
        };

        if (this.outboundStarted && acceptable[name]) {
            this.unacked.push(stanza);
            if (this.needAck()) {
                this.request();
            }
        }
    },
    handle: function () {
        if (this.inboundStarted) {
            this.handled = mod(this.handled + 1, MAX_SEQ);
        }
    },
    needAck: function () {
        return !this.pendingAck && this.unacked.length >= this.windowSize;
    }
};

Object.defineProperties(StreamManagement.prototype, {
    started: {
        get: function () {
            return this.outboundStarted && this.inboundStarted;
        },
        set: function (value) {
            if (!value) {
                this.outboundStarted = false;
                this.inboundStarted = false;
            }
        }
    }
});

module.exports = StreamManagement;

},{}],1387:[function(require,module,exports){
'use strict';

var _ = require('underscore');


module.exports = function (stanza) {
    var types = stanza.utils;

    var Avatar = stanza.define({
        name: 'avatar',
        namespace: 'urn:xmpp:avatar:metadata',
        element: 'info',
        fields: {
            id: types.attribute('id'),
            bytes: types.attribute('bytes'),
            height: types.attribute('height'),
            width: types.attribute('width'),
            type: types.attribute('type', 'image/png'),
            url: types.attribute('url')
        }
    });
    
    var avatars = {
        get: function () {
            var metadata = types.find(this.xml, 'urn:xmpp:avatar:metadata', 'metadata');
            var results = [];
            if (metadata.length) {
                var avatars = types.find(metadata[0], 'urn:xmpp:avatar:metadata', 'info');
                _.forEach(avatars, function (info) {
                    results.push(new Avatar({}, info));
                });
            }
            return results;
        },
        set: function (value) {
            var metadata = types.findOrCreate(this.xml, 'urn:xmpp:avatar:metadata', 'metadata');
            types.setAttribute(metadata, 'xmlns', 'urn:xmpp:avatar:metadata');
            _.forEach(value, function (info) {
                var avatar = new Avatar(info);
                metadata.appendChild(avatar.xml);
            });
        }
    };
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'avatars', avatars);
        stanza.add(Item, 'avatarData', types.textSub('urn:xmpp:avatar:data', 'data'));
    });
};

},{"underscore":1602}],1388:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-bind';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Bind = stanza.define({
        name: 'bind',
        namespace: NS,
        element: 'bind',
        fields: {
            resource: types.textSub(NS, 'resource'),
            jid: types.jidSub(NS, 'jid')
        }
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Bind);
    });
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Bind);
    });
};

},{}],1389:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;

var NS = 'urn:xmpp:blocking';


module.exports = function (stanza) {
    var types = stanza.utils;

    var jids = {
        get: function () {
            var result = [];
            var items = types.find(this.xml, NS, 'item');
            if (!items.length) {
                return result;
            }
    
            items.forEach(function (item) {
                result.push(new JID(types.getAttribute(item, 'jid', '')));
            });
    
            return result;
        },
        set: function (values) {
            var self = this;
            values.forEach(function (value) {
                var item = types.createElement(NS, 'item', NS);
                types.setAttribute(item, 'jid', value.toString());
                self.xml.appendChild(item);
            });
        }
    };
    
    var Block = stanza.define({
        name: 'block',
        namespace: NS,
        element: 'block',
        fields: {
            jids: jids
        }
    });
    
    var Unblock = stanza.define({
        name: 'unblock',
        namespace: NS,
        element: 'unblock',
        fields: {
            jids: jids
        }
    });
    
    var BlockList = stanza.define({
        name: 'blockList',
        namespace: NS,
        element: 'blocklist',
        fields: {
            jids: jids
        }
    });
    
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Block);
        stanza.extend(Iq, Unblock);
        stanza.extend(Iq, BlockList);
    });
};

},{"xmpp-jid":1604}],1390:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:bob';


module.exports = function (stanza) {
    var types = stanza.utils;

    var BOB = stanza.define({
        name: 'bob',
        namespace: NS,
        element: 'data',
        fields: {
            cid: types.attribute('cid'),
            maxAge: types.numberAttribute('max-age'),
            type: types.attribute('type'),
            data: types.text()
        }
    });


    stanza.withIq(function (Iq) {
        stanza.extend(Iq, BOB);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, BOB);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, BOB);
    });
};

},{}],1391:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Conference = stanza.define({
        name: '_conference',
        namespace: 'storage:bookmarks',
        element: 'conference',
        fields: {
            name: types.attribute('name'),
            autoJoin: types.boolAttribute('autojoin'),
            jid: types.jidAttribute('jid'),
            nick: types.textSub('storage:bookmarks', 'nick')
        }
    });
    
    var Bookmarks = stanza.define({
        name: 'bookmarks',
        namespace: 'storage:bookmarks',
        element: 'storage'
    });
    
    
    stanza.extend(Bookmarks, Conference, 'conferences');

    stanza.withDefinition('query', 'jabber:iq:private', function (PrivateStorage) {
        stanza.extend(PrivateStorage, Bookmarks);
    });
};

},{}],1392:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/httpbind';
var XMPP_NS = 'urn:xmpp:xbosh';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'bosh',
        namespace: NS,
        element: 'body',
        prefixes: {
            xmpp: XMPP_NS
        },
        fields: {
            accept: types.attribute('accept'),
            ack: types.numberAttribute('ack'),
            authid: types.attribute('authid'),
            charsets: types.attribute('charsets'),
            condition: types.attribute('condition'),
            content: types.attribute('content'),
            from: types.jidAttribute('from', true),
            hold: types.numberAttribute('hold'),
            inactivity: types.numberAttribute('inactivity'),
            key: types.attribute('key'),
            maxpause: types.numberAttribute('maxpause'),
            newKey: types.attribute('newkey'),
            pause: types.numberAttribute('pause'),
            polling: types.numberAttribute('polling'),
            resport: types.numberAttribute('report'),
            requests: types.numberAttribute('requests'),
            rid: types.numberAttribute('rid'),
            sid: types.attribute('sid'),
            stream: types.attribute('stream'),
            time: types.attribute('time'),
            to: types.jidAttribute('to', true),
            type: types.attribute('type'),
            ver: types.attribute('ver'),
            wait: types.numberAttribute('wait'),
            uri: types.textSub(NS, 'uri'),
            lang: types.langAttribute(),
            // These three should be using namespaced attributes, but browsers are stupid
            // when it comes to serializing attributes with namespaces
            version: types.attribute('xmpp:version', '1.0'),
            restart: types.attribute('xmpp:restart'),
            restartLogic: types.boolAttribute('xmpp:restartLogic'),
            payload: {
                get: function () {
                    var results = [];
                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++)  {
                        var obj = stanza.build(this.xml.childNodes[i]);
                        if (obj !== undefined) {
                            results.push(obj);
                        }
                    }
                    return results;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (types) {
                        self.xml.appendChild(types.xml);
                    });
                }
            }
        }
    });
};

},{}],1393:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Caps = stanza.define({
        name: 'caps',
        namespace: 'http://jabber.org/protocol/caps',
        element: 'c',
        fields: {
            ver: types.attribute('ver'),
            node: types.attribute('node'),
            hash: types.attribute('hash'),
            ext: types.attribute('ext')
        }
    });
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, Caps);
    });

    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Caps);
    });
};

},{}],1394:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var Sent = stanza.define({
        name: 'carbonSent',
        eventName: 'carbon:sent',
        namespace: 'urn:xmpp:carbons:2',
        element: 'sent'
    });
    
    var Received = stanza.define({
        name: 'carbonReceived',
        eventName: 'carbon:received',
        namespace: 'urn:xmpp:carbons:2',
        element: 'received'
    });
    
    var Private = stanza.define({
        name: 'carbonPrivate',
        eventName: 'carbon:private',
        namespace: 'urn:xmpp:carbons:2',
        element: 'private'
    });
    
    var Enable = stanza.define({
        name: 'enableCarbons',
        namespace: 'urn:xmpp:carbons:2',
        element: 'enable'
    });
    
    var Disable = stanza.define({
        name: 'disableCarbons',
        namespace: 'urn:xmpp:carbons:2',
        element: 'disable'
    });
    
    
    stanza.withDefinition('forwarded', 'urn:xmpp:forward:0', function (Forwarded) {
        stanza.extend(Sent, Forwarded);
        stanza.extend(Received, Forwarded);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Sent);
        stanza.extend(Message, Received);
        stanza.extend(Message, Private);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Enable);
        stanza.extend(Iq, Disable);
    });
};

},{}],1395:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/commands';
var ACTIONS = ['next', 'prev', 'complete', 'cancel'];
var CONDITIONS = [
    'bad-action',
    'bad-locale',
    'bad-payload',
    'bad-sessionid',
    'malformed-action',
    'session-expired'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Command = stanza.define({
        name: 'command',
        namespace: NS,
        element: 'command',
        fields: {
            action: types.attribute('action'),
            node: types.attribute('node'),
            sessionid: types.attribute('sessionid'),
            status: types.attribute('status'),
            execute: types.subAttribute(NS, 'actions', 'execute'),
            actions: {
                get: function () {
                    var result = [];
                    var actionSet = types.find(this.xml, NS, 'actions');
                    if (!actionSet.length) {
                        return [];
                    }
                    ACTIONS.forEach(function (action) {
                        var existing = types.find(actionSet[0], NS, action);
                        if (existing.length) {
                            result.push(action);
                        }
                    });
                    return result;
                },
                set: function (values) {
                    var actionSet = types.findOrCreate(this.xml, NS, 'actions');
                    for (var i = 0, len = actionSet.childNodes.length; i < len; i++) {
                        actionSet.removeChild(actionSet.childNodes[i]);
                    }
                    values.forEach(function (value) {
                        actionSet.appendChild(types.createElement(NS, value.toLowerCase(), NS));
                    });
                }
            }
        }
    });

    var Note = stanza.define({
        name: '_commandNote',
        namespace: NS,
        element: 'note',
        fields: {
            type: types.attribute('type'),
            value: types.text()
        }
    });


    stanza.extend(Command, Note, 'notes');
    
    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'adhocCommandCondition', types.enumSub(NS, CONDITIONS));
    });
    
    stanza.withDataForm(function (DataForm) {
        stanza.extend(Command, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Command);
    });
};

},{}],1396:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:csi';


module.exports = function (stanza) {
    var CSIFeature = stanza.define({
        name: 'clientStateIndication',
        namespace: NS,
        element: 'csi'
    });
    
    stanza.define({
        name: 'csiActive',
        eventName: 'csi:active',
        namespace: NS,
        element: 'active',
        topLevel: true
    });
    
    stanza.define({
        name: 'csiInactive',
        eventName: 'csi:inactive',
        namespace: NS,
        element: 'inactive',
        topLevel: true
    });
    
    
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, CSIFeature);
    });
};

},{}],1397:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;

var FORM_NS = 'jabber:x:data';
var MEDIA_NS = 'urn:xmpp:media-element';
var VALIDATE_NS = 'http://jabber.org/protocol/xdata-validate';
var LAYOUT_NS = 'http://jabber.org/protocol/xdata-layout';

var SINGLE_FIELDS = [
    'text-single',
    'text-private',
    'list-single',
    'jid-single'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Field = stanza.define({
        name: '_field',
        namespace: FORM_NS,
        element: 'field',
        init: function (data) {
            this._type = (data || {}).type || this.type;
        },
        fields: {
            type: {
                get: function () {
                    return types.getAttribute(this.xml, 'type', 'text-single');
                },
                set: function (value) {
                    this._type = value;
                    types.setAttribute(this.xml, 'type', value);
                }
            },
            name: types.attribute('var'),
            desc: types.textSub(FORM_NS, 'desc'),
            required: types.boolSub(FORM_NS, 'required'),
            label: types.attribute('label'),
            value: {
                get: function () {
                    var vals = types.getMultiSubText(this.xml, FORM_NS, 'value');
                    if (this._type === 'boolean') {
                        return vals[0] === '1' || vals[0] === 'true';
                    }
                    if (vals.length > 1) {
                        if (this._type === 'text-multi') {
                            return vals.join('\n');
                        }
    
                        if (this._type === 'jid-multi') {
                            return vals.map(function (jid) {
                                return new JID(jid);
                            });
                        }
    
                        return vals;
                    }
                    if (SINGLE_FIELDS.indexOf(this._type) >= 0) {
                        if (this._type === 'jid-single') {
                            return new JID(vals[0]);
                        }
                        return vals[0];
                    }
    
                    return vals;
                },
                set: function (value) {
                    if (this._type === 'boolean') {
                        var truthy = value === true || value === 'true' || value === '1';
                        types.setSubText(this.xml, FORM_NS, 'value', truthy ? '1' : '0');
                    } else {
                        if (this._type === 'text-multi' && typeof(value) === 'string') {
                            value = value.split('\n');
                        }
                        types.setMultiSubText(this.xml, FORM_NS, 'value', value);
                    }
                }
            }
        }
    });
    
    var Option = stanza.define({
        name: '_formoption',
        namespace: FORM_NS,
        element: 'option',
        fields: {
            label: types.attribute('label'),
            value: types.textSub(FORM_NS, 'value')
        }
    });
    
    var Item = stanza.define({
        name: '_formitem',
        namespace: FORM_NS,
        element: 'item'
    });
    
    var Media = stanza.define({
        name: 'media',
        element: 'media',
        namespace: MEDIA_NS,
        fields: {
            height: types.numberAttribute('height'),
            width: types.numberAttribute('width')
        }
    });
    
    var MediaURI = stanza.define({
        name: '_mediaURI',
        element: 'uri',
        namespace: MEDIA_NS,
        fields: {
            uri: types.text(),
            type: types.attribute('type')
        }
    });
    
    var Validation = stanza.define({
        name: 'validation',
        element: 'validate',
        namespace: VALIDATE_NS,
        fields: {
            dataType: types.attribute('datatype'),
            basic: types.boolSub(VALIDATE_NS, 'basic'),
            open: types.boolSub(VALIDATE_NS, 'open'),
            regex: types.textSub(VALIDATE_NS, 'regex')
        }
    });
    
    var Range = stanza.define({
        name: 'range',
        element: 'range',
        namespace: VALIDATE_NS,
        fields: {
            min: types.attribute('min'),
            max: types.attribute('max')
        }
    });
    
    var ListRange = stanza.define({
        name: 'select',
        element: 'list-range',
        namespace: VALIDATE_NS,
        fields: {
            min: types.numberAttribute('min'),
            max: types.numberAttribute('max')
        }
    });
    
    var layoutContents = {
        get: function () {
            var result = [];
            for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                var child = this.xml.childNodes[i];
                if (child.namespaceURI !== LAYOUT_NS) {
                    continue;
                }
    
                switch (child.localName) {
                    case 'text':
                        result.push({
                            text: child.textContent
                        });
                        break;
                    case 'fieldref':
                        result.push({
                            field: child.getAttribute('var')
                        });
                        break;
                    case 'reportedref':
                        result.push({
                            reported: true
                        });
                        break;
                    case 'section':
                        result.push({
                            section: new Section(null, child, this).toJSON()
                        });
                        break;
                }
            }
    
            return result;
        },
        set: function (values) {
            for (var i = 0, len = values.length; i < len; i++) {
                var value = values[i];
                if (value.text) {
                    var text = stanza.createElement(LAYOUT_NS, 'text', LAYOUT_NS);
                    text.textContent = value.text;
                    this.xml.appendChild(text);
                }
                if (value.field) {
                    var field = stanza.createElement(LAYOUT_NS, 'fieldref', LAYOUT_NS);
                    field.setAttribute('var', value.field);
                    this.xml.appendChild(field);
                }
                if (value.reported) {
                    this.xml.appendChild(stanza.createElement(LAYOUT_NS, 'reportedref', LAYOUT_NS));
                }
                if (value.section) {
                    var sectionXML = stanza.createElement(LAYOUT_NS, 'section', LAYOUT_NS);
                    this.xml.appendChild(sectionXML);
    
                    var section = new Section(null, sectionXML);
                    section.label = value.section.label;
                    section.contents = value.section.contents;
                }
            }
        }
    };
    
    var Section = stanza.define({
        name: '_section',
        element: 'section',
        namespace: LAYOUT_NS,
        fields: {
            label: types.attribute('label'),
            contents: layoutContents
        }
    });
    
    var Page = stanza.define({
        name: '_page',
        element: 'page',
        namespace: LAYOUT_NS,
        fields: {
            label: types.attribute('label'),
            contents: layoutContents
        }
    });
 
    var DataForm = stanza.define({
        name: 'form',
        namespace: FORM_NS,
        element: 'x',
        init: function () {
            // Propagate reported field types to items
    
            if (!this.reportedFields.length) {
                return;
            }
    
            var fieldTypes = {};
            this.reportedFields.forEach(function (reported) {
                fieldTypes[reported.name] = reported.type;
            });
            this.items.forEach(function (item) {
                item.fields.forEach(function (field) {
                    field.type = field._type = fieldTypes[field.name];
                });
            });
        },
        fields: {
            title: types.textSub(FORM_NS, 'title'),
            instructions: types.multiTextSub(FORM_NS, 'instructions'),
            type: types.attribute('type', 'form'),
            reportedFields: types.subMultiExtension(FORM_NS, 'reported', Field)
        }
    });
    
    
    stanza.extend(DataForm, Field, 'fields');
    stanza.extend(DataForm, Item, 'items');
    stanza.extend(DataForm, Page, 'layout');

    stanza.extend(Field, Media);
    stanza.extend(Field, Validation);
    stanza.extend(Field, Option, 'options');
    
    stanza.extend(Item, Field, 'fields');
    
    stanza.extend(Media, MediaURI, 'uris');
    stanza.extend(Validation, Range);
    stanza.extend(Validation, ListRange);

    stanza.withMessage(function (Message) {
        stanza.extend(Message, DataForm);
    });
};

},{"xmpp-jid":1604}],1398:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var DelayedDelivery = stanza.define({
        name: 'delay',
        namespace: 'urn:xmpp:delay',
        element: 'delay',
        fields: {
            from: types.jidAttribute('from'),
            stamp: types.dateAttribute('stamp'),
            reason: types.text()
        }
    });
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, DelayedDelivery);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, DelayedDelivery);
    });
};

},{}],1399:[function(require,module,exports){
'use strict';

var NSInfo = 'http://jabber.org/protocol/disco#info';
var NSItems = 'http://jabber.org/protocol/disco#items';


module.exports = function (stanza) {
    var types = stanza.utils;

    var DiscoInfo = stanza.define({
        name: 'discoInfo',
        namespace: NSInfo,
        element: 'query',
        fields: {
            node: types.attribute('node'),
            features: types.multiSubAttribute(NSInfo, 'feature', 'var')
        }
    });


    var DiscoIdentity = stanza.define({
        name: '_discoIdentity',
        namespace: NSInfo,
        element: 'identity',
        fields: {
            category: types.attribute('category'),
            type: types.attribute('type'),
            name: types.attribute('name'),
            lang: types.langAttribute()
        }
    });


    var DiscoItems = stanza.define({
        name: 'discoItems',
        namespace: NSItems,
        element: 'query',
        fields: {
            node: types.attribute('node'),
        }
    });

    var DiscoItem = stanza.define({
        name: '_discoItem',
        namespace: NSItems,
        element: 'item',
        fields: {
            jid: types.jidAttribute('jid'),
            node: types.attribute('node'),
            name: types.attribute('name')
        }
    });


    stanza.extend(DiscoItems, DiscoItem, 'items');
    stanza.extend(DiscoInfo, DiscoIdentity, 'identities');

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, DiscoInfo);
        stanza.extend(Iq, DiscoItems);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(DiscoInfo, DataForm, 'extensions');
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(DiscoItems, RSM);
    });
};

},{}],1400:[function(require,module,exports){
'use strict';

var ERR_NS = 'urn:ietf:params:xml:ns:xmpp-stanzas';
var CONDITIONS = [
    'bad-request',
    'conflict',
    'feature-not-implemented',
    'forbidden',
    'gone',
    'internal-server-error',
    'item-not-found',
    'jid-malformed',
    'not-acceptable',
    'not-allowed',
    'not-authorized',
    'payment-required',
    'recipient-unavailable',
    'redirect',
    'registration-required',
    'remote-server-not-found',
    'remote-server-timeout',
    'resource-constraint',
    'service-unavailable',
    'subscription-required',
    'undefined-condition',
    'unexpected-request'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var ErrorStanza = stanza.define({
        name: 'error',
        namespace: 'jabber:client',
        element: 'error',
        fields: {
            lang: {
                get: function () {
                    return (this.parent || {}).lang || '';
                }
            },
            condition: types.enumSub(ERR_NS, CONDITIONS),
            gone: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'gone');
                },
                set: function (value) {
                    this.condition = 'gone';
                    types.setSubText(this.xml, ERR_NS, 'gone', value);
                }
            },
            redirect: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'redirect');
                },
                set: function (value) {
                    this.condition = 'redirect';
                    types.setSubText(this.xml, ERR_NS, 'redirect', value);
                }
            },
            code: types.attribute('code'),
            type: types.attribute('type'),
            by: types.jidAttribute('by'),
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, ERR_NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, ERR_NS, 'text', value, this.lang);
                }
            }
        }
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, ErrorStanza);
    });
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, ErrorStanza);
    });
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, ErrorStanza);
    });
};

},{}],1401:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:extdisco:1';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Services = exports.Services = stanza.define({
        name: 'services',
        namespace: NS,
        element: 'services',
        fields: {
            type: types.attribute('type')
        }
    });
    
    var Credentials = exports.Credentials = stanza.define({
        name: 'credentials',
        namespace: NS,
        element: 'credentials'
    });
    
    var Service = stanza.define({
        name: 'service',
        namespace: NS,
        element: 'service',
        fields: {
            host: types.attribute('host'),
            port: types.attribute('port'),
            transport: types.attribute('transport'),
            type: types.attribute('type'),
            username: types.attribute('username'),
            password: types.attribute('password')
        }
    });
    
    
    stanza.extend(Services, Service, 'services');
    stanza.extend(Credentials, Service);

    stanza.withDataForm(function (DataForm) {
        stanza.extend(Service, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Services);
        stanza.extend(Iq, Credentials);
    });
};

},{}],1402:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:apps:file-transfer:3';
var TB_NS = 'urn:xmpp:thumbs:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var File = stanza.define({
        name: '_file',
        namespace: NS,
        element: 'file',
        fields: {
            name: types.textSub(NS, 'name'),
            desc: types.textSub(NS, 'desc'),
            size: types.numberSub(NS, 'size'),
            date: types.dateSub(NS, 'date')
        }
    });
    
    var Range = stanza.define({
        name: 'range',
        namespace: NS,
        element: 'range',
        fields: {
            offset: types.numberAttribute('offset')
        }
    });
    
    var Thumbnail = stanza.define({
        name: 'thumbnail',
        namespace: TB_NS,
        element: 'thumbnail',
        fields: {
            cid: types.attribute('cid'),
            mimeType: types.attribute('mime-type'),
            width: types.numberAttribute('width'),
            height: types.numberAttribute('height')
        }
    });
    
    var FileTransfer = stanza.define({
        name: '_filetransfer',
        namespace: NS,
        element: 'description',
        tags: ['jingle-description'],
        fields: {
            descType: {value: 'filetransfer'},
            offer: types.subExtension('offer', NS, 'offer', File),
            request: types.subExtension('request', NS, 'request', File)
        }
    });
    
    stanza.extend(File, Range);
    stanza.extend(File, Thumbnail);

    stanza.withDefinition('hash', 'urn:xmpp:hashes:1', function (Hash) {
        stanza.extend(File, Hash, 'hashes');
    });

    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, FileTransfer);
    });
};

},{}],1403:[function(require,module,exports){
'use strict';

module.exports = function (stanza) {
    var Forwarded = stanza.define({
        name: 'forwarded',
        eventName: 'forward',
        namespace: 'urn:xmpp:forward:0',
        element: 'forwarded'
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, Forwarded);
        stanza.extend(Forwarded, Message);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Forwarded, Presence);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Forwarded, Iq);
    });

    stanza.withDefinition('delay', 'urn:xmpp:delay', function (Delayed) {
        stanza.extend(Forwarded, Delayed);
    });
};

},{}],1404:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-framing';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'openStream',
        namespace: NS,
        element: 'open',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            version: types.attribute('version', '1.0'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true)
        }
    });
    
    stanza.define({
        name: 'closeStream',
        namespace: NS,
        element: 'close',
        topLevel: true,
        fields: {
            seeOtherURI: types.attribute('see-other-uri')
        }
    });
};

},{}],1405:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/geoloc';


module.exports = function (stanza) {
    var types = stanza.utils;

    var GeoLoc = stanza.define({
        name: 'geoloc',
        namespace: NS,
        element: 'geoloc',
        fields: {
            accuracy: types.numberSub(NS, 'accuracy', true),
            altitude: types.numberSub(NS, 'alt', true),
            area: types.textSub(NS, 'area'),
            heading: types.numberSub(NS, 'bearing', true),
            bearing: types.numberSub(NS, 'bearing', true),
            building: types.textSub(NS, 'building'),
            country: types.textSub(NS, 'country'),
            countrycode: types.textSub(NS, 'countrycode'),
            datum: types.textSub(NS, 'datum'),
            description: types.textSub(NS, 'description'),
            error: types.numberSub(NS, 'error', true),
            floor: types.textSub(NS, 'floor'),
            latitude: types.numberSub(NS, 'lat', true),
            locality: types.textSub(NS, 'locality'),
            longitude: types.numberSub(NS, 'lon', true),
            postalcode: types.textSub(NS, 'postalcode'),
            region: types.textSub(NS, 'region'),
            room: types.textSub(NS, 'room'),
            speed: types.numberSub(NS, 'speed', true),
            street: types.textSub(NS, 'street'),
            text: types.textSub(NS, 'text'),
            timestamp: types.dateSub(NS, 'timestamp'),
            tzo: types.tzoSub(NS, 'tzo'),
            uri: types.textSub(NS, 'uri')
        }
    });
    
    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, GeoLoc);
    });
};

},{}],1406:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    stanza.define({
        name: 'hash',
        namespace: 'urn:xmpp:hashes:1',
        element: 'hash',
        fields: {
            algo: stanza.utils.attribute('algo'),
            value: stanza.utils.text()
        }
    });
};

},{}],1407:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:hats:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Hat = stanza.define({
        name: '_hat',
        namespace: NS,
        element: 'hat',
        fields: {
            lang: types.langAttribute(),
            name: types.attribute('name'),
            displayName: types.attribute('displayName')
        }
    });
    
    
    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'hats', types.subMultiExtension(NS, 'hats', Hat));
    });
};

},{}],1408:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:transports:ice-udp:1';


module.exports = function (stanza) {
    var types = stanza.utils;

    var ICE = stanza.define({
        name: '_iceUdp',
        namespace: NS,
        element: 'transport',
        tags: ['jingle-transport'],
        fields: {
            transType: {value: 'iceUdp'},
            pwd: types.attribute('pwd'),
            ufrag: types.attribute('ufrag')
        }
    });
    
    
    var RemoteCandidate = stanza.define({
        name: 'remoteCandidate',
        namespace: NS,
        element: 'remote-candidate',
        fields: {
            component: types.attribute('component'),
            ip: types.attribute('ip'),
            port: types.attribute('port')
        }
    });
    
    
    var Candidate = stanza.define({
        name: '_iceUdpCandidate',
        namespace: NS,
        element: 'candidate',
        fields: {
            component: types.attribute('component'),
            foundation: types.attribute('foundation'),
            generation: types.attribute('generation'),
            id: types.attribute('id'),
            ip: types.attribute('ip'),
            network: types.attribute('network'),
            port: types.attribute('port'),
            priority: types.attribute('priority'),
            protocol: types.attribute('protocol'),
            relAddr: types.attribute('rel-addr'),
            relPort: types.attribute('rel-port'),
            tcpType: types.attribute('tcptype'),
            type: types.attribute('type')
        }
    });
    
    
    var Fingerprint = stanza.define({
        name: '_iceFingerprint',
        namespace: 'urn:xmpp:jingle:apps:dtls:0',
        element: 'fingerprint',
        fields: {
            hash: types.attribute('hash'),
            setup: types.attribute('setup'),
            value: types.text(),
            required: types.boolAttribute('required')
        }
    });
    
    var SctpMap = stanza.define({
        name: '_sctpMap',
        namespace: 'urn:xmpp:jingle:transports:dtls-sctp:1',
        element: 'sctpmap',
        fields: {
            number: types.attribute('number'),
            protocol: types.attribute('protocol'),
            streams: types.attribute('streams')
        }
    });

    
    stanza.extend(ICE, Candidate, 'candidates');
    stanza.extend(ICE, RemoteCandidate);
    stanza.extend(ICE, Fingerprint, 'fingerprints');
    stanza.extend(ICE, SctpMap, 'sctp');

    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, ICE);
    });
};

},{}],1409:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Iq = stanza.define({
        name: 'iq',
        namespace: 'jabber:client',
        element: 'iq',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            type: types.attribute('type')
        }
    });
    
    var toJSON = Iq.prototype.toJSON;
    
    Iq.prototype.toJSON = function () {
        var result = toJSON.call(this);
        result.resultReply = this.resultReply;
        result.errorReply = this.errorReply;
        return result;
    };
    
    Iq.prototype.resultReply = function (data) {
        data = data || {};
        data.to = this.from;
        data.id = this.id;
        data.type = 'result';
        return new Iq(data);
    };
    
    Iq.prototype.errorReply = function (data) {
        data = data || {};
        data.to = this.from;
        data.id = this.id;
        data.type = 'error';
        return new Iq(data);
    };
};

},{}],1410:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;
var NS = 'urn:xmpp:jidprep:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'jidPrep', {
            get: function () {
                var data = types.getSubText(this.xml, NS, 'jid');
                if (data) {
                    var jid = new JID(data);
                    jid.prepped = true;
                    return jid;
                }
            },
            set: function (value) {
                types.setSubText(this.xml, NS, 'jid', (value || '').toString());
            }
        });
    });
};

},{"xmpp-jid":1604}],1411:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:1';
var ERRNS = 'urn:xmpp:jingle:errors:1';
var CONDITIONS = ['out-of-order', 'tie-break', 'unknown-session', 'unsupported-info'];
var REASONS = [
    'alternative-session',
    'busy',
    'cancel',
    'connectivity-error',
    'decline',
    'expired',
    'failed-application',
    'failed-transport',
    'general-error',
    'gone',
    'incompatible-parameters',
    'media-error',
    'security-error',
    'success',
    'timeout',
    'unsupported-applications',
    'unsupported-transports'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Jingle = stanza.define({
        name: 'jingle',
        namespace: NS,
        element: 'jingle',
        fields: {
            action: types.attribute('action'),
            initiator: types.attribute('initiator'),
            responder: types.attribute('responder'),
            sid: types.attribute('sid')
        }
    });
    
    
    var Content = stanza.define({
        name: '_jingleContent',
        namespace: NS,
        element: 'content',
        fields: {
            creator: types.attribute('creator'),
            disposition: types.attribute('disposition', 'session'),
            name: types.attribute('name'),
            senders: types.attribute('senders', 'both'),
            description: {
                get: function () {
                    var opts = stanza.tagged('jingle-description').map(function (Description) {
                        return Description.prototype._name;
                    });
                    for (var i = 0, len = opts.length; i < len; i++) {
                        if (this._extensions[opts[i]]) {
                            return this._extensions[opts[i]];
                        }
                    }
                },
                set: function (value) {
                    var ext = '_' + value.descType;
                    this[ext] = value;
                }
            },
            transport: {
                get: function () {
                    var opts = stanza.tagged('jingle-transport').map(function (Transport) {
                        return Transport.prototype._name;
                    });
                    for (var i = 0, len = opts.length; i < len; i++) {
                        if (this._extensions[opts[i]]) {
                            return this._extensions[opts[i]];
                        }
                    }
                },
                set: function (value) {
                    var ext = '_' + value.transType;
                    this[ext] = value;
                }
            }
        }
    });
    
    var Reason = stanza.define({
        name: 'reason',
        namespace: NS,
        element: 'reason',
        fields: {
            condition: types.enumSub(NS, REASONS),
            alternativeSession: {
                get: function () {
                    return types.getSubText(this.xml, NS, 'alternative-session');
                },
                set: function (value) {
                    this.condition = 'alternative-session';
                    types.setSubText(this.xml, NS, 'alternative-session', value);
                }
            },
            text: types.textSub(NS, 'text')
        }
    });
    
    
    stanza.extend(Jingle, Content, 'contents');
    stanza.extend(Jingle, Reason);

    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'jingleCondition', types.enumSub(ERRNS, CONDITIONS));
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Jingle);
    });
};

},{}],1412:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var JSONExtension = {
        get: function () {
            var data = types.getSubText(this.xml, 'urn:xmpp:json:0', 'json');
            if (data) {
                return JSON.parse(data);
            }
        },
        set: function (value) {
            value = JSON.stringify(value);
            if (value) {
                types.setSubText(this.xml, 'urn:xmpp:json:0', 'json', value);
            }
        }
    };
    
    
    stanza.withMessage(function (Message) {
        stanza.add(Message, 'json', JSONExtension);
    });

    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'json', JSONExtension);
    });
};

},{}],1413:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:eventlog';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Log = stanza.define({
        name: 'log',
        namespace: NS,
        element: 'log',
        fields: {
            id: types.attribute('id'),
            timestamp: types.dateAttribute('timestamp'),
            type: types.attribute('type'),
            level: types.attribute('level'),
            object: types.attribute('object'),
            subject: types.attribute('subject'),
            facility: types.attribute('facility'),
            module: types.attribute('module'),
            message: types.textSub(NS, 'message'),
            stackTrace: types.textSub(NS, 'stackTrace')
        }
    });
    
    var Tag = stanza.define({
        name: '_logtag',
        namespace: NS,
        element: 'tag',
        fields: {
            name: types.attribute('name'),
            value: types.attribute('value'),
            type: types.attribute('type')
        }
    });
    
    
    stanza.extend(Log, Tag, 'tags');

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Log);
    });

    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, Log);
    });
};

},{}],1414:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;
var NS = 'urn:xmpp:mam:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var MAMQuery = stanza.define({
        name: 'mam',
        namespace: NS,
        element: 'query',
        fields: {
            queryid: types.attribute('queryid')
        }
    });
    
    var Result = stanza.define({
        name: 'mamItem',
        namespace: NS,
        element: 'result',
        fields: {
            queryid: types.attribute('queryid'),
            id: types.attribute('id')
        }
    });

    var Fin = stanza.define({
        name: 'mamResult',
        namespace: NS,
        element: 'fin',
        fields: {
            queryid: types.attribute('queryid'),
            complete: types.boolAttribute('complete'),
            stable: types.boolAttribute('stable')
        }
    });
    
    var Prefs = stanza.define({
        name: 'mamPrefs',
        namespace: NS,
        element: 'prefs',
        fields: {
            defaultCondition: types.attribute('default'),
            always: {
                get: function () {
                    var results = [];
                    var container = types.find(this.xml, NS, 'always');
                    if (container.length === 0) {
                        return results;
                    }
                    container = container[0];
                    var jids = types.getMultiSubText(container, NS, 'jid');
                    jids.forEach(function (jid) {
                        results.push(new JID(jid.textContent));
                    });
                    return results;
                },
                set: function (value) {
                    if (value.length > 0) {
                        var container = types.find(this.xml, NS, 'always');
                        types.setMultiSubText(container, NS, 'jid', value);
                    }
                }
            },
            never: {
                get: function () {
                    var results = [];
                    var container = types.find(this.xml, NS, 'always');
                    if (container.length === 0) {
                        return results;
                    }
                    container = container[0];
                    var jids = types.getMultiSubText(container, NS, 'jid');
                    jids.forEach(function (jid) {
                        results.push(new JID(jid.textContent));
                    });
                    return results;
                },
                set: function (value) {
                    if (value.length > 0) {
                        var container = types.find(this.xml, NS, 'never');
                        types.setMultiSubText(container, NS, 'jid', value);
                    }
                }
            }
        }
    });
    

    stanza.withDefinition('forwarded', 'urn:xmpp:forward:0', function (Forwarded) {
        stanza.extend(Result, Forwarded);
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(MAMQuery, RSM);
        stanza.extend(Fin, RSM);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(MAMQuery, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, MAMQuery);
        stanza.extend(Iq, Prefs);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Result);
        stanza.extend(Message, Fin);
    });
};

},{"xmpp-jid":1604}],1415:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'message',
        namespace: 'jabber:client',
        element: 'message',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            type: types.attribute('type', 'normal'),
            thread: types.textSub('jabber:client', 'thread'),
            parentThread: types.subAttribute('jabber:client', 'thread', 'parent'),
            subject: types.textSub('jabber:client', 'subject'),
            $body: {
                get: function () {
                    return types.getSubLangText(this.xml, this._NS, 'body', this.lang);
                }
            },
            body: {
                get: function () {
                    var bodies = this.$body;
                    return bodies[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, this._NS, 'body', value, this.lang);
                }
            },
            attention: types.boolSub('urn:xmpp:attention:0', 'attention'),
            chatState: types.enumSub('http://jabber.org/protocol/chatstates', [
                'active', 'composing', 'paused', 'inactive', 'gone'
            ]),
            replace: types.subAttribute('urn:xmpp:message-correct:0', 'replace', 'id'),
            requestReceipt: types.boolSub('urn:xmpp:receipts', 'request'),
            receipt: types.subAttribute('urn:xmpp:receipts', 'received', 'id')
        }
    });
};

},{}],1416:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/mood';
var MOODS = [
    'afraid',
    'amazed',
    'amorous',
    'angry',
    'annoyed',
    'anxious',
    'aroused',
    'ashamed',
    'bored',
    'brave',
    'calm',
    'cautious',
    'cold',
    'confident',
    'confused',
    'contemplative',
    'contented',
    'cranky',
    'crazy',
    'creative',
    'curious',
    'dejected',
    'depressed',
    'disappointed',
    'disgusted',
    'dismayed',
    'distracted',
    'embarrassed',
    'envious',
    'excited',
    'flirtatious',
    'frustrated',
    'grateful',
    'grieving',
    'grumpy',
    'guilty',
    'happy',
    'hopeful',
    'hot',
    'humbled',
    'humiliated',
    'hungry',
    'hurt',
    'impressed',
    'in_awe',
    'in_love',
    'indignant',
    'interested',
    'intoxicated',
    'invincible',
    'jealous',
    'lonely',
    'lucky',
    'mean',
    'moody',
    'nervous',
    'neutral',
    'offended',
    'outraged',
    'playful',
    'proud',
    'relaxed',
    'relieved',
    'remorseful',
    'restless',
    'sad',
    'sarcastic',
    'serious',
    'shocked',
    'shy',
    'sick',
    'sleepy',
    'spontaneous',
    'stressed',
    'strong',
    'surprised',
    'thankful',
    'thirsty',
    'tired',
    'undefined',
    'weak',
    'worried'
];


module.exports = function (stanza) {
    var Mood = stanza.define({
        name: 'mood',
        namespace: NS,
        element: 'mood',
        fields: {
            text: stanza.utils.textSub(NS, 'text'),
            value: stanza.utils.enumSub(NS, MOODS)
        }
    });
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, Mood);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Mood);
    });
};

},{}],1417:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/muc';
var USER_NS = NS + '#user';
var ADMIN_NS = NS + '#admin';
var OWNER_NS = NS + '#owner';
var UNIQ_NS = NS + '#unique';


var proxy = function (child, field) {
    return {
        get: function () {
            if (this._extensions[child]) {
                return this[child][field];
            }
        },
        set: function (value) {
            this[child][field] = value;
        }
    };
};


module.exports = function (stanza) {
    var types = stanza.utils;

    var UserItem = stanza.define({
        name: '_mucUserItem',
        namespace: USER_NS,
        element: 'item',
        fields: {
            affiliation: types.attribute('affiliation'),
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid'),
            role: types.attribute('role'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var UserActor = stanza.define({
        name: '_mucUserActor',
        namespace: USER_NS,
        element: 'actor',
        fields: {
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Destroyed = stanza.define({
        name: 'destroyed',
        namespace: USER_NS,
        element: 'destroy',
        fields: {
            jid: types.jidAttribute('jid'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var Invite = stanza.define({
        name: 'invite',
        namespace: USER_NS,
        element: 'invite',
        fields: {
            to: types.jidAttribute('to'),
            from: types.jidAttribute('from'),
            reason: types.textSub(USER_NS, 'reason'),
            thread: types.subAttribute(USER_NS, 'continue', 'thread'),
            'continue': types.boolSub(USER_NS, 'continue')
        }
    });
    
    var Decline = stanza.define({
        name: 'decline',
        namespace: USER_NS,
        element: 'decline',
        fields: {
            to: types.jidAttribute('to'),
            from: types.jidAttribute('from'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var AdminItem = stanza.define({
        name: '_mucAdminItem',
        namespace: ADMIN_NS,
        element: 'item',
        fields: {
            affiliation: types.attribute('affiliation'),
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid'),
            role: types.attribute('role'),
            reason: types.textSub(ADMIN_NS, 'reason')
        }
    });
    
    var AdminActor = stanza.define({
        name: 'actor',
        namespace: USER_NS,
        element: 'actor',
        fields: {
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Destroy = stanza.define({
        name: 'destroy',
        namespace: OWNER_NS,
        element: 'destroy',
        fields: {
            jid: types.jidAttribute('jid'),
            password: types.textSub(OWNER_NS, 'password'),
            reason: types.textSub(OWNER_NS, 'reason')
        }
    });
    
    var MUC = stanza.define({
        name: 'muc',
        namespace: USER_NS,
        element: 'x',
        fields: {
            affiliation: proxy('_mucUserItem', 'affiliation'),
            nick: proxy('_mucUserItem', 'nick'),
            jid: proxy('_mucUserItem', 'jid'),
            role: proxy('_mucUserItem', 'role'),
            actor: proxy('_mucUserItem', '_mucUserActor'),
            reason: proxy('_mucUserItem', 'reason'),
            password: types.textSub(USER_NS, 'password'),
            codes: {
                get: function () {
                    return types.getMultiSubText(this.xml, USER_NS, 'status', function (sub) {
                        return types.getAttribute(sub, 'code');
                    });
                },
                set: function (value) {
                    var self = this;
                    types.setMultiSubText(this.xml, USER_NS, 'status', value, function (val) {
                        var child = types.createElement(USER_NS, 'status', USER_NS);
                        types.setAttribute(child, 'code', val);
                        self.xml.appendChild(child);
                    });
                }
            }
        }
    });
    
    var MUCAdmin = stanza.define({
        name: 'mucAdmin',
        namespace: ADMIN_NS,
        element: 'query',
        fields: {
            affiliation: proxy('_mucAdminItem', 'affiliation'),
            nick: proxy('_mucAdminItem', 'nick'),
            jid: proxy('_mucAdminItem', 'jid'),
            role: proxy('_mucAdminItem', 'role'),
            actor: proxy('_mucAdminItem', '_mucAdminActor'),
            reason: proxy('_mucAdminItem', 'reason')
        }
    });
    
    var MUCOwner = stanza.define({
        name: 'mucOwner',
        namespace: OWNER_NS,
        element: 'query'
    });
    
    var MUCJoin = stanza.define({
        name: 'joinMuc',
        namespace: NS,
        element: 'x',
        fields: {
            password: types.textSub(NS, 'password'),
            history: {
                get: function () {
                    var result = {};
                    var hist = types.find(this.xml, this._NS, 'history');
    
                    if (!hist.length) {
                        return {};
                    }
                    hist = hist[0];
    
                    var maxchars = hist.getAttribute('maxchars') || '';
                    var maxtypess = hist.getAttribute('maxstanas') || '';
                    var seconds = hist.getAttribute('seconds') || '';
                    var since = hist.getAttribute('since') || '';
    
    
                    if (maxchars) {
                        result.maxchars = parseInt(maxchars, 10);
                    }
                    if (maxtypess) {
                        result.maxtypess = parseInt(maxtypess, 10);
                    }
                    if (seconds) {
                        result.seconds = parseInt(seconds, 10);
                    }
                    if (since) {
                        result.since = new Date(since);
                    }
                },
                set: function (opts) {
                    var existing = types.find(this.xml, this._NS, 'history');
                    if (existing.length) {
                        for (var i = 0; i < existing.length; i++) {
                            this.xml.removeChild(existing[i]);
                        }
                    }
    
                    var hist = types.createElement(this._NS, 'history', this._NS);
                    this.xml.appendChild(hist);
    
                    if (opts.maxchars) {
                        hist.setAttribute('' + opts.maxchars);
                    }
                    if (opts.maxtypess) {
                        hist.setAttribute('' + opts.maxtypess);
                    }
                    if (opts.seconds) {
                        hist.setAttribute('' + opts.seconds);
                    }
                    if (opts.since) {
                        hist.setAttribute(opts.since.toISOString());
                    }
                }
            }
        }
    });
    
    var DirectInvite = stanza.define({
        name: 'mucInvite',
        namespace: 'jabber:x:conference',
        element: 'x',
        fields: {
            jid: types.jidAttribute('jid'),
            password: types.attribute('password'),
            reason: types.attribute('reason'),
            thread: types.attribute('thread'),
            'continue': types.boolAttribute('continue')
        }
    });
    
    
    stanza.extend(UserItem, UserActor);
    stanza.extend(MUC, UserItem);
    stanza.extend(MUC, Invite, 'invites');
    stanza.extend(MUC, Decline);
    stanza.extend(MUC, Destroyed);
    stanza.extend(AdminItem, AdminActor);
    stanza.extend(MUCAdmin, AdminItem, 'items');
    stanza.extend(MUCOwner, Destroy);

    stanza.withDataForm(function (DataForm) {
        stanza.extend(MUCOwner, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'mucUnique', types.textSub(UNIQ_NS, 'unique'));
        stanza.extend(Iq, MUCAdmin);
        stanza.extend(Iq, MUCOwner);
    });
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, MUC);
        stanza.extend(Presence, MUCJoin);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, MUC);
        stanza.extend(Message, DirectInvite);
    });
};

},{}],1418:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var nick = stanza.utils.textSub('http://jabber.org/protocol/nick', 'nick');
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'nick', nick);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'nick', nick);
    });

    stanza.withMessage(function (Message) {
        stanza.add(Message, 'nick', nick);
    });
};

},{}],1419:[function(require,module,exports){
'use strict';

var NS = 'jabber:x:oob';


module.exports = function (stanza) {
    var OOB = stanza.define({
        name: 'oob',
        element: 'x',
        namespace: NS,
        fields: {
            url: stanza.utils.textSub(NS, 'url'),
            desc: stanza.utils.textSub(NS, 'desc')
        }
    });
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, OOB, 'oobURIs');
    });
};

},{}],1420:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:ping';


module.exports = function (stanza) {
    var Ping = stanza.define({
        name: 'ping',
        namespace: NS,
        element: 'ping'
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Ping);
    });
};

},{}],1421:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'presence',
        namespace: 'jabber:client',
        element: 'presence',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            priority: types.numberSub('jabber:client', 'priority', false, 0),
            show: types.textSub('jabber:client', 'show'),
            type: {
                get: function () {
                    return types.getAttribute(this.xml, 'type', 'available');
                },
                set: function (value) {
                    if (value === 'available') {
                        value = false;
                    }
                    types.setAttribute(this.xml, 'type', value);
                }
            },
            $status: {
                get: function () {
                    return types.getSubLangText(this.xml, this._NS, 'status', this.lang);
                }
            },
            status: {
                get: function () {
                    var statuses = this.$status;
                    return statuses[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, this._NS, 'status', value, this.lang);
                }
            },
            idleSince: types.dateSubAttribute('urn:xmpp:idle:1', 'idle', 'since'),
            decloak: types.subAttribute('urn:xmpp:decloak:0', 'decloak', 'reason'),
            avatarId: {
                get: function () {
                    var NS = 'vcard-temp:x:update';
                    var update = types.find(this.xml, NS, 'x');
                    if (!update.length) {
                        return '';
                    }
                    return types.getSubText(update[0], NS, 'photo');
                },
                set: function (value) {
                    var NS = 'vcard-temp:x:update';
                    var update = types.findOrCreate(this.xml, NS, 'x');
    
                    if (value === '') {
                        types.setBoolSub(update, NS, 'photo', true);
                    } else if (value === true) {
                        return;
                    } else if (value) {
                        types.setSubText(update, NS, 'photo', value);
                    } else {
                        this.xml.removeChild(update);
                    }
                }
            }
        }
    });
};

},{}],1422:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var PrivateStorage = stanza.define({
        name: 'privateStorage',
        namespace: 'jabber:iq:private',
        element: 'query'
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, PrivateStorage);
    });
};


},{}],1423:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:psa';
var CONDITIONS = [
    'server-unavailable', 'connection-paused'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var PSA = stanza.define({
        name: 'state',
        namespace: NS,
        element: 'state-annotation',
        fields: {
            from: types.jidAttribute('from'),
            condition: types.enumSub(NS, CONDITIONS),
            description: types.textSub(NS, 'description')
        }
    });
    
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, PSA);
    });
};

},{}],1424:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub';


module.exports = function (stanza) {
    var types = stanza.utils;


    var Pubsub = stanza.define({
        name: 'pubsub',
        namespace: 'http://jabber.org/protocol/pubsub',
        element: 'pubsub',
        fields: {
            publishOptions: {
                get: function () {
                    var DataForm = stanza.getDefinition('x', 'jabber:x:data');
                    var conf = types.find(this.xml, this._NS, 'publish-options');
                    if (conf.length && conf[0].childNodes.length) {
                        return new DataForm({}, conf[0].childNodes[0]);
                    }
                },
                set: function (value) {
                    var DataForm = stanza.getDefinition('x', 'jabber:x:data');
                    var conf = types.findOrCreate(this.xml, this._NS, 'publish-options');
                    if (value) {
                        var form = new DataForm(value);
                        conf.appendChild(form.xml);
                    }
                }
            }
        }
    });
    
    var Subscribe = stanza.define({
        name: 'subscribe',
        namespace: NS,
        element: 'subscribe',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Subscription = stanza.define({
        name: 'subscription',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid'),
            type: types.attribute('subscription'),
            configurable: types.boolSub('subscribe-options'),
            configurationRequired: {
                get: function () {
                    var options = types.find(this.xml, NS, 'subscribe-options');
                    if (options.length) {
                        return types.getBoolSub(options[0], NS, 'required');
                    }
                    return false;
                }
            }
        }
    });

    var Subscriptions = stanza.define({
        name: 'subscriptions',
        namespace: NS,
        element: 'subscriptions',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Affiliation = stanza.define({
        name: 'affiliation',
        namespace: NS,
        element: 'affiliation',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            type: types.attribute('affiliation')
        }
    });
    
    var Affiliations = stanza.define({
        name: 'affiliations',
        namespace: NS,
        element: 'affiliations',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });

    var SubscriptionOptions = stanza.define({
        name: 'subscriptionOptions',
        namespace: NS,
        element: 'options',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid')
        }
    });
    
    var Unsubscribe = stanza.define({
        name: 'unsubscribe',
        namespace: NS,
        element: 'unsubscribe',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Publish = stanza.define({
        name: 'publish',
        namespace: NS,
        element: 'publish',
        fields: {
            node: types.attribute('node'),
        }
    });
    
    var Retract = stanza.define({
        name: 'retract',
        namespace: NS,
        element: 'retract',
        fields: {
            node: types.attribute('node'),
            notify: types.boolAttribute('notify'),
            id: types.subAttribute(NS, 'item', 'id')
        }
    });
    
    var Retrieve = stanza.define({
        name: 'retrieve',
        namespace: NS,
        element: 'items',
        fields: {
            node: types.attribute('node'),
            max: types.attribute('max_items')
        }
    });
    
    var Item = stanza.define({
        name: 'item',
        namespace: NS,
        element: 'item',
        fields: {
            id: types.attribute('id')
        }
    });
    
    
    stanza.extend(Pubsub, Subscribe);
    stanza.extend(Pubsub, Unsubscribe);
    stanza.extend(Pubsub, Publish);
    stanza.extend(Pubsub, Retract);
    stanza.extend(Pubsub, Retrieve);
    stanza.extend(Pubsub, Subscription);
    stanza.extend(Pubsub, SubscriptionOptions);
    stanza.extend(Pubsub, Subscriptions);
    stanza.extend(Pubsub, Affiliations);
   
    stanza.extend(Publish, Item, 'items');
    stanza.extend(Retrieve, Item, 'items');
    
    stanza.extend(Subscriptions, Subscription, 'list');
    stanza.extend(Affiliations, Affiliation, 'list');

    stanza.withDataForm(function (DataForm) {
        stanza.extend(SubscriptionOptions, DataForm);
        stanza.extend(Item, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Pubsub);
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(Pubsub, RSM);
    });
};

},{}],1425:[function(require,module,exports){
'use strict';

var ERRNS = 'http://jabber.org/protocol/pubsub#errors';
var CONDITIONS = [
    'closed-node',
    'configuration-required',
    'invalid-jid',
    'invalid-options',
    'invalid-payload',
    'invalid-subid',
    'item-forbidden',
    'item-required',
    'jid-required',
    'max-items-exceeded',
    'max-nodes-exceeded',
    'nodeid-required',
    'not-in-roster-group',
    'not-subscribed',
    'payload-too-big',
    'payload-required',
    'pending-subscription',
    'presence-subscription-required',
    'subid-required',
    'too-many-subscriptions',
    'unsupported',
    'unsupported-access-model'
];


module.exports = function (stanza) {
    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'pubsubCondition', stanza.utils.enumSub(ERRNS, CONDITIONS));
    });
};

},{}],1426:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub#event';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Event = stanza.define({
        name: 'event',
        namespace: NS,
        element: 'event'
    });
    
    var EventPurge = stanza.define({
        name: 'purged',
        namespace: NS,
        element: 'purge',
        fields: {
            node: types.attribute('node'),
        }
    });
    
    var EventDelete = stanza.define({
        name: 'deleted',
        namespace: NS,
        element: 'delete',
        fields: {
            node: types.attribute('node'),
            redirect: types.subAttribute(NS, 'redirect', 'uri')
        }
    });
    
    var EventSubscription = stanza.define({
        name: 'subscriptionChanged',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            type: types.attribute('subscription'),
            subid: types.attribute('subid'),
            expiry: {
                get: function () {
                    var text = types.getAttribute(this.xml, 'expiry');
                    if (text === 'presence') {
                        return text;
                    } else if (text) {
                        return new Date(text);
                    }
                },
                set: function (value) {
                    if (!value) {
                        return;
                    }
    
                    if (typeof value !== 'string') {
                        value = value.toISOString();
                    }
    
                    types.setAttribute(this.xml, 'expiry', value);
                }
            }
        }
    });
    
    var EventConfiguration = stanza.define({
        name: 'configurationChanged',
        namespace: NS,
        element: 'configuration',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var EventItems = stanza.define({
        name: 'updated',
        namespace: NS,
        element: 'items',
        fields: {
            node: types.attribute('node'),
            retracted: {
                get: function () {
                    var results = [];
                    var retracted = types.find(this.xml, this._NS, 'retract');
    
                    retracted.forEach(function (xml) {
                        results.push(xml.getAttribute('id'));
                    });
                    return results;
                },
                set: function (value) {
                    var self = this;
                    value.forEach(function (id) {
                        var retracted = types.createElement(self._NS, 'retract', self._NS);
                        retracted.setAttribute('id', id);
                        this.xml.appendChild(retracted);
                    });
                }
            }
        }
    });
    
    var EventItem = stanza.define({
        name: '_eventItem',
        namespace: NS,
        element: 'item',
        fields: {
            id: types.attribute('id'),
            node: types.attribute('node'),
            publisher: types.jidAttribute('publisher')
        }
    });
    
    
    stanza.extend(EventItems, EventItem, 'published');
    
    stanza.extend(Event, EventItems);
    stanza.extend(Event, EventSubscription);
    stanza.extend(Event, EventConfiguration);
    stanza.extend(Event, EventDelete);
    stanza.extend(Event, EventPurge);
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, Event);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(EventConfiguration, DataForm);
    });
};

},{}],1427:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub#owner';


module.exports = function (stanza) {
    var types = stanza.utils;

    var PubsubOwner = stanza.define({
        name: 'pubsubOwner',
        namespace: NS,
        element: 'pubsub',
        fields: {
            create: types.subAttribute(NS, 'create', 'node'),
            purge: types.subAttribute(NS, 'purge', 'node'),
            del: types.subAttribute(NS, 'delete', 'node'),
            redirect: {
                get: function () {
                    var del = types.find(this.xml, this._NS, 'delete');
                    if (del.length) {
                        return types.getSubAttribute(del[0], this._NS, 'redirect', 'uri');
                    }
                    return '';
                },
                set: function (value) {
                    var del = types.findOrCreate(this.xml, this._NS, 'delete');
                    types.setSubAttribute(del, this._NS, 'redirect', 'uri', value);
                }
            }
        }
    });

    var Subscription = stanza.define({
        name: 'subscription',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid'),
            type: types.attribute('subscription'),
            configurable: types.boolSub('subscribe-options'),
            configurationRequired: {
                get: function () {
                    var options = types.find(this.xml, NS, 'subscribe-options');
                    if (options.length) {
                        return types.getBoolSub(options[0], NS, 'required');
                    }
                    return false;
                }
            }
        }
    });
    
    var Subscriptions = stanza.define({
        name: 'subscriptions',
        namespace: NS,
        element: 'subscriptions',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var Affiliation = stanza.define({
        name: 'affiliation',
        namespace: NS,
        element: 'affiliation',
        fields: {
            node: types.attribute('node'),
            type: types.attribute('affiliation')
        }
    });
    
    var Affiliations = stanza.define({
        name: 'affiliations',
        namespace: NS,
        element: 'affiliations',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var Configure = stanza.define({
        name: 'config',
        namespace: NS,
        element: 'configure',
        fields: {
            node: types.attribute('node')
        }
    });
    
    
    stanza.extend(PubsubOwner, Configure);
    stanza.extend(PubsubOwner, Subscriptions);
    stanza.extend(PubsubOwner, Affiliations);
    
    stanza.extend(Subscriptions, Subscription, 'list');
    stanza.extend(Affiliations, Affiliation, 'list');

    stanza.withDataForm(function (DataForm) {
        stanza.extend(Configure, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, PubsubOwner);
    });
};

},{}],1428:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var NS = 'urn:xmpp:reach:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var ReachURI = stanza.define({
        name: '_reachAddr',
        namespace: NS,
        element: 'addr',
        fields: {
            uri: types.attribute('uri'),
            $desc: {
                get: function () {
                    return types.getSubLangText(this.xml, NS, 'desc', this.lang);
                }
            },
            desc: {
                get: function () {
                    var descs = this.$desc;
                    return descs[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, NS, 'desc', value, this.lang);
                }
            }
        }
    });
    
    var reachability = {
        get: function () {
            var reach = types.find(this.xml, NS, 'reach');
            var results = [];
            if (reach.length) {
                var addrs = types.find(reach[0], NS, 'addr');
                _.forEach(addrs, function (addr) {
                    results.push(new ReachURI({}, addr));
                });
            }
            return results;
        },
        set: function (value) {
            var reach = types.findOrCreate(this.xml, NS, 'reach');
            types.setAttribute(reach, 'xmlns', NS);
            _.forEach(value, function (info) {
                var addr = new ReachURI(info);
                reach.appendChild(addr.xml);
            });
        }
    };
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'reach', reachability);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'reach', reachability);
    });
};

},{"underscore":1602}],1429:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:register';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Register = stanza.define({
        name: 'register',
        namespace: NS,
        element: 'query',
        fields: {
            instructions: types.textSub(NS, 'instructions'),
            registered: types.boolSub(NS, 'registered'),
            remove: types.boolSub(NS, 'remove'),
            username: types.textSub(NS, 'username'),
            nick: types.textSub(NS, 'nick'),
            password: types.textSub(NS, 'password'),
            name: types.textSub(NS, 'name'),
            first: types.textSub(NS, 'first'),
            last: types.textSub(NS, 'last'),
            email: types.textSub(NS, 'email'),
            address: types.textSub(NS, 'address'),
            city: types.textSub(NS, 'city'),
            state: types.textSub(NS, 'state'),
            zip: types.textSub(NS, 'zip'),
            phone: types.textSub(NS, 'phone'),
            url: types.textSub(NS, 'url'),
            date: types.textSub(NS, 'date'),
            misc: types.textSub(NS, 'misc'),
            text: types.textSub(NS, 'text'),
            key: types.textSub(NS, 'key')
        }
    });
    

    stanza.withDefinition('x', 'jabber:x:oob', function (OOB) {
        stanza.extend(Register, OOB);
    });
    
    stanza.withDataForm(function (DataForm) {
        stanza.extend(Register, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Register);
    });
};

},{}],1430:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:roster';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Roster = stanza.define({
        name: 'roster',
        namespace: NS,
        element: 'query',
        fields: {
            ver: {
                get: function () {
                    return types.getAttribute(this.xml, 'ver');
                },
                set: function (value) {
                    var force = (value === '');
                    types.setAttribute(this.xml, 'ver', value, force);
                }
            }
        }
    });
    
    var RosterItem = stanza.define({
        name: '_rosterItem',
        namespace: NS,
        element: 'item',
        fields: {
            jid: types.jidAttribute('jid', true),
            name: types.attribute('name'),
            subscription: types.attribute('subscription', 'none'),
            subscriptionRequested: {
                get: function () {
                    var ask = types.getAttribute(this.xml, 'ask');
                    return ask === 'subscribe';
                }
            },
            preApproved: types.boolAttribute(NS, 'approved'),
            groups: types.multiTextSub(NS, 'group')
        }
    });
    
    
    stanza.extend(Roster, RosterItem, 'items');
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Roster);
    });
};

},{}],1431:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/rsm';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'rsm',
        namespace: NS,
        element: 'set',
        fields: {
            after: types.textSub(NS, 'after'),
            before: {
                get: function () {
                    return types.getSubText(this.xml, this._NS, 'before');
                },
                set: function (value) {
                    if (value === true) {
                        types.findOrCreate(this.xml, this._NS, 'before');
                    } else {
                        types.setSubText(this.xml, this._NS, 'before', value);
                    }
                }
            },
            count: types.numberSub(NS, 'count', false, 0),
            first: types.textSub(NS, 'first'),
            firstIndex: types.subAttribute(NS, 'first', 'index'),
            index: types.textSub(NS, 'index'),
            last: types.textSub(NS, 'last'),
            max: types.textSub(NS, 'max')
        }
    });
};

},{}],1432:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:apps:rtp:1';
var FBNS = 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0';
var HDRNS = 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0';
var INFONS = 'urn:xmpp:jingle:apps:rtp:info:1';
var SSMANS = 'urn:xmpp:jingle:apps:rtp:ssma:0';
var GROUPNS = 'urn:xmpp:jingle:apps:grouping:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Feedback = {
        get: function () {
            var existing = types.find(this.xml, FBNS, 'rtcp-fb');
            var result = [];
            existing.forEach(function (xml) {
                result.push({
                    type: types.getAttribute(xml, 'type'),
                    subtype: types.getAttribute(xml, 'subtype')
                });
            });
            existing = types.find(this.xml, FBNS, 'rtcp-fb-trr-int');
            existing.forEach(function (xml) {
                result.push({
                    type: types.getAttribute(xml, 'type'),
                    value: types.getAttribute(xml, 'value')
                });
            });
            return result;
        },
        set: function (values) {
            var self = this;
            var existing = types.find(this.xml, FBNS, 'rtcp-fb');
            existing.forEach(function (item) {
                self.xml.removeChild(item);
            });
            existing = types.find(this.xml, FBNS, 'rtcp-fb-trr-int');
            existing.forEach(function (item) {
                self.xml.removeChild(item);
            });
    
            values.forEach(function (value) {
                var fb;
                if (value.type === 'trr-int') {
                    fb = types.createElement(FBNS, 'rtcp-fb-trr-int', NS);
                    types.setAttribute(fb, 'type', value.type);
                    types.setAttribute(fb, 'value', value.value);
                } else {
                    fb = types.createElement(FBNS, 'rtcp-fb', NS);
                    types.setAttribute(fb, 'type', value.type);
                    types.setAttribute(fb, 'subtype', value.subtype);
                }
                self.xml.appendChild(fb);
            });
        }
    };
    
    var Bandwidth = stanza.define({
        name: 'bandwidth',
        namespace: NS,
        element: 'bandwidth',
        fields: {
            type: types.attribute('type'),
            bandwidth: types.text()
        }
    });

    var RTP = stanza.define({
        name: '_rtp',
        namespace: NS,
        element: 'description',
        tags: ['jingle-description'],
        fields: {
            descType: {value: 'rtp'},
            media: types.attribute('media'),
            ssrc: types.attribute('ssrc'),
            mux: types.boolSub(NS, 'rtcp-mux'),
            encryption: {
                get: function () {
                    var enc = types.find(this.xml, NS, 'encryption');
                    if (!enc.length) {
                        return [];
                    }
                    enc = enc[0];
    
                    var self = this;
                    var data = types.find(enc, NS, 'crypto');
                    var results = [];
    
                    data.forEach(function (xml) {
                        results.push(new Crypto({}, xml, self).toJSON());
                    });
                    return results;
                },
                set: function (values) {
                    var enc = types.find(this.xml, NS, 'encryption');
                    if (enc.length) {
                        this.xml.removeChild(enc);
                    }
    
                    if (!values.length) {
                        return;
                    }
    
                    types.setBoolSubAttribute(this.xml, NS, 'encryption', 'required', true);
                    enc = types.find(this.xml, NS, 'encryption')[0];
    
                    var self = this;
                    values.forEach(function (value) {
                        var content = new Crypto(value, null, self);
                        enc.appendChild(content.xml);
                    });
                }
            },
            feedback: Feedback,
            headerExtensions: {
                get: function () {
                    var existing = types.find(this.xml, HDRNS, 'rtp-hdrext');
                    var result = [];
                    existing.forEach(function (xml) {
                        result.push({
                            id: types.getAttribute(xml, 'id'),
                            uri: types.getAttribute(xml, 'uri'),
                            senders: types.getAttribute(xml, 'senders')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    var existing = types.find(this.xml, HDRNS, 'rtp-hdrext');
                    existing.forEach(function (item) {
                        self.xml.removeChild(item);
                    });
    
                    values.forEach(function (value) {
                        var hdr = types.createElement(HDRNS, 'rtp-hdrext', NS);
                        types.setAttribute(hdr, 'id', value.id);
                        types.setAttribute(hdr, 'uri', value.uri);
                        types.setAttribute(hdr, 'senders', value.senders);
                        self.xml.appendChild(hdr);
                    });
                }
            }
        }
    });
    
    
    var PayloadType = stanza.define({
        name: '_payloadType',
        namespace: NS,
        element: 'payload-type',
        fields: {
            channels: types.attribute('channels'),
            clockrate: types.attribute('clockrate'),
            id: types.attribute('id'),
            maxptime: types.attribute('maxptime'),
            name: types.attribute('name'),
            ptime: types.attribute('ptime'),
            feedback: Feedback,
            parameters: {
                get: function () {
                    var result = [];
                    var params = types.find(this.xml, NS, 'parameter');
                    params.forEach(function (param) {
                        result.push({
                            key: types.getAttribute(param, 'name'),
                            value: types.getAttribute(param, 'value')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (value) {
                        var param = types.createElement(NS, 'parameter');
                        types.setAttribute(param, 'name', value.key);
                        types.setAttribute(param, 'value', value.value);
                        self.xml.appendChild(param);
                    });
                }
            }
        }
    });
    
    
    var Crypto = stanza.define({
        name: 'crypto',
        namespace: NS,
        element: 'crypto',
        fields: {
            cipherSuite: types.attribute('crypto-suite'),
            keyParams: types.attribute('key-params'),
            sessionParams: types.attribute('session-params'),
            tag: types.attribute('tag')
        }
    });
    
    
    var ContentGroup = stanza.define({
        name: '_group',
        namespace: GROUPNS,
        element: 'group',
        fields: {
            semantics: types.attribute('semantics'),
            contents: types.multiSubAttribute(GROUPNS, 'content', 'name')
        }
    });
    
    var SourceGroup = stanza.define({
        name: '_sourceGroup',
        namespace: SSMANS,
        element: 'ssrc-group',
        fields: {
            semantics: types.attribute('semantics'),
            sources: types.multiSubAttribute(SSMANS, 'source', 'ssrc')
        }
    });
    
    var Source = stanza.define({
        name: '_source',
        namespace: SSMANS,
        element: 'source',
        fields: {
            ssrc: types.attribute('ssrc'),
            parameters: {
                get: function () {
                    var result = [];
                    var params = types.find(this.xml, SSMANS, 'parameter');
                    params.forEach(function (param) {
                        result.push({
                            key: types.getAttribute(param, 'name'),
                            value: types.getAttribute(param, 'value')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (value) {
                        var param = types.createElement(SSMANS, 'parameter');
                        types.setAttribute(param, 'name', value.key);
                        types.setAttribute(param, 'value', value.value);
                        self.xml.appendChild(param);
                    });
                }
            }
        }
    });
    
    
    var Mute = stanza.define({
        name: 'mute',
        namespace: INFONS,
        element: 'mute',
        fields: {
            creator: types.attribute('creator'),
            name: types.attribute('name')
        }
    });
    
    
    var Unmute = stanza.define({
        name: 'unmute',
        namespace: INFONS,
        element: 'unmute',
        fields: {
            creator: types.attribute('creator'),
            name: types.attribute('name')
        }
    });
    
    
    stanza.extend(RTP, Bandwidth);
    stanza.extend(RTP, PayloadType, 'payloads');
    stanza.extend(RTP, Source, 'sources');
    stanza.extend(RTP, SourceGroup, 'sourceGroups');
    
    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, RTP);
    });

    stanza.withDefinition('jingle', 'urn:xmpp:jingle:1', function (Jingle) {
        stanza.extend(Jingle, Mute);
        stanza.extend(Jingle, Unmute);
        stanza.extend(Jingle, ContentGroup, 'groups');
        stanza.add(Jingle, 'ringing', types.boolSub(INFONS, 'ringing'));
        stanza.add(Jingle, 'hold', types.boolSub(INFONS, 'hold'));
        stanza.add(Jingle, 'active', types.boolSub(INFONS, 'active'));
    });
};

},{}],1433:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:rtt:0';
var typemap = {
    'insert': 't',
    'erase': 'e',
    'wait': 'w',
};
var actionmap = {
    't': 'insert',
    'e': 'erase',
    'w': 'wait'
};


module.exports = function (stanza) {
    var types = stanza.utils;

    var RTT = stanza.define({
        name: 'rtt',
        namespace: NS,
        element: 'rtt',
        fields: {
            id: types.attribute('id'),
            event: types.attribute('event', 'edit'),
            seq: types.numberAttribute('seq'),
            actions: {
                get: function () {
                    var results = [];
                    for(var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                        var child = this.xml.childNodes[i];
                        var name = child.localName;
                        var action = {};
    
                        if (child.namespaceURI !== NS) {
                            continue;
                        }
    
                        if (actionmap[name]) {
                            action.type = actionmap[name];
                        } else {
                            continue;
                        }
    
                        var pos = types.getAttribute(child, 'p');
                        if (pos) {
                            action.pos = parseInt(pos, 10);
                        }
    
                        var n = types.getAttribute(child, 'n');
                        if (n) {
                            action.num = parseInt(n, 10);
                        }
    
                        var t = types.getText(child);
                        if (t && name === 't') {
                            action.text = t;
                        }
    
    
                        results.push(action);
                    }
    
                    return results;
                },
                set: function (actions) {
                    var self = this;
    
                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                        this.xml.removeChild(this.xml.childNodes[i]);
                    }
    
                    actions.forEach(function (action ) {
                        if (!typemap[action.type]) {
                            return;
                        }
    
                        var child = types.createElement(NS, typemap[action.type], NS);
    
                        if (action.pos !== undefined) {
                            types.setAttribute(child, 'p', action.pos.toString());
                        }
    
                        if (action.num) {
                            types.setAttribute(child, 'n', action.num.toString());
                        }
    
                        if (action.text) {
                            types.setText(child, action.text);
                        }
    
                        self.xml.appendChild(child);
                    });
                }
            }
        }
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, RTT);
    });
};

},{}],1434:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';
var CONDITIONS = [
    'aborted',
    'account-disabled',
    'credentials-expired',
    'encryption-required',
    'incorrect-encoding',
    'invalid-authzid',
    'invalid-mechanism',
    'malformed-request',
    'mechanism-too-weak',
    'not-authorized',
    'temporary-auth-failure'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Mechanisms = stanza.define({
        name: 'sasl',
        namespace: NS,
        element: 'mechanisms',
        fields: {
            mechanisms: types.multiTextSub(NS, 'mechanism')
        }
    });

    stanza.define({
        name: 'saslAuth',
        eventName: 'sasl:auth',
        namespace: NS,
        element: 'auth',
        topLevel: true,
        fields: {
            value: types.b64Text(),
            mechanism: types.attribute('mechanism')
        }
    });

    stanza.define({
        name: 'saslChallenge',
        eventName: 'sasl:challenge',
        namespace: NS,
        element: 'challenge',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslResponse',
        eventName: 'sasl:response',
        namespace: NS,
        element: 'response',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslAbort',
        eventName: 'sasl:abort',
        namespace: NS,
        element: 'abort',
        topLevel: true
    });

    stanza.define({
        name: 'saslSuccess',
        eventName: 'sasl:success',
        namespace: NS,
        element: 'success',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslFailure',
        eventName: 'sasl:failure',
        namespace: NS,
        element: 'failure',
        topLevel: true,
        fields: {
            lang: {
                get: function () {
                    return this._lang || '';
                },
                set: function (value) {
                    this._lang = value;
                }
            },
            condition: types.enumSub(NS, CONDITIONS),
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, NS, 'text', value, this.lang);
                }
            }
        }
    });


    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Mechanisms);
    });
};

},{}],1435:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-session';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Session = stanza.define({
        name: 'session',
        namespace: NS,
        element: 'session',
        fields: {
            required: types.boolSub(NS, 'required'),
            optional: types.boolSub(NS, 'optional')
        }
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Session);
    });
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Session);
    });
};

},{}],1436:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/shim';


module.exports = function (stanza) {
    var types = stanza.utils;

    var SHIM = {
        get: function () {
            var headerSet = types.find(this.xml, NS, 'headers');
            if (headerSet.length) {
                return types.getMultiSubText(headerSet[0], NS, 'header', function (header) {
                    var name = types.getAttribute(header, 'name');
                    if (name) {
                        return {
                            name: name,
                            value: types.getText(header)
                        };
                    }
                });
            }
            return [];
        },
        set: function (values) {
            var headerSet = types.findOrCreate(this.xml, NS, 'headers');
            stanza.setMultiSubText(headerSet, NS, 'header', values, function (val) {
                var header = types.createElement(NS, 'header', NS);
                types.setAttribute(header, 'name', val.name);
                types.setText(header, val.value);
                headerSet.appendChild(header);
            });
        }
    };
    
    
    stanza.withMessage(function (Message) {
        stanza.add(Message, 'headers', SHIM);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'headers', SHIM);
    });
};

},{}],1437:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:sm:3';


module.exports = function (stanza) {
    var types = stanza.utils;

    var SMFeature = stanza.define({
        name: 'streamManagement',
        namespace: NS,
        element: 'sm'
    });

    stanza.define({
        name: 'smEnable',
        eventName: 'stream:management:enable',
        namespace: NS,
        element: 'enable',
        topLevel: true,
        fields: {
            resume: types.boolAttribute('resume')
        }
    });

    stanza.define({
        name: 'smEnabled',
        eventName: 'stream:management:enabled',
        namespace: NS,
        element: 'enabled',
        topLevel: true,
        fields: {
            id: types.attribute('id'),
            resume: types.boolAttribute('resume')
        }
    });

    stanza.define({
        name: 'smResume',
        eventName: 'stream:management:resume',
        namespace: NS,
        element: 'resume',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0),
            previd: types.attribute('previd')
        }
    });

    stanza.define({
        name: 'smResumed',
        eventName: 'stream:management:resumed',
        namespace: NS,
        element: 'resumed',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0),
            previd: types.attribute('previd')
        }
    });

    stanza.define({
        name: 'smFailed',
        eventName: 'stream:management:failed',
        namespace: NS,
        element: 'failed',
        topLevel: true
    });

    stanza.define({
        name: 'smAck',
        eventName: 'stream:management:ack',
        namespace: NS,
        element: 'a',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0)
        }
    });

    stanza.define({
        name: 'smRequest',
        eventName: 'stream:management:request',
        namespace: NS,
        element: 'r',
        topLevel: true
    });
    
    
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, SMFeature);
    });
};

},{}],1438:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'stream',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'stream',
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            version: types.attribute('version', '1.0'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true)
        }
    });
};

},{}],1439:[function(require,module,exports){
'use strict';

var ERR_NS = 'urn:ietf:params:xml:ns:xmpp-streams';
var CONDITIONS = [
    'bad-format',
    'bad-namespace-prefix',
    'conflict',
    'connection-timeout',
    'host-gone',
    'host-unknown',
    'improper-addressing',
    'internal-server-error',
    'invalid-from',
    'invalid-namespace',
    'invalid-xml',
    'not-authorized',
    'not-well-formed',
    'policy-violation',
    'remote-connection-failed',
    'reset',
    'resource-constraint',
    'restricted-xml',
    'see-other-host',
    'system-shutdown',
    'undefined-condition',
    'unsupported-encoding',
    'unsupported-feature',
    'unsupported-stanza-type',
    'unsupported-version'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'streamError',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'error',
        topLevel: true,
        fields: {
            lang: {
                get: function () {
                    return this._lang || '';
                },
                set: function (value) {
                    this._lang = value;
                }
            },
            condition: types.enumSub(ERR_NS, CONDITIONS),
            seeOtherHost: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'see-other-host');
                },
                set: function (value) {
                    this.condition = 'see-other-host';
                    types.setSubText(this.xml, ERR_NS, 'see-other-host', value);
                }
            },
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, ERR_NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, ERR_NS, 'text', value, this.lang);
                }
            }
        }
    });
};

},{}],1440:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var StreamFeatures = stanza.define({
        name: 'streamFeatures',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'features',
        topLevel: true
    });
    
    var RosterVerFeature = stanza.define({
        name: 'rosterVersioning',
        namespace: 'urn:xmpp:features:rosterver',
        element: 'ver'
    });
    
    var SubscriptionPreApprovalFeature = stanza.define({
        name: 'subscriptionPreApproval',
        namespace: 'urn:xmpp:features:pre-approval',
        element: 'sub'
    });
    
    
    stanza.extend(StreamFeatures, RosterVerFeature);
    stanza.extend(StreamFeatures, SubscriptionPreApprovalFeature);
};

},{}],1441:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var EntityTime = stanza.define({
        name: 'time',
        namespace: 'urn:xmpp:time',
        element: 'time',
        fields: {
            utc: stanza.utils.dateSub('urn:xmpp:time', 'utc'),
            tzo: stanza.utils.tzoSub('urn:xmpp:time', 'tzo', 0)
        }
    });
    
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, EntityTime);
    });
};

},{}],1442:[function(require,module,exports){
'use strict';

var NS = 'vcard-temp';


module.exports = function (stanza) {
    var types = stanza.utils;

    var VCardTemp = stanza.define({
        name: 'vCardTemp',
        namespace: NS,
        element: 'vCard',
        fields: {
            role: types.textSub(NS, 'ROLE'),
            website: types.textSub(NS, 'URL'),
            title: types.textSub(NS, 'TITLE'),
            description: types.textSub(NS, 'DESC'),
            fullName: types.textSub(NS, 'FN'),
            birthday: types.dateSub(NS, 'BDAY'),
            nicknames: types.multiTextSub(NS, 'NICKNAME'),
            jids: types.multiTextSub(NS, 'JABBERID')
        }
    });
    
    var Email = stanza.define({
        name: '_email',
        namespace: NS,
        element: 'EMAIL',
        fields: {
            email: types.textSub(NS, 'USERID'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var PhoneNumber = stanza.define({
        name: '_tel',
        namespace: NS,
        element: 'TEL',
        fields: {
            number: types.textSub(NS, 'NUMBER'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            mobile: types.boolSub(NS, 'CELL'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var Address = stanza.define({
        name: '_address',
        namespace: NS,
        element: 'ADR',
        fields: {
            street: types.textSub(NS, 'STREET'),
            street2: types.textSub(NS, 'EXTADD'),
            country: types.textSub(NS, 'CTRY'),
            city: types.textSub(NS, 'LOCALITY'),
            region: types.textSub(NS, 'REGION'),
            postalCode: types.textSub(NS, 'PCODE'),
            pobox: types.textSub(NS, 'POBOX'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var Organization = stanza.define({
        name: 'organization',
        namespace: NS,
        element: 'ORG',
        fields: {
            name: types.textSub(NS, 'ORGNAME'),
            unit: types.textSub(NS, 'ORGUNIT')
        }
    });
    
    var Name = stanza.define({
        name: 'name',
        namespace: NS,
        element: 'N',
        fields: {
            family: types.textSub(NS, 'FAMILY'),
            given: types.textSub(NS, 'GIVEN'),
            middle: types.textSub(NS, 'MIDDLE'),
            prefix: types.textSub(NS, 'PREFIX'),
            suffix: types.textSub(NS, 'SUFFIX')
        }
    });
    
    var Photo = stanza.define({
        name: 'photo',
        namespace: NS,
        element: 'PHOTO',
        fields: {
            type: types.textSub(NS, 'TYPE'),
            data: types.textSub(NS, 'BINVAL'),
            url: types.textSub(NS, 'EXTVAL')
        }
    });
    
    
    stanza.extend(VCardTemp, Email, 'emails');
    stanza.extend(VCardTemp, Address, 'addresses');
    stanza.extend(VCardTemp, PhoneNumber, 'phoneNumbers');
    stanza.extend(VCardTemp, Organization);
    stanza.extend(VCardTemp, Name);
    stanza.extend(VCardTemp, Photo);

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, VCardTemp);
    });
};

},{}],1443:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:version';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Version = stanza.define({
        name: 'version',
        namespace: NS,
        element: 'query',
        fields: {
            name: types.textSub(NS, 'name'),
            version: types.textSub(NS, 'version'),
            os: types.textSub(NS, 'os')
        }
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Version);
    });
};

},{}],1444:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:invisible:0';


module.exports = function (stanza) {
    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'visible', stanza.utils.boolSub(NS, 'visible'));
        stanza.add(Iq, 'invisible', stanza.utils.boolSub(NS, 'invisible'));
    });
};

},{}],1445:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var _ = require('underscore');
var util = require('util');
var BPromise = require('bluebird');
var request = BPromise.promisify(require('request'));

var WildEmitter = require('wildemitter');


function ConnectionError() {}
util.inherits(ConnectionError, Error);


function retryRequest(opts, timeout, allowedRetries, retries) {
    retries = retries || 0;

    var req = request(opts).cancellable().timeout((timeout || 20) * 1000);

    return req.spread(function (req, body) {
        if (req.statusCode < 200 || req.statusCode >= 400) {
            throw new ConnectionError('HTTP Status Error');
        }
        return body;
    }).catch(BPromise.TimeoutError, function () {
        throw new ConnectionError('Dead Connection, exceeded timeout limit');
    }).catch(function () {
        if (retries < allowedRetries) {
            return BPromise.delay(100).then(function () {
                return retryRequest(opts, timeout, allowedRetries, retries + 1);
            });
        } else {
            throw new ConnectionError('Dead Connection, exceeded retry limit');
        }
    });
}


function BOSHConnection(sm, stanzas) {
    var self = this;

    WildEmitter.call(this);

    self.sm = sm;

    self.stanzas = {
        BOSH: stanzas.getDefinition('body', 'http://jabber.org/protocol/httpbind'),
        StreamError: stanzas.getStreamError()
    };

    self.sendQueue = [];
    self.requests = [];
    self.maxRequests = 2;
    self.sid = '';

    self.on('raw:incoming', function (data) {
        data = data.trim();
        if (data === '') {
            return;
        }

        var bosh, err;

        try {
            bosh = stanzas.parse(data, self.stanzas.BOSH);
        } catch (e) {
            err = new self.stanzas.StreamError({
                condition: 'invalid-xml'
            });
            self.emit('stream:error', err, e);
            self.send(err);
            return self.disconnect();
        }

        if (!self.hasStream) {
            self.hasStream = true;
            self.stream = {
                id: bosh.sid,
                lang: bosh.lang || 'en',
                version: bosh.version || '1.0',
                to: bosh.to,
                from: bosh.from
            };
            self.sid = bosh.sid;
            self.maxRequests = bosh.requests;
        }

        var payload = bosh.payload;
        payload.forEach(function (stanzaObj) {
            if (!stanzaObj.lang) {
                stanzaObj.lang = self.stream.lang;
            }

            self.emit('stream:data', stanzaObj);
        });

        if (bosh.type === 'terminate') {
            self.rid = undefined;
            self.sid = undefined;
            self.emit('bosh:terminate', bosh);
            self.emit('stream:end');
            self.emit('disconnected', self);
        }
    });
}

util.inherits(BOSHConnection, WildEmitter);

BOSHConnection.prototype.connect = function (opts) {
    var self = this;

    self.config = _.extend({
        rid: Math.ceil(Math.random() * 9999999999),
        wait: 30,
        maxRetries: 5
    }, opts);

    self.hasStream = false;
    self.sm.started = false;
    self.url = opts.boshURL;

    self.rid = self.config.rid;

    self.requests = [];

    self.rid++;
    self.request(new self.stanzas.BOSH({
        version: self.config.version || '1.0',
        to: self.config.server,
        lang: self.config.lang || 'en',
        wait: self.config.wait,
        ver: '1.6',
        hold: 1
    }));
};

BOSHConnection.prototype.disconnect = function () {
    if (this.hasStream) {
        this.rid++;
        this.request(new this.stanzas.BOSH({
            type: 'terminate'
        }));
    } else {
        this.requests.forEach(function (ticket) {
            ticket.request.cancel();
        });
        this.stream = undefined;
        this.sid = undefined;
        this.rid = undefined;
        this.emit('disconnected', this);
    }
};

BOSHConnection.prototype.restart = function () {
    var self = this;
    self.rid++;
    self.request(new self.stanzas.BOSH({
        to: self.config.server,
        lang: self.config.lang || 'en',
        restart: 'true'
    }));
};

BOSHConnection.prototype.send = function (data) {
    var self = this;
    if (self.hasStream) {
        self.sendQueue.push(data);
        process.nextTick(self.longPoll.bind(self));
    }
};

BOSHConnection.prototype.longPoll = function () {
    var canReceive = this.requests.length === 0;
    var canSend = this.sendQueue.length > 0 && this.requests.length < this.maxRequests;

    if (!this.sid || (!canReceive && !canSend)) {
        return;
    }

    var stanzas = this.sendQueue;
    this.sendQueue = [];
    this.rid++;

    this.request(new this.stanzas.BOSH({
        payload: stanzas
    }));
};

BOSHConnection.prototype.request = function (bosh) {
    var self = this;

    var ticket = {id: self.rid, request: null};
    bosh.rid = self.rid;
    bosh.sid = self.sid;

    var body = new Buffer(bosh.toString(), 'utf8').toString();

    self.emit('raw:outgoing', body);

    self.requests.push(ticket);

    var req = retryRequest({
        uri: self.url,
        body: body,
        method: 'POST',
        strictSSL: true
    }, self.config.wait * 1.5, this.config.maxRetries);

    ticket.request = req;

    return req.then(function (body) {
        self.emit('raw:incoming', new Buffer(body, 'utf8').toString());
    }).catch(ConnectionError, function (err) {
        self.hasStream = false;
        var serr = new self.stanzas.StreamError({
            condition: 'connection-timeout'
        });
        console.error(err.stack);
        self.emit('stream:error', serr, err);
        self.disconnect();
    }).catch(BPromise.CancellationError, function () {
        return; // We only cancel on manual disconnect, so let things die silently
    }).finally(function () {
        self.requests = _.filter(self.requests, function (item) {
            return item.id !== ticket.id;
        });
        if (bosh.type !== 'terminate') {
            // Delay next auto-request by two ticks since we're likely
            // to send data anyway next tick.
            process.nextTick(function () {
                process.nextTick(self.longPoll.bind(self));
            });
        }
    });
};

module.exports = BOSHConnection;

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":22,"bluebird":1464,"buffer":9,"request":1465,"underscore":1602,"util":43,"wildemitter":1603}],1446:[function(require,module,exports){
'use strict';

var WSConnection = require('./websocket');
var _ = require('underscore');
var util = require('util');



function OldWSConnection(sm, stanzas) {
    WSConnection.call(this, sm, stanzas);

    var self = this;


    function wrap(data) {
        return [self.streamStart, data, self.streamEnd].join('');
    }


    self.on('connected', function () {
        self.streamStart = '<stream:stream xmlns:stream="http://etherx.jabber.org/streams">';
        self.streamEnd = '</stream:stream>';
    });

    self.off('raw:incoming');
    self.on('raw:incoming', function (data) {
        var streamData, ended, err;

        data = data.trim();
        data = data.replace(/^(\s*<\?.*\?>\s*)*/, '');
        if (data === '') {
            return;
        }

        if (data.match(self.streamEnd)) {
            return self.disconnect();
        } else if (self.hasStream) {
            try {
                streamData = stanzas.parse(wrap(data));
            } catch (e) {
                err = new this.stanzas.StreamError({
                    condition: 'invalid-xml'
                });
                self.emit('stream:error', err, e);
                self.send(err);
                return self.disconnect();
            }
        } else {
            // Inspect start of stream element to get NS prefix name
            var parts = data.match(/^<(\S+:)?(\S+) /);
            self.streamStart = data;
            self.streamEnd = '</' + (parts[1] || '') + parts[2] + '>';

            ended = false;
            try {
                streamData = stanzas.parse(data + self.streamEnd);
            } catch (e) {
                try {
                    streamData = stanzas.parse(data);
                    ended = true;
                } catch (e2) {
                    err = new this.stanzas.StreamError({
                        condition: 'invalid-xml'
                    });
                    self.emit('stream:error', err, e2);
                    self.send(err);
                    return self.disconnect();
                }
            }

            self.hasStream = true;
            self.stream = streamData;
            self.emit('stream:start', streamData);
        }

        _.each(streamData._extensions, function (stanzaObj) {
            if (!stanzaObj.lang && self.stream) {
                stanzaObj.lang = self.stream.lang;
            }

            self.emit('stream:data', stanzaObj);
        });

        if (ended) {
            self.emit('stream:end');
        }
    });
}

util.inherits(OldWSConnection, WSConnection);


OldWSConnection.prototype.startHeader = function () {
    return [
        '<stream:stream',
        'xmlns:stream="http://etherx.jabber.org/streams"',
        'xmlns="jabber:client"',
        'version="' + (this.config.version || '1.0') + '"',
        'xml:lang="' + (this.config.lang || 'en') + '"',
        'to="' + this.config.server + '">'
    ].join(' ');
};

OldWSConnection.prototype.closeHeader = function () {
    return '</stream:stream>';
};


module.exports = OldWSConnection;

},{"./websocket":1447,"underscore":1602,"util":43}],1447:[function(require,module,exports){
(function (Buffer){
'use strict';

var util = require('util');
var WildEmitter = require('wildemitter');
var async = require('async');

var WS = (require('faye-websocket') && require('faye-websocket').Client) ?
                                       require('faye-websocket').Client :
                                       window.WebSocket;

var WS_OPEN = 1;



function WSConnection(sm, stanzas) {
    var self = this;

    WildEmitter.call(this);

    self.sm = sm;
    self.closing = false;

    self.stanzas = {
        Open: stanzas.getDefinition('open', 'urn:ietf:params:xml:ns:xmpp-framing', true),
        Close: stanzas.getDefinition('close', 'urn:ietf:params:xml:ns:xmpp-framing', true),
        StreamError: stanzas.getStreamError()
    };

    self.sendQueue = async.queue(function (data, cb) {
        if (self.conn) {
            if (typeof data !== 'string') {
                data = data.toString();
            }

            data = new Buffer(data, 'utf8').toString();

            self.emit('raw:outgoing', data);
            if (self.conn.readyState === WS_OPEN) {
                self.conn.send(data);
            }
        }
        cb();
    }, 1);

    self.on('connected', function () {
        self.send(self.startHeader());
    });

    self.on('raw:incoming', function (data) {
        var stanzaObj, err;

        data = data.trim();
        if (data === '') {
            return;
        }

        try {
            stanzaObj = stanzas.parse(data);
        } catch (e) {
            err = new this.stanzas.StreamError({
                condition: 'invalid-xml'
            });
            self.emit('stream:error', err, e);
            self.send(err);
            return self.disconnect();
        }

        if (stanzaObj._name === 'openStream') {
            self.hasStream = true;
            self.stream = stanzaObj;
            return self.emit('stream:start', stanzaObj.toJSON());
        }
        if (stanzaObj._name === 'closeStream') {
            self.emit('stream:end');
            return self.disconnect();
        }

        if (!stanzaObj.lang && self.stream) {
            stanzaObj.lang = self.stream.lang;
        }

        self.emit('stream:data', stanzaObj);
    });
}

util.inherits(WSConnection, WildEmitter);

WSConnection.prototype.connect = function (opts) {
    var self = this;

    self.config = opts;

    self.hasStream = false;
    self.closing = false;

    self.conn = new WS(opts.wsURL, 'xmpp');
    self.conn.onerror = function (e) {
        e.preventDefault();
        self.emit('disconnected', self);
    };

    self.conn.onclose = function () {
        self.emit('disconnected', self);
    };

    self.conn.onopen = function () {
        self.sm.started = false;
        self.emit('connected', self);
    };

    self.conn.onmessage = function (wsMsg) {
        self.emit('raw:incoming', new Buffer(wsMsg.data, 'utf8').toString());
    };
};

WSConnection.prototype.startHeader = function () {
    return new this.stanzas.Open({
        version: this.config.version || '1.0',
        lang: this.config.lang || 'en',
        to: this.config.server
    });
};

WSConnection.prototype.closeHeader = function () {
    return new this.stanzas.Close();
};

WSConnection.prototype.disconnect = function () {
    if (this.conn && !this.closing) {
        this.closing = true;
        this.send(this.closeHeader());
    } else {
        this.hasStream = false;
        this.stream = undefined;
        if (this.conn.readyState === WS_OPEN) {
            this.conn.close();
        }
        this.conn = undefined;
    }
};

WSConnection.prototype.restart = function () {
    var self = this;
    self.hasStream = false;
    self.send(this.startHeader());
};

WSConnection.prototype.send = function (data) {
    this.sendQueue.push(data);
};


module.exports = WSConnection;

}).call(this,require("buffer").Buffer)
},{"async":1463,"buffer":9,"faye-websocket":8,"util":43,"wildemitter":1603}],1448:[function(require,module,exports){
var randomBytes = require('randombytes');
var createHash = require('create-hash');


function parse(chal) {
    var dtives = {};
    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
    for (var i = 0, len = tokens.length; i < len; i++) {
        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
        if (dtiv) {
            dtives[dtiv[1]] = dtiv[2];
        }
    }
    return dtives;
}

function genNonce() {
    return randomBytes(16).toString('hex');
}



function Mechanism(options) {
    options = options || {};
    this._genNonce = options.genNonce || genNonce;
}

// Conform to the SASL lib's expectations
Mechanism.Mechanism = Mechanism;


Mechanism.prototype.name = 'DIGEST-MD5';
Mechanism.prototype.clientFirst = false;


Mechanism.prototype.response = function(cred) {
    if (this._completed) {
        return undefined;
    }

    var uri = cred.serviceType + '/' + cred.host;

    if (cred.serviceName && cred.host !== cred.serviceName) {
        uri += '/' + cred.serviceName;
    }

    var realm = cred.realm || this._realm || '';
    var cnonce = this._genNonce();
    var nc = '00000001';
    var qop = 'auth';

    var str = '';
    str += 'username="' + cred.username + '"';
    if (realm) {
        str += ',realm="' + realm + '"';
    }
    str += ',nonce="' + this._nonce + '"';
    str += ',cnonce="' + cnonce + '"';
    str += ',nc=' + nc;
    str += ',qop=' + qop;
    str += ',digest-uri="' + uri + '"';
  
    var base = createHash('md5').update(cred.username)
                                .update(':')
                                .update(realm)
                                .update(':')
                                .update(cred.password)
                                .digest();

    var ha1 = createHash('md5').update(base)
                               .update(':')
                               .update(this._nonce)
                               .update(':')
                               .update(cnonce);


    if (cred.authzid) {
        ha1.update(':').update(cred.authzid);
    }

    ha1 = ha1.digest('hex');
  
    var ha2 = createHash('md5').update('AUTHENTICATE:')
                               .update(uri);
    
    if (qop === 'auth-int' || qop === 'auth-conf') {
        ha2.update(':00000000000000000000000000000000');
    }

    ha2 = ha2.digest('hex');
  
    var digest = createHash('md5').update(ha1)
                                  .update(':')
                                  .update(this._nonce)
                                  .update(':')
                                  .update(nc)
                                  .update(':')
                                  .update(cnonce)
                                  .update(':')
                                  .update(qop)
                                  .update(':')
                                  .update(ha2)
                                  .digest('hex');

    str += ',response=' + digest;
  
    if (this._charset === 'utf-8') {
        str += ',charset=utf-8';
    }
    if (cred.authzid) {
        str += 'authzid="' + cred.authzid + '"';
    }
  
    return str;
};

Mechanism.prototype.challenge = function(chal) {
    var dtives = parse(chal);

    this._completed = !!dtives.rspauth;

    this._realm = dtives.realm;
    this._nonce = dtives.nonce;
    this._qop = (dtives.qop || 'auth').split(',');
    this._stale = dtives.stale;
    this._maxbuf = parseInt(dtives.maxbuf) || 65536;
    this._charset = dtives.charset;
    this._algo = dtives.algorithm;
    this._cipher = dtives.cipher;
    if (this._cipher) {
        this._cipher.split(',');
    }

    return this;
};



module.exports = Mechanism;

},{"create-hash":1449,"randombytes":1462}],1449:[function(require,module,exports){
(function (Buffer){
'use strict';
var inherits = require('inherits')
var md5 = require('./md5')
var rmd160 = require('ripemd160')
var sha = require('sha.js')

var Transform = require('stream').Transform

function HashNoConstructor(hash) {
  Transform.call(this)

  this._hash = hash
  this.buffers = []
}

inherits(HashNoConstructor, Transform)

HashNoConstructor.prototype._transform = function (data, _, next) {
  this.buffers.push(data)

  next()
}

HashNoConstructor.prototype._flush = function (next) {
  this.push(this.digest())
  next()
}

HashNoConstructor.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this.buffers.push(data)
  return this
}

HashNoConstructor.prototype.digest = function (enc) {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null

  return enc ? r.toString(enc) : r
}

function Hash(hash) {
  Transform.call(this)

  this._hash = hash
}

inherits(Hash, Transform)

Hash.prototype._transform = function (data, enc, next) {
  if (enc) data = new Buffer(data, enc)

  this._hash.update(data)

  next()
}

Hash.prototype._flush = function (next) {
  this.push(this._hash.digest())
  this._hash = null

  next()
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    data = new Buffer(data, enc)
  }

  this._hash.update(data)
  return this
}

Hash.prototype.digest = function (enc) {
  var outData = this._hash.digest()

  return enc ? outData.toString(enc) : outData
}

module.exports = function createHash (alg) {
  if ('md5' === alg) return new HashNoConstructor(md5)
  if ('rmd160' === alg) return new HashNoConstructor(rmd160)

  return new Hash(sha(alg))
}

}).call(this,require("buffer").Buffer)
},{"./md5":1451,"buffer":9,"inherits":1452,"ripemd160":1453,"sha.js":1455,"stream":39}],1450:[function(require,module,exports){
(function (Buffer){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("buffer").Buffer)
},{"buffer":9}],1451:[function(require,module,exports){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
},{"./helpers":1450}],1452:[function(require,module,exports){
module.exports=require(19)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/node_modules/inherits/inherits_browser.js":19}],1453:[function(require,module,exports){
(function (Buffer){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cédric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords (bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes (words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock (H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
      (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
      (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (i = 0; i < 80; i += 1) {
    t = (al + M[offset + zl[i]]) | 0
    if (i < 16) {
      t += f1(bl, cl, dl) + hl[0]
    } else if (i < 32) {
      t += f2(bl, cl, dl) + hl[1]
    } else if (i < 48) {
      t += f3(bl, cl, dl) + hl[2]
    } else if (i < 64) {
      t += f4(bl, cl, dl) + hl[3]
    } else {// if (i<80) {
      t += f5(bl, cl, dl) + hl[4]
    }
    t = t | 0
    t = rotl(t, sl[i])
    t = (t + el) | 0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset + zr[i]]) | 0
    if (i < 16) {
      t += f5(br, cr, dr) + hr[0]
    } else if (i < 32) {
      t += f4(br, cr, dr) + hr[1]
    } else if (i < 48) {
      t += f3(br, cr, dr) + hr[2]
    } else if (i < 64) {
      t += f2(br, cr, dr) + hr[3]
    } else {// if (i<80) {
      t += f1(br, cr, dr) + hr[4]
    }

    t = t | 0
    t = rotl(t, sr[i])
    t = (t + er) | 0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t = (H[1] + cl + dr) | 0
  H[1] = (H[2] + dl + er) | 0
  H[2] = (H[3] + el + ar) | 0
  H[3] = (H[4] + al + br) | 0
  H[4] = (H[0] + bl + cr) | 0
  H[0] = t
}

function f1 (x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2 (x, y, z) {
  return (((x) & (y)) | ((~x) & (z)))
}

function f3 (x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4 (x, y, z) {
  return (((x) & (z)) | ((y) & (~(z))))
}

function f5 (x, y, z) {
  return ((x) ^ ((y) | (~(z))))
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function ripemd160 (message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message === 'string') {
    message = new Buffer(message, 'utf8')
  }

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
    (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
  )

  for (var i = 0; i < m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (i = 0; i < 5; i++) {
    // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
      (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("buffer").Buffer)
},{"buffer":9}],1454:[function(require,module,exports){
(function (Buffer){
// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("buffer").Buffer)
},{"buffer":9}],1455:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":1456,"./sha1":1457,"./sha224":1458,"./sha256":1459,"./sha384":1460,"./sha512":1461}],1456:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0, k

  /*
   * SHA-1 has a bitwise rotate left operation. But, SHA is not
   * function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
   */
  function calcW () { return W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16] }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha


}).call(this,require("buffer").Buffer)
},{"./hash":1454,"buffer":9,"inherits":1452}],1457:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301 | 0
  this._b = 0xefcdab89 | 0
  this._c = 0x98badcfe | 0
  this._d = 0x10325476 | 0
  this._e = 0xc3d2e1f0 | 0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol (num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt))
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0, k

  function calcW () { return rol(W[j - 3] ^ W[j - 8] ^ W[j - 14] ^ W[j - 16], 1) }
  function loop (w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

}).call(this,require("buffer").Buffer)
},{"./hash":1454,"buffer":9,"inherits":1452}],1458:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8 | 0
  this._b = 0x367cd507 | 0
  this._c = 0x3070dd17 | 0
  this._d = 0xf70e5939 | 0
  this._e = 0xffc00b31 | 0
  this._f = 0x68581511 | 0
  this._g = 0x64f98fa7 | 0
  this._h = 0xbefa4fa4 | 0

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("buffer").Buffer)
},{"./hash":1454,"./sha256":1459,"buffer":9,"inherits":1452}],1459:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  return this
}

function S (X, n) {
  return (X >>> n) | (X << (32 - n))
}

function R (X, n) {
  return (X >>> n)
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z))
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z))
}

function Sigma0256 (x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22))
}

function Sigma1256 (x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25))
}

function Gamma0256 (x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3))
}

function Gamma1256 (x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10))
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var j = 0

  function calcW () { return Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16] }
  function loop (w) {
    W[j] = w

    var T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
    var T2 = Sigma0256(a) + Maj(a, b, c)

    h = g
    g = f
    f = e
    e = d + T1
    d = c
    c = b
    b = a
    a = T1 + T2

    j++
  }

  while (j < 16) loop(M.readInt32BE(j * 4))
  while (j < 64) loop(calcW())

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("buffer").Buffer)
},{"./hash":1454,"buffer":9,"inherits":1452}],1460:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._a = 0xcbbb9d5d | 0
  this._b = 0x629a292a | 0
  this._c = 0x9159015a | 0
  this._d = 0x152fecd8 | 0
  this._e = 0x67332667 | 0
  this._f = 0x8eb44a87 | 0
  this._g = 0xdb0c2e0d | 0
  this._h = 0x47b5481d | 0

  this._al = 0xc1059ed8 | 0
  this._bl = 0x367cd507 | 0
  this._cl = 0x3070dd17 | 0
  this._dl = 0xf70e5939 | 0
  this._el = 0xffc00b31 | 0
  this._fl = 0x68581511 | 0
  this._gl = 0x64f98fa7 | 0
  this._hl = 0xbefa4fa4 | 0

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("buffer").Buffer)
},{"./hash":1454,"./sha512":1461,"buffer":9,"inherits":1452}],1461:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._a = 0x6a09e667 | 0
  this._b = 0xbb67ae85 | 0
  this._c = 0x3c6ef372 | 0
  this._d = 0xa54ff53a | 0
  this._e = 0x510e527f | 0
  this._f = 0x9b05688c | 0
  this._g = 0x1f83d9ab | 0
  this._h = 0x5be0cd19 | 0

  this._al = 0xf3bcc908 | 0
  this._bl = 0x84caa73b | 0
  this._cl = 0xfe94f82b | 0
  this._dl = 0x5f1d36f1 | 0
  this._el = 0xade682d1 | 0
  this._fl = 0x2b3e6c1f | 0
  this._gl = 0xfb41bd6b | 0
  this._hl = 0x137e2179 | 0

  return this
}

function S (X, Xl, n) {
  return (X >>> n) | (Xl << (32 - n))
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z))
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z))
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  var i = 0, j = 0
  var Wi, Wil
  function calcW () {
    var x = W[j - 15 * 2]
    var xl = W[j - 15 * 2 + 1]
    var gamma0 = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
    var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

    x = W[j - 2 * 2]
    xl = W[j - 2 * 2 + 1]
    var gamma1 = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
    var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7 = W[j - 7 * 2]
    var Wi7l = W[j - 7 * 2 + 1]

    var Wi16 = W[j - 16 * 2]
    var Wi16l = W[j - 16 * 2 + 1]

    Wil = gamma0l + Wi7l
    Wi = gamma0 + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
    Wil = Wil + gamma1l
    Wi = Wi + gamma1 + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
    Wil = Wil + Wi16l
    Wi = Wi + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
  }

  function loop () {
    W[j] = Wi
    W[j + 1] = Wil

    var maj = Maj(a, b, c)
    var majl = Maj(al, bl, cl)

    var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
    var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
    var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
    var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

    // t1 = h + sigma1 + ch + K[i] + W[i]
    var Ki = K[j]
    var Kil = K[j + 1]

    var ch = Ch(e, f, g)
    var chl = Ch(el, fl, gl)

    var t1l = hl + sigma1l
    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
    t1l = t1l + chl
    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
    t1l = t1l + Kil
    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
    t1l = t1l + Wil
    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl
    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

    h = g
    hl = gl
    g = f
    gl = fl
    f = e
    fl = el
    el = (dl + t1l) | 0
    e = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
    d = c
    dl = cl
    c = b
    cl = bl
    b = a
    bl = al
    al = (t1l + t2l) | 0
    a = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0

    i++
    j += 2
  }

  while (i < 16) {
    Wi = M.readInt32BE(j * 4)
    Wil = M.readInt32BE(j * 4 + 4)

    loop()
  }

  while (i < 80) {
    calcW()
    loop()
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)
  writeInt64BE(this._g, this._gl, 48)
  writeInt64BE(this._h, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("buffer").Buffer)
},{"./hash":1454,"buffer":9,"inherits":1452}],1462:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var crypto = global.crypto || global.msCrypto
if(crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}
function oldBrowser() {
  throw new Error(
      'secure random number generation not supported by this browser\n'+
      'use chrome, FireFox or Internet Explorer 11'
    )
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"_process":22,"buffer":9}],1463:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        };

        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":22}],1464:[function(require,module,exports){
(function (process,global){
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 2.9.34
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, cancel, using, filter, any, each, timers
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule.js");
var Queue = _dereq_("./queue.js");
var util = _dereq_("./util.js");

function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    this._trampolineEnabled = true;
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule =
        schedule.isStatic ? schedule(this.drainQueues) : schedule;
}

Async.prototype.disableTrampolineIfNecessary = function() {
    if (util.hasDevTools) {
        this._trampolineEnabled = false;
    }
};

Async.prototype.enableTrampoline = function() {
    if (!this._trampolineEnabled) {
        this._trampolineEnabled = true;
        this._schedule = function(fn) {
            setTimeout(fn, 0);
        };
    }
};

Async.prototype.haveItemsQueued = function () {
    return this._normalQueue.length() > 0;
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    }
};

function AsyncInvokeLater(fn, receiver, arg) {
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncInvoke(fn, receiver, arg) {
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
}

function AsyncSettlePromises(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
}

if (!util.hasDevTools) {
    Async.prototype.invokeLater = AsyncInvokeLater;
    Async.prototype.invoke = AsyncInvoke;
    Async.prototype.settlePromises = AsyncSettlePromises;
} else {
    if (schedule.isStatic) {
        schedule = function(fn) { setTimeout(fn, 0); };
    }
    Async.prototype.invokeLater = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                setTimeout(function() {
                    fn.call(receiver, arg);
                }, 100);
            });
        }
    };

    Async.prototype.invoke = function (fn, receiver, arg) {
        if (this._trampolineEnabled) {
            AsyncInvoke.call(this, fn, receiver, arg);
        } else {
            this._schedule(function() {
                fn.call(receiver, arg);
            });
        }
    };

    Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
            AsyncSettlePromises.call(this, promise);
        } else {
            this._schedule(function() {
                promise._settlePromises();
            });
        }
    };
}

Async.prototype.invokeFirst = function (fn, receiver, arg) {
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
};

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = new Async();
module.exports.firstLineError = firstLineError;

},{"./queue.js":28,"./schedule.js":31,"./util.js":38}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
var rejectThis = function(_, e) {
    this._reject(e);
};

var targetRejected = function(e, context) {
    context.promiseRejectionQueued = true;
    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
};

var bindingResolved = function(thisArg, context) {
    if (this._isPending()) {
        this._resolveCallback(context.target);
    }
};

var bindingRejected = function(e, context) {
    if (!context.promiseRejectionQueued) this._reject(e);
};

Promise.prototype.bind = function (thisArg) {
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);
    ret._propagateFrom(this, 1);
    var target = this._target();

    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        var context = {
            promiseRejectionQueued: false,
            promise: ret,
            target: target,
            bindingPromise: maybePromise
        };
        target._then(INTERNAL, targetRejected, ret._progress, ret, context);
        maybePromise._then(
            bindingResolved, bindingRejected, ret._progress, ret, context);
    } else {
        ret._resolveCallback(target);
    }
    return ret;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj !== undefined) {
        this._bitField = this._bitField | 131072;
        this._boundTo = obj;
    } else {
        this._bitField = this._bitField & (~131072);
    }
};

Promise.prototype._isBound = function () {
    return (this._bitField & 131072) === 131072;
};

Promise.bind = function (thisArg, value) {
    var maybePromise = tryConvertToPromise(thisArg);
    var ret = new Promise(INTERNAL);

    ret._setBoundTo(maybePromise);
    if (maybePromise instanceof Promise) {
        maybePromise._then(function() {
            ret._resolveCallback(value);
        }, ret._reject, ret._progress, ret, null);
    } else {
        ret._resolveCallback(value);
    }
    return ret;
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise.js")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise.js":23}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util.js":38}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var errors = _dereq_("./errors.js");
var async = _dereq_("./async.js");
var CancellationError = errors.CancellationError;

Promise.prototype._cancel = function (reason) {
    if (!this.isCancellable()) return this;
    var parent;
    var promiseToReject = this;
    while ((parent = promiseToReject._cancellationParent) !== undefined &&
        parent.isCancellable()) {
        promiseToReject = parent;
    }
    this._unsetCancellable();
    promiseToReject._target()._rejectCallback(reason, false, true);
};

Promise.prototype.cancel = function (reason) {
    if (!this.isCancellable()) return this;
    if (reason === undefined) reason = new CancellationError();
    async.invokeLater(this._cancel, this, reason);
    return this;
};

Promise.prototype.cancellable = function () {
    if (this._cancellable()) return this;
    async.enableTrampoline();
    this._setCancellable();
    this._cancellationParent = undefined;
    return this;
};

Promise.prototype.uncancellable = function () {
    var ret = this.then();
    ret._unsetCancellable();
    return ret;
};

Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
    var ret = this._then(didFulfill, didReject, didProgress,
                         undefined, undefined);

    ret._setCancellable();
    ret._cancellationParent = undefined;
    return ret;
};
};

},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var warn;

function CapturedTrace(parent) {
    this._parent = parent;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.parent = function() {
    return this._parent;
};

CapturedTrace.prototype.hasParent = function() {
    return this._parent !== undefined;
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = CapturedTrace.parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
    util.notEnumerableProp(error, "__stackCleaned__", true);
};

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) ||
            "    (No stack trace)" === line;
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0) {
        stack = stack.slice(i);
    }
    return stack;
}

CapturedTrace.parseStackAndMessage = function(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: cleanStack(stack)
    };
};

CapturedTrace.formatAndLogError = function(error, title) {
    if (typeof console !== "undefined") {
        var message;
        if (typeof error === "object" || typeof error === "function") {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof warn === "function") {
            warn(message);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
};

CapturedTrace.unhandledRejection = function (reason) {
    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
};

CapturedTrace.isSupported = function () {
    return typeof captureStackTrace === "function";
};

CapturedTrace.fireRejectionEvent =
function(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
    } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
    }

    var domEventFired = false;
    if (fireDomEvent) {
        try {
            domEventFired = fireDomEvent(name.toLowerCase(), {
                reason: reason,
                promise: promise
            });
        } catch (e) {
            domEventFired = true;
            async.throwLater(e);
        }
    }

    if (!globalEventFired && !localEventFired && !domEventFired &&
        name === "unhandledRejection") {
        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
    }
};

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}
CapturedTrace.setBounds = function(firstLineError, lastLineError) {
    if (!CapturedTrace.isSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit = Error.stackTraceLimit + 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow &&
        typeof Error.stackTraceLimit === "number") {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

var fireDomEvent;
var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function(name, reason, promise) {
            if (name === "rejectionHandled") {
                return process.emit(name, promise);
            } else {
                return process.emit(name, reason, promise);
            }
        };
    } else {
        var customEventWorks = false;
        var anyEventWorks = true;
        try {
            var ev = new self.CustomEvent("test");
            customEventWorks = ev instanceof CustomEvent;
        } catch (e) {}
        if (!customEventWorks) {
            try {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                self.dispatchEvent(event);
            } catch (e) {
                anyEventWorks = false;
            }
        }
        if (anyEventWorks) {
            fireDomEvent = function(type, detail) {
                var event;
                if (customEventWorks) {
                    event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                    });
                } else if (self.dispatchEvent) {
                    event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, false, true, detail);
                }

                return event ? !self.dispatchEvent(event) : false;
            };
        }

        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) {
            var methodName = toWindowMethodNameMap[name];
            var method = self[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") {
                method.call(self, promise);
            } else {
                method.call(self, reason, promise);
            }
            return true;
        };
    }
})();

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    warn = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        warn = function(message) {
            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        warn = function(message) {
            console.warn("%c" + message, "color: red");
        };
    }
}

return CapturedTrace;
};

},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util.js");
var errors = _dereq_("./errors.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var keys = _dereq_("./es5.js").keys;
var TypeError = errors.TypeError;

function CatchFilter(instances, callback, promise) {
    this._instances = instances;
    this._callback = callback;
    this._promise = promise;
}

function safePredicate(predicate, e) {
    var safeObject = {};
    var retfilter = tryCatch(predicate).call(safeObject, e);

    if (retfilter === errorObj) return retfilter;

    var safeKeys = keys(safeObject);
    if (safeKeys.length) {
        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
        return errorObj;
    }
    return retfilter;
}

CatchFilter.prototype.doFilter = function (e) {
    var cb = this._callback;
    var promise = this._promise;
    var boundTo = promise._boundValue();
    for (var i = 0, len = this._instances.length; i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error ||
            (item != null && item.prototype instanceof Error);

        if (itemIsErrorType && e instanceof item) {
            var ret = tryCatch(cb).call(boundTo, e);
            if (ret === errorObj) {
                NEXT_FILTER.e = ret.e;
                return NEXT_FILTER;
            }
            return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
            var shouldHandle = safePredicate(item, e);
            if (shouldHandle === errorObj) {
                e = errorObj.e;
                break;
            } else if (shouldHandle) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            }
        }
    }
    NEXT_FILTER.e = e;
    return NEXT_FILTER;
};

return CatchFilter;
};

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace, isDebugging) {
var contextStack = [];
function Context() {
    this._trace = new CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.pop();
    }
};

function createContext() {
    if (isDebugging()) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}

Promise.prototype._peekContext = peekContext;
Promise.prototype._pushContext = Context.prototype._pushContext;
Promise.prototype._popContext = Context.prototype._popContext;

return createContext;
};

},{}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var Warning = _dereq_("./errors.js").Warning;
var util = _dereq_("./util.js");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var debugging = false || (util.isNode &&
                    (!!process.env["BLUEBIRD_DEBUG"] ||
                     process.env["NODE_ENV"] === "development"));

if (debugging) {
    async.disableTrampolineIfNecessary();
}

Promise.prototype._ignoreRejections = function() {
    this._unsetRejectionIsUnhandled();
    this._bitField = this._bitField | 16777216;
};

Promise.prototype._ensurePossibleRejectionHandled = function () {
    if ((this._bitField & 16777216) !== 0) return;
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    CapturedTrace.fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 524288;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~524288);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 524288) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 2097152;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 2097152) > 0;
};

Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
};

Promise.prototype._isCarryingStackTrace = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._getCarriedStackTrace = function () {
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : undefined;
};

Promise.prototype._captureStackTrace = function () {
    if (debugging) {
        this._trace = new CapturedTrace(this._peekContext());
    }
    return this;
};

Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
    if (debugging && canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = CapturedTrace.parseStackAndMessage(error);
            util.notEnumerableProp(error, "stack",
                parsed.message + "\n" + parsed.stack.join("\n"));
            util.notEnumerableProp(error, "__stackCleaned__", true);
        }
    }
};

Promise.prototype._warn = function(message) {
    var warning = new Warning(message);
    var ctx = this._peekContext();
    if (ctx) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = CapturedTrace.parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }
    CapturedTrace.formatAndLogError(warning, "");
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    var domain = getDomain();
    possiblyUnhandledRejection =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    var domain = getDomain();
    unhandledRejectionHandled =
        typeof fn === "function" ? (domain === null ? fn : domain.bind(fn))
                                 : undefined;
};

Promise.longStackTraces = function () {
    if (async.haveItemsQueued() &&
        debugging === false
   ) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
    }
    debugging = CapturedTrace.isSupported();
    if (debugging) {
        async.disableTrampolineIfNecessary();
    }
};

Promise.hasLongStackTraces = function () {
    return debugging && CapturedTrace.isSupported();
};

if (!CapturedTrace.isSupported()) {
    Promise.longStackTraces = function(){};
    debugging = false;
}

return function() {
    return debugging;
};
};

},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;

module.exports = function(Promise) {
var returner = function () {
    return this;
};
var thrower = function () {
    throw this;
};
var returnUndefined = function() {};
var throwUndefined = function() {
    throw undefined;
};

var wrapper = function (value, action) {
    if (action === 1) {
        return function () {
            throw value;
        };
    } else if (action === 2) {
        return function () {
            return value;
        };
    }
};


Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (value === undefined) return this.then(returnUndefined);

    if (isPrimitive(value)) {
        return this._then(
            wrapper(value, 2),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(returner, undefined, undefined, value, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    if (reason === undefined) return this.then(throwUndefined);

    if (isPrimitive(reason)) {
        return this._then(
            wrapper(reason, 1),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(thrower, undefined, undefined, reason, undefined);
};
};

},{"./util.js":38}],12:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, null, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, null, INTERNAL);
};
};

},{}],13:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util.js");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;
var thrower = util.thrower;

function returnThis() {
    return this;
}
function throwThis() {
    throw this;
}
function return$(r) {
    return function() {
        return r;
    };
}
function throw$(r) {
    return function() {
        throw r;
    };
}
function promisedFinally(ret, reasonOrValue, isFulfilled) {
    var then;
    if (isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
    } else {
        then = isFulfilled ? returnThis : throwThis;
    }
    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
}

function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundValue())
                    : handler();

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, reasonOrValue,
                                    promise.isFulfilled());
        }
    }

    if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
    } else {
        return reasonOrValue;
    }
}

function tapHandler(value) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundValue(), value)
                    : handler(value);

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, value, true);
        }
    }
    return value;
}

Promise.prototype._passThroughHandler = function (handler, isFinally) {
    if (typeof handler !== "function") return this.then();

    var promiseAndHandler = {
        promise: this,
        handler: handler
    };

    return this._then(
            isFinally ? finallyHandler : tapHandler,
            isFinally ? finallyHandler : undefined, undefined,
            promiseAndHandler, undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThroughHandler(handler, true);
};

Promise.prototype.tap = function (handler) {
    return this._passThroughHandler(handler, false);
};
};

},{"./util.js":38}],17:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise) {
var errors = _dereq_("./errors.js");
var TypeError = errors.TypeError;
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    var promise = this._promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
}

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._next(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    if (result === errorObj) {
        return this._promise._rejectCallback(result.e, false, true);
    }

    var value = result.value;
    if (result.done === true) {
        this._promise._resolveCallback(value);
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._throw(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise._then(
            this._next,
            this._throw,
            undefined,
            this,
            null
       );
    }
};

PromiseSpawn.prototype._throw = function (reason) {
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._next = function (value) {
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        spawn._generator = generator;
        spawn._next(undefined);
        return spawn.promise();
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var caller = function(count) {
        var values = [];
        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
        return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
    };
    var thenCallbacks = [];
    var callers = [undefined];
    for (var i = 1; i <= 5; ++i) {
        thenCallbacks.push(thenCallback(i));
        callers.push(caller(i));
    }

    var Holder = function(total, fn) {
        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
        this.fn = fn;
        this.total = total;
        this.now = 0;
    };

    Holder.prototype.callers = callers;
    Holder.prototype.checkFulfillment = function(promise) {
        var now = this.now;
        now++;
        var total = this.total;
        if (now >= total) {
            var handler = this.callers[total];
            promise._pushContext();
            var ret = tryCatch(handler)(this);
            promise._popContext();
            if (ret === errorObj) {
                promise._rejectCallback(ret.e, false, true);
            } else {
                promise._resolveCallback(ret);
            }
        } else {
            this.now = now;
        }
    };

    var reject = function (reason) {
        this._reject(reason);
    };
}
}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last < 6 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var holder = new Holder(last, fn);
                var callbacks = thenCallbacks;
                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        if (maybePromise._isPending()) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                        } else if (maybePromise._isFulfilled()) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else {
                            ret._reject(maybePromise._reason());
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }
                return ret;
            }
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util.js":38}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var PENDING = {};
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    async.invoke(init, this, undefined);
}
util.inherits(MappingPromiseArray, PromiseArray);
function init() {this._init$(undefined, -2);}

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundValue();
        this._promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }

    }
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
}

Promise.prototype.map = function (fn, options) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

    return map(this, fn, options, null).promise();
};

Promise.map = function (promises, fn, options, _filter) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    return map(promises, fn, options, _filter).promise();
};


};

},{"./async.js":2,"./util.js":38}],20:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn, args, ctx) {
    if (typeof fn !== "function") {
        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value = util.isArray(args)
        ? tryCatch(fn).apply(ctx, args)
        : tryCatch(fn).call(ctx, args);
    ret._popContext();
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false, true);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util.js":38}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret =
        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundValue();
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var target = promise._target();
        var newReason = target._getCarriedStackTrace();
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.asCallback =
Promise.prototype.nodeify = function (nodeback, options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

Promise.prototype.progressed = function (handler) {
    return this._then(undefined, undefined, handler, undefined, undefined);
};

Promise.prototype._progress = function (progressValue) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._target()._progressUnchecked(progressValue);

};

Promise.prototype._progressHandlerAt = function (index) {
    return index === 0
        ? this._progressHandler0
        : this[(index << 2) + index - 5 + 2];
};

Promise.prototype._doProgressWith = function (progression) {
    var progressValue = progression.value;
    var handler = progression.handler;
    var promise = progression.promise;
    var receiver = progression.receiver;

    var ret = tryCatch(handler).call(receiver, progressValue);
    if (ret === errorObj) {
        if (ret.e != null &&
            ret.e.name !== "StopProgressPropagation") {
            var trace = util.canAttachTrace(ret.e)
                ? ret.e : new Error(util.toString(ret.e));
            promise._attachExtraTrace(trace);
            promise._progress(ret.e);
        }
    } else if (ret instanceof Promise) {
        ret._then(promise._progress, null, null, promise, undefined);
    } else {
        promise._progress(ret);
    }
};


Promise.prototype._progressUnchecked = function (progressValue) {
    var len = this._length();
    var progress = this._progress;
    for (var i = 0; i < len; i++) {
        var handler = this._progressHandlerAt(i);
        var promise = this._promiseAt(i);
        if (!(promise instanceof Promise)) {
            var receiver = this._receiverAt(i);
            if (typeof handler === "function") {
                handler.call(receiver, progressValue, promise);
            } else if (receiver instanceof PromiseArray &&
                       !receiver._isResolved()) {
                receiver._promiseProgressed(progressValue, promise);
            }
            continue;
        }

        if (typeof handler === "function") {
            async.invoke(this._doProgressWith, this, {
                handler: handler,
                promise: promise,
                receiver: this._receiverAt(i),
                value: progressValue
            });
        } else {
            async.invoke(progress, promise, progressValue);
        }
    }
};
};

},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
};
var reflect = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};

var util = _dereq_("./util.js");

var getDomain;
if (util.isNode) {
    getDomain = function() {
        var ret = process.domain;
        if (ret === undefined) ret = null;
        return ret;
    };
} else {
    getDomain = function() {
        return null;
    };
}
util.notEnumerableProp(Promise, "_getDomain", getDomain);

var async = _dereq_("./async.js");
var errors = _dereq_("./errors.js");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {e: null};
var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array.js")(Promise, INTERNAL,
                                    tryConvertToPromise, apiRejection);
var CapturedTrace = _dereq_("./captured_trace.js")();
var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
 /*jshint unused:false*/
var createContext =
    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
var PromiseResolver = _dereq_("./promise_resolver.js");
var nodebackForPromise = PromiseResolver._nodebackForPromise;
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function Promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
    }
    if (this.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._progressHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settledValue = undefined;
    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (typeof item === "function") {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(
                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(undefined, catchFilter.doFilter, undefined,
            catchFilter, undefined);
    }
    return this._then(undefined, fn, undefined, undefined, undefined);
};

Promise.prototype.reflect = function () {
    return this._then(reflect, reflect, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject, didProgress) {
    if (isDebugging() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject, didProgress) {
    var promise = this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (didFulfill, didReject) {
    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
};

Promise.prototype.isCancellable = function () {
    return !this.isResolved() &&
        this._cancellable();
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = function(fn) {
    var ret = new Promise(INTERNAL);
    var result = tryCatch(fn)(nodebackForPromise(ret));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true, true);
    }
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.defer = Promise.pending = function () {
    var promise = new Promise(INTERNAL);
    return new PromiseResolver(promise);
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        var val = ret;
        ret = new Promise(INTERNAL);
        ret._fulfillUnchecked(val);
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var prev = async._schedule;
    async._schedule = fn;
    return prev;
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    didProgress,
    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

    if (!haveInternalData) {
        ret._propagateFrom(this, 4 | 1);
        ret._captureStackTrace();
    }

    var target = this._target();
    if (target !== this) {
        if (receiver === undefined) receiver = this._boundTo;
        if (!haveInternalData) ret._setIsMigrated();
    }

    var callbackIndex = target._addCallbacks(didFulfill,
                                             didReject,
                                             didProgress,
                                             ret,
                                             receiver,
                                             getDomain());

    if (target._isResolved() && !target._isSettlePromisesQueued()) {
        async.invoke(
            target._settlePromiseAtPostResolution, target, callbackIndex);
    }

    return ret;
};

Promise.prototype._settlePromiseAtPostResolution = function (index) {
    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
    this._settlePromiseAt(index);
};

Promise.prototype._length = function () {
    return this._bitField & 131071;
};

Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
    return (this._bitField & 939524096) > 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 536870912) === 536870912;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -131072) |
        (len & 131071);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 536870912;
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 33554432) > 0;
};

Promise.prototype._cancellable = function () {
    return (this._bitField & 67108864) > 0;
};

Promise.prototype._setCancellable = function () {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._unsetCancellable = function () {
    this._bitField = this._bitField & (~67108864);
};

Promise.prototype._setIsMigrated = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._unsetIsMigrated = function () {
    this._bitField = this._bitField & (~4194304);
};

Promise.prototype._isMigrated = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0
        ? this._receiver0
        : this[
            index * 5 - 5 + 4];
    if (ret === undefined && this._isBound()) {
        return this._boundValue();
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return index === 0
        ? this._promise0
        : this[index * 5 - 5 + 3];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return index === 0
        ? this._fulfillmentHandler0
        : this[index * 5 - 5 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return index === 0
        ? this._rejectionHandler0
        : this[index * 5 - 5 + 1];
};

Promise.prototype._boundValue = function() {
    var ret = this._boundTo;
    if (ret !== undefined) {
        if (ret instanceof Promise) {
            if (ret.isFulfilled()) {
                return ret.value();
            } else {
                return undefined;
            }
        }
    }
    return ret;
};

Promise.prototype._migrateCallbacks = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var progress = follower._progressHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (promise instanceof Promise) promise._setIsMigrated();
    this._addCallbacks(fulfill, reject, progress, promise, receiver, null);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    progress,
    promise,
    receiver,
    domain
) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        if (receiver !== undefined) this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this._rejectionHandler0 =
                domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
            this._progressHandler0 =
                domain === null ? progress : domain.bind(progress);
        }
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        if (typeof fulfill === "function") {
            this[base + 0] =
                domain === null ? fulfill : domain.bind(fulfill);
        }
        if (typeof reject === "function") {
            this[base + 1] =
                domain === null ? reject : domain.bind(reject);
        }
        if (typeof progress === "function") {
            this[base + 2] =
                domain === null ? progress : domain.bind(progress);
        }
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }
    if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
    }
    this._setLength(index + 1);
};

Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
    this._setProxyHandlers(promiseArray, index);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false, true);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    var propagationFlags = 1 | (shouldBind ? 4 : 0);
    this._propagateFrom(maybePromise, propagationFlags);
    var promise = maybePromise._target();
    if (promise._isPending()) {
        var len = this._length();
        for (var i = 0; i < len; ++i) {
            promise._migrateCallbacks(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (promise._isFulfilled()) {
        this._fulfillUnchecked(promise._value());
    } else {
        this._rejectUnchecked(promise._reason(),
            promise._getCarriedStackTrace());
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
    if (!shouldNotMarkOriginatingFromRejection) {
        util.markAsOriginatingFromRejection(reason);
    }
    var trace = util.ensureErrorObject(reason);
    var hasStack = trace === reason;
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason, hasStack ? undefined : trace);
};

Promise.prototype._resolveFromResolver = function (resolver) {
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = tryCatch(resolver)(function(value) {
        if (promise === null) return;
        promise._resolveCallback(value);
        promise = null;
    }, function (reason) {
        if (promise === null) return;
        promise._rejectCallback(reason, synchronous);
        promise = null;
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined && r === errorObj && promise !== null) {
        promise._rejectCallback(r.e, true, true);
        promise = null;
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    if (promise._isRejected()) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY && !this._isRejected()) {
        x = tryCatch(handler).apply(this._boundValue(), value);
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    promise._popContext();

    if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise ? makeSelfResolutionError() : x.e;
        promise._rejectCallback(err, false, true);
    } else {
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._cleanValues = function () {
    if (this._cancellable()) {
        this._cancellationParent = undefined;
    }
};

Promise.prototype._propagateFrom = function (parent, flags) {
    if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
    }
    if ((flags & 4) > 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
};

Promise.prototype._fulfill = function (value) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._fulfillUnchecked(value);
};

Promise.prototype._reject = function (reason, carriedStackTrace) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._rejectUnchecked(reason, carriedStackTrace);
};

Promise.prototype._settlePromiseAt = function (index) {
    var promise = this._promiseAt(index);
    var isPromise = promise instanceof Promise;

    if (isPromise && promise._isMigrated()) {
        promise._unsetIsMigrated();
        return async.invoke(this._settlePromiseAt, this, index);
    }
    var handler = this._isFulfilled()
        ? this._fulfillmentHandlerAt(index)
        : this._rejectionHandlerAt(index);

    var carriedStackTrace =
        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
    var value = this._settledValue;
    var receiver = this._receiverAt(index);
    this._clearCallbackDataAtIndex(index);

    if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof PromiseArray) {
        if (!receiver._isResolved()) {
            if (this._isFulfilled()) {
                receiver._promiseFulfilled(value, promise);
            }
            else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (this._isFulfilled()) {
            promise._fulfill(value);
        } else {
            promise._reject(value, carriedStackTrace);
        }
    }

    if (index >= 4 && (index & 31) === 4)
        async.invokeLater(this._setLength, this, 0);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    if (index === 0) {
        if (!this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 = undefined;
        }
        this._rejectionHandler0 =
        this._progressHandler0 =
        this._receiver0 =
        this._promise0 = undefined;
    } else {
        var base = index * 5 - 5;
        this[base + 3] =
        this[base + 4] =
        this[base + 0] =
        this[base + 1] =
        this[base + 2] = undefined;
    }
};

Promise.prototype._isSettlePromisesQueued = function () {
    return (this._bitField &
            -1073741824) === -1073741824;
};

Promise.prototype._setSettlePromisesQueued = function () {
    this._bitField = this._bitField | -1073741824;
};

Promise.prototype._unsetSettlePromisesQueued = function () {
    this._bitField = this._bitField & (~-1073741824);
};

Promise.prototype._queueSettlePromises = function() {
    async.settlePromises(this);
    this._setSettlePromisesQueued();
};

Promise.prototype._fulfillUnchecked = function (value) {
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, undefined);
    }
    this._setFulfilled();
    this._settledValue = value;
    this._cleanValues();

    if (this._length() > 0) {
        this._queueSettlePromises();
    }
};

Promise.prototype._rejectUncheckedCheckError = function (reason) {
    var trace = util.ensureErrorObject(reason);
    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
};

Promise.prototype._rejectUnchecked = function (reason, trace) {
    if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
    }
    this._setRejected();
    this._settledValue = reason;
    this._cleanValues();

    if (this._isFinal()) {
        async.throwLater(function(e) {
            if ("stack" in e) {
                async.invokeFirst(
                    CapturedTrace.unhandledRejection, undefined, e);
            }
            throw e;
        }, trace === undefined ? reason : trace);
        return;
    }

    if (trace !== undefined && trace !== reason) {
        this._setCarriedStackTrace(trace);
    }

    if (this._length() > 0) {
        this._queueSettlePromises();
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._settlePromises = function () {
    this._unsetSettlePromisesQueued();
    var len = this._length();
    for (var i = 0; i < len; i++) {
        this._settlePromiseAt(i);
    }
};

util.notEnumerableProp(Promise,
                       "_makeSelfResolutionError",
                       makeSelfResolutionError);

_dereq_("./progress.js")(Promise, PromiseArray);
_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
_dereq_("./direct_resolve.js")(Promise);
_dereq_("./synchronous_inspection.js")(Promise);
_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
Promise.Promise = Promise;
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./cancel.js')(Promise);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
_dereq_('./nodeify.js')(Promise);
_dereq_('./call_get.js')(Promise);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./settle.js')(Promise, PromiseArray);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./any.js')(Promise);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./timers.js')(Promise, INTERNAL);
_dereq_('./filter.js')(Promise, INTERNAL);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._progressHandler0 = value;                                         
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
        p._settledValue = value;                                             
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
    return Promise;                                                          

};

},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection) {
var util = _dereq_("./util.js");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    var parent;
    if (values instanceof Promise) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
    }
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        this._values = values;
        if (values._isFulfilled()) {
            values = values._value();
            if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                this.__hardReject__(err);
                return;
            }
        } else if (values._isPending()) {
            values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
            return;
        } else {
            this._reject(values._reason());
            return;
        }
    } else if (!isArray(values)) {
        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var promise = this._promise;
    for (var i = 0; i < len; ++i) {
        var isResolved = this._isResolved();
        var maybePromise = tryConvertToPromise(values[i], promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (isResolved) {
                maybePromise._ignoreRejections();
            } else if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                this._promiseFulfilled(maybePromise._value(), i);
            } else {
                this._promiseRejected(maybePromise._reason(), i);
            }
        } else if (!isResolved) {
            this._promiseFulfilled(maybePromise, i);
        }
    }
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype.__hardReject__ =
PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false, true);
};

PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
    this._promise._progress({
        index: index,
        value: progressValue
    });
};


PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

PromiseArray.prototype._promiseRejected = function (reason, index) {
    this._totalResolved++;
    this._reject(reason);
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util.js":38}],25:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors.js");
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var haveGetters = util.haveGetters;
var es5 = _dereq_("./es5.js");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise) {
    return function(err, value) {
        if (promise === null) return;

        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (arguments.length > 2) {
            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
            promise._fulfill(args);
        } else {
            promise._fulfill(value);
        }

        promise = null;
    };
}


var PromiseResolver;
if (!haveGetters) {
    PromiseResolver = function (promise) {
        this.promise = promise;
        this.asCallback = nodebackForPromise(promise);
        this.callback = this.asCallback;
    };
}
else {
    PromiseResolver = function (promise) {
        this.promise = promise;
    };
}
if (haveGetters) {
    var prop = {
        get: function() {
            return nodebackForPromise(this.promise);
        }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
}

PromiseResolver._nodebackForPromise = nodebackForPromise;

PromiseResolver.prototype.toString = function () {
    return "[object PromiseResolver]";
};

PromiseResolver.prototype.resolve =
PromiseResolver.prototype.fulfill = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._resolveCallback(value);
};

PromiseResolver.prototype.reject = function (reason) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._rejectCallback(reason);
};

PromiseResolver.prototype.progress = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._progress(value);
};

PromiseResolver.prototype.cancel = function (err) {
    this.promise.cancel(err);
};

PromiseResolver.prototype.timeout = function () {
    this.reject(new TimeoutError("timeout"));
};

PromiseResolver.prototype.isResolved = function () {
    return this.promise.isResolved();
};

PromiseResolver.prototype.toJSON = function () {
    return this.promise.toJSON();
};

module.exports = PromiseResolver;

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util.js");
var nodebackForPromise = _dereq_("./promise_resolver.js")
    ._nodebackForPromise;
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyProps = [
    "arity",    "length",
    "name",
    "arguments",
    "caller",
    "callee",
    "prototype",
    "__isPromisified__"
];
var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

var defaultFilter = function(name) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        name !== "constructor";
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";

    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "notEnumerableProp",
                        "INTERNAL","'use strict';                            \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
        return ret;                                                          \n\
        "
        .replace("Parameters", parameterDeclaration(newParameterCount))
        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode))(
            Promise,
            fn,
            receiver,
            withAppended,
            maybeWrapAsError,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL
        );
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        return promise;
    }
    util.notEnumerableProp(promisified, "__isPromisified__", true);
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        obj[promisifiedKey] = promisifier === makeNodePromisified
                ? makeNodePromisified(key, THIS, key, fn, suffix)
                : promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix);
                });
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver) {
    return makeNodePromisified(callback, receiver, undefined, callback);
}

Promise.promisify = function (fn, receiver) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    if (isPromisified(fn)) {
        return fn;
    }
    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
    }
    options = Object(options);
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier);
            promisifyAll(value, suffix, filter, promisifier);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier);
};
};


},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var isObject = util.isObject;
var es5 = _dereq_("./es5.js");

function PropertiesPromiseArray(obj) {
    var keys = es5.keys(obj);
    var len = keys.length;
    var values = new Array(len * 2);
    for (var i = 0; i < len; ++i) {
        var key = keys[i];
        values[i] = obj[key];
        values[i + len] = key;
    }
    this.constructor$(values);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {
    this._init$(undefined, -3) ;
};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val = {};
        var keyOffset = this.length();
        for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
        }
        this._resolve(val);
    }
};

PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
    this._promise._progress({
        key: this._values[index + this.length()],
        value: value
    });
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 4);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
};

Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],29:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var isArray = _dereq_("./util.js").isArray;

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else if (!isArray(promises)) {
        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 4 | 1);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util.js":38}],30:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var getDomain = Promise._getDomain;
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === undefined);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;
    var maybePromise = tryConvertToPromise(accum, this._promise);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) {
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) {
            maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise._isFulfilled()) {
            accum = maybePromise._value();
            this._gotAccum = true;
        } else {
            this._reject(maybePromise._reason());
            rejected = true;
        }
    }
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    var domain = getDomain();
    this._callback = domain === null ? fn : domain.bind(fn);
    this._accum = accum;
    if (!rejected) async.invoke(init, this, undefined);
}
function init() {
    this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init = function () {};

ReductionPromiseArray.prototype._resolveEmptyArray = function () {
    if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    }
};

ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    values[index] = value;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) {
        valuesPhase = this._valuesPhase = new Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
            valuesPhase[valuesPhaseIndex] = 0;
        }
    }
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    } else if (index === -1) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
    } else {
        if (valuesPhaseIndex === 0) {
            valuesPhase[index] = 1;
        } else {
            valuesPhase[index] = 2;
            this._accum = value;
        }
    }
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundValue();
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
            this._reducingIndex = i + 1;
            continue;
        }
        if (valuesPhaseIndex !== 1) return;
        value = values[i];
        this._promise._pushContext();
        if (isEach) {
            preservedValues.push(value);
            ret = tryCatch(callback).call(receiver, value, i, length);
        }
        else {
            ret = tryCatch(callback)
                .call(receiver, this._accum, value, i, length);
        }
        this._promise._popContext();

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }

        this._reducingIndex = i + 1;
        this._accum = ret;
    }

    this._resolve(isEach ? preservedValues : this._accum);
};

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};
};

},{"./async.js":2,"./util.js":38}],31:[function(_dereq_,module,exports){
"use strict";
var schedule;
var util = _dereq_("./util");
var noAsyncScheduler = function() {
    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
};
if (util.isNode && typeof MutationObserver === "undefined") {
    var GlobalSetImmediate = global.setImmediate;
    var ProcessNextTick = process.nextTick;
    schedule = util.isRecentNode
                ? function(fn) { GlobalSetImmediate.call(global, fn); }
                : function(fn) { ProcessNextTick.call(process, fn); };
} else if ((typeof MutationObserver !== "undefined") &&
          !(typeof window !== "undefined" &&
            window.navigator &&
            window.navigator.standalone)) {
    schedule = function(fn) {
        var div = document.createElement("div");
        var observer = new MutationObserver(fn);
        observer.observe(div, {attributes: true});
        return function() { div.classList.toggle("foo"); };
    };
    schedule.isStatic = true;
} else if (typeof setImmediate !== "undefined") {
    schedule = function (fn) {
        setImmediate(fn);
    };
} else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
} else {
    schedule = noAsyncScheduler;
}
module.exports = schedule;

},{"./util":38}],32:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util.js");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 268435456;
    ret._settledValue = value;
    this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 134217728;
    ret._settledValue = reason;
    this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return new SettledPromiseArray(this).promise();
};
};

},{"./util.js":38}],33:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util.js");
var RangeError = _dereq_("./errors.js").RangeError;
var AggregateError = _dereq_("./errors.js").AggregateError;
var isArray = util.isArray;


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
    }

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            e.push(this._values[i]);
        }
        this._reject(e);
    }
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValue = promise._settledValue;
    }
    else {
        this._bitField = 0;
        this._settledValue = undefined;
    }
}

PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.isFulfilled =
Promise.prototype._isFulfilled = function () {
    return (this._bitField & 268435456) > 0;
};

PromiseInspection.prototype.isRejected =
Promise.prototype._isRejected = function () {
    return (this._bitField & 134217728) > 0;
};

PromiseInspection.prototype.isPending =
Promise.prototype._isPending = function () {
    return (this._bitField & 402653184) === 0;
};

PromiseInspection.prototype.isResolved =
Promise.prototype._isResolved = function () {
    return (this._bitField & 402653184) > 0;
};

Promise.prototype.isPending = function() {
    return this._target()._isPending();
};

Promise.prototype.isRejected = function() {
    return this._target()._isRejected();
};

Promise.prototype.isFulfilled = function() {
    return this._target()._isFulfilled();
};

Promise.prototype.isResolved = function() {
    return this._target()._isResolved();
};

Promise.prototype._value = function() {
    return this._settledValue;
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue;
};

Promise.prototype.value = function() {
    var target = this._target();
    if (!target.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return target._settledValue;
};

Promise.prototype.reason = function() {
    var target = this._target();
    if (!target.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    target._unsetRejectionIsUnhandled();
    return target._settledValue;
};


Promise.PromiseInspection = PromiseInspection;
};

},{}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) {
            return obj;
        }
        else if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise(INTERNAL);
            obj._then(
                ret._fulfillUnchecked,
                ret._rejectUncheckedCheckError,
                ret._progressUnchecked,
                ret,
                null
            );
            return ret;
        }
        var then = util.tryCatch(getThen)(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function getThen(obj) {
    return obj.then;
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x,
                                        resolveFromThenable,
                                        rejectFromThenable,
                                        progressFromThenable);
    synchronous = false;
    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolveFromThenable(value) {
        if (!promise) return;
        promise._resolveCallback(value);
        promise = null;
    }

    function rejectFromThenable(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }

    function progressFromThenable(value) {
        if (!promise) return;
        if (typeof promise._progress === "function") {
            promise._progress(value);
        }
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util.js":38}],36:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var TimeoutError = Promise.TimeoutError;

var afterTimeout = function (promise, message) {
    if (!promise.isPending()) return;
    if (typeof message !== "string") {
        message = "operation timed out";
    }
    var err = new TimeoutError(message);
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._cancel(err);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (value, ms) {
    if (ms === undefined) {
        ms = value;
        value = undefined;
        var ret = new Promise(INTERNAL);
        setTimeout(function() { ret._fulfill(); }, ms);
        return ret;
    }
    ms = +ms;
    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
};

Promise.prototype.delay = function (ms) {
    return delay(this, ms);
};

function successClear(value) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    return value;
}

function failureClear(reason) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret = this.then().cancellable();
    ret._cancellationParent = this;
    var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message);
    }, ms);
    return ret._then(successClear, failureClear, undefined, handle, undefined);
};

};

},{"./util.js":38}],37:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext) {
    var TypeError = _dereq_("./errors.js").TypeError;
    var inherits = _dereq_("./util.js").inherits;
    var PromiseInspection = Promise.PromiseInspection;

    function inspectionMapper(inspections) {
        var len = inspections.length;
        for (var i = 0; i < len; ++i) {
            var inspection = inspections[i];
            if (inspection.isRejected()) {
                return Promise.reject(inspection.error());
            }
            inspections[i] = inspection._settledValue;
        }
        return inspections;
    }

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = Promise.defer();
        function iterator() {
            if (i >= len) return ret.resolve();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret.promise;
    }

    function disposerSuccess(value) {
        var inspection = new PromiseInspection();
        inspection._settledValue = value;
        inspection._bitField = 268435456;
        return dispose(this, inspection).thenReturn(value);
    }

    function disposerFail(reason) {
        var inspection = new PromiseInspection();
        inspection._settledValue = reason;
        inspection._bitField = 134217728;
        return dispose(this, inspection).thenThrow(reason);
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return null;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== null
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        len--;
        var resources = new Array(len);
        for (var i = 0; i < len; ++i) {
            var resource = arguments[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var promise = Promise.settle(resources)
            .then(inspectionMapper)
            .then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                    ret = fn.apply(undefined, vals);
                } finally {
                    promise._popContext();
                }
                return ret;
            })
            ._then(
                disposerSuccess, disposerFail, undefined, resources, undefined);
        resources.promise = promise;
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 262144;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~262144);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var canEvaluate = typeof navigator == "undefined";
var haveGetters = (function(){
    try {
        var o = {};
        es5.defineProperty(o, "f", {
            get: function () {
                return 3;
            }
        });
        return o.f === 3;
    }
    catch (e) {
        return false;
    }

})();

var errorObj = {e: {}};
var tryCatchTarget;
function tryCatcher() {
    try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return !isPrimitive(value);
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);

        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
    ];

    var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
            if (excludedPrototypes[i] === val) {
                return true;
            }
        }
        return false;
    };

    if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && !isExcludedProto(obj)) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj) {
            if (isExcludedProto(obj)) return [];
            var ret = [];

            /*jshint forin:false */
            enumeration: for (var key in obj) {
                if (hasProp.call(obj, key)) {
                    ret.push(key);
                } else {
                    for (var i = 0; i < excludedPrototypes.length; ++i) {
                        if (hasProp.call(excludedPrototypes[i], key)) {
                            continue enumeration;
                        }
                    }
                    ret.push(key);
                }
            }
            return ret;
        };
    }

})();

var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);

            var hasMethods = es5.isES5 && keys.length > 1;
            var hasMethodsOtherThanConstructor = keys.length > 0 &&
                !(keys.length === 1 && keys[0] === "constructor");
            var hasThisAssignmentAndStaticMethods =
                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

            if (hasMethods || hasMethodsOtherThanConstructor ||
                hasThisAssignmentAndStaticMethods) {
                return true;
            }
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027,-W055,-W031*/
    function f() {}
    f.prototype = obj;
    var l = 8;
    while (l--) new f();
    return obj;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            try {
                es5.defineProperty(to, key, es5.getDescriptor(from, key));
            } catch (ignore) {}
        }
    }
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    haveGetters: haveGetters,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    hasDevTools: typeof chrome !== "undefined" && chrome &&
                 typeof chrome.loadTimes === "function",
    isNode: typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]"
};
ret.isRecentNode = ret.isNode && (function() {
    var version = process.versions.node.split(".").map(Number);
    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
})();

if (ret.isNode) ret.toFastProperties(process);

try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5.js":14}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":22}],1465:[function(require,module,exports){
// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// UMD HEADER START 
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
  }
}(this, function () {
// UMD HEADER END

var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')
request.log = {
  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
}

var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

//
// request
//

function request(options, callback) {
  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
  if(typeof callback !== 'function')
    throw new Error('Bad callback given: ' + callback)

  if(!options)
    throw new Error('No options given')

  var options_onResponse = options.onResponse; // Save this for later.

  if(typeof options === 'string')
    options = {'uri':options};
  else
    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

  options.onResponse = options_onResponse // And put it back.

  if (options.verbose) request.log = getLogger();

  if(options.url) {
    options.uri = options.url;
    delete options.url;
  }

  if(!options.uri && options.uri !== "")
    throw new Error("options.uri is a required argument");

  if(typeof options.uri != "string")
    throw new Error("options.uri must be a string");

  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
  for (var i = 0; i < unsupported_options.length; i++)
    if(options[ unsupported_options[i] ])
      throw new Error("options." + unsupported_options[i] + " is not supported")

  options.callback = callback
  options.method = options.method || 'GET';
  options.headers = options.headers || {};
  options.body    = options.body || null
  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

  if(options.headers.host)
    throw new Error("Options.headers.host is not supported");

  if(options.json) {
    options.headers.accept = options.headers.accept || 'application/json'
    if(options.method !== 'GET')
      options.headers['content-type'] = 'application/json'

    if(typeof options.json !== 'boolean')
      options.body = JSON.stringify(options.json)
    else if(typeof options.body !== 'string')
      options.body = JSON.stringify(options.body)
  }
  
  //BEGIN QS Hack
  var serialize = function(obj) {
    var str = [];
    for(var p in obj)
      if (obj.hasOwnProperty(p)) {
        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
      }
    return str.join("&");
  }
  
  if(options.qs){
    var qs = (typeof options.qs == 'string')? options.qs : serialize(options.qs);
    if(options.uri.indexOf('?') !== -1){ //no get params
        options.uri = options.uri+'&'+qs;
    }else{ //existing get params
        options.uri = options.uri+'?'+qs;
    }
  }
  //END QS Hack
  
  //BEGIN FORM Hack
  var multipart = function(obj) {
    //todo: support file type (useful?)
    var result = {};
    result.boundry = '-------------------------------'+Math.floor(Math.random()*1000000000);
    var lines = [];
    for(var p in obj){
        if (obj.hasOwnProperty(p)) {
            lines.push(
                '--'+result.boundry+"\n"+
                'Content-Disposition: form-data; name="'+p+'"'+"\n"+
                "\n"+
                obj[p]+"\n"
            );
        }
    }
    lines.push( '--'+result.boundry+'--' );
    result.body = lines.join('');
    result.length = result.body.length;
    result.type = 'multipart/form-data; boundary='+result.boundry;
    return result;
  }
  
  if(options.form){
    if(typeof options.form == 'string') throw('form name unsupported');
    if(options.method === 'POST'){
        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
        options.headers['content-type'] = encoding;
        switch(encoding){
            case 'application/x-www-form-urlencoded':
                options.body = serialize(options.form).replace(/%20/g, "+");
                break;
            case 'multipart/form-data':
                var multi = multipart(options.form);
                //options.headers['content-length'] = multi.length;
                options.body = multi.body;
                options.headers['content-type'] = multi.type;
                break;
            default : throw new Error('unsupported encoding:'+encoding);
        }
    }
  }
  //END FORM Hack

  // If onResponse is boolean true, call back immediately when the response is known,
  // not when the full request is complete.
  options.onResponse = options.onResponse || noop
  if(options.onResponse === true) {
    options.onResponse = callback
    options.callback = noop
  }

  // XXX Browsers do not like this.
  //if(options.body)
  //  options.headers['content-length'] = options.body.length;

  // HTTP basic authentication
  if(!options.headers.authorization && options.auth)
    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

  return run_xhr(options)
}

var req_seq = 0
function run_xhr(options) {
  var xhr = new XHR
    , timed_out = false
    , is_cors = is_crossDomain(options.uri)
    , supports_cors = ('withCredentials' in xhr)

  req_seq += 1
  xhr.seq_id = req_seq
  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

  if(is_cors && !supports_cors) {
    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
    cors_err.cors = 'unsupported'
    return options.callback(cors_err, xhr)
  }

  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
  function too_late() {
    timed_out = true
    var er = new Error('ETIMEDOUT')
    er.code = 'ETIMEDOUT'
    er.duration = options.timeout

    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
    return options.callback(er, xhr)
  }

  // Some states can be skipped over, so remember what is still incomplete.
  var did = {'response':false, 'loading':false, 'end':false}

  xhr.onreadystatechange = on_state_change
  xhr.open(options.method, options.uri, true) // asynchronous
  if(is_cors)
    xhr.withCredentials = !! options.withCredentials
  xhr.send(options.body)
  return xhr

  function on_state_change(event) {
    if(timed_out)
      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

    if(xhr.readyState === XHR.OPENED) {
      request.log.debug('Request started', {'id':xhr.id})
      for (var key in options.headers)
        xhr.setRequestHeader(key, options.headers[key])
    }

    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
      on_response()

    else if(xhr.readyState === XHR.LOADING) {
      on_response()
      on_loading()
    }

    else if(xhr.readyState === XHR.DONE) {
      on_response()
      on_loading()
      on_end()
    }
  }

  function on_response() {
    if(did.response)
      return

    did.response = true
    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
    clearTimeout(xhr.timeoutTimer)
    xhr.statusCode = xhr.status // Node request compatibility

    // Detect failed CORS requests.
    if(is_cors && xhr.statusCode == 0) {
      var cors_err = new Error('CORS request rejected: ' + options.uri)
      cors_err.cors = 'rejected'

      // Do not process this request further.
      did.loading = true
      did.end = true

      return options.callback(cors_err, xhr)
    }

    options.onResponse(null, xhr)
  }

  function on_loading() {
    if(did.loading)
      return

    did.loading = true
    request.log.debug('Response body loading', {'id':xhr.id})
    // TODO: Maybe simulate "data" events by watching xhr.responseText
  }

  function on_end() {
    if(did.end)
      return

    did.end = true
    request.log.debug('Request done', {'id':xhr.id})

    xhr.body = xhr.responseText
    if(options.json) {
      try        { xhr.body = JSON.parse(xhr.responseText) }
      catch (er) { return options.callback(er, xhr)        }
    }

    options.callback(null, xhr, xhr.body)
  }

} // request

request.withCredentials = false;
request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

//
// defaults
//

request.defaults = function(options, requester) {
  var def = function (method) {
    var d = function (params, callback) {
      if(typeof params === 'string')
        params = {'uri': params};
      else {
        params = JSON.parse(JSON.stringify(params));
      }
      for (var i in options) {
        if (params[i] === undefined) params[i] = options[i]
      }
      return method(params, callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  return de
}

//
// HTTP method shortcuts
//

var shortcuts = [ 'get', 'put', 'post', 'head' ];
shortcuts.forEach(function(shortcut) {
  var method = shortcut.toUpperCase();
  var func   = shortcut.toLowerCase();

  request[func] = function(opts) {
    if(typeof opts === 'string')
      opts = {'method':method, 'uri':opts};
    else {
      opts = JSON.parse(JSON.stringify(opts));
      opts.method = method;
    }

    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
    return request.apply(this, args);
  }
})

//
// CouchDB shortcut
//

request.couch = function(options, callback) {
  if(typeof options === 'string')
    options = {'uri':options}

  // Just use the request API to do JSON.
  options.json = true
  if(options.body)
    options.json = options.body
  delete options.body

  callback = callback || noop

  var xhr = request(options, couch_handler)
  return xhr

  function couch_handler(er, resp, body) {
    if(er)
      return callback(er, resp, body)

    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
      // The body is a Couch JSON object indicating the error.
      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
      for (var key in body)
        er[key] = body[key]
      return callback(er, resp, body);
    }

    return callback(er, resp, body);
  }
}

//
// Utility
//

function noop() {}

function getLogger() {
  var logger = {}
    , levels = ['trace', 'debug', 'info', 'warn', 'error']
    , level, i

  for(i = 0; i < levels.length; i++) {
    level = levels[i]

    logger[level] = noop
    if(typeof console !== 'undefined' && console && console[level])
      logger[level] = formatted(console, level)
  }

  return logger
}

function formatted(obj, method) {
  return formatted_logger

  function formatted_logger(str, context) {
    if(typeof context === 'object')
      str += ' ' + JSON.stringify(context)

    return obj[method].call(obj, str)
  }
}

// Return whether a URL is a cross-domain request.
function is_crossDomain(url) {
  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

  // jQuery #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  var ajaxLocation
  try { ajaxLocation = location.href }
  catch (e) {
    // Use the href attribute of an A element since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  }

  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
    , parts = rurl.exec(url.toLowerCase() )

  var result = !!(
    parts &&
    (  parts[1] != ajaxLocParts[1]
    || parts[2] != ajaxLocParts[2]
    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
    )
  )

  //console.debug('is_crossDomain('+url+') -> ' + result)
  return result
}

// MIT License from http://phpjs.org/functions/base64_encode:358
function b64_enc (data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

    if (!data) {
        return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1<<16 | o2<<8 | o3;

        h1 = bits>>18 & 0x3f;
        h2 = bits>>12 & 0x3f;
        h3 = bits>>6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
        break;
        case 2:
            enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
}
    return request;
//UMD FOOTER START
}));
//UMD FOOTER END

},{}],1466:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');
var request = BPromise.promisify(require('request'));

var JXT = require('jxt').createRegistry();

JXT.use(require('./lib/xrd'));


module.exports = function (opts, cb) {
    if (typeof opts === 'string') {
        opts = {host: opts};
    }

    var config = {
        ssl: true,
        json: true,
        xrd: true
    };

    for (var prop in opts) {
        config[prop] = opts[prop];
    }

    var scheme = config.ssl ? 'https://' : 'http://';

    var getJSON = new BPromise(function (resolve, reject) {
        request(scheme + config.host + '/.well-known/host-meta.json').spread(function (req, body) {
            resolve(JSON.parse(body));
        }).catch(reject);
    });

    var getXRD = new BPromise(function (resolve, reject) {
        request(scheme + config.host + '/.well-known/host-meta').spread(function (req, body) {
            var xrd = JXT.parse(body);
            resolve(xrd.toJSON());
        }).catch(reject);
    });


    return new BPromise(function (resolve, reject) {
        BPromise.some([getJSON, getXRD], 1).spread(resolve).catch(function () {
            reject('no-host-meta');
        });
    }).nodeify(cb);
};

},{"./lib/xrd":1467,"bluebird":1464,"jxt":1560,"request":1468}],1467:[function(require,module,exports){
'use strict';

var jxt = require('jxt');
var NS = 'http://docs.oasis-open.org/ns/xri/xrd-1.0';


module.exports = function (registry) {
    var Properties = {
        get: function () {
            var results = {};
            var props = jxt.find(this.xml, NS, 'Property');
    
            for (var i = 0, len = props.length; i < len; i++) {
                var property = props[i];
                var type = jxt.getAttribute(property, 'type');
                results[type] = property.textContent;
            }
    
            return results;
        }
    };
    
    var XRD = registry.define({
        name: 'xrd',
        namespace: NS,
        element: 'XRD',
        fields: {
            subject: jxt.subText(NS, 'Subject'),
            expires: jxt.dateSub(NS, 'Expires'),
            aliases: jxt.multiSubText(NS, 'Alias'),
            properties: Properties
        }
    });
    
    
    var Link = registry.define({
        name: '_xrdlink',
        namespace: NS,
        element: 'Link',
        fields: {
            rel: jxt.attribute('rel'),
            href: jxt.attribute('href'),
            type: jxt.attribute('type'),
            template: jxt.attribute('template'),
            titles: jxt.subLangText(NS, 'Title', 'default'),
            properties: Properties
        }
    });
    
    registry.extend(XRD, Link, 'links');

    return XRD;
};

},{"jxt":1560}],1468:[function(require,module,exports){
// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')

module.exports = request
request.log = {
  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
}

var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

//
// request
//

function request(options, callback) {
  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
  if(typeof callback !== 'function')
    throw new Error('Bad callback given: ' + callback)

  if(!options)
    throw new Error('No options given')

  var options_onResponse = options.onResponse; // Save this for later.

  if(typeof options === 'string')
    options = {'uri':options};
  else
    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

  options.onResponse = options_onResponse // And put it back.

  if (options.verbose) request.log = getLogger();

  if(options.url) {
    options.uri = options.url;
    delete options.url;
  }

  if(!options.uri && options.uri !== "")
    throw new Error("options.uri is a required argument");

  if(typeof options.uri != "string")
    throw new Error("options.uri must be a string");

  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
  for (var i = 0; i < unsupported_options.length; i++)
    if(options[ unsupported_options[i] ])
      throw new Error("options." + unsupported_options[i] + " is not supported")

  options.callback = callback
  options.method = options.method || 'GET';
  options.headers = options.headers || {};
  options.body    = options.body || null
  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

  if(options.headers.host)
    throw new Error("Options.headers.host is not supported");

  if(options.json) {
    options.headers.accept = options.headers.accept || 'application/json'
    if(options.method !== 'GET')
      options.headers['content-type'] = 'application/json'

    if(typeof options.json !== 'boolean')
      options.body = JSON.stringify(options.json)
    else if(typeof options.body !== 'string')
      options.body = JSON.stringify(options.body)
  }

  // If onResponse is boolean true, call back immediately when the response is known,
  // not when the full request is complete.
  options.onResponse = options.onResponse || noop
  if(options.onResponse === true) {
    options.onResponse = callback
    options.callback = noop
  }

  // XXX Browsers do not like this.
  //if(options.body)
  //  options.headers['content-length'] = options.body.length;

  // HTTP basic authentication
  if(!options.headers.authorization && options.auth)
    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

  return run_xhr(options)
}

var req_seq = 0
function run_xhr(options) {
  var xhr = new XHR
    , timed_out = false
    , is_cors = is_crossDomain(options.uri)
    , supports_cors = ('withCredentials' in xhr)

  req_seq += 1
  xhr.seq_id = req_seq
  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

  if(is_cors && !supports_cors) {
    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
    cors_err.cors = 'unsupported'
    return options.callback(cors_err, xhr)
  }

  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
  function too_late() {
    timed_out = true
    var er = new Error('ETIMEDOUT')
    er.code = 'ETIMEDOUT'
    er.duration = options.timeout

    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
    return options.callback(er, xhr)
  }

  // Some states can be skipped over, so remember what is still incomplete.
  var did = {'response':false, 'loading':false, 'end':false}

  xhr.onreadystatechange = on_state_change
  xhr.open(options.method, options.uri, true) // asynchronous
  if(is_cors)
    xhr.withCredentials = !! options.withCredentials
  xhr.send(options.body)
  return xhr

  function on_state_change(event) {
    if(timed_out)
      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

    if(xhr.readyState === XHR.OPENED) {
      request.log.debug('Request started', {'id':xhr.id})
      for (var key in options.headers)
        xhr.setRequestHeader(key, options.headers[key])
    }

    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
      on_response()

    else if(xhr.readyState === XHR.LOADING) {
      on_response()
      on_loading()
    }

    else if(xhr.readyState === XHR.DONE) {
      on_response()
      on_loading()
      on_end()
    }
  }

  function on_response() {
    if(did.response)
      return

    did.response = true
    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
    clearTimeout(xhr.timeoutTimer)
    xhr.statusCode = xhr.status // Node request compatibility

    // Detect failed CORS requests.
    if(is_cors && xhr.statusCode == 0) {
      var cors_err = new Error('CORS request rejected: ' + options.uri)
      cors_err.cors = 'rejected'

      // Do not process this request further.
      did.loading = true
      did.end = true

      return options.callback(cors_err, xhr)
    }

    options.onResponse(null, xhr)
  }

  function on_loading() {
    if(did.loading)
      return

    did.loading = true
    request.log.debug('Response body loading', {'id':xhr.id})
    // TODO: Maybe simulate "data" events by watching xhr.responseText
  }

  function on_end() {
    if(did.end)
      return

    did.end = true
    request.log.debug('Request done', {'id':xhr.id})

    xhr.body = xhr.responseText
    if(options.json) {
      try        { xhr.body = JSON.parse(xhr.responseText) }
      catch (er) { return options.callback(er, xhr)        }
    }

    options.callback(null, xhr, xhr.body)
  }

} // request

request.withCredentials = false;
request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

//
// defaults
//

request.defaults = function(options, requester) {
  var def = function (method) {
    var d = function (params, callback) {
      if(typeof params === 'string')
        params = {'uri': params};
      else {
        params = JSON.parse(JSON.stringify(params));
      }
      for (var i in options) {
        if (params[i] === undefined) params[i] = options[i]
      }
      return method(params, callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  return de
}

//
// HTTP method shortcuts
//

var shortcuts = [ 'get', 'put', 'post', 'head' ];
shortcuts.forEach(function(shortcut) {
  var method = shortcut.toUpperCase();
  var func   = shortcut.toLowerCase();

  request[func] = function(opts) {
    if(typeof opts === 'string')
      opts = {'method':method, 'uri':opts};
    else {
      opts = JSON.parse(JSON.stringify(opts));
      opts.method = method;
    }

    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
    return request.apply(this, args);
  }
})

//
// CouchDB shortcut
//

request.couch = function(options, callback) {
  if(typeof options === 'string')
    options = {'uri':options}

  // Just use the request API to do JSON.
  options.json = true
  if(options.body)
    options.json = options.body
  delete options.body

  callback = callback || noop

  var xhr = request(options, couch_handler)
  return xhr

  function couch_handler(er, resp, body) {
    if(er)
      return callback(er, resp, body)

    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
      // The body is a Couch JSON object indicating the error.
      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
      for (var key in body)
        er[key] = body[key]
      return callback(er, resp, body);
    }

    return callback(er, resp, body);
  }
}

//
// Utility
//

function noop() {}

function getLogger() {
  var logger = {}
    , levels = ['trace', 'debug', 'info', 'warn', 'error']
    , level, i

  for(i = 0; i < levels.length; i++) {
    level = levels[i]

    logger[level] = noop
    if(typeof console !== 'undefined' && console && console[level])
      logger[level] = formatted(console, level)
  }

  return logger
}

function formatted(obj, method) {
  return formatted_logger

  function formatted_logger(str, context) {
    if(typeof context === 'object')
      str += ' ' + JSON.stringify(context)

    return obj[method].call(obj, str)
  }
}

// Return whether a URL is a cross-domain request.
function is_crossDomain(url) {
  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

  // jQuery #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  var ajaxLocation
  try { ajaxLocation = location.href }
  catch (e) {
    // Use the href attribute of an A element since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  }

  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
    , parts = rurl.exec(url.toLowerCase() )

  var result = !!(
    parts &&
    (  parts[1] != ajaxLocParts[1]
    || parts[2] != ajaxLocParts[2]
    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
    )
  )

  //console.debug('is_crossDomain('+url+') -> ' + result)
  return result
}

// MIT License from http://phpjs.org/functions/base64_encode:358
function b64_enc (data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

    if (!data) {
        return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1<<16 | o2<<8 | o3;

        h1 = bits>>18 & 0x3f;
        h2 = bits>>12 & 0x3f;
        h3 = bits>>6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
        break;
        case 2:
            enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
}

},{}],1469:[function(require,module,exports){
var createHash = require('create-hash');
var createHmac = require('create-hmac');
var getHashes = require('./lib/get-hashes');

var mapping = {
    md2: 'md2',
    md5: 'md5',
    'sha-1': 'sha1',
    'sha-224': 'sha224',
    'sha-256': 'sha256',
    'sha-384': 'sha384',
    'sha-512': 'sha512'
};

var names = Object.keys(mapping);


exports.getHashes = function () {
    var result = [];
    var available = getHashes();
    for (var i = 0, len = names.length; i < len; i++) {
        if (available.indexOf(mapping[names[i]]) >= 0) {
            result.push(names[i]);
        }
    }
    return result;
};

exports.createHash = function (algorithm) {
    algorithm = algorithm.toLowerCase();
    if (mapping[algorithm]) {
        algorithm = mapping[algorithm];
    }
    return createHash(algorithm);
};

exports.createHmac = function (algorithm, key) {
    algorithm = algorithm.toLowerCase();
    if (mapping[algorithm]) {
        algorithm = mapping[algorithm];
    }
    return createHmac(algorithm, key);
};

},{"./lib/get-hashes":1470,"create-hash":1471,"create-hmac":1484}],1470:[function(require,module,exports){
module.exports = function () {
    return ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'];
};

},{}],1471:[function(require,module,exports){
module.exports=require(1449)
},{"./md5":1473,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/browser.js":1449,"buffer":9,"inherits":1474,"ripemd160":1475,"sha.js":1477,"stream":39}],1472:[function(require,module,exports){
module.exports=require(1450)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/helpers.js":1450,"buffer":9}],1473:[function(require,module,exports){
module.exports=require(1451)
},{"./helpers":1472,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/md5.js":1451}],1474:[function(require,module,exports){
module.exports=require(19)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/node_modules/inherits/inherits_browser.js":19}],1475:[function(require,module,exports){
module.exports=require(1453)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":1453,"buffer":9}],1476:[function(require,module,exports){
module.exports=require(1454)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/hash.js":1454,"buffer":9}],1477:[function(require,module,exports){
module.exports=require(1455)
},{"./sha":1478,"./sha1":1479,"./sha224":1480,"./sha256":1481,"./sha384":1482,"./sha512":1483,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/index.js":1455}],1478:[function(require,module,exports){
module.exports=require(1456)
},{"./hash":1476,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha.js":1456,"buffer":9,"inherits":1474}],1479:[function(require,module,exports){
module.exports=require(1457)
},{"./hash":1476,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha1.js":1457,"buffer":9,"inherits":1474}],1480:[function(require,module,exports){
module.exports=require(1458)
},{"./hash":1476,"./sha256":1481,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha224.js":1458,"buffer":9,"inherits":1474}],1481:[function(require,module,exports){
module.exports=require(1459)
},{"./hash":1476,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha256.js":1459,"buffer":9,"inherits":1474}],1482:[function(require,module,exports){
module.exports=require(1460)
},{"./hash":1476,"./sha512":1483,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha384.js":1460,"buffer":9,"inherits":1474}],1483:[function(require,module,exports){
module.exports=require(1461)
},{"./hash":1476,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha512.js":1461,"buffer":9,"inherits":1474}],1484:[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)

  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("buffer").Buffer)
},{"buffer":9,"create-hash/browser":1471,"inherits":1485,"stream":39}],1485:[function(require,module,exports){
module.exports=require(19)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/node_modules/inherits/inherits_browser.js":19}],1486:[function(require,module,exports){
var util = require('util');
var intersect = require('intersect');
var WildEmitter = require('wildemitter');
var webrtc = require('webrtcsupport');

var BaseSession = require('jingle-session');
var MediaSession = require('jingle-media-session');
var FileSession = require('jingle-filetransfer-session');


function SessionManager(conf) {
    WildEmitter.call(this);

    conf = conf || {};

    this.jid = conf.jid;
    this.selfID = conf.selfID || (this.jid && this.jid.full) || this.jid || '';

    this.sessions = {};
    this.peers = {};

    this.prepareSession = conf.prepareSession || function (opts) {
        if (opts.descriptionTypes.indexOf('rtp') >= 0) {
            return new MediaSession(opts);
        }
        if (opts.descriptionTypes.indexOf('filetransfer') >= 0) {
            return new FileSession(opts);
        }
    };

    this.performTieBreak = conf.performTieBreak || function (sess, req) {
        var descriptionTypes = req.jingle.contents.map(function (content) {
            if (content.description) {
                return content.description.descType;
            }
        });

        var matching = intersect(sess.pendingDescriptionTypes, descriptionTypes);

        return matching.length > 0;
    };

    this.screenSharingSupport = webrtc.screenSharing;

    this.capabilities = [
        'urn:xmpp:jingle:1'
    ];
    if (webrtc.support) {
        this.capabilities = [
            'urn:xmpp:jingle:1',
            'urn:xmpp:jingle:apps:rtp:1',
            'urn:xmpp:jingle:apps:rtp:audio',
            'urn:xmpp:jingle:apps:rtp:video',
            'urn:xmpp:jingle:apps:rtp:rtcb-fb:0',
            'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
            'urn:xmpp:jingle:apps:rtp:ssma:0',
            'urn:xmpp:jingle:apps:dtls:0',
            'urn:xmpp:jingle:apps:grouping:0',
            'urn:xmpp:jingle:apps:file-transfer:3',
            'urn:xmpp:jingle:transports:ice-udp:1',
            'urn:xmpp:jingle:transports.dtls-sctp:1',
            'urn:ietf:rfc:3264',
            'urn:ietf:rfc:5576',
            'urn:ietf:rfc:5888'
        ];
    }

    this.config = {
        debug: false,
        peerConnectionConfig: {
            iceServers: conf.iceServers || [{'url': 'stun:stun.l.google.com:19302'}]
        },
        peerConnectionConstraints: {
            optional: [
                {DtlsSrtpKeyAgreement: true},
                {RtpDataChannels: false}
            ]
        },
        media: {
            audio: true,
            video: true
        }
    };

    for (var item in conf) {
        this.config[item] = conf[item];
    }

    this.iceServers = this.config.peerConnectionConfig.iceServers;
}


util.inherits(SessionManager, WildEmitter);


SessionManager.prototype.addICEServer = function (server) {
    // server == {
    //    url: '',
    //    [username: '',]
    //    [credential: '']
    // }
    if (typeof server === 'string') {
        server = {url: server};
    }
    this.iceServers.push(server);
};

SessionManager.prototype.addSession = function (session) {
    var self = this;

    var sid = session.sid;
    var peer = session.peerID;

    this.sessions[sid] = session;
    if (!this.peers[peer]) {
        this.peers[peer] = [];
    }

    this.peers[peer].push(session);

    // Automatically clean up tracked sessions
    session.on('terminated', function () {
        var peers = self.peers[peer] || [];
        if (peers.length) {
            peers.splice(peers.indexOf(session), 1);
        }
        delete self.sessions[sid];
    });

    // Proxy session events
    session.on('*', function (name, data, extraData, extraData2) {
        // Listen for when we actually try to start a session to
        // trigger the outgoing event.
        if (name === 'send') {
            var action = data.jingle && data.jingle.action;
            if (session.isInitiator && action === 'session-initiate') {
                self.emit('outgoing', session);
            }
        }

        if (self.config.debug && (name === 'log:debug' || name === 'log:error')) {
            console.log('Jingle:', data, extraData, extraData2);
        }

        // Don't proxy change:* events, since those don't apply to
        // the session manager itself.
        if (name.indexOf('change') === 0) {
            return;
        }

        self.emit(name, data, extraData, extraData2);
    });

    this.emit('createdSession', session);

    return session;
};

SessionManager.prototype.createMediaSession = function (peer, sid, stream) {
    var session = new MediaSession({
        sid: sid,
        peer: peer,
        initiator: true,
        stream: stream,
        parent: this,
        iceServers: this.iceServers,
        constraints: this.config.peerConnectionConstraints
    });

    this.addSession(session);

    return session;
};

SessionManager.prototype.createFileTransferSession = function (peer, sid) {
    var session = new FileSession({
        sid: sid,
        peer: peer,
        initiator: true,
        parent: this
    });

    this.addSession(session);

    return session;
};

SessionManager.prototype.endPeerSessions = function (peer, reason, silent) {
    peer = peer.full || peer;

    var sessions = this.peers[peer] || [];
    delete this.peers[peer];

    sessions.forEach(function (session) {
        session.end(reason || 'gone', silent);
    });
};

SessionManager.prototype.endAllSessions = function (reason, silent) {
    var self = this;
    Object.keys(this.peers).forEach(function (peer) {
        self.endPeerSessions(peer, reason, silent);
    });
};

SessionManager.prototype._createIncomingSession = function (meta, req) {
    var session;

    if (this.prepareSession) {
        session = this.prepareSession(meta, req);
    }

    // Fallback to a generic session type, which can
    // only be used to end the session.

    if (!session) {
        session = new BaseSession(meta);
    }

    this.addSession(session);

    return session;
};

SessionManager.prototype._sendError = function (to, id, data) {
    if (!data.type) {
        data.type = 'cancel';
    }
    this.emit('send', {
        to: to,
        id: id,
        type: 'error',
        error: data
    });
};

SessionManager.prototype._log = function (level, message) {
    this.emit('log:' + level, message);
};

SessionManager.prototype.process = function (req) {
    var self = this;

    // Extract the request metadata that we need to verify
    var sid = !!req.jingle ? req.jingle.sid : null;
    var session = this.sessions[sid] || null;
    var rid = req.id;
    var sender = req.from.full || req.from;


    if (req.type === 'error') {
        var isTieBreak = req.error && req.error.jingleCondition === 'tie-break';
        if (session && session.pending && isTieBreak) {
            return session.end('alternative-session', true);
        } else {
            if (session) {
                session.pendingAction = false;
            }
            return this.emit('error', req);
        }
    }

    if (req.type === 'result') {
        if (session) {
            session.pendingAction = false;
        }
        return;
    }

    var action = req.jingle.action;
    var contents = req.jingle.contents || [];

    var descriptionTypes = contents.map(function (content) {
        if (content.description) {
            return content.description.descType;
        }
    });
    var transportTypes = contents.map(function (content) {
        if (content.transport) {
            return content.transport.transType;
        }
    });


    // Now verify that we are allowed to actually process the
    // requested action

    if (action !== 'session-initiate') {
        // Can't modify a session that we don't have.
        if (!session) {
            this._log('error', 'Unknown session', sid);
            return this._sendError(sender, rid, {
                condition: 'item-not-found',
                jingleCondition: 'unknown-session'
            });
        }

        // Check if someone is trying to hijack a session.
        if (session.peerID !== sender || session.ended) {
            this._log('error', 'Session has ended, or action has wrong sender');
            return this._sendError(sender, rid, {
                condition: 'item-not-found',
                jingleCondition: 'unknown-session'
            });
        }

        // Can't accept a session twice
        if (action === 'session-accept' && !session.pending) {
            this._log('error', 'Tried to accept session twice', sid);
            return this._sendError(sender, rid, {
                condition: 'unexpected-request',
                jingleCondition: 'out-of-order'
            });
        }

        // Can't process two requests at once, need to tie break
        if (action !== 'session-terminate' && action === session.pendingAction) {
            this._log('error', 'Tie break during pending request');
            if (session.isInitiator) {
                return this._sendError(sender, rid, {
                    condition: 'conflict',
                    jingleCondition: 'tie-break'
                });
            }
        }
    } else if (session) {
        // Don't accept a new session if we already have one.
        if (session.peerID !== sender) {
            this._log('error', 'Duplicate sid from new sender');
            return this._sendError(sender, rid, {
                condition: 'service-unavailable'
            });
        }

        // Check if we need to have a tie breaker because both parties
        // happened to pick the same random sid.
        if (session.pending) {
            if (this.selfID > session.peerID && this.performTieBreak(session, req)) {
                this._log('error', 'Tie break new session because of duplicate sids');
                return this._sendError(sender, rid, {
                    condition: 'conflict',
                    jingleCondition: 'tie-break'
                });
            }
        } else {
            // The other side is just doing it wrong.
            this._log('error', 'Someone is doing this wrong');
            return this._sendError(sender, rid, {
                condition: 'unexpected-request',
                jingleCondition: 'out-of-order'
            });
        }
    } else if (this.peers[sender] && this.peers[sender].length) {
        // Check if we need to have a tie breaker because we already have
        // a different session with this peer that is using the requested
        // content description types.
        for (var i = 0, len = this.peers[sender].length; i < len; i++) {
            var sess = this.peers[sender][i];
            if (sess && sess.pending && sess.sid > sid && this.performTieBreak(sess, req)) {
                this._log('info', 'Tie break session-initiate');
                return this._sendError(sender, rid, {
                    condition: 'conflict',
                    jingleCondition: 'tie-break'
                });
            }
        }
    }

    // We've now weeded out invalid requests, so we can process the action now.

    if (action === 'session-initiate') {
        if (!contents.length) {
            return self._sendError(sender, rid, {
                condition: 'bad-request'
            });
        }

        session = this._createIncomingSession({
            sid: sid,
            peer: req.from,
            peerID: sender,
            initiator: false,
            parent: this,
            descriptionTypes: descriptionTypes,
            transportTypes: transportTypes,
            iceServers: this.iceServers,
            constraints: this.config.peerConnectionConstraints
        }, req);
    }

    session.process(action, req.jingle, function (err) {
        if (err) {
            self._log('error', 'Could not process request', req, err);
            self._sendError(sender, rid, err);
        } else {
            self.emit('send', {
                to: sender,
                id: rid,
                type: 'result',
            });

            // Wait for the initial action to be processed before emitting
            // the session for the user to accept/reject.
            if (action === 'session-initiate') {
                self.emit('incoming', session);
            }
        }
    });
};


module.exports = SessionManager;

},{"intersect":1488,"jingle-filetransfer-session":1489,"jingle-media-session":1523,"jingle-session":1555,"util":43,"webrtcsupport":1558,"wildemitter":1603}],1487:[function(require,module,exports){
var arr = [];
var each = arr.forEach;
var slice = arr.slice;


module.exports = function(obj) {
    each.call(slice.call(arguments, 1), function(source) {
        if (source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

},{}],1488:[function(require,module,exports){
module.exports = intersect;

function intersect (a, b) {
  var res = [];
  for (var i = 0; i < a.length; i++) {
    if (indexOf(b, a[i]) > -1) res.push(a[i]);
  }
  return res;
}

intersect.big = function(a, b) {
  var ret = [];
  var temp = {};
  
  for (var i = 0; i < b.length; i++) {
    temp[b[i]] = true;
  }
  for (var i = 0; i < a.length; i++) {
    if (temp[a[i]]) ret.push(a[i]);
  }
  
  return ret;
}

function indexOf(arr, el) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === el) return i;
  }
  return -1;
}

},{}],1489:[function(require,module,exports){
var util = require('util');
var extend = require('extend-object');
var BaseSession = require('jingle-session');
var RTCPeerConnection = require('rtcpeerconnection');
var FileTransfer = require('filetransfer/hashed');


function FileTransferSession(opts) {
    BaseSession.call(this, opts);

    this.pc = new RTCPeerConnection({
        iceServers: opts.iceServers || [],
        useJingle: true
    }, opts.constraints || {});

    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
    this.pc.on('addChannel', this.onChannelAdded.bind(this));

    this.sender = null;
    this.receiver = null;
}


util.inherits(FileTransferSession, BaseSession);


FileTransferSession.prototype = extend(FileTransferSession.prototype, {

    // ----------------------------------------------------------------
    // Session control methods
    // ----------------------------------------------------------------

    start: function (file) {
        var self = this;
        this.state = 'pending';

        this.pc.isInitiator = true;

        this.sender = new FileTransfer.Sender();
        this.sender.on('progress', function (sent, size) {
            self._log('info', 'Send progress ' + sent + '/' + size);
        });
        this.sender.on('sentFile', function (meta) {
            self._log('info', 'Sent file', meta.name);

            var content = self.pc.localDescription.contents[0];
            delete content.transport;

            content.description = {
                descType: 'filetransfer',
                offer: {
                    hash: {
                        algo: meta.algo,
                        value: meta.hash
                    }
                }
            };

            self.send('description-info', {
                contents: [content]
            });
            self.emit('sentFile', self, meta);
        });

        var sendChannel = this.pc.createDataChannel('filetransfer');
        sendChannel.onopen = function () {
            self.sender.send(file, sendChannel);
        };

        var constraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };

        this.pc.offer(constraints, function (err, offer) {
            if (err) {
                self._log('error', 'Could not create WebRTC offer', err);
                return self.end('failed-application', true);
            }

            offer.jingle.contents[0].description = {
                descType: 'filetransfer',
                offer: {
                    date: file.lastModifiedDate,
                    name: file.name,
                    size: file.size,
                    hash: {
                        algo: 'sha-1',
                        value: ''
                    }
                }
            };

            self.send('session-initiate', offer.jingle);
        });
    },

    accept: function () {
        var self = this;

        this._log('info', 'Accepted incoming session');

        this.state = 'active';

        this.pc.answer(function (err, answer) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer', err);
                return self.end('failed-application');
            }
            self.send('session-accept', answer.jingle);
        });
    },

    end: function (reason, silent) {
        this.pc.close();
        BaseSession.prototype.end.call(this, reason, silent);
    },

    maybeReceivedFile: function () {
        if (!this.receiver.metadata.hash.value) {
            // unknown hash, file transfer not completed
        } else if (this.receiver.metadata.hash.value === this.receiver.metadata.actualhash) {
            this._log('info', 'File hash matches');
            this.emit('receivedFile', this, this.receivedFile, this.receiver.metadata);
            this.end('success');
        } else {
            this._log('error', 'File hash does not match');
            this.end('media-error');
        }
    },

    // ----------------------------------------------------------------
    // ICE action handers
    // ----------------------------------------------------------------

    onIceCandidate: function (candidate) {
        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
        this.send('transport-info', candidate.jingle);
    },

    onIceStateChange: function () {
        switch (this.pc.iceConnectionState) {
            case 'checking':
                this.connectionState = 'connecting';
                break;
            case 'completed':
            case 'connected':
                this.connectionState = 'connected';
                break;
            case 'disconnected':
                if (this.pc.signalingState === 'stable') {
                    this.connectionState = 'interrupted';
                } else {
                    this.connectionState = 'disconnected';
                }
                break;
            case 'failed':
                this.connectionState = 'failed';
                this.end('failed-transport');
                break;
            case 'closed':
                this.connectionState = 'disconnected';
                break;
        }
    },

    onChannelAdded: function (channel) {
        this.receiver.receive(null, channel);
    },

    // ----------------------------------------------------------------
    // Jingle action handers
    // ----------------------------------------------------------------

    onSessionInitiate: function (changes, cb) {
        var self = this;

        this._log('info', 'Initiating incoming session');

        this.state = 'pending';

        this.pc.isInitiator = false;

        var desc = changes.contents[0].description;


        this.receiver = new FileTransfer.Receiver({hash: desc.offer.hash.algo});
        this.receiver.on('progress', function (received, size) {
            self._log('info', 'Receive progress ' + received + '/' + size);
        });
        this.receiver.on('receivedFile', function (file) {
            self.receivedFile = file;
            self.maybeReceivedFile();
        });
        this.receiver.metadata = desc.offer;

        changes.contents[0].description = {
            descType: 'datachannel'
        };

        this.pc.handleOffer({
            type: 'offer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer');
                return cb({condition: 'general-error'});
            }
            cb();
        });
    },

    onSessionAccept: function (changes, cb) {
        var self = this;

        this.state = 'active';
        
        changes.contents[0].description = {
            descType: 'datachannel'
        };

        this.pc.handleAnswer({
            type: 'answer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process WebRTC answer');
                return cb({condition: 'general-error'});
            }
            self.emit('accepted', self);
            cb();
        });
    },

    onSessionTerminate: function (changes, cb) {
        this._log('info', 'Terminating session');
        this.pc.close();
        BaseSession.prototype.end.call(this, changes.reason, true);
        cb();
    },

    onDescriptionInfo: function (info, cb) {
        var hash = info.contents[0].description.offer.hash;
        this.receiver.metadata.hash = hash;
        if (this.receiver.metadata.actualhash) {
            this.maybeReceivedFile();
        }
        cb();
    },

    onTransportInfo: function (changes, cb) {
        this.pc.processIce(changes, function () {
            cb();
        });
    }
});


module.exports = FileTransferSession;

},{"extend-object":1487,"filetransfer/hashed":1491,"jingle-session":1555,"rtcpeerconnection":1522,"util":43}],1490:[function(require,module,exports){
var WildEmitter = require('wildemitter');
var util = require('util');

function Sender(opts) {
    WildEmitter.call(this);
    var options = opts || {};
    this.config = {
        chunksize: 16384,
        pacing: 0
    };
    // set our config from options
    var item;
    for (item in options) {
        this.config[item] = options[item];
    }

    this.file = null;
    this.channel = null;
}
util.inherits(Sender, WildEmitter);

Sender.prototype.send = function (file, channel) {
    var self = this;
    this.file = file;
    this.channel = channel;
    var sliceFile = function(offset) {
        var reader = new window.FileReader();
        reader.onload = (function() {
            return function(e) {
                self.channel.send(e.target.result);
                self.emit('progress', offset, file.size, e.target.result);
                if (file.size > offset + e.target.result.byteLength) {
                    window.setTimeout(sliceFile, self.config.pacing, offset + self.config.chunksize);
                } else {
                    self.emit('progress', file.size, file.size, null);
                    self.emit('sentFile');
                }
            };
        })(file);
        var slice = file.slice(offset, offset + self.config.chunksize);
        reader.readAsArrayBuffer(slice);
    };
    window.setTimeout(sliceFile, 0, 0);
};

function Receiver() {
    WildEmitter.call(this);

    this.receiveBuffer = [];
    this.received = 0;
    this.metadata = {};
    this.channel = null;
}
util.inherits(Receiver, WildEmitter);

Receiver.prototype.receive = function (metadata, channel) {
    var self = this;

    if (metadata) {
        this.metadata = metadata;
    }
    this.channel = channel;
    // chrome only supports arraybuffers and those make it easier to calc the hash
    channel.binaryType = 'arraybuffer';
    this.channel.onmessage = function (event) {
        var len = event.data.byteLength;
        self.received += len;
        self.receiveBuffer.push(event.data);

        self.emit('progress', self.received, self.metadata.size, event.data);
        if (self.received === self.metadata.size) {
            self.emit('receivedFile', new window.Blob(self.receiveBuffer), self.metadata);
            self.receiveBuffer = []; // discard receivebuffer
        } else if (self.received > self.metadata.size) {
            // FIXME
            console.error('received more than expected, discarding...');
            self.receiveBuffer = []; // just discard...

        }
    };
};

module.exports = {};
module.exports.support = typeof window !== 'undefined' && window && window.File && window.FileReader && window.Blob;
module.exports.Sender = Sender;
module.exports.Receiver = Receiver;

},{"util":43,"wildemitter":1603}],1491:[function(require,module,exports){
var WildEmitter = require('wildemitter');
var util = require('util');
var hashes = require('iana-hashes');
var base = require('./filetransfer');

// drop-in replacement for filetransfer which also calculates hashes
function Sender(opts) {
    WildEmitter.call(this);
    var self = this;
    this.base = new base.Sender(opts);

    var options = opts || {};
    if (!options.hash) {
        options.hash = 'sha-1';
    }
    this.hash = hashes.createHash(options.hash);

    this.base.on('progress', function (start, size, data) {
        self.emit('progress', start, size, data);
        if (data) {
            self.hash.update(new Uint8Array(data));
        }
    });
    this.base.on('sentFile', function () {
        self.emit('sentFile', {hash: self.hash.digest('hex'), algo: options.hash });
    });
}
util.inherits(Sender, WildEmitter);
Sender.prototype.send = function () {
    this.base.send.apply(this.base, arguments);
};

function Receiver(opts) {
    WildEmitter.call(this);
    var self = this;
    this.base = new base.Receiver(opts);

    var options = opts || {};
    if (!options.hash) {
        options.hash = 'sha-1';
    }
    this.hash = hashes.createHash(options.hash);

    this.base.on('progress', function (start, size, data) {
        self.emit('progress', start, size, data);
        if (data) {
            self.hash.update(new Uint8Array(data));
        }
    });
    this.base.on('receivedFile', function (file, metadata) {
        metadata.actualhash = self.hash.digest('hex');
        self.emit('receivedFile', file, metadata);
    });
}
util.inherits(Receiver, WildEmitter);
Receiver.prototype.receive = function () {
    this.base.receive.apply(this.base, arguments);
};
Object.defineProperty(Receiver.prototype, 'metadata', {
    get: function () {
        return this.base.metadata;
    },
    set: function (value) {
        this.base.metadata = value;
    }
});

module.exports = {};
module.exports.support = base.support;
module.exports.Sender = Sender;
module.exports.Receiver = Receiver;

},{"./filetransfer":1490,"iana-hashes":1469,"util":43,"wildemitter":1603}],1492:[function(require,module,exports){
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayEach = require('lodash._arrayeach'),
    baseEach = require('lodash._baseeach'),
    bindCallback = require('lodash._bindcallback'),
    isArray = require('lodash.isarray');

/**
 * Creates a function for `_.forEach` or `_.forEachRight`.
 *
 * @private
 * @param {Function} arrayFunc The function to iterate over an array.
 * @param {Function} eachFunc The function to iterate over a collection.
 * @returns {Function} Returns the new each function.
 */
function createForEach(arrayFunc, eachFunc) {
  return function(collection, iteratee, thisArg) {
    return (typeof iteratee == 'function' && thisArg === undefined && isArray(collection))
      ? arrayFunc(collection, iteratee)
      : eachFunc(collection, bindCallback(iteratee, thisArg, 3));
  };
}

/**
 * Iterates over elements of `collection` invoking `iteratee` for each element.
 * The `iteratee` is bound to `thisArg` and invoked with three arguments:
 * (value, index|key, collection). Iteratee functions may exit iteration early
 * by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length" property
 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
 * may be used for object iteration.
 *
 * @static
 * @memberOf _
 * @alias each
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array|Object|string} Returns `collection`.
 * @example
 *
 * _([1, 2]).forEach(function(n) {
 *   console.log(n);
 * }).value();
 * // => logs each value from left to right and returns the array
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
 *   console.log(n, key);
 * });
 * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
 */
var forEach = createForEach(arrayEach, baseEach);

module.exports = forEach;

},{"lodash._arrayeach":1493,"lodash._baseeach":1494,"lodash._bindcallback":1498,"lodash.isarray":1499}],1493:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.forEach` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;

},{}],1494:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.forEach` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object|string} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

/**
 * The base implementation of `baseForIn` and `baseForOwn` which iterates
 * over `object` properties returned by `keysFunc` invoking `iteratee` for
 * each property. Iteratee functions may exit iteration early by explicitly
 * returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/**
 * The base implementation of `_.forOwn` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return baseFor(object, iteratee, keys);
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    var length = collection ? getLength(collection) : 0;
    if (!isLength(length)) {
      return eachFunc(collection, iteratee);
    }
    var index = fromRight ? length : -1,
        iterable = toObject(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

/**
 * Creates a base function for `_.forIn` or `_.forInRight`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var iterable = toObject(object),
        props = keysFunc(object),
        length = props.length,
        index = fromRight ? length : -1;

    while ((fromRight ? index-- : ++index < length)) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseEach;

},{"lodash.keys":1495}],1495:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var getNative = require('lodash._getnative'),
    isArguments = require('lodash.isarguments'),
    isArray = require('lodash.isarray');

/** Used to detect unsigned integer values. */
var reIsUint = /^\d+$/;

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/* Native method references for those with the same name as other `lodash` methods. */
var nativeKeys = getNative(Object, 'keys');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return value > -1 && value % 1 == 0 && value < length;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * A fallback implementation of `Object.keys` which creates an array of the
 * own enumerable property names of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function shimKeys(object) {
  var props = keysIn(object),
      propsLength = props.length,
      length = propsLength && object.length;

  var allowIndexes = !!length && isLength(length) &&
    (isArray(object) || isArguments(object));

  var index = -1,
      result = [];

  while (++index < propsLength) {
    var key = props[index];
    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
var keys = !nativeKeys ? shimKeys : function(object) {
  var Ctor = object == null ? undefined : object.constructor;
  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
      (typeof object != 'function' && isArrayLike(object))) {
    return shimKeys(object);
  }
  return isObject(object) ? nativeKeys(object) : [];
};

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  if (object == null) {
    return [];
  }
  if (!isObject(object)) {
    object = Object(object);
  }
  var length = object.length;
  length = (length && isLength(length) &&
    (isArray(object) || isArguments(object)) && length) || 0;

  var Ctor = object.constructor,
      index = -1,
      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
      result = Array(length),
      skipIndexes = length > 0;

  while (++index < length) {
    result[index] = (index + '');
  }
  for (var key in object) {
    if (!(skipIndexes && isIndex(key, length)) &&
        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = keys;

},{"lodash._getnative":1496,"lodash.isarguments":1497,"lodash.isarray":1499}],1496:[function(require,module,exports){
/**
 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = getNative;

},{}],1497:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Native method references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `arguments` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  return isObjectLike(value) && isArrayLike(value) &&
    hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
}

module.exports = isArguments;

},{}],1498:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `baseCallback` which only supports `this` binding
 * and specifying the number of arguments to provide to `func`.
 *
 * @private
 * @param {Function} func The function to bind.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function bindCallback(func, thisArg, argCount) {
  if (typeof func != 'function') {
    return identity;
  }
  if (thisArg === undefined) {
    return func;
  }
  switch (argCount) {
    case 1: return function(value) {
      return func.call(thisArg, value);
    };
    case 3: return function(value, index, collection) {
      return func.call(thisArg, value, index, collection);
    };
    case 4: return function(accumulator, value, index, collection) {
      return func.call(thisArg, accumulator, value, index, collection);
    };
    case 5: return function(value, other, key, object, source) {
      return func.call(thisArg, value, other, key, object, source);
    };
  }
  return function() {
    return func.apply(thisArg, arguments);
  };
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = bindCallback;

},{}],1499:[function(require,module,exports){
/**
 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var arrayTag = '[object Array]',
    funcTag = '[object Function]';

/** Used to detect host constructors (Safari > 5). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var fnToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/* Native method references for those with the same name as other `lodash` methods. */
var nativeIsArray = getNative(Array, 'isArray');

/**
 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = object == null ? undefined : object[key];
  return isNative(value) ? value : undefined;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(function() { return arguments; }());
 * // => false
 */
var isArray = nativeIsArray || function(value) {
  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
};

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in older versions of Chrome and Safari which return 'function' for regexes
  // and Safari 8 equivalents which return 'object' for typed array constructors.
  return isObject(value) && objToString.call(value) == funcTag;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is a native function.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
 * @example
 *
 * _.isNative(Array.prototype.push);
 * // => true
 *
 * _.isNative(_);
 * // => false
 */
function isNative(value) {
  if (value == null) {
    return false;
  }
  if (isFunction(value)) {
    return reIsNative.test(fnToString.call(value));
  }
  return isObjectLike(value) && reIsHostCtor.test(value);
}

module.exports = isArray;

},{}],1500:[function(require,module,exports){
/**
 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseGet = require('lodash._baseget'),
    toPath = require('lodash._topath'),
    isArray = require('lodash.isarray'),
    map = require('lodash.map');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Gets the property value of `path` from all elements in `collection`.
 *
 * @static
 * @memberOf _
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Array|string} path The path of the property to pluck.
 * @returns {Array} Returns the property values.
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 }
 * ];
 *
 * _.pluck(users, 'user');
 * // => ['barney', 'fred']
 *
 * var userIndex = _.indexBy(users, 'user');
 * _.pluck(userIndex, 'age');
 * // => [36, 40] (iteration order is not guaranteed)
 */
function pluck(collection, path) {
  return map(collection, property(path));
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates a function which returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = pluck;

},{"lodash._baseget":1501,"lodash._topath":1502,"lodash.isarray":1503,"lodash.map":1504}],1501:[function(require,module,exports){
/**
 * lodash 3.7.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseGet;

},{}],1502:[function(require,module,exports){
/**
 * lodash 3.8.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArray = require('lodash.isarray');

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  return value == null ? '' : (value + '');
}

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

module.exports = toPath;

},{"lodash.isarray":1503}],1503:[function(require,module,exports){
module.exports=require(1499)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash.isarray/index.js":1499}],1504:[function(require,module,exports){
/**
 * lodash 3.1.4 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var arrayMap = require('lodash._arraymap'),
    baseCallback = require('lodash._basecallback'),
    baseEach = require('lodash._baseeach'),
    isArray = require('lodash.isarray');

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * The base implementation of `_.map` without support for callback shorthands
 * and `this` binding.
 *
 * @private
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * Gets the "length" property value of `object`.
 *
 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
 * that affects Safari on at least iOS 8.1-8.3 ARM64.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {*} Returns the "length" value.
 */
var getLength = baseProperty('length');

/**
 * Checks if `value` is array-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 */
function isArrayLike(value) {
  return value != null && isLength(getLength(value));
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Creates an array of values by running each element in `collection` through
 * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
 * arguments: (value, index|key, collection).
 *
 * If a property name is provided for `iteratee` the created `_.property`
 * style callback returns the property value of the given element.
 *
 * If a value is also provided for `thisArg` the created `_.matchesProperty`
 * style callback returns `true` for elements that have a matching property
 * value, else `false`.
 *
 * If an object is provided for `iteratee` the created `_.matches` style
 * callback returns `true` for elements that have the properties of the given
 * object, else `false`.
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`,
 * `drop`, `dropRight`, `every`, `fill`, `flatten`, `invert`, `max`, `min`,
 * `parseInt`, `slice`, `sortBy`, `take`, `takeRight`, `template`, `trim`,
 * `trimLeft`, `trimRight`, `trunc`, `random`, `range`, `sample`, `some`,
 * `sum`, `uniq`, and `words`
 *
 * @static
 * @memberOf _
 * @alias collect
 * @category Collection
 * @param {Array|Object|string} collection The collection to iterate over.
 * @param {Function|Object|string} [iteratee=_.identity] The function invoked
 *  per iteration.
 * @param {*} [thisArg] The `this` binding of `iteratee`.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function timesThree(n) {
 *   return n * 3;
 * }
 *
 * _.map([1, 2], timesThree);
 * // => [3, 6]
 *
 * _.map({ 'a': 1, 'b': 2 }, timesThree);
 * // => [3, 6] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // using the `_.property` callback shorthand
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee, thisArg) {
  var func = isArray(collection) ? arrayMap : baseMap;
  iteratee = baseCallback(iteratee, thisArg, 3);
  return func(collection, iteratee);
}

module.exports = map;

},{"lodash._arraymap":1505,"lodash._basecallback":1506,"lodash._baseeach":1511,"lodash.isarray":1503}],1505:[function(require,module,exports){
/**
 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * A specialized version of `_.map` for arrays without support for callback
 * shorthands or `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],1506:[function(require,module,exports){
/**
 * lodash 3.3.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var baseIsEqual = require('lodash._baseisequal'),
    bindCallback = require('lodash._bindcallback'),
    isArray = require('lodash.isarray'),
    pairs = require('lodash.pairs');

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\n\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\n\\]|\\.)*?)\2)\]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `value` to a string if it's not one. An empty string is returned
 * for `null` or `undefined` values.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  return value == null ? '' : (value + '');
}

/**
 * The base implementation of `_.callback` which supports specifying the
 * number of arguments to provide to `func`.
 *
 * @private
 * @param {*} [func=_.identity] The value to convert to a callback.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {number} [argCount] The number of arguments to provide to `func`.
 * @returns {Function} Returns the callback.
 */
function baseCallback(func, thisArg, argCount) {
  var type = typeof func;
  if (type == 'function') {
    return thisArg === undefined
      ? func
      : bindCallback(func, thisArg, argCount);
  }
  if (func == null) {
    return identity;
  }
  if (type == 'object') {
    return baseMatches(func);
  }
  return thisArg === undefined
    ? property(func)
    : baseMatchesProperty(func, thisArg);
}

/**
 * The base implementation of `get` without support for string paths
 * and default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path of the property to get.
 * @param {string} [pathKey] The key representation of path.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path, pathKey) {
  if (object == null) {
    return;
  }
  if (pathKey !== undefined && pathKey in toObject(object)) {
    path = [pathKey];
  }
  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[path[index++]];
  }
  return (index && index == length) ? object : undefined;
}

/**
 * The base implementation of `_.isMatch` without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Array} matchData The propery names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = toObject(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var result = customizer ? customizer(objValue, srcValue, key) : undefined;
      if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, true) : result)) {
        return false;
      }
    }
  }
  return true;
}

/**
 * The base implementation of `_.matches` which does not clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    var key = matchData[0][0],
        value = matchData[0][1];

    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === value && (value !== undefined || (key in toObject(object)));
    };
  }
  return function(object) {
    return baseIsMatch(object, matchData);
  };
}

/**
 * The base implementation of `_.matchesProperty` which does not clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to compare.
 * @returns {Function} Returns the new function.
 */
function baseMatchesProperty(path, srcValue) {
  var isArr = isArray(path),
      isCommon = isKey(path) && isStrictComparable(srcValue),
      pathKey = (path + '');

  path = toPath(path);
  return function(object) {
    if (object == null) {
      return false;
    }
    var key = pathKey;
    object = toObject(object);
    if ((isArr || !isCommon) && !(key in object)) {
      object = path.length == 1 ? object : baseGet(object, baseSlice(path, 0, -1));
      if (object == null) {
        return false;
      }
      key = last(path);
      object = toObject(object);
    }
    return object[key] === srcValue
      ? (srcValue !== undefined || (key in object))
      : baseIsEqual(srcValue, object[key], undefined, true);
  };
}

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 */
function basePropertyDeep(path) {
  var pathKey = (path + '');
  path = toPath(path);
  return function(object) {
    return baseGet(object, path, pathKey);
  };
}

/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  start = start == null ? 0 : (+start || 0);
  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = (end === undefined || end > length) ? length : (+end || 0);
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/**
 * Gets the propery names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = pairs(object),
      length = result.length;

  while (length--) {
    result[length][2] = isStrictComparable(result[length][1]);
  }
  return result;
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  var type = typeof value;
  if ((type == 'string' && reIsPlainProp.test(value)) || type == 'number') {
    return true;
  }
  if (isArray(value)) {
    return false;
  }
  var result = !reIsDeepProp.test(value);
  return result || (object != null && value in toObject(object));
}

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Converts `value` to property path array if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Array} Returns the property path array.
 */
function toPath(value) {
  if (isArray(value)) {
    return value;
  }
  var result = [];
  baseToString(value).replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
}

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array ? array.length : 0;
  return length ? array[length - 1] : undefined;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * This method returns the first argument provided to it.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * _.identity(object) === object;
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * Creates a function that returns the property value at `path` on a
 * given object.
 *
 * @static
 * @memberOf _
 * @category Utility
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': { 'c': 2 } } },
 *   { 'a': { 'b': { 'c': 1 } } }
 * ];
 *
 * _.map(objects, _.property('a.b.c'));
 * // => [2, 1]
 *
 * _.pluck(_.sortBy(objects, _.property(['a', 'b', 'c'])), 'a.b.c');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(path) : basePropertyDeep(path);
}

module.exports = baseCallback;

},{"lodash._baseisequal":1507,"lodash._bindcallback":1509,"lodash.isarray":1503,"lodash.pairs":1510}],1507:[function(require,module,exports){
/**
 * lodash 3.0.7 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var isArray = require('lodash.isarray'),
    isTypedArray = require('lodash.istypedarray'),
    keys = require('lodash.keys');

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    stringTag = '[object String]';

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * A specialized version of `_.some` for arrays without support for callback
 * shorthands and `this` binding.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/**
 * The base implementation of `_.isEqual` without support for `this` binding
 * `customizer` functions.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, customizer, isLoose, stackA, stackB) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObject(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, baseIsEqual, customizer, isLoose, stackA, stackB);
}

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing objects.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA=[]] Tracks traversed `value` objects.
 * @param {Array} [stackB=[]] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = arrayTag,
      othTag = arrayTag;

  if (!objIsArr) {
    objTag = objToString.call(object);
    if (objTag == argsTag) {
      objTag = objectTag;
    } else if (objTag != objectTag) {
      objIsArr = isTypedArray(object);
    }
  }
  if (!othIsArr) {
    othTag = objToString.call(other);
    if (othTag == argsTag) {
      othTag = objectTag;
    } else if (othTag != objectTag) {
      othIsArr = isTypedArray(other);
    }
  }
  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && !(objIsArr || objIsObj)) {
    return equalByTag(object, other, objTag);
  }
  if (!isLoose) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      return equalFunc(objIsWrapped ? object.value() : object, othIsWrapped ? other.value() : other, customizer, isLoose, stackA, stackB);
    }
  }
  if (!isSameTag) {
    return false;
  }
  // Assume cyclic values are equal.
  // For more information on detecting circular references see https://es5.github.io/#JO.
  stackA || (stackA = []);
  stackB || (stackB = []);

  var length = stackA.length;
  while (length--) {
    if (stackA[length] == object) {
      return stackB[length] == other;
    }
  }
  // Add `object` and `other` to the stack of traversed objects.
  stackA.push(object);
  stackB.push(other);

  var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isLoose, stackA, stackB);

  stackA.pop();
  stackB.pop();

  return result;
}

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing arrays.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var index = -1,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isLoose && othLength > arrLength)) {
    return false;
  }
  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index],
        result = customizer ? customizer(isLoose ? othValue : arrValue, isLoose ? arrValue : othValue, index) : undefined;

    if (result !== undefined) {
      if (result) {
        continue;
      }
      return false;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (isLoose) {
      if (!arraySome(other, function(othValue) {
            return arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB);
          })) {
        return false;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, isLoose, stackA, stackB))) {
      return false;
    }
  }
  return true;
}

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} value The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag) {
  switch (tag) {
    case boolTag:
    case dateTag:
      // Coerce dates and booleans to numbers, dates to milliseconds and booleans
      // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
      return +object == +other;

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case numberTag:
      // Treat `NaN` vs. `NaN` as equal.
      return (object != +object)
        ? other != +other
        : object == +other;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings primitives and string
      // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
      return object == (other + '');
  }
  return false;
}

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Function} [customizer] The function to customize comparing values.
 * @param {boolean} [isLoose] Specify performing partial comparisons.
 * @param {Array} [stackA] Tracks traversed `value` objects.
 * @param {Array} [stackB] Tracks traversed `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, equalFunc, customizer, isLoose, stackA, stackB) {
  var objProps = keys(object),
      objLength = objProps.length,
      othProps = keys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isLoose) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isLoose ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  var skipCtor = isLoose;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key],
        result = customizer ? customizer(isLoose ? othValue : objValue, isLoose? objValue : othValue, key) : undefined;

    // Recursively compare objects (susceptible to call stack limits).
    if (!(result === undefined ? equalFunc(objValue, othValue, customizer, isLoose, stackA, stackB) : result)) {
      return false;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (!skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      return false;
    }
  }
  return true;
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = baseIsEqual;

},{"lodash.isarray":1503,"lodash.istypedarray":1508,"lodash.keys":1512}],1508:[function(require,module,exports){
/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dateTag] = typedArrayTags[errorTag] =
typedArrayTags[funcTag] = typedArrayTags[mapTag] =
typedArrayTags[numberTag] = typedArrayTags[objectTag] =
typedArrayTags[regexpTag] = typedArrayTags[setTag] =
typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

/**
 * Checks if `value` is object-like.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/** Used for native method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
 * of values.
 */
var objToString = objectProto.toString;

/**
 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
 * of an array-like value.
 */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 */
function isLength(value) {
  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
function isTypedArray(value) {
  return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objToString.call(value)];
}

module.exports = isTypedArray;

},{}],1509:[function(require,module,exports){
module.exports=require(1498)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._bindcallback/index.js":1498}],1510:[function(require,module,exports){
/**
 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
var keys = require('lodash.keys');

/**
 * Converts `value` to an object if it's not one.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {Object} Returns the object.
 */
function toObject(value) {
  return isObject(value) ? value : Object(value);
}

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Creates a two dimensional array of the key-value pairs for `object`,
 * e.g. `[[key1, value1], [key2, value2]]`.
 *
 * @static
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the new array of key-value pairs.
 * @example
 *
 * _.pairs({ 'barney': 36, 'fred': 40 });
 * // => [['barney', 36], ['fred', 40]] (iteration order is not guaranteed)
 */
function pairs(object) {
  object = toObject(object);

  var index = -1,
      props = keys(object),
      length = props.length,
      result = Array(length);

  while (++index < length) {
    var key = props[index];
    result[index] = [key, object[key]];
  }
  return result;
}

module.exports = pairs;

},{"lodash.keys":1512}],1511:[function(require,module,exports){
module.exports=require(1494)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/index.js":1494,"lodash.keys":1512}],1512:[function(require,module,exports){
module.exports=require(1495)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/index.js":1495,"lodash._getnative":1513,"lodash.isarguments":1514,"lodash.isarray":1503}],1513:[function(require,module,exports){
module.exports=require(1496)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash._getnative/index.js":1496}],1514:[function(require,module,exports){
module.exports=require(1497)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js":1497}],1515:[function(require,module,exports){
var toSDP = require('./lib/tosdp');
var toJSON = require('./lib/tojson');


// Converstion from JSON to SDP

exports.toIncomingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toCandidateSDP = toSDP.toCandidateSDP;
exports.toMediaSDP = toSDP.toMediaSDP;
exports.toSessionSDP = toSDP.toSessionSDP;


// Conversion from SDP to JSON

exports.toIncomingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toIncomingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toCandidateJSON = toJSON.toCandidateJSON;
exports.toMediaJSON = toJSON.toMediaJSON;
exports.toSessionJSON = toJSON.toSessionJSON;

},{"./lib/tojson":1518,"./lib/tosdp":1519}],1516:[function(require,module,exports){
exports.lines = function (sdp) {
    return sdp.split('\r\n').filter(function (line) {
        return line.length > 0;
    });
};

exports.findLine = function (prefix, mediaLines, sessionLines) {
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            return mediaLines[i];
        }
    }
    // Continue searching in parent session section
    if (!sessionLines) {
        return false;
    }

    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            return sessionLines[j];
        }
    }

    return false;
};

exports.findLines = function (prefix, mediaLines, sessionLines) {
    var results = [];
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            results.push(mediaLines[i]);
        }
    }
    if (results.length || !sessionLines) {
        return results;
    }
    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            results.push(sessionLines[j]);
        }
    }
    return results;
};

exports.mline = function (line) {
    var parts = line.substr(2).split(' ');
    var parsed = {
        media: parts[0],
        port: parts[1],
        proto: parts[2],
        formats: []
    };
    for (var i = 3; i < parts.length; i++) {
        if (parts[i]) {
            parsed.formats.push(parts[i]);
        }
    }
    return parsed;
};

exports.rtpmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        id: parts.shift()
    };

    parts = parts[0].split('/');

    parsed.name = parts[0];
    parsed.clockrate = parts[1];
    parsed.channels = parts.length == 3 ? parts[2] : '1';
    return parsed;
};

exports.sctpmap = function (line) {
    // based on -05 draft
    var parts = line.substr(10).split(' ');
    var parsed = {
        number: parts.shift(),
        protocol: parts.shift(),
        streams: parts.shift()
    };
    return parsed;
};


exports.fmtp = function (line) {
    var kv, key, value;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    var parsed = [];
    for (var i = 0; i < parts.length; i++) {
        kv = parts[i].split('=');
        key = kv[0].trim();
        value = kv[1];
        if (key && value) {
            parsed.push({key: key, value: value});
        } else if (key) {
            parsed.push({key: '', value: key});
        }
    }
    return parsed;
};

exports.crypto = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        tag: parts[0],
        cipherSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3).join(' ')
    };
    return parsed;
};

exports.fingerprint = function (line) {
    var parts = line.substr(14).split(' ');
    return {
        hash: parts[0],
        value: parts[1]
    };
};

exports.extmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {};

    var idpart = parts.shift();
    var sp = idpart.indexOf('/');
    if (sp >= 0) {
        parsed.id = idpart.substr(0, sp);
        parsed.senders = idpart.substr(sp + 1);
    } else {
        parsed.id = idpart;
        parsed.senders = 'sendrecv';
    }

    parsed.uri = parts.shift() || '';

    return parsed;
};

exports.rtcpfb = function (line) {
    var parts = line.substr(10).split(' ');
    var parsed = {};
    parsed.id = parts.shift();
    parsed.type = parts.shift();
    if (parsed.type === 'trr-int') {
        parsed.value = parts.shift();
    } else {
        parsed.subtype = parts.shift() || '';
    }
    parsed.parameters = parts;
    return parsed;
};

exports.candidate = function (line) {
    var parts;
    if (line.indexOf('a=candidate:') === 0) {
        parts = line.substring(12).split(' ');
    } else { // no a=candidate
        parts = line.substring(10).split(' ');
    }

    var candidate = {
        foundation: parts[0],
        component: parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parts[3],
        ip: parts[4],
        port: parts[5],
        // skip parts[6] == 'typ'
        type: parts[7],
        generation: '0'
    };

    for (var i = 8; i < parts.length; i += 2) {
        if (parts[i] === 'raddr') {
            candidate.relAddr = parts[i + 1];
        } else if (parts[i] === 'rport') {
            candidate.relPort = parts[i + 1];
        } else if (parts[i] === 'generation') {
            candidate.generation = parts[i + 1];
        } else if (parts[i] === 'tcptype') {
            candidate.tcpType = parts[i + 1];
        }
    }

    candidate.network = '1';

    return candidate;
};

exports.sourceGroups = function (lines) {
    var parsed = [];
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(13).split(' ');
        parsed.push({
            semantics: parts.shift(),
            sources: parts
        });
    }
    return parsed;
};

exports.sources = function (lines) {
    // http://tools.ietf.org/html/rfc5576
    var parsed = [];
    var sources = {};
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(7).split(' ');
        var ssrc = parts.shift();

        if (!sources[ssrc]) {
            var source = {
                ssrc: ssrc,
                parameters: []
            };
            parsed.push(source);

            // Keep an index
            sources[ssrc] = source;
        }

        parts = parts.join(' ').split(':');
        var attribute = parts.shift();
        var value = parts.join(':') || null;

        sources[ssrc].parameters.push({
            key: attribute,
            value: value
        });
    }

    return parsed;
};

exports.groups = function (lines) {
    // http://tools.ietf.org/html/rfc5888
    var parsed = [];
    var parts;
    for (var i = 0; i < lines.length; i++) {
        parts = lines[i].substr(8).split(' ');
        parsed.push({
            semantics: parts.shift(),
            contents: parts
        });
    }
    return parsed;
};

exports.bandwidth = function (line) {
    var parts = line.substr(2).split(':');
    var parsed = {};
    parsed.type = parts.shift();
    parsed.bandwidth = parts.shift();
    return parsed;
};

exports.msid = function (line) {
    var data = line.substr(7);
    var parts = data.split(' ');
    return {
        msid: data,
        mslabel: parts[0],
        label: parts[1]
    };
};

},{}],1517:[function(require,module,exports){
module.exports = {
    initiator: {
        incoming: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        }
    },
    responder: {
        incoming: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        }
    }
};

},{}],1518:[function(require,module,exports){
var SENDERS = require('./senders');
var parsers = require('./parsers');
var idCounter = Math.random();


exports._setIdCounter = function (counter) {
    idCounter = counter;
};

exports.toSessionJSON = function (sdp, opts) {
    var i;
    var creators = opts.creators || [];
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';


    // Divide the SDP into session and media sections.
    var media = sdp.split('\r\nm=');
    for (i = 1; i < media.length; i++) {
        media[i] = 'm=' + media[i];
        if (i !== media.length - 1) {
            media[i] += '\r\n';
        }
    }
    var session = media.shift() + '\r\n';
    var sessionLines = parsers.lines(session);
    var parsed = {};

    var contents = [];
    for (i = 0; i < media.length; i++) {
        contents.push(exports.toMediaJSON(media[i], session, {
            role: role,
            direction: direction,
            creator: creators[i] || 'initiator'
        }));
    }
    parsed.contents = contents;

    var groupLines = parsers.findLines('a=group:', sessionLines);
    if (groupLines.length) {
        parsed.groups = parsers.groups(groupLines);
    }

    return parsed;
};

exports.toMediaJSON = function (media, session, opts) {
    var creator = opts.creator || 'initiator';
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var lines = parsers.lines(media);
    var sessionLines = parsers.lines(session);
    var mline = parsers.mline(lines[0]);

    var content = {
        creator: creator,
        name: mline.media,
        description: {
            descType: 'rtp',
            media: mline.media,
            payloads: [],
            encryption: [],
            feedback: [],
            headerExtensions: []
        },
        transport: {
            transType: 'iceUdp',
            candidates: [],
            fingerprints: []
        }
    };
    if (mline.media == 'application') {
        // FIXME: the description is most likely to be independent
        // of the SDP and should be processed by other parts of the library
        content.description = {
            descType: 'datachannel'
        };
        content.transport.sctp = [];
    }
    var desc = content.description;
    var trans = content.transport;

    // If we have a mid, use that for the content name instead.
    var mid = parsers.findLine('a=mid:', lines);
    if (mid) {
        content.name = mid.substr(6);
    }

    if (parsers.findLine('a=sendrecv', lines, sessionLines)) {
        content.senders = 'both';
    } else if (parsers.findLine('a=sendonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].sendonly;
    } else if (parsers.findLine('a=recvonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].recvonly;
    } else if (parsers.findLine('a=inactive', lines, sessionLines)) {
        content.senders = 'none';
    }

    if (desc.descType == 'rtp') {
        var bandwidth = parsers.findLine('b=', lines);
        if (bandwidth) {
            desc.bandwidth = parsers.bandwidth(bandwidth);
        }

        var ssrc = parsers.findLine('a=ssrc:', lines);
        if (ssrc) {
            desc.ssrc = ssrc.substr(7).split(' ')[0];
        }

        var rtpmapLines = parsers.findLines('a=rtpmap:', lines);
        rtpmapLines.forEach(function (line) {
            var payload = parsers.rtpmap(line);
            payload.parameters = [];
            payload.feedback = [];

            var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines);
            // There should only be one fmtp line per payload
            fmtpLines.forEach(function (line) {
                payload.parameters = parsers.fmtp(line);
            });

            var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);
            fbLines.forEach(function (line) {
                payload.feedback.push(parsers.rtcpfb(line));
            });

            desc.payloads.push(payload);
        });

        var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);
        cryptoLines.forEach(function (line) {
            desc.encryption.push(parsers.crypto(line));
        });

        if (parsers.findLine('a=rtcp-mux', lines)) {
            desc.mux = true;
        }

        var fbLines = parsers.findLines('a=rtcp-fb:*', lines);
        fbLines.forEach(function (line) {
            desc.feedback.push(parsers.rtcpfb(line));
        });

        var extLines = parsers.findLines('a=extmap:', lines);
        extLines.forEach(function (line) {
            var ext = parsers.extmap(line);

            ext.senders = SENDERS[role][direction][ext.senders];

            desc.headerExtensions.push(ext);
        });

        var ssrcGroupLines = parsers.findLines('a=ssrc-group:', lines);
        desc.sourceGroups = parsers.sourceGroups(ssrcGroupLines || []);

        var ssrcLines = parsers.findLines('a=ssrc:', lines);
        var sources = desc.sources = parsers.sources(ssrcLines || []);

        var msidLine = parsers.findLine('a=msid:', lines);
        if (msidLine) {
            var msid = parsers.msid(msidLine);
            ['msid', 'mslabel', 'label'].forEach(function (key) {
                for (var i = 0; i < sources.length; i++) {
                    var found = false;
                    for (var j = 0; j < sources[i].parameters.length; j++) {
                        if (sources[i].parameters[j].key === key) {
                            found = true;
                        }
                    }
                    if (!found) {
                        sources[i].parameters.push({ key: key, value: msid[key] });
                    }
                }
            });
        }

        if (parsers.findLine('a=x-google-flag:conference', lines, sessionLines)) {
            desc.googConferenceFlag = true;
        }
    }

    // transport specific attributes
    var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);
    var setup = parsers.findLine('a=setup:', lines, sessionLines);
    fingerprintLines.forEach(function (line) {
        var fp = parsers.fingerprint(line);
        if (setup) {
            fp.setup = setup.substr(8);
        }
        trans.fingerprints.push(fp);
    });

    var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);
    var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);
    if (ufragLine && pwdLine) {
        trans.ufrag = ufragLine.substr(12);
        trans.pwd = pwdLine.substr(10);
        trans.candidates = [];

        var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);
        candidateLines.forEach(function (line) {
            trans.candidates.push(exports.toCandidateJSON(line));
        });
    }

    if (desc.descType == 'datachannel') {
        var sctpmapLines = parsers.findLines('a=sctpmap:', lines);
        sctpmapLines.forEach(function (line) {
            var sctp = parsers.sctpmap(line);
            trans.sctp.push(sctp);
        });
    }

    return content;
};

exports.toCandidateJSON = function (line) {
    var candidate = parsers.candidate(line.split('\r\n')[0]);
    candidate.id = (idCounter++).toString(36).substr(0, 12);
    return candidate;
};

},{"./parsers":1516,"./senders":1517}],1519:[function(require,module,exports){
var SENDERS = require('./senders');


exports.toSessionSDP = function (session, opts) {
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';
    var sid = opts.sid || session.sid || Date.now();
    var time = opts.time || Date.now();

    var sdp = [
        'v=0',
        'o=- ' + sid + ' ' + time + ' IN IP4 0.0.0.0',
        's=-',
        't=0 0'
    ];

    var groups = session.groups || [];
    groups.forEach(function (group) {
        sdp.push('a=group:' + group.semantics + ' ' + group.contents.join(' '));
    });

    var contents = session.contents || [];
    contents.forEach(function (content) {
        sdp.push(exports.toMediaSDP(content, opts));
    });

    return sdp.join('\r\n') + '\r\n';
};

exports.toMediaSDP = function (content, opts) {
    var sdp = [];

    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var desc = content.description;
    var transport = content.transport;
    var payloads = desc.payloads || [];
    var fingerprints = (transport && transport.fingerprints) || [];

    var mline = [];
    if (desc.descType == 'datachannel') {
        mline.push('application');
        mline.push('1');
        mline.push('DTLS/SCTP');
        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                mline.push(map.number);
            });
        }
    } else {
        mline.push(desc.media);
        mline.push('1');
        if ((desc.encryption && desc.encryption.length > 0) || (fingerprints.length > 0)) {
            mline.push('RTP/SAVPF');
        } else {
            mline.push('RTP/AVPF');
        }
        payloads.forEach(function (payload) {
            mline.push(payload.id);
        });
    }


    sdp.push('m=' + mline.join(' '));

    sdp.push('c=IN IP4 0.0.0.0');
    if (desc.bandwidth && desc.bandwidth.type && desc.bandwidth.bandwidth) {
        sdp.push('b=' + desc.bandwidth.type + ':' + desc.bandwidth.bandwidth);
    }
    if (desc.descType == 'rtp') {
        sdp.push('a=rtcp:1 IN IP4 0.0.0.0');
    }

    if (transport) {
        if (transport.ufrag) {
            sdp.push('a=ice-ufrag:' + transport.ufrag);
        }
        if (transport.pwd) {
            sdp.push('a=ice-pwd:' + transport.pwd);
        }

        var pushedSetup = false;
        fingerprints.forEach(function (fingerprint) {
            sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);
            if (fingerprint.setup && !pushedSetup) {
                sdp.push('a=setup:' + fingerprint.setup);
            }
        });

        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                sdp.push('a=sctpmap:' + map.number + ' ' + map.protocol + ' ' + map.streams);
            });
        }
    }

    if (desc.descType == 'rtp') {
        sdp.push('a=' + (SENDERS[role][direction][content.senders] || 'sendrecv'));
    }
    sdp.push('a=mid:' + content.name);

    if (desc.sources && desc.sources.length) {
        (desc.sources[0].parameters || []).forEach(function (param) {
            if (param.key === 'msid') {
                sdp.push('a=msid:' + param.value);
            }
        });
    }

    if (desc.mux) {
        sdp.push('a=rtcp-mux');
    }

    var encryption = desc.encryption || [];
    encryption.forEach(function (crypto) {
        sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));
    });
    if (desc.googConferenceFlag) {
        sdp.push('a=x-google-flag:conference');
    }

    payloads.forEach(function (payload) {
        var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;
        if (payload.channels && payload.channels != '1') {
            rtpmap += '/' + payload.channels;
        }
        sdp.push(rtpmap);

        if (payload.parameters && payload.parameters.length) {
            var fmtp = ['a=fmtp:' + payload.id];
            var parameters = [];
            payload.parameters.forEach(function (param) {
                parameters.push((param.key ? param.key + '=' : '') + param.value);
            });
            fmtp.push(parameters.join(';'));
            sdp.push(fmtp.join(' '));
        }

        if (payload.feedback) {
            payload.feedback.forEach(function (fb) {
                if (fb.type === 'trr-int') {
                    sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + (fb.value ? fb.value : '0'));
                } else {
                    sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
                }
            });
        }
    });

    if (desc.feedback) {
        desc.feedback.forEach(function (fb) {
            if (fb.type === 'trr-int') {
                sdp.push('a=rtcp-fb:* trr-int ' + (fb.value ? fb.value : '0'));
            } else {
                sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
            }
        });
    }

    var hdrExts = desc.headerExtensions || [];
    hdrExts.forEach(function (hdr) {
        sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + SENDERS[role][direction][hdr.senders] : '') + ' ' + hdr.uri);
    });

    var ssrcGroups = desc.sourceGroups || [];
    ssrcGroups.forEach(function (ssrcGroup) {
        sdp.push('a=ssrc-group:' + ssrcGroup.semantics + ' ' + ssrcGroup.sources.join(' '));
    });

    var ssrcs = desc.sources || [];
    ssrcs.forEach(function (ssrc) {
        for (var i = 0; i < ssrc.parameters.length; i++) {
            var param = ssrc.parameters[i];
            sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + param.key + (param.value ? (':' + param.value) : ''));
        }
    });

    var candidates = transport.candidates || [];
    candidates.forEach(function (candidate) {
        sdp.push(exports.toCandidateSDP(candidate));
    });

    return sdp.join('\r\n');
};

exports.toCandidateSDP = function (candidate) {
    var sdp = [];

    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.ip);
    sdp.push(candidate.port);

    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type === 'srflx' || type === 'prflx' || type === 'relay') {
        if (candidate.relAddr && candidate.relPort) {
            sdp.push('raddr');
            sdp.push(candidate.relAddr);
            sdp.push('rport');
            sdp.push(candidate.relPort);
        }
    }
    if (candidate.tcpType && candidate.protocol.toUpperCase() == 'TCP') {
        sdp.push('tcptype');
        sdp.push(candidate.tcpType);
    }

    sdp.push('generation');
    sdp.push(candidate.generation || '0');

    // FIXME: apparently this is wrong per spec
    // but then, we need this when actually putting this into
    // SDP so it's going to stay.
    // decision needs to be revisited when browsers dont
    // accept this any longer
    return 'a=candidate:' + sdp.join(' ');
};

},{"./senders":1517}],1520:[function(require,module,exports){
// based on https://github.com/ESTOS/strophe.jingle/
// adds wildemitter support
var util = require('util');
var adapter = require('webrtc-adapter-test');
var WildEmitter = require('wildemitter');

function dumpSDP(description) {
    return {
        type: description.type,
        sdp: description.sdp
    };
}

function dumpStream(stream) {
    var info = {
        label: stream.id,
    };
    if (stream.getAudioTracks().length) {
        info.audio = stream.getAudioTracks().map(function (track) {
            return track.id;
        });
    }
    if (stream.getVideoTracks().length) {
        info.video = stream.getVideoTracks().map(function (track) {
            return track.id;
        });
    }
    return info;
}

function TraceablePeerConnection(config, constraints) {
    var self = this;
    WildEmitter.call(this);

    this.peerconnection = new window.RTCPeerConnection(config, constraints);

    this.trace = function (what, info) {
        self.emit('PeerConnectionTrace', {
            time: new Date(),
            type: what,
            value: info || ""
        });
    };

    this.onicecandidate = null;
    this.peerconnection.onicecandidate = function (event) {
        self.trace('onicecandidate', event.candidate);
        if (self.onicecandidate !== null) {
            self.onicecandidate(event);
        }
    };
    this.onaddstream = null;
    this.peerconnection.onaddstream = function (event) {
        self.trace('onaddstream', dumpStream(event.stream));
        if (self.onaddstream !== null) {
            self.onaddstream(event);
        }
    };
    this.onremovestream = null;
    this.peerconnection.onremovestream = function (event) {
        self.trace('onremovestream', dumpStream(event.stream));
        if (self.onremovestream !== null) {
            self.onremovestream(event);
        }
    };
    this.onsignalingstatechange = null;
    this.peerconnection.onsignalingstatechange = function (event) {
        self.trace('onsignalingstatechange', self.signalingState);
        if (self.onsignalingstatechange !== null) {
            self.onsignalingstatechange(event);
        }
    };
    this.oniceconnectionstatechange = null;
    this.peerconnection.oniceconnectionstatechange = function (event) {
        self.trace('oniceconnectionstatechange', self.iceConnectionState);
        if (self.oniceconnectionstatechange !== null) {
            self.oniceconnectionstatechange(event);
        }
    };
    this.onnegotiationneeded = null;
    this.peerconnection.onnegotiationneeded = function (event) {
        self.trace('onnegotiationneeded');
        if (self.onnegotiationneeded !== null) {
            self.onnegotiationneeded(event);
        }
    };
    self.ondatachannel = null;
    this.peerconnection.ondatachannel = function (event) {
        self.trace('ondatachannel', event);
        if (self.ondatachannel !== null) {
            self.ondatachannel(event);
        }
    };
    this.getLocalStreams = this.peerconnection.getLocalStreams.bind(this.peerconnection);
    this.getRemoteStreams = this.peerconnection.getRemoteStreams.bind(this.peerconnection);
}

util.inherits(TraceablePeerConnection, WildEmitter);

['signalingState', 'iceConnectionState', 'localDescription', 'remoteDescription'].forEach(function (prop) {
    Object.defineProperty(TraceablePeerConnection.prototype, prop, {
        get: function () {
            return this.peerconnection[prop];
        }
    });
});

TraceablePeerConnection.prototype.addStream = function (stream) {
    this.trace('addStream', dumpStream(stream));
    this.peerconnection.addStream(stream);
};

TraceablePeerConnection.prototype.removeStream = function (stream) {
    this.trace('removeStream', dumpStream(stream));
    this.peerconnection.removeStream(stream);
};

TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
    this.trace('createDataChannel', label, opts);
    return this.peerconnection.createDataChannel(label, opts);
};

TraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setLocalDescription', dumpSDP(description));
    this.peerconnection.setLocalDescription(description,
        function () {
            self.trace('setLocalDescriptionOnSuccess');
            if (successCallback) successCallback();
        },
        function (err) {
            self.trace('setLocalDescriptionOnFailure', err);
            if (failureCallback) failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setRemoteDescription', dumpSDP(description));
    this.peerconnection.setRemoteDescription(description,
        function () {
            self.trace('setRemoteDescriptionOnSuccess');
            if (successCallback) successCallback();
        },
        function (err) {
            self.trace('setRemoteDescriptionOnFailure', err);
            if (failureCallback) failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.close = function () {
    this.trace('stop');
    if (this.peerconnection.signalingState != 'closed') {
        this.peerconnection.close();
    }
};

TraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createOffer', constraints);
    this.peerconnection.createOffer(
        function (offer) {
            self.trace('createOfferOnSuccess', dumpSDP(offer));
            if (successCallback) successCallback(offer);
        },
        function (err) {
            self.trace('createOfferOnFailure', err);
            if (failureCallback) failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createAnswer', constraints);
    this.peerconnection.createAnswer(
        function (answer) {
            self.trace('createAnswerOnSuccess', dumpSDP(answer));
            if (successCallback) successCallback(answer);
        },
        function (err) {
            self.trace('createAnswerOnFailure', err);
            if (failureCallback) failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {
    var self = this;
    this.trace('addIceCandidate', candidate);
    this.peerconnection.addIceCandidate(candidate,
        function () {
            //self.trace('addIceCandidateOnSuccess');
            if (successCallback) successCallback();
        },
        function (err) {
            self.trace('addIceCandidateOnFailure', err);
            if (failureCallback) failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.getStats = function () {
    this.peerconnection.getStats.apply(this.pc, arguments);
};

module.exports = TraceablePeerConnection;

},{"util":43,"webrtc-adapter-test":1521,"wildemitter":1603}],1521:[function(require,module,exports){
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

/* More information about these options at jshint.com/docs/options */
/* jshint browser: true, camelcase: true, curly: true, devel: true,
   eqeqeq: true, forin: false, globalstrict: true, node: true,
   quotmark: single, undef: true, unused: strict */
/* global mozRTCIceCandidate, mozRTCPeerConnection, Promise,
mozRTCSessionDescription, webkitRTCPeerConnection, MediaStreamTrack */
/* exported trace,requestUserMedia */

'use strict';

var getUserMedia = null;
var attachMediaStream = null;
var reattachMediaStream = null;
var webrtcDetectedBrowser = null;
var webrtcDetectedVersion = null;
var webrtcMinimumVersion = null;
var webrtcUtils = {
  log: function() {
    // suppress console.log output when being included as a module.
    if (!(typeof module !== 'undefined' ||
        typeof require === 'function') && (typeof define === 'function')) {
      console.log.apply(console, arguments);
    }
  }
};

function trace(text) {
  // This function is used for logging.
  if (text[text.length - 1] === '\n') {
    text = text.substring(0, text.length - 1);
  }
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    webrtcUtils.log(now + ': ' + text);
  } else {
    webrtcUtils.log(text);
  }
}

if (typeof window === 'undefined' || !window.navigator) {
  webrtcUtils.log('This does not appear to be a browser');
  webrtcDetectedBrowser = 'not a browser';
} else if (navigator.mozGetUserMedia) {
  webrtcUtils.log('This appears to be Firefox');

  webrtcDetectedBrowser = 'firefox';

  // the detected firefox version.
  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

  // the minimum firefox version still supported by adapter.
  webrtcMinimumVersion = 31;

  // The RTCPeerConnection object.
  window.RTCPeerConnection = function(pcConfig, pcConstraints) {
    if (webrtcDetectedVersion < 38) {
      // .urls is not supported in FF < 38.
      // create RTCIceServers with a single url.
      if (pcConfig && pcConfig.iceServers) {
        var newIceServers = [];
        for (var i = 0; i < pcConfig.iceServers.length; i++) {
          var server = pcConfig.iceServers[i];
          if (server.hasOwnProperty('urls')) {
            for (var j = 0; j < server.urls.length; j++) {
              var newServer = {
                url: server.urls[j]
              };
              if (server.urls[j].indexOf('turn') === 0) {
                newServer.username = server.username;
                newServer.credential = server.credential;
              }
              newIceServers.push(newServer);
            }
          } else {
            newIceServers.push(pcConfig.iceServers[i]);
          }
        }
        pcConfig.iceServers = newIceServers;
      }
    }
    return new mozRTCPeerConnection(pcConfig, pcConstraints);
  };

  // The RTCSessionDescription object.
  window.RTCSessionDescription = mozRTCSessionDescription;

  // The RTCIceCandidate object.
  window.RTCIceCandidate = mozRTCIceCandidate;

  // getUserMedia constraints shim.
  getUserMedia = (webrtcDetectedVersion < 38) ?
      function(c, onSuccess, onError) {
    var constraintsToFF37 = function(c) {
      if (typeof c !== 'object' || c.require) {
        return c;
      }
      var require = [];
      Object.keys(c).forEach(function(key) {
        var r = c[key] = (typeof c[key] === 'object') ?
            c[key] : {ideal: c[key]};
        if (r.exact !== undefined) {
          r.min = r.max = r.exact;
          delete r.exact;
        }
        if (r.min !== undefined || r.max !== undefined) {
          require.push(key);
        }
        if (r.ideal !== undefined) {
          c.advanced = c.advanced || [];
          var oc = {};
          oc[key] = {min: r.ideal, max: r.ideal};
          c.advanced.push(oc);
          delete r.ideal;
          if (!Object.keys(r).length) {
            delete c[key];
          }
        }
      });
      if (require.length) {
        c.require = require;
      }
      return c;
    };
    webrtcUtils.log('spec: ' + JSON.stringify(c));
    c.audio = constraintsToFF37(c.audio);
    c.video = constraintsToFF37(c.video);
    webrtcUtils.log('ff37: ' + JSON.stringify(c));
    return navigator.mozGetUserMedia(c, onSuccess, onError);
  } : navigator.mozGetUserMedia.bind(navigator);

  navigator.getUserMedia = getUserMedia;

  // Shim for mediaDevices on older versions.
  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: requestUserMedia,
      addEventListener: function() { },
      removeEventListener: function() { }
    };
  }
  navigator.mediaDevices.enumerateDevices =
      navigator.mediaDevices.enumerateDevices || function() {
    return new Promise(function(resolve) {
      var infos = [
        {kind: 'audioinput', deviceId: 'default', label:'', groupId:''},
        {kind: 'videoinput', deviceId: 'default', label:'', groupId:''}
      ];
      resolve(infos);
    });
  };

  if (webrtcDetectedVersion < 41) {
    // Work around http://bugzil.la/1169665
    var orgEnumerateDevices =
        navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);
    navigator.mediaDevices.enumerateDevices = function() {
      return orgEnumerateDevices().catch(function(e) {
        if (e.name === 'NotFoundError') {
          return [];
        }
        throw e;
      });
    };
  }
  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    element.mozSrcObject = stream;
  };

  reattachMediaStream = function(to, from) {
    to.mozSrcObject = from.mozSrcObject;
  };

} else if (navigator.webkitGetUserMedia) {
  webrtcUtils.log('This appears to be Chrome');

  webrtcDetectedBrowser = 'chrome';

  // the detected chrome version.
  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);

  // the minimum chrome version still supported by adapter.
  webrtcMinimumVersion = 38;

  // The RTCPeerConnection object.
  window.RTCPeerConnection = function(pcConfig, pcConstraints) {
    var pc = new webkitRTCPeerConnection(pcConfig, pcConstraints);
    var origGetStats = pc.getStats.bind(pc);
    pc.getStats = function(selector, successCallback, errorCallback) { // jshint ignore: line
      // If selector is a function then we are in the old style stats so just
      // pass back the original getStats format to avoid breaking old users.
      if (typeof selector === 'function') {
        return origGetStats(selector, successCallback);
      }

      var fixChromeStats = function(response) {
        var standardReport = {};
        var reports = response.result();
        reports.forEach(function(report) {
          var standardStats = {
            id: report.id,
            timestamp: report.timestamp,
            type: report.type
          };
          report.names().forEach(function(name) {
            standardStats[name] = report.stat(name);
          });
          standardReport[standardStats.id] = standardStats;
        });

        return standardReport;
      };
      var successCallbackWrapper = function(response) {
        successCallback(fixChromeStats(response));
      };
      return origGetStats(successCallbackWrapper, selector);
    };

    return pc;
  };

  // add promise support
  ['createOffer', 'createAnswer'].forEach(function(method) {
    var nativeMethod = webkitRTCPeerConnection.prototype[method];
    webkitRTCPeerConnection.prototype[method] = function() {
      var self = this;
      if (arguments.length < 1 || (arguments.length === 1 &&
          typeof(arguments[0]) === 'object')) {
        var opts = arguments.length === 1 ? arguments[0] : undefined;
        return new Promise(function(resolve, reject) {
          nativeMethod.apply(self, [resolve, reject, opts]);
        });
      } else {
        return nativeMethod.apply(this, arguments);
      }
    };
  });

  ['setLocalDescription', 'setRemoteDescription',
      'addIceCandidate'].forEach(function(method) {
    var nativeMethod = webkitRTCPeerConnection.prototype[method];
    webkitRTCPeerConnection.prototype[method] = function() {
      var args = arguments;
      var self = this;
      return new Promise(function(resolve, reject) {
        nativeMethod.apply(self, [args[0],
            function() {
              resolve();
              if (args.length >= 2) {
                args[1].apply(null, []);
              }
            },
            function(err) {
              reject(err);
              if (args.length >= 3) {
                args[2].apply(null, [err]);
              }
            }]
          );
      });
    };
  });

  // getUserMedia constraints shim.
  var constraintsToChrome = function(c) {
    if (typeof c !== 'object' || c.mandatory || c.optional) {
      return c;
    }
    var cc = {};
    Object.keys(c).forEach(function(key) {
      if (key === 'require' || key === 'advanced') {
        return;
      }
      var r = (typeof c[key] === 'object') ? c[key] : {ideal: c[key]};
      if (r.exact !== undefined && typeof r.exact === 'number') {
        r.min = r.max = r.exact;
      }
      var oldname = function(prefix, name) {
        if (prefix) {
          return prefix + name.charAt(0).toUpperCase() + name.slice(1);
        }
        return (name === 'deviceId') ? 'sourceId' : name;
      };
      if (r.ideal !== undefined) {
        cc.optional = cc.optional || [];
        var oc = {};
        if (typeof r.ideal === 'number') {
          oc[oldname('min', key)] = r.ideal;
          cc.optional.push(oc);
          oc = {};
          oc[oldname('max', key)] = r.ideal;
          cc.optional.push(oc);
        } else {
          oc[oldname('', key)] = r.ideal;
          cc.optional.push(oc);
        }
      }
      if (r.exact !== undefined && typeof r.exact !== 'number') {
        cc.mandatory = cc.mandatory || {};
        cc.mandatory[oldname('', key)] = r.exact;
      } else {
        ['min', 'max'].forEach(function(mix) {
          if (r[mix] !== undefined) {
            cc.mandatory = cc.mandatory || {};
            cc.mandatory[oldname(mix, key)] = r[mix];
          }
        });
      }
    });
    if (c.advanced) {
      cc.optional = (cc.optional || []).concat(c.advanced);
    }
    return cc;
  };

  getUserMedia = function(c, onSuccess, onError) {
    c.audio = constraintsToChrome(c.audio);
    c.video = constraintsToChrome(c.video);
    webrtcUtils.log('chrome: ' + JSON.stringify(c));
    return navigator.webkitGetUserMedia(c, onSuccess, onError);
  };
  navigator.getUserMedia = getUserMedia;

  if (!navigator.mediaDevices) {
    navigator.mediaDevices = {getUserMedia: requestUserMedia,
                              enumerateDevices: function() {
      return new Promise(function(resolve) {
        var kinds = {audio: 'audioinput', video: 'videoinput'};
        return MediaStreamTrack.getSources(function(devices) {
          resolve(devices.map(function(device) {
            return {label: device.label,
                    kind: kinds[device.kind],
                    deviceId: device.id,
                    groupId: ''};
          }));
        });
      });
    }};
  }

  // A shim for getUserMedia method on the mediaDevices object.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (!navigator.mediaDevices.getUserMedia) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      return requestUserMedia(constraints);
    };
  } else {
    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia
    // function which returns a Promise, it does not accept spec-style
    // constraints.
    var origGetUserMedia = navigator.mediaDevices.getUserMedia.
        bind(navigator.mediaDevices);
    navigator.mediaDevices.getUserMedia = function(c) {
      webrtcUtils.log('spec:   ' + JSON.stringify(c)); // whitespace for alignment
      c.audio = constraintsToChrome(c.audio);
      c.video = constraintsToChrome(c.video);
      webrtcUtils.log('chrome: ' + JSON.stringify(c));
      return origGetUserMedia(c);
    };
  }

  // Dummy devicechange event methods.
  // TODO(KaptenJansson) remove once implemented in Chrome stable.
  if (typeof navigator.mediaDevices.addEventListener === 'undefined') {
    navigator.mediaDevices.addEventListener = function() {
      webrtcUtils.log('Dummy mediaDevices.addEventListener called.');
    };
  }
  if (typeof navigator.mediaDevices.removeEventListener === 'undefined') {
    navigator.mediaDevices.removeEventListener = function() {
      webrtcUtils.log('Dummy mediaDevices.removeEventListener called.');
    };
  }

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    if (typeof element.srcObject !== 'undefined') {
      element.srcObject = stream;
    } else if (typeof element.src !== 'undefined') {
      element.src = URL.createObjectURL(stream);
    } else {
      webrtcUtils.log('Error attaching stream to element.');
    }
  };

  reattachMediaStream = function(to, from) {
    to.src = from.src;
  };

} else if (navigator.mediaDevices && navigator.userAgent.match(
    /Edge\/(\d+).(\d+)$/)) {
  webrtcUtils.log('This appears to be Edge');
  webrtcDetectedBrowser = 'edge';

  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Edge\/(\d+).(\d+)$/)[2], 10);

  // the minimum version still supported by adapter.
  webrtcMinimumVersion = 12;

  getUserMedia = navigator.getUserMedia;

  attachMediaStream = function(element, stream) {
    element.srcObject = stream;
  };
  reattachMediaStream = function(to, from) {
    to.srcObject = from.srcObject;
  };
} else {
  webrtcUtils.log('Browser does not appear to be WebRTC-capable');
}

// Returns the result of getUserMedia as a Promise.
function requestUserMedia(constraints) {
  return new Promise(function(resolve, reject) {
    getUserMedia(constraints, resolve, reject);
  });
}

if (typeof module !== 'undefined') {
  var RTCPeerConnection;
  if (typeof window !== 'undefined') {
    RTCPeerConnection = window.RTCPeerConnection;
  }
  module.exports = {
    RTCPeerConnection: RTCPeerConnection,
    getUserMedia: getUserMedia,
    attachMediaStream: attachMediaStream,
    reattachMediaStream: reattachMediaStream,
    webrtcDetectedBrowser: webrtcDetectedBrowser,
    webrtcDetectedVersion: webrtcDetectedVersion,
    webrtcMinimumVersion: webrtcMinimumVersion
    //requestUserMedia: not exposed on purpose.
    //trace: not exposed on purpose.
  };
} else if ((typeof require === 'function') && (typeof define === 'function')) {
  // Expose objects and functions when RequireJS is doing the loading.
  define([], function() {
    return {
      RTCPeerConnection: window.RTCPeerConnection,
      getUserMedia: getUserMedia,
      attachMediaStream: attachMediaStream,
      reattachMediaStream: reattachMediaStream,
      webrtcDetectedBrowser: webrtcDetectedBrowser,
      webrtcDetectedVersion: webrtcDetectedVersion,
      webrtcMinimumVersion: webrtcMinimumVersion
      //requestUserMedia: not exposed on purpose.
      //trace: not exposed on purpose.
    };
  });
}

},{}],1522:[function(require,module,exports){
var util = require('util');
var each = require('lodash.foreach');
var pluck = require('lodash.pluck');
var SJJ = require('sdp-jingle-json');
var WildEmitter = require('wildemitter');
var peerconn = require('traceablepeerconnection');
var adapter = require('webrtc-adapter-test');

function PeerConnection(config, constraints) {
    var self = this;
    var item;
    WildEmitter.call(this);

    config = config || {};
    config.iceServers = config.iceServers || [];

    // make sure this only gets enabled in Google Chrome
    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableChromeNativeSimulcast = false;
    if (constraints && constraints.optional &&
            adapter.webrtcDetectedBrowser === 'chrome' &&
            navigator.appVersion.match(/Chromium\//) === null) {
        constraints.optional.forEach(function (constraint) {
            if (constraint.enableChromeNativeSimulcast) {
                self.enableChromeNativeSimulcast = true;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableMultiStreamHacks = false;
    if (constraints && constraints.optional &&
            adapter.webrtcDetectedBrowser === 'chrome') {
        constraints.optional.forEach(function (constraint) {
            if (constraint.enableMultiStreamHacks) {
                self.enableMultiStreamHacks = true;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    this.restrictBandwidth = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint) {
            if (constraint.andyetRestrictBandwidth) {
                self.restrictBandwidth = constraint.andyetRestrictBandwidth;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // bundle up ice candidates, only works for jingle mode
    // number > 0 is the delay to wait for additional candidates
    // ~20ms seems good
    this.batchIceCandidates = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint) {
            if (constraint.andyetBatchIce) {
                self.batchIceCandidates = constraint.andyetBatchIce;
            }
        });
    }
    this.batchedIceCandidates = [];

    // EXPERIMENTAL FLAG, might get removed without notice
    // this attemps to strip out candidates with an already known foundation
    // and type -- i.e. those which are gathered via the same TURN server
    // but different transports (TURN udp, tcp and tls respectively)
    if (constraints && constraints.optional && adapter.webrtcDetectedBrowser === 'chrome') {
        constraints.optional.forEach(function (constraint) {
            if (constraint.andyetFasterICE) {
                self.eliminateDuplicateCandidates = constraint.andyetFasterICE;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    // when using a server such as the jitsi videobridge we don't need to signal
    // our candidates
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint) {
            if (constraint.andyetDontSignalCandidates) {
                self.dontSignalCandidates = constraint.andyetDontSignalCandidates;
            }
        });
    }


    // EXPERIMENTAL FLAG, might get removed without notice
    this.assumeSetLocalSuccess = false;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint) {
            if (constraint.andyetAssumeSetLocalSuccess) {
                self.assumeSetLocalSuccess = constraint.andyetAssumeSetLocalSuccess;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // working around https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
    // pass in a timeout for this
    if (adapter.webrtcDetectedBrowser === 'firefox') {
        if (constraints && constraints.optional) {
            this.wtFirefox = 0;
            constraints.optional.forEach(function (constraint) {
                if (constraint.andyetFirefoxMakesMeSad) {
                    self.wtFirefox = constraint.andyetFirefoxMakesMeSad;
                    if (self.wtFirefox > 0) {
                        self.firefoxcandidatebuffer = [];
                    }
                }
            });
        }
    }


    this.pc = new peerconn(config, constraints);

    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);
    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);
    this.addStream = this.pc.addStream.bind(this.pc);
    this.removeStream = this.pc.removeStream.bind(this.pc);

    // proxy events
    this.pc.on('*', function () {
        self.emit.apply(self, arguments);
    });

    // proxy some events directly
    this.pc.onremovestream = this.emit.bind(this, 'removeStream');
    this.pc.onaddstream = this.emit.bind(this, 'addStream');
    this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
    this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
    this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');

    // handle ice candidate and data channel events
    this.pc.onicecandidate = this._onIce.bind(this);
    this.pc.ondatachannel = this._onDataChannel.bind(this);

    this.localDescription = {
        contents: []
    };
    this.remoteDescription = {
        contents: []
    };

    this.config = {
        debug: false,
        ice: {},
        sid: '',
        isInitiator: true,
        sdpSessionID: Date.now(),
        useJingle: false
    };

    // apply our config
    for (item in config) {
        this.config[item] = config[item];
    }

    if (this.config.debug) {
        this.on('*', function () {
            var logger = config.logger || console;
            logger.log('PeerConnection event:', arguments);
        });
    }
    this.hadLocalStunCandidate = false;
    this.hadRemoteStunCandidate = false;
    this.hadLocalRelayCandidate = false;
    this.hadRemoteRelayCandidate = false;

    this.hadLocalIPv6Candidate = false;
    this.hadRemoteIPv6Candidate = false;

    // keeping references for all our data channels
    // so they dont get garbage collected
    // can be removed once the following bugs have been fixed
    // https://crbug.com/405545
    // https://bugzilla.mozilla.org/show_bug.cgi?id=964092
    // to be filed for opera
    this._remoteDataChannels = [];
    this._localDataChannels = [];

    this._candidateBuffer = [];
}

util.inherits(PeerConnection, WildEmitter);

Object.defineProperty(PeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.pc.signalingState;
    }
});
Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.pc.iceConnectionState;
    }
});

PeerConnection.prototype._role = function () {
    return this.isInitiator ? 'initiator' : 'responder';
};

// Add a stream to the peer connection object
PeerConnection.prototype.addStream = function (stream) {
    this.localStream = stream;
    this.pc.addStream(stream);
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkLocalCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadLocalStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadLocalRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadLocalIPv6Candidate = true;
    }
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkRemoteCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadRemoteStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadRemoteRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadRemoteIPv6Candidate = true;
    }
};


// Init and add ice candidate object with correct constructor
PeerConnection.prototype.processIce = function (update, cb) {
    cb = cb || function () {};
    var self = this;

    // ignore any added ice candidates to avoid errors. why does the
    // spec not do this?
    if (this.pc.signalingState === 'closed') return cb();

    if (update.contents || (update.jingle && update.jingle.contents)) {
        var contentNames = pluck(this.remoteDescription.contents, 'name');
        var contents = update.contents || update.jingle.contents;

        contents.forEach(function (content) {
            var transport = content.transport || {};
            var candidates = transport.candidates || [];
            var mline = contentNames.indexOf(content.name);
            var mid = content.name;

            candidates.forEach(
                function (candidate) {
                var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
                self.pc.addIceCandidate(
                    new RTCIceCandidate({
                        candidate: iceCandidate,
                        sdpMLineIndex: mline,
                        sdpMid: mid
                    }), function () {
                        // well, this success callback is pretty meaningless
                    },
                    function (err) {
                        self.emit('error', err);
                    }
                );
                self._checkRemoteCandidate(iceCandidate);
            });
        });
    } else {
        // working around https://code.google.com/p/webrtc/issues/detail?id=3669
        if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {
            update.candidate.candidate = 'a=' + update.candidate.candidate;
        }

        if (this.wtFirefox && this.firefoxcandidatebuffer !== null) {
            // we cant add this yet due to https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
            if (this.pc.localDescription && this.pc.localDescription.type === 'offer') {
                this.firefoxcandidatebuffer.push(update.candidate);
                return cb();
            }
        }

        self.pc.addIceCandidate(
            new RTCIceCandidate(update.candidate),
            function () { },
            function (err) {
                self.emit('error', err);
            }
        );
        self._checkRemoteCandidate(update.candidate.candidate);
    }
    cb();
};

// Generate and emit an offer with the given constraints
PeerConnection.prototype.offer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };
    cb = hasConstraints ? cb : constraints;
    cb = cb || function () {};

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    // Actually generate the offer
    this.pc.createOffer(
        function (offer) {
            // does not work for jingle, but jingle.js doesn't need
            // this hack...
            var expandedOffer = {
                type: 'offer',
                sdp: offer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                self.emit('offer', expandedOffer);
                cb(null, expandedOffer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(offer,
                function () {
                    var jingle;
                    if (self.config.useJingle) {
                        jingle = SJJ.toSessionJSON(offer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;

                        // Save ICE credentials
                        each(jingle.contents, function (content) {
                            var transport = content.transport || {};
                            if (transport.ufrag) {
                                self.config.ice[content.name] = {
                                    ufrag: transport.ufrag,
                                    pwd: transport.pwd
                                };
                            }
                        });

                        expandedOffer.jingle = jingle;
                    }
                    expandedOffer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });

                    if (!self.assumeSetLocalSuccess) {
                        self.emit('offer', expandedOffer);
                        cb(null, expandedOffer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        mediaConstraints
    );
};


// Process an incoming offer so that ICE may proceed before deciding
// to answer the request.
PeerConnection.prototype.handleOffer = function (offer, cb) {
    cb = cb || function () {};
    var self = this;
    offer.type = 'offer';
    if (offer.jingle) {
        if (this.enableChromeNativeSimulcast) {
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    content.description.googConferenceFlag = true;
                }
            });
        }
        if (this.enableMultiStreamHacks) {
            // add a mixed video stream as first stream
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    var sources = content.description.sources || [];
                    if (sources.length === 0 || sources[0].ssrc !== "3735928559") {
                        sources.unshift({
                            ssrc: "3735928559", // 0xdeadbeef
                            parameters: [
                                {
                                    key: "cname",
                                    value: "deadbeef"
                                },
                                {
                                    key: "msid",
                                    value: "mixyourfecintothis please"
                                }
                            ]
                        });
                        content.description.sources = sources;
                    }
                }
            });
        }
        if (self.restrictBandwidth > 0) {
            if (offer.jingle.contents.length >= 2 && offer.jingle.contents[1].name === 'video') {
                var content = offer.jingle.contents[1];
                var hasBw = content.description && content.description.bandwidth;
                if (!hasBw) {
                    offer.jingle.contents[1].description.bandwidth = { type: 'AS', bandwidth: self.restrictBandwidth.toString() };
                    offer.sdp = SJJ.toSessionSDP(offer.jingle, {
                        sid: self.config.sdpSessionID,
                        role: self._role(),
                        direction: 'outgoing'
                    });
                }
            }
        }
        offer.sdp = SJJ.toSessionSDP(offer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = offer.jingle;
    }
    offer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(new RTCSessionDescription(offer),
        function () {
            cb();
        },
        cb
    );
};

// Answer an offer with audio only
PeerConnection.prototype.answerAudioOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer without offering to recieve
PeerConnection.prototype.answerBroadcastOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer with given constraints default is audio/video
PeerConnection.prototype.answer = function (constraints, cb) {
    var hasConstraints = arguments.length === 2;
    var callback = hasConstraints ? cb : constraints;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };

    this._answer(mediaConstraints, callback);
};

// Process an answer
PeerConnection.prototype.handleAnswer = function (answer, cb) {
    cb = cb || function () {};
    var self = this;
    if (answer.jingle) {
        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = answer.jingle;
    }
    answer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(
        new RTCSessionDescription(answer),
        function () {
            if (self.wtFirefox) {
                window.setTimeout(function () {
                    self.firefoxcandidatebuffer.forEach(function (candidate) {
                        // add candidates later
                        self.pc.addIceCandidate(
                            new RTCIceCandidate(candidate),
                            function () { },
                            function (err) {
                                self.emit('error', err);
                            }
                        );
                        self._checkRemoteCandidate(candidate.candidate);
                    });
                    self.firefoxcandidatebuffer = null;
                }, self.wtFirefox);
            }
            cb(null);
        },
        cb
    );
};

// Close the peer connection
PeerConnection.prototype.close = function () {
    this.pc.close();

    this._localDataChannels = [];
    this._remoteDataChannels = [];

    this.emit('close');
};

// Internal code sharing for various types of answer methods
PeerConnection.prototype._answer = function (constraints, cb) {
    cb = cb || function () {};
    var self = this;
    if (!this.pc.remoteDescription) {
        // the old API is used, call handleOffer
        throw new Error('remoteDescription not set');
    }

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    self.pc.createAnswer(
        function (answer) {
            var sim = [];
            if (self.enableChromeNativeSimulcast) {
                // native simulcast part 1: add another SSRC
                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
                    var groups = answer.jingle.contents[1].description.sourceGroups || [];
                    var hasSim = false;
                    groups.forEach(function (group) {
                        if (group.semantics == 'SIM') hasSim = true;
                    });
                    if (!hasSim &&
                        answer.jingle.contents[1].description.sources.length) {
                        var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].description.sources[0]));
                        newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(newssrc);

                        sim.push(answer.jingle.contents[1].description.sources[0].ssrc);
                        sim.push(newssrc.ssrc);
                        groups.push({
                            semantics: 'SIM',
                            sources: sim
                        });

                        // also create an RTX one for the SIM one
                        var rtxssrc = JSON.parse(JSON.stringify(newssrc));
                        rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(rtxssrc);
                        groups.push({
                            semantics: 'FID',
                            sources: [newssrc.ssrc, rtxssrc.ssrc]
                        });

                        answer.jingle.contents[1].description.sourceGroups = groups;
                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
                            sid: self.config.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                }
            }
            var expandedAnswer = {
                type: 'answer',
                sdp: answer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                // not safe to do when doing simulcast mangling
                self.emit('answer', expandedAnswer);
                cb(null, expandedAnswer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(answer,
                function () {
                    if (self.config.useJingle) {
                        var jingle = SJJ.toSessionJSON(answer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;
                        expandedAnswer.jingle = jingle;
                    }
                    if (self.enableChromeNativeSimulcast) {
                        // native simulcast part 2:
                        // signal multiple tracks to the receiver
                        // for anything in the SIM group
                        if (!expandedAnswer.jingle) {
                            expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {
                                role: self._role(),
                                direction: 'outgoing'
                            });
                        }
                        expandedAnswer.jingle.contents[1].description.sources.forEach(function (source, idx) {
                            // the floor idx/2 is a hack that relies on a particular order
                            // of groups, alternating between sim and rtx
                            source.parameters = source.parameters.map(function (parameter) {
                                if (parameter.key === 'msid') {
                                    parameter.value += '-' + Math.floor(idx / 2);
                                }
                                return parameter;
                            });
                        });
                        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {
                            sid: self.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                    expandedAnswer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });
                    if (!self.assumeSetLocalSuccess) {
                        self.emit('answer', expandedAnswer);
                        cb(null, expandedAnswer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        constraints
    );
};

// Internal method for emitting ice candidates on our peer object
PeerConnection.prototype._onIce = function (event) {
    var self = this;
    if (event.candidate) {
        if (this.dontSignalCandidates) return;
        var ice = event.candidate;

        var expandedCandidate = {
            candidate: {
                candidate: ice.candidate,
                sdpMid: ice.sdpMid,
                sdpMLineIndex: ice.sdpMLineIndex
            }
        };
        this._checkLocalCandidate(ice.candidate);

        var cand = SJJ.toCandidateJSON(ice.candidate);

        var already;
        var idx;
        if (this.eliminateDuplicateCandidates && cand.type === 'relay') {
            // drop candidates with same foundation, component
            // take local type pref into account so we don't ignore udp
            // ones when we know about a TCP one. unlikely but...
            already = this._candidateBuffer.filter(
                function (c) {
                    return c.type === 'relay';
                }).map(function (c) {
                    return c.foundation + ':' + c.component;
                }
            );
            idx = already.indexOf(cand.foundation + ':' + cand.component);
            // remember: local type pref of udp is 0, tcp 1, tls 2
            if (idx > -1 && ((cand.priority >> 24) >= (already[idx].priority >> 24))) {
                // drop it, same foundation with higher (worse) type pref
                return;
            }
        }
        if (this.config.bundlePolicy === 'max-bundle') {
            // drop candidates which are duplicate for audio/video/data
            // duplicate means same host/port but different sdpMid
            already = this._candidateBuffer.filter(
                function (c) {
                    return cand.type === c.type;
                }).map(function (cand) {
                    return cand.address + ':' + cand.port;
                }
            );
            idx = already.indexOf(cand.address + ':' + cand.port);
            if (idx > -1) return;
        }
        // also drop rtcp candidates since we know the peer supports RTCP-MUX
        // this is a workaround until browsers implement this natively
        if (this.config.rtcpMuxPolicy === 'require' && cand.component === '2') {
            return;
        }
        this._candidateBuffer.push(cand);

        if (self.config.useJingle) {
            if (!ice.sdpMid) { // firefox doesn't set this
                if (self.pc.remoteDescription && self.pc.remoteDescription.type === 'offer') {
                    // preserve name from remote
                    ice.sdpMid = self.remoteDescription.contents[ice.sdpMLineIndex].name;
                } else {
                    ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;
                }
            }
            if (!self.config.ice[ice.sdpMid]) {
                var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                each(jingle.contents, function (content) {
                    var transport = content.transport || {};
                    if (transport.ufrag) {
                        self.config.ice[content.name] = {
                            ufrag: transport.ufrag,
                            pwd: transport.pwd
                        };
                    }
                });
            }
            expandedCandidate.jingle = {
                contents: [{
                    name: ice.sdpMid,
                    creator: self._role(),
                    transport: {
                        transType: 'iceUdp',
                        ufrag: self.config.ice[ice.sdpMid].ufrag,
                        pwd: self.config.ice[ice.sdpMid].pwd,
                        candidates: [
                            cand
                        ]
                    }
                }]
            };
            if (self.batchIceCandidates > 0) {
                if (self.batchedIceCandidates.length === 0) {
                    window.setTimeout(function () {
                        var contents = {};
                        self.batchedIceCandidates.forEach(function (content) {
                            content = content.contents[0];
                            if (!contents[content.name]) contents[content.name] = content;
                            contents[content.name].transport.candidates.push(content.transport.candidates[0]);
                        });
                        var newCand = {
                            jingle: {
                                contents: []
                            }
                        };
                        Object.keys(contents).forEach(function (name) {
                            newCand.jingle.contents.push(contents[name]);
                        });
                        self.batchedIceCandidates = [];
                        self.emit('ice', newCand);
                    }, self.batchIceCandidates);
                }
                self.batchedIceCandidates.push(expandedCandidate.jingle);
                return;
            }

        }
        this.emit('ice', expandedCandidate);
    } else {
        this.emit('endOfCandidates');
    }
};

// Internal method for processing a new data channel being added by the
// other peer.
PeerConnection.prototype._onDataChannel = function (event) {
    // make sure we keep a reference so this doesn't get garbage collected
    var channel = event.channel;
    this._remoteDataChannels.push(channel);

    this.emit('addChannel', channel);
};

// Create a data channel spec reference:
// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
PeerConnection.prototype.createDataChannel = function (name, opts) {
    var channel = this.pc.createDataChannel(name, opts);

    // make sure we keep a reference so this doesn't get garbage collected
    this._localDataChannels.push(channel);

    return channel;
};

// a wrapper around getStats which hides the differences (where possible)
// TODO: remove in favor of adapter.js shim
PeerConnection.prototype.getStats = function (cb) {
    if (adapter.webrtcDetectedBrowser === 'firefox') {
        this.pc.getStats(
            function (res) {
                var items = [];
                for (var result in res) {
                    if (typeof res[result] === 'object') {
                        items.push(res[result]);
                    }
                }
                cb(null, items);
            },
            cb
        );
    } else {
        this.pc.getStats(function (res) {
            var items = [];
            res.result().forEach(function (result) {
                var item = {};
                result.names().forEach(function (name) {
                    item[name] = result.stat(name);
                });
                item.id = result.id;
                item.type = result.type;
                item.timestamp = result.timestamp;
                items.push(item);
            });
            cb(null, items);
        });
    }
};

module.exports = PeerConnection;

},{"lodash.foreach":1492,"lodash.pluck":1500,"sdp-jingle-json":1515,"traceablepeerconnection":1520,"util":43,"webrtc-adapter-test":1521,"wildemitter":1603}],1523:[function(require,module,exports){
var util = require('util');
var extend = require('extend-object');
var BaseSession = require('jingle-session');
var RTCPeerConnection = require('rtcpeerconnection');


function filterContentSources(content, stream) {
    delete content.transport;
    delete content.description.payloads;
    if (content.description.sources) {
        content.description.sources = content.description.sources.filter(function (source) {
            return stream.id === source.parameters[1].value.split(' ')[0];
        });
    }
}

function filterUnusedLabels(content) {
    // Remove mslabel and label ssrc-specific attributes
    var sources = content.description.sources || [];
    sources.forEach(function (source) {
        source.parameters = source.parameters.filter(function (parameter) {
            return !(parameter.key === 'mslabel' || parameter.key === 'label');
        });
    });
}


function MediaSession(opts) {
    BaseSession.call(this, opts);

    this.pc = new RTCPeerConnection({
        iceServers: opts.iceServers || [],
        useJingle: true
    }, opts.constraints || {});

    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
    this.pc.on('addStream', this.onAddStream.bind(this));
    this.pc.on('removeStream', this.onRemoveStream.bind(this));

    if (opts.stream) {
        this.addStream(opts.stream);
    }

    this._ringing = false;
}


util.inherits(MediaSession, BaseSession);


Object.defineProperties(MediaSession.prototype, {
    ringing: {
        get: function () {
            return this._ringing;
        },
        set: function (value) {
            if (value !== this._ringing) {
                this._ringing = value;
                this.emit('change:ringing', value);
            }
        }
    },
    streams: {
        get: function () {
            if (this.pc.signalingState !== 'closed') {
                return this.pc.getRemoteStreams();
            }
            return [];
        }
    }
});


MediaSession.prototype = extend(MediaSession.prototype, {

    // ----------------------------------------------------------------
    // Session control methods
    // ----------------------------------------------------------------

    start: function (constraints, next) {
        var self = this;
        this.state = 'pending';

        next = next || function () {};

        this.pc.isInitiator = true;
        this.pc.offer(constraints, function (err, offer) {
            if (err) {
                self._log('error', 'Could not create WebRTC offer', err);
                return self.end('failed-application', true);
            }

            // a workaround for missing a=sendonly
            // https://code.google.com/p/webrtc/issues/detail?id=1553
            if (constraints && constraints.mandatory) {
                offer.jingle.contents.forEach(function (content) {
                    var mediaType = content.description.media;

                    if (!content.description || content.description.descType !== 'rtp') {
                        return;
                    }

                    if (!constraints.mandatory.OfferToReceiveAudio && mediaType === 'audio') {
                        content.senders = 'initiator';
                    }

                    if (!constraints.mandatory.OfferToReceiveVideo && mediaType === 'video') {
                        content.senders = 'initiator';
                    }
                });
            }

            offer.jingle.contents.forEach(filterUnusedLabels);

            self.send('session-initiate', offer.jingle);

            next();
        });
    },

    accept: function (next) {
        var self = this;

        next = next || function () {};

        this._log('info', 'Accepted incoming session');

        this.state = 'active';

        this.pc.answer(function (err, answer) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer', err);
                return self.end('failed-application');
            }

            answer.jingle.contents.forEach(filterUnusedLabels);

            self.send('session-accept', answer.jingle);

            next();
        });
    },

    end: function (reason, silent) {
        var self = this;
        this.streams.forEach(function (stream) {
            self.onRemoveStream({stream: stream});
        });
        this.pc.close();
        BaseSession.prototype.end.call(this, reason, silent);
    },

    ring: function () {
        this._log('info', 'Ringing on incoming session');
        this.ringing = true;
        this.send('session-info', {ringing: true});
    },

    mute: function (creator, name) {
        this._log('info', 'Muting', name);

        this.send('session-info', {
            mute: {
                creator: creator,
                name: name
            }
        });
    },

    unmute: function (creator, name) {
        this._log('info', 'Unmuting', name);
        this.send('session-info', {
            unmute: {
                creator: creator,
                name: name
            }
        });
    },

    hold: function () {
        this._log('info', 'Placing on hold');
        this.send('session-info', {hold: true});
    },

    resume: function () {
        this._log('info', 'Resuming from hold');
        this.send('session-info', {active: true});
    },

    // ----------------------------------------------------------------
    // Stream control methods
    // ----------------------------------------------------------------

    addStream: function (stream, renegotiate, cb) {
        var self = this;

        cb = cb || function () {};

        this.pc.addStream(stream);

        if (!renegotiate) {
            return;
        }

        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create offer for adding new stream');
                return cb(err);
            }
            self.pc.answer(function (err, answer) {
                if (err) {
                    self._log('error', 'Could not create answer for adding new stream');
                    return cb(err);
                }
                answer.jingle.contents.forEach(function (content) {
                    filterContentSources(content, stream);
                });

                self.send('source-add', answer.jingle);
                cb();
            });
        });
    },

    addStream2: function (stream, cb) {
        this.addStream(stream, true, cb);
    },

    removeStream: function (stream, renegotiate, cb) {
        var self = this;

        cb = cb || function () {};

        if (!renegotiate) {
            this.pc.removeStream(stream);
            return;
        }

        var desc = this.pc.localDescription;
        desc.contents.forEach(function (content) {
            filterContentSources(content, stream);
        });

        this.send('source-remove', desc);
        this.pc.removeStream(stream);

        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process offer for removing stream');
                return cb(err);
            }
            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Could not process answer for removing stream');
                    return cb(err);
                }
                cb();
            });
        });
    },

    removeStream2: function (stream, cb) {
        this.removeStream(stream, true, cb);
    },

    switchStream: function (oldStream, newStream, cb) {
        var self = this;

        cb = cb || function () {};

        var desc = this.pc.localDescription;
        desc.contents.forEach(function (content) {
            delete content.transport;
            delete content.description.payloads;
        });

        this.pc.removeStream(oldStream);
        this.send('source-remove', desc);

        var audioTracks = oldStream.getAudioTracks();
        if (audioTracks.length) {
            newStream.addTrack(audioTracks[0]);
        }

        this.pc.addStream(newStream);
        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process offer for switching streams');
                return cb(err);
            }
            self.pc.answer(function (err, answer) {
                if (err) {
                    self._log('error', 'Could not process answer for switching streams');
                    return cb(err);
                }
                answer.jingle.contents.forEach(function (content) {
                    delete content.transport;
                    delete content.description.payloads;
                });
                self.send('source-add', answer.jingle);
                cb();
            });
        });
    },

    // ----------------------------------------------------------------
    // ICE action handers
    // ----------------------------------------------------------------

    onIceCandidate: function (candidate) {
        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
        this.send('transport-info', candidate.jingle);
    },

    onIceStateChange: function () {
        switch (this.pc.iceConnectionState) {
            case 'checking':
                this.connectionState = 'connecting';
                break;
            case 'completed':
            case 'connected':
                this.connectionState = 'connected';
                break;
            case 'disconnected':
                if (this.pc.signalingState === 'stable') {
                    this.connectionState = 'interrupted';
                } else {
                    this.connectionState = 'disconnected';
                }
                break;
            case 'failed':
                this.connectionState = 'failed';
                this.end('failed-transport');
                break;
            case 'closed':
                this.connectionState = 'disconnected';
                break;
        }
    },

    // ----------------------------------------------------------------
    // Stream event handlers
    // ----------------------------------------------------------------

    onAddStream: function (event) {
        this._log('info', 'Stream added');
        this.emit('peerStreamAdded', this, event.stream);
    },

    onRemoveStream: function (event) {
        this._log('info', 'Stream removed');
        this.emit('peerStreamRemoved', this, event.stream);
    },

    // ----------------------------------------------------------------
    // Jingle action handers
    // ----------------------------------------------------------------

    onSessionInitiate: function (changes, cb) {
        var self = this;

        this._log('info', 'Initiating incoming session');

        this.state = 'pending';

        this.pc.isInitiator = false;
        this.pc.handleOffer({
            type: 'offer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer');
                return cb({condition: 'general-error'});
            }
            cb();
        });
    },

    onSessionAccept: function (changes, cb) {
        var self = this;

        this.state = 'active';
        this.pc.handleAnswer({
            type: 'answer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process WebRTC answer');
                return cb({condition: 'general-error'});
            }
            self.emit('accepted', self);
            cb();
        });
    },

    onSessionTerminate: function (changes, cb) {
        var self = this;

        this._log('info', 'Terminating session');
        this.streams.forEach(function (stream) {
            self.onRemoveStream({stream: stream});
        });
        this.pc.close();
        BaseSession.prototype.end.call(this, changes.reason, true);

        cb();
    },

    onSessionInfo: function (info, cb) {
        if (info.ringing) {
            this._log('info', 'Outgoing session is ringing');
            this.ringing = true;
            this.emit('ringing', this);
            return cb();
        }

        if (info.hold) {
            this._log('info', 'On hold');
            this.emit('hold', this);
            return cb();
        }

        if (info.active) {
            this._log('info', 'Resuming from hold');
            this.emit('resumed', this);
            return cb();
        }

        if (info.mute) {
            this._log('info', 'Muting', info.mute);
            this.emit('mute', this, info.mute);
            return cb();
        }

        if (info.unmute) {
            this._log('info', 'Unmuting', info.unmute);
            this.emit('unmute', this, info.unmute);
            return cb();
        }

        cb();
    },

    onTransportInfo: function (changes, cb) {
        this.pc.processIce(changes, function () {
            cb();
        });
    },

    onSourceAdd: function (changes, cb) {
        var self = this;
        this._log('info', 'Adding new stream source');

        var newDesc = this.pc.remoteDescription;
        this.pc.remoteDescription.contents.forEach(function (content, idx) {
            var desc = content.description;
            var ssrcs = desc.sources || [];
            var groups = desc.sourceGroups || [];

            changes.contents.forEach(function (newContent) {
                if (content.name !== newContent.name) {
                    return;
                }

                var newContentDesc = newContent.description;
                var newSSRCs = newContentDesc.sources || [];

                ssrcs = ssrcs.concat(newSSRCs);
                newDesc.contents[idx].description.sources = JSON.parse(JSON.stringify(ssrcs));

                var newGroups = newContentDesc.sourceGroups || [];
                groups = groups.concat(newGroups);
                newDesc.contents[idx].description.sourceGroups = JSON.parse(JSON.stringify(groups));
            });
        });

        this.pc.handleOffer({
            type: 'offer',
            jingle: newDesc
        }, function (err) {
            if (err) {
                self._log('error', 'Error adding new stream source');
                return cb({
                    condition: 'general-error'
                });
            }

            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Error adding new stream source');
                    return cb({
                        condition: 'general-error'
                    });
                }
                cb();
            });
        });
    },

    onSourceRemove: function (changes, cb) {
        var self = this;
        this._log('info', 'Removing stream source');

        var newDesc = this.pc.remoteDescription;
        this.pc.remoteDescription.contents.forEach(function (content, idx) {
            var desc = content.description;
            var ssrcs = desc.sources || [];
            var groups = desc.sourceGroups || [];

            changes.contents.forEach(function (newContent) {
                if (content.name !== newContent.name) {
                    return;
                }

                var newContentDesc = newContent.description;
                var newSSRCs = newContentDesc.sources || [];
                var newGroups = newContentDesc.sourceGroups || [];

                var found, i, j, k;


                for (i = 0; i < newSSRCs.length; i++) {
                    found = -1;
                    for (j = 0; j < ssrcs.length; j++) {
                        if (newSSRCs[i].ssrc === ssrcs[j].ssrc) {
                            found = j;
                            break;
                        }
                    }
                    if (found > -1) {
                        ssrcs.splice(found, 1);
                        newDesc.contents[idx].description.sources = JSON.parse(JSON.stringify(ssrcs));
                    }
                }

                // Remove ssrc-groups that are no longer needed
                for (i = 0; i < newGroups.length; i++) {
                    found = -1;
                    for (j = 0; i < groups.length; j++) {
                        if (newGroups[i].semantics === groups[j].semantics &&
                            newGroups[i].sources.length === groups[j].sources.length) {
                            var same = true;
                            for (k = 0; k < newGroups[i].sources.length; k++) {
                                if (newGroups[i].sources[k] !== groups[j].sources[k]) {
                                    same = false;
                                    break;
                                }
                            }
                            if (same) {
                                found = j;
                                break;
                            }
                        }
                    }
                    if (found > -1) {
                        groups.splice(found, 1);
                        newDesc.contents[idx].description.sourceGroups = JSON.parse(JSON.stringify(groups));
                    }
                }
            });
        });

        this.pc.handleOffer({
            type: 'offer',
            jingle: newDesc
        }, function (err) {
            if (err) {
                self._log('error', 'Error removing stream source');
                return cb({
                    condition: 'general-error'
                });
            }
            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Error removing stream source');
                    return cb({
                        condition: 'general-error'
                    });
                }
                cb();
            });
        });
    }
});


module.exports = MediaSession;

},{"extend-object":1487,"jingle-session":1555,"rtcpeerconnection":1554,"util":43}],1524:[function(require,module,exports){
module.exports=require(1492)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/index.js":1492,"lodash._arrayeach":1525,"lodash._baseeach":1526,"lodash._bindcallback":1530,"lodash.isarray":1531}],1525:[function(require,module,exports){
module.exports=require(1493)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._arrayeach/index.js":1493}],1526:[function(require,module,exports){
module.exports=require(1494)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/index.js":1494,"lodash.keys":1527}],1527:[function(require,module,exports){
module.exports=require(1495)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/index.js":1495,"lodash._getnative":1528,"lodash.isarguments":1529,"lodash.isarray":1531}],1528:[function(require,module,exports){
module.exports=require(1496)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash._getnative/index.js":1496}],1529:[function(require,module,exports){
module.exports=require(1497)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js":1497}],1530:[function(require,module,exports){
module.exports=require(1498)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._bindcallback/index.js":1498}],1531:[function(require,module,exports){
module.exports=require(1499)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash.isarray/index.js":1499}],1532:[function(require,module,exports){
module.exports=require(1500)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/index.js":1500,"lodash._baseget":1533,"lodash._topath":1534,"lodash.isarray":1535,"lodash.map":1536}],1533:[function(require,module,exports){
module.exports=require(1501)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash._baseget/index.js":1501}],1534:[function(require,module,exports){
module.exports=require(1502)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash._topath/index.js":1502,"lodash.isarray":1535}],1535:[function(require,module,exports){
module.exports=require(1499)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash.isarray/index.js":1499}],1536:[function(require,module,exports){
module.exports=require(1504)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/index.js":1504,"lodash._arraymap":1537,"lodash._basecallback":1538,"lodash._baseeach":1543,"lodash.isarray":1535}],1537:[function(require,module,exports){
module.exports=require(1505)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/node_modules/lodash._arraymap/index.js":1505}],1538:[function(require,module,exports){
module.exports=require(1506)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/node_modules/lodash._basecallback/index.js":1506,"lodash._baseisequal":1539,"lodash._bindcallback":1541,"lodash.isarray":1535,"lodash.pairs":1542}],1539:[function(require,module,exports){
module.exports=require(1507)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/node_modules/lodash._basecallback/node_modules/lodash._baseisequal/index.js":1507,"lodash.isarray":1535,"lodash.istypedarray":1540,"lodash.keys":1544}],1540:[function(require,module,exports){
module.exports=require(1508)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/node_modules/lodash._basecallback/node_modules/lodash._baseisequal/node_modules/lodash.istypedarray/index.js":1508}],1541:[function(require,module,exports){
module.exports=require(1498)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._bindcallback/index.js":1498}],1542:[function(require,module,exports){
module.exports=require(1510)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.pluck/node_modules/lodash.map/node_modules/lodash._basecallback/node_modules/lodash.pairs/index.js":1510,"lodash.keys":1544}],1543:[function(require,module,exports){
module.exports=require(1494)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/index.js":1494,"lodash.keys":1544}],1544:[function(require,module,exports){
module.exports=require(1495)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/index.js":1495,"lodash._getnative":1545,"lodash.isarguments":1546,"lodash.isarray":1535}],1545:[function(require,module,exports){
module.exports=require(1496)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash._getnative/index.js":1496}],1546:[function(require,module,exports){
module.exports=require(1497)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/lodash.foreach/node_modules/lodash._baseeach/node_modules/lodash.keys/node_modules/lodash.isarguments/index.js":1497}],1547:[function(require,module,exports){
module.exports=require(1515)
},{"./lib/tojson":1550,"./lib/tosdp":1551,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/index.js":1515}],1548:[function(require,module,exports){
module.exports=require(1516)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/parsers.js":1516}],1549:[function(require,module,exports){
module.exports=require(1517)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/senders.js":1517}],1550:[function(require,module,exports){
module.exports=require(1518)
},{"./parsers":1548,"./senders":1549,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/tojson.js":1518}],1551:[function(require,module,exports){
module.exports=require(1519)
},{"./senders":1549,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/tosdp.js":1519}],1552:[function(require,module,exports){
module.exports=require(1520)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/traceablepeerconnection/index.js":1520,"util":43,"webrtc-adapter-test":1553,"wildemitter":1603}],1553:[function(require,module,exports){
module.exports=require(1521)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/webrtc-adapter-test/adapter.js":1521}],1554:[function(require,module,exports){
var util = require('util');
var each = require('lodash.foreach');
var pluck = require('lodash.pluck');
var webrtc = require('webrtcsupport');
var SJJ = require('sdp-jingle-json');
var WildEmitter = require('wildemitter');
var peerconn = require('traceablepeerconnection');


function PeerConnection(config, constraints) {
    var self = this;
    var item;
    WildEmitter.call(this);

    config = config || {};
    config.iceServers = config.iceServers || [];

    // make sure this only gets enabled in Google Chrome
    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableChromeNativeSimulcast = false;
    if (constraints && constraints.optional &&
            webrtc.prefix === 'webkit' &&
            navigator.appVersion.match(/Chromium\//) === null) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableChromeNativeSimulcast) {
                self.enableChromeNativeSimulcast = true;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableMultiStreamHacks = false;
    if (constraints && constraints.optional &&
            webrtc.prefix === 'webkit') {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableMultiStreamHacks) {
                self.enableMultiStreamHacks = true;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    this.restrictBandwidth = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetRestrictBandwidth) {
                self.restrictBandwidth = constraint.andyetRestrictBandwidth;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // bundle up ice candidates, only works for jingle mode
    // number > 0 is the delay to wait for additional candidates
    // ~20ms seems good
    this.batchIceCandidates = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetBatchIce) {
                self.batchIceCandidates = constraint.andyetBatchIce;
            }
        });
    }
    this.batchedIceCandidates = [];

    // EXPERIMENTAL FLAG, might get removed without notice
    // this attemps to strip out candidates with an already known foundation
    // and type -- i.e. those which are gathered via the same TURN server
    // but different transports (TURN udp, tcp and tls respectively)
    if (constraints && constraints.optional && webrtc.prefix === 'webkit') {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetFasterICE) {
                self.eliminateDuplicateCandidates = constraint.andyetFasterICE;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    // when using a server such as the jitsi videobridge we don't need to signal
    // our candidates
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetDontSignalCandidates) {
                self.dontSignalCandidates = constraint.andyetDontSignalCandidates;
            }
        });
    }


    // EXPERIMENTAL FLAG, might get removed without notice
    this.assumeSetLocalSuccess = false;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetAssumeSetLocalSuccess) {
                self.assumeSetLocalSuccess = constraint.andyetAssumeSetLocalSuccess;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // working around https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
    // pass in a timeout for this
    if (webrtc.prefix === 'moz') {
        if (constraints && constraints.optional) {
            this.wtFirefox = 0;
            constraints.optional.forEach(function (constraint, idx) {
                if (constraint.andyetFirefoxMakesMeSad) {
                    self.wtFirefox = constraint.andyetFirefoxMakesMeSad;
                    if (self.wtFirefox > 0) {
                        self.firefoxcandidatebuffer = [];
                    }
                }
            });
        }
    }


    this.pc = new peerconn(config, constraints);

    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);
    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);
    this.addStream = this.pc.addStream.bind(this.pc);
    this.removeStream = this.pc.removeStream.bind(this.pc);

    // proxy events
    this.pc.on('*', function () {
        self.emit.apply(self, arguments);
    });

    // proxy some events directly
    this.pc.onremovestream = this.emit.bind(this, 'removeStream');
    this.pc.onaddstream = this.emit.bind(this, 'addStream');
    this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
    this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
    this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');

    // handle ice candidate and data channel events
    this.pc.onicecandidate = this._onIce.bind(this);
    this.pc.ondatachannel = this._onDataChannel.bind(this);

    this.localDescription = {
        contents: []
    };
    this.remoteDescription = {
        contents: []
    };

    this.config = {
        debug: false,
        ice: {},
        sid: '',
        isInitiator: true,
        sdpSessionID: Date.now(),
        useJingle: false
    };

    // apply our config
    for (item in config) {
        this.config[item] = config[item];
    }

    if (this.config.debug) {
        this.on('*', function (eventName, event) {
            var logger = config.logger || console;
            logger.log('PeerConnection event:', arguments);
        });
    }
    this.hadLocalStunCandidate = false;
    this.hadRemoteStunCandidate = false;
    this.hadLocalRelayCandidate = false;
    this.hadRemoteRelayCandidate = false;

    this.hadLocalIPv6Candidate = false;
    this.hadRemoteIPv6Candidate = false;

    // keeping references for all our data channels
    // so they dont get garbage collected
    // can be removed once the following bugs have been fixed
    // https://crbug.com/405545
    // https://bugzilla.mozilla.org/show_bug.cgi?id=964092
    // to be filed for opera
    this._remoteDataChannels = [];
    this._localDataChannels = [];

    this._candidateBuffer = [];
}

util.inherits(PeerConnection, WildEmitter);

Object.defineProperty(PeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.pc.signalingState;
    }
});
Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.pc.iceConnectionState;
    }
});

PeerConnection.prototype._role = function () {
    return this.isInitiator ? 'initiator' : 'responder';
};

// Add a stream to the peer connection object
PeerConnection.prototype.addStream = function (stream) {
    this.localStream = stream;
    this.pc.addStream(stream);
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkLocalCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadLocalStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadLocalRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadLocalIPv6Candidate = true;
    }
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkRemoteCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadRemoteStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadRemoteRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadRemoteIPv6Candidate = true;
    }
};


// Init and add ice candidate object with correct constructor
PeerConnection.prototype.processIce = function (update, cb) {
    cb = cb || function () {};
    var self = this;

    // ignore any added ice candidates to avoid errors. why does the
    // spec not do this?
    if (this.pc.signalingState === 'closed') return cb();

    if (update.contents || (update.jingle && update.jingle.contents)) {
        var contentNames = pluck(this.remoteDescription.contents, 'name');
        var contents = update.contents || update.jingle.contents;

        contents.forEach(function (content) {
            var transport = content.transport || {};
            var candidates = transport.candidates || [];
            var mline = contentNames.indexOf(content.name);
            var mid = content.name;

            candidates.forEach(
                function (candidate) {
                var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
                self.pc.addIceCandidate(
                    new webrtc.IceCandidate({
                        candidate: iceCandidate,
                        sdpMLineIndex: mline,
                        sdpMid: mid
                    }), function () {
                        // well, this success callback is pretty meaningless
                    },
                    function (err) {
                        self.emit('error', err);
                    }
                );
                self._checkRemoteCandidate(iceCandidate);
            });
        });
    } else {
        // working around https://code.google.com/p/webrtc/issues/detail?id=3669
        if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {
            update.candidate.candidate = 'a=' + update.candidate.candidate;
        }

        if (this.wtFirefox && this.firefoxcandidatebuffer !== null) {
            // we cant add this yet due to https://bugzilla.mozilla.org/show_bug.cgi?id=1087551
            if (this.pc.localDescription && this.pc.localDescription.type === 'offer') {
                this.firefoxcandidatebuffer.push(update.candidate);
                return cb();
            }
        }

        self.pc.addIceCandidate(
            new webrtc.IceCandidate(update.candidate),
            function () { },
            function (err) {
                self.emit('error', err);
            }
        );
        self._checkRemoteCandidate(update.candidate.candidate);
    }
    cb();
};

// Generate and emit an offer with the given constraints
PeerConnection.prototype.offer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };
    cb = hasConstraints ? cb : constraints;
    cb = cb || function () {};

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    // Actually generate the offer
    this.pc.createOffer(
        function (offer) {
            // does not work for jingle, but jingle.js doesn't need
            // this hack...
            var expandedOffer = {
                type: 'offer',
                sdp: offer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                self.emit('offer', expandedOffer);
                cb(null, expandedOffer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(offer,
                function () {
                    var jingle;
                    if (self.config.useJingle) {
                        jingle = SJJ.toSessionJSON(offer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;

                        // Save ICE credentials
                        each(jingle.contents, function (content) {
                            var transport = content.transport || {};
                            if (transport.ufrag) {
                                self.config.ice[content.name] = {
                                    ufrag: transport.ufrag,
                                    pwd: transport.pwd
                                };
                            }
                        });

                        expandedOffer.jingle = jingle;
                    }
                    expandedOffer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });

                    if (!self.assumeSetLocalSuccess) {
                        self.emit('offer', expandedOffer);
                        cb(null, expandedOffer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        mediaConstraints
    );
};


// Process an incoming offer so that ICE may proceed before deciding
// to answer the request.
PeerConnection.prototype.handleOffer = function (offer, cb) {
    cb = cb || function () {};
    var self = this;
    offer.type = 'offer';
    if (offer.jingle) {
        if (this.enableChromeNativeSimulcast) {
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    content.description.googConferenceFlag = true;
                }
            });
        }
        if (this.enableMultiStreamHacks) {
            // add a mixed video stream as first stream
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    var sources = content.description.sources || [];
                    if (sources.length === 0 || sources[0].ssrc !== "3735928559") {
                        sources.unshift({
                            ssrc: "3735928559", // 0xdeadbeef
                            parameters: [
                                {
                                    key: "cname",
                                    value: "deadbeef"
                                },
                                {
                                    key: "msid",
                                    value: "mixyourfecintothis please"
                                }
                            ]
                        });
                        content.description.sources = sources;
                    }
                }
            });
        }
        if (self.restrictBandwidth > 0) {
            if (offer.jingle.contents.length >= 2 && offer.jingle.contents[1].name === 'video') {
                var content = offer.jingle.contents[1];
                var hasBw = content.description && content.description.bandwidth;
                if (!hasBw) {
                    offer.jingle.contents[1].description.bandwidth = { type: 'AS', bandwidth: self.restrictBandwidth.toString() };
                    offer.sdp = SJJ.toSessionSDP(offer.jingle, {
                        sid: self.config.sdpSessionID,
                        role: self._role(),
                        direction: 'outgoing'
                    });
                }
            }
        }
        offer.sdp = SJJ.toSessionSDP(offer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = offer.jingle;
    }
    offer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(new webrtc.SessionDescription(offer),
        function () {
            cb();
        },
        cb
    );
};

// Answer an offer with audio only
PeerConnection.prototype.answerAudioOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer without offering to recieve
PeerConnection.prototype.answerBroadcastOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer with given constraints default is audio/video
PeerConnection.prototype.answer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var callback = hasConstraints ? cb : constraints;
    var mediaConstraints = hasConstraints && constraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };

    this._answer(mediaConstraints, callback);
};

// Process an answer
PeerConnection.prototype.handleAnswer = function (answer, cb) {
    cb = cb || function () {};
    var self = this;
    if (answer.jingle) {
        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = answer.jingle;
    }
    answer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(
        new webrtc.SessionDescription(answer),
        function () {
            if (self.wtFirefox) {
                window.setTimeout(function () {
                    self.firefoxcandidatebuffer.forEach(function (candidate) {
                        // add candidates later
                        self.pc.addIceCandidate(
                            new webrtc.IceCandidate(candidate),
                            function () { },
                            function (err) {
                                self.emit('error', err);
                            }
                        );
                        self._checkRemoteCandidate(candidate.candidate);
                    });
                    self.firefoxcandidatebuffer = null;
                }, self.wtFirefox);
            }
            cb(null);
        },
        cb
    );
};

// Close the peer connection
PeerConnection.prototype.close = function () {
    this.pc.close();

    this._localDataChannels = [];
    this._remoteDataChannels = [];

    this.emit('close');
};

// Internal code sharing for various types of answer methods
PeerConnection.prototype._answer = function (constraints, cb) {
    cb = cb || function () {};
    var self = this;
    if (!this.pc.remoteDescription) {
        // the old API is used, call handleOffer
        throw new Error('remoteDescription not set');
    }

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    self.pc.createAnswer(
        function (answer) {
            var sim = [];
            var rtx = [];
            if (self.enableChromeNativeSimulcast) {
                // native simulcast part 1: add another SSRC
                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
                    var hasSimgroup = false;
                    var groups = answer.jingle.contents[1].description.sourceGroups || [];
                    var hasSim = false;
                    groups.forEach(function (group) {
                        if (group.semantics == 'SIM') hasSim = true;
                    });
                    if (!hasSim &&
                        answer.jingle.contents[1].description.sources.length) {
                        var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].description.sources[0]));
                        newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(newssrc);

                        sim.push(answer.jingle.contents[1].description.sources[0].ssrc);
                        sim.push(newssrc.ssrc);
                        groups.push({
                            semantics: 'SIM',
                            sources: sim
                        });

                        // also create an RTX one for the SIM one
                        var rtxssrc = JSON.parse(JSON.stringify(newssrc));
                        rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(rtxssrc);
                        groups.push({
                            semantics: 'FID',
                            sources: [newssrc.ssrc, rtxssrc.ssrc]
                        });

                        answer.jingle.contents[1].description.sourceGroups = groups;
                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
                            sid: self.config.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                }
            }
            var expandedAnswer = {
                type: 'answer',
                sdp: answer.sdp
            };
            if (self.assumeSetLocalSuccess) {
                // not safe to do when doing simulcast mangling
                self.emit('answer', expandedAnswer);
                cb(null, expandedAnswer);
            }
            self._candidateBuffer = [];
            self.pc.setLocalDescription(answer,
                function () {
                    if (self.config.useJingle) {
                        var jingle = SJJ.toSessionJSON(answer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;
                        expandedAnswer.jingle = jingle;
                    }
                    if (self.enableChromeNativeSimulcast) {
                        // native simulcast part 2:
                        // signal multiple tracks to the receiver
                        // for anything in the SIM group
                        if (!expandedAnswer.jingle) {
                            expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {
                                role: self._role(),
                                direction: 'outgoing'
                            });
                        }
                        var groups = expandedAnswer.jingle.contents[1].description.sourceGroups || [];
                        expandedAnswer.jingle.contents[1].description.sources.forEach(function (source, idx) {
                            // the floor idx/2 is a hack that relies on a particular order
                            // of groups, alternating between sim and rtx
                            source.parameters = source.parameters.map(function (parameter) {
                                if (parameter.key === 'msid') {
                                    parameter.value += '-' + Math.floor(idx / 2);
                                }
                                return parameter;
                            });
                        });
                        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {
                            sid: self.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                    expandedAnswer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });
                    if (!self.assumeSetLocalSuccess) {
                        self.emit('answer', expandedAnswer);
                        cb(null, expandedAnswer);
                    }
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        constraints
    );
};

// Internal method for emitting ice candidates on our peer object
PeerConnection.prototype._onIce = function (event) {
    var self = this;
    if (event.candidate) {
        if (this.dontSignalCandidates) return;
        var ice = event.candidate;

        var expandedCandidate = {
            candidate: {
                candidate: ice.candidate,
                sdpMid: ice.sdpMid,
                sdpMLineIndex: ice.sdpMLineIndex
            }
        };
        this._checkLocalCandidate(ice.candidate);

        var cand = SJJ.toCandidateJSON(ice.candidate);

        var already;
        var idx;
        if (this.eliminateDuplicateCandidates && cand.type === 'relay') {
            // drop candidates with same foundation, component
            // take local type pref into account so we don't ignore udp
            // ones when we know about a TCP one. unlikely but...
            already = this._candidateBuffer.filter(
                function (c) {
                    return c.type === 'relay';
                }).map(function (c) {
                    return c.foundation + ':' + c.component;
                }
            );
            idx = already.indexOf(cand.foundation + ':' + cand.component);
            // remember: local type pref of udp is 0, tcp 1, tls 2
            if (idx > -1 && ((cand.priority >> 24) >= (already[idx].priority >> 24))) {
                // drop it, same foundation with higher (worse) type pref
                return;
            }
        }
        if (this.config.bundlePolicy === 'max-bundle') {
            // drop candidates which are duplicate for audio/video/data
            // duplicate means same host/port but different sdpMid
            already = this._candidateBuffer.filter(
                function (c) {
                    return cand.type === c.type;
                }).map(function (cand) {
                    return cand.address + ':' + cand.port;
                }
            );
            idx = already.indexOf(cand.address + ':' + cand.port);
            if (idx > -1) return;
        }
        // also drop rtcp candidates since we know the peer supports RTCP-MUX
        // this is a workaround until browsers implement this natively
        if (this.config.rtcpMuxPolicy === 'require' && cand.component === '2') {
            return;
        }
        this._candidateBuffer.push(cand);

        if (self.config.useJingle) {
            if (!ice.sdpMid) { // firefox doesn't set this
                if (self.pc.remoteDescription && self.pc.remoteDescription.type === 'offer') {
                    // preserve name from remote
                    ice.sdpMid = self.remoteDescription.contents[ice.sdpMLineIndex].name;
                } else {
                    ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;
                }
            }
            if (!self.config.ice[ice.sdpMid]) {
                var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                each(jingle.contents, function (content) {
                    var transport = content.transport || {};
                    if (transport.ufrag) {
                        self.config.ice[content.name] = {
                            ufrag: transport.ufrag,
                            pwd: transport.pwd
                        };
                    }
                });
            }
            expandedCandidate.jingle = {
                contents: [{
                    name: ice.sdpMid,
                    creator: self._role(),
                    transport: {
                        transType: 'iceUdp',
                        ufrag: self.config.ice[ice.sdpMid].ufrag,
                        pwd: self.config.ice[ice.sdpMid].pwd,
                        candidates: [
                            cand
                        ]
                    }
                }]
            };
            if (self.batchIceCandidates > 0) {
                if (self.batchedIceCandidates.length === 0) {
                    window.setTimeout(function () {
                        var contents = {};
                        self.batchedIceCandidates.forEach(function (content) {
                            content = content.contents[0];
                            if (!contents[content.name]) contents[content.name] = content;
                            contents[content.name].transport.candidates.push(content.transport.candidates[0]);
                        });
                        var newCand = {
                            jingle: {
                                contents: []
                            }
                        };
                        Object.keys(contents).forEach(function (name) {
                            newCand.jingle.contents.push(contents[name]);
                        });
                        self.batchedIceCandidates = [];
                        self.emit('ice', newCand);
                    }, self.batchIceCandidates);
                }
                self.batchedIceCandidates.push(expandedCandidate.jingle);
                return;
            }

        }
        this.emit('ice', expandedCandidate);
    } else {
        this.emit('endOfCandidates');
    }
};

// Internal method for processing a new data channel being added by the
// other peer.
PeerConnection.prototype._onDataChannel = function (event) {
    // make sure we keep a reference so this doesn't get garbage collected
    var channel = event.channel;
    this._remoteDataChannels.push(channel);

    this.emit('addChannel', channel);
};

// Create a data channel spec reference:
// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
PeerConnection.prototype.createDataChannel = function (name, opts) {
    var channel = this.pc.createDataChannel(name, opts);

    // make sure we keep a reference so this doesn't get garbage collected
    this._localDataChannels.push(channel);

    return channel;
};

// a wrapper around getStats which hides the differences (where possible)
PeerConnection.prototype.getStats = function (cb) {
    if (webrtc.prefix === 'moz') {
        this.pc.getStats(
            function (res) {
                var items = [];
                for (var result in res) {
                    if (typeof res[result] === 'object') {
                        items.push(res[result]);
                    }
                }
                cb(null, items);
            },
            cb
        );
    } else {
        this.pc.getStats(function (res) {
            var items = [];
            res.result().forEach(function (result) {
                var item = {};
                result.names().forEach(function (name) {
                    item[name] = result.stat(name);
                });
                item.id = result.id;
                item.type = result.type;
                item.timestamp = result.timestamp;
                items.push(item);
            });
            cb(null, items);
        });
    }
};

module.exports = PeerConnection;

},{"lodash.foreach":1524,"lodash.pluck":1532,"sdp-jingle-json":1547,"traceablepeerconnection":1552,"util":43,"webrtcsupport":1558,"wildemitter":1603}],1555:[function(require,module,exports){
var util = require('util');
var uuid = require('uuid');
var async = require('async');
var extend = require('extend-object');
var WildEmitter = require('wildemitter');


var ACTIONS = {
    'content-accept': 'onContentAccept',
    'content-add': 'onContentAdd',
    'content-modify': 'onConentModify',
    'content-reject': 'onContentReject',
    'content-remove': 'onContentRemove',
    'description-info': 'onDescriptionInfo',
    'security-info': 'onSecurityInfo',
    'session-accept': 'onSessionAccept',
    'session-info': 'onSessionInfo',
    'session-initiate': 'onSessionInitiate',
    'session-terminate': 'onSessionTerminate',
    'transport-accept': 'onTransportAccept',
    'transport-info': 'onTransportInfo',
    'transport-reject': 'onTransportReject',
    'transport-replace': 'onTransportReplace',

    // Unstandardized actions: might go away anytime without notice
    'source-add': 'onSourceAdd',
    'source-remove': 'onSourceRemove'
};


function JingleSession(opts) {
    WildEmitter.call(this);

    var self = this;

    this.sid = opts.sid || uuid.v4();
    this.peer = opts.peer;
    this.peerID = opts.peerID || this.peer.full || this.peer;
    this.isInitiator = opts.initiator || false;
    this.parent = opts.parent;
    this.state = 'starting';
    this.connectionState = 'starting';

    // We track the intial pending description types in case
    // of the need for a tie-breaker.
    this.pendingDescriptionTypes = opts.descriptionTypes || [];

    this.pendingAction = false;

    // Here is where we'll ensure that all actions are processed
    // in order, even if a particular action requires async handling.
    this.processingQueue = async.queue(function (task, next) {
        if (self.ended) {
            // Don't process anything once the session has been ended
            return next();
        }

        var action = task.action;
        var changes = task.changes;
        var cb = task.cb;

        self._log('debug', action);

        if (!ACTIONS[action]) {
            self._log('error', 'Invalid action: ' + action);
            cb({condition: 'bad-request'});
            return next();
        }

        self[ACTIONS[action]](changes, function (err, result) {
            cb(err, result);
            return next();
        });
    });
}


util.inherits(JingleSession, WildEmitter);

// We don't know how to handle any particular content types,
// so no actions are supported.
Object.keys(ACTIONS).forEach(function (action) {
    var method = ACTIONS[action];
    JingleSession.prototype[method] = function (changes, cb) {
        this._log('error', 'Unsupported action: ' + action);
        cb();
    };
});

// Provide some convenience properties for checking
// the session's state.
Object.defineProperties(JingleSession.prototype, {
    state: {
        get: function () {
            return this._sessionState;
        },
        set: function (value) {
            if (value !== this._sessionState) {
                var prev = this._sessionState;
                this._log('info', 'Changing session state to: ' + value);
                this._sessionState = value;
                this.emit('change:sessionState', this, value);
                this.emit('change:' + value, this, true);
                if (prev) {
                    this.emit('change:' + prev, this, false);
                }
            }
        }
    },
    connectionState: {
        get: function () {
            return this._connectionState;
        },
        set: function (value) {
            if (value !== this._connectionState) {
                var prev = this._connectionState;
                this._log('info', 'Changing connection state to: ' + value);
                this._connectionState = value;
                this.emit('change:connectionState', this, value);
                this.emit('change:' + value, this, true);
                if (prev) {
                    this.emit('change:' + prev, this, false);
                }
            }
        }
    },
    starting: {
        get: function () {
            return this._sessionState === 'starting';
        }
    },
    pending: {
        get: function () {
            return this._sessionState === 'pending';
        }
    },
    active: {
        get: function () {
            return this._sessionState === 'active';
        }
    },
    ended: {
        get: function () {
            return this._sessionState === 'ended';
        }
    },
    connected: {
        get: function () {
            return this._connectionState === 'connected';
        }
    },
    connecting: {
        get: function () {
            return this._connectionState === 'connecting';
        }
    },
    disconnected: {
        get: function () {
            return this._connectionState === 'disconnected';
        }
    },
    interrupted: {
        get: function () {
            return this._connectionState === 'interrupted';
        }
    }
});

JingleSession.prototype = extend(JingleSession.prototype, {
    _log: function (level, message) {
        message = this.sid + ': ' + message;
        this.emit('log:' + level, message);
    },
    
    send: function (action, data) {
        data = data || {};
        data.sid = this.sid;
        data.action = action;

        var requirePending = {
            'session-inititate': true,
            'session-accept': true,
            'content-add': true,
            'content-remove': true,
            'content-reject': true,
            'content-accept': true,
            'content-modify': true,
            'transport-replace': true,
            'transport-reject': true,
            'transport-accept': true,
            'source-add': true,
            'source-remove': true
        };

        if (requirePending[action]) {
            this.pendingAction = action;
        } else {
            this.pendingAction = false;
        }

        this.emit('send', {
            to: this.peer,
            type: 'set',
            jingle: data
        });
    },
    
    process: function (action, changes, cb) {
        this.processingQueue.push({
            action: action,
            changes: changes,
            cb: cb
        });
    },
    
    start: function () {
        this._log('error', 'Can not start base sessions');
        this.end('unsupported-applications', true);
    },
    
    accept: function () {
        this._log('error', 'Can not accept base sessions');
        this.end('unsupported-applications');
    },
    
    cancel: function () {
        this.end('cancel');
    },
    
    decline: function () {
        this.end('decline');
    },
    
    end: function (reason, silent) {
        this.state = 'ended';

        this.processingQueue.kill();

        if (!reason) {
            reason = 'success';
        }

        if (typeof reason === 'string') {
            reason = {
                condition: reason
            };
        }
    
        if (!silent) {
            this.send('session-terminate', {
                reason: reason
            });
        }
    
        this.emit('terminated', this, reason);
    },

    onSessionTerminate: function (changes, cb) {
        this.end(changes.reason, true);
        cb();
    },

    // It is mandatory to reply to a session-info action with 
    // an unsupported-info error if the info isn't recognized.
    //
    // However, a session-info action with no associated payload
    // is acceptable (works like a ping).
    onSessionInfo: function (changes, cb) {
        var okKeys = {
            sid: true,
            action: true,
            initiator: true,
            responder: true
        };

        var unknownPayload = false;
        Object.keys(changes).forEach(function (key) {
            if (!okKeys[key]) {
                unknownPayload = true;
            }
        });

        if (unknownPayload) {
            cb({
                type: 'modify',
                condition: 'feature-not-implemented',
                jingleCondition: 'unsupported-info'
            });
        } else {
            cb();
        }
    },

    // It is mandatory to reply to a description-info action with 
    // an unsupported-info error if the info isn't recognized.
    onDescriptionInfo: function (changes, cb) {
        cb({
            type: 'modify',
            condition: 'feature-not-implemented',
            jingleCondition: 'unsupported-info'
        });
    },

    // It is mandatory to reply to a transport-info action with 
    // an unsupported-info error if the info isn't recognized.
    onTransportInfo: function (changes, cb) {
        cb({
            type: 'modify',
            condition: 'feature-not-implemented',
            jingleCondition: 'unsupported-info'
        });
    },

    // It is mandatory to reply to a content-add action with either
    // a content-accept or content-reject.
    onContentAdd: function (changes, cb) {
        // Allow ack for the content-add to be sent.
        cb();

        this.send('content-reject', {
            reason: {
                condition: 'failed-application',
                text: 'content-add is not supported'
            }
        });
    },

    // It is mandatory to reply to a transport-add action with either
    // a transport-accept or transport-reject.
    onTransportReplace: function (changes, cb) {
        // Allow ack for the transport-replace be sent.
        cb();

        this.send('transport-reject', {
            reason: {
                condition: 'failed-application',
                text: 'transport-replace is not supported'
            }
        });
    }
});


module.exports = JingleSession;

},{"async":1463,"extend-object":1487,"util":43,"uuid":1557,"wildemitter":1603}],1556:[function(require,module,exports){
(function (global){

var rng;

if (global.crypto && crypto.getRandomValues) {
  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
  // Moderately fast, high quality
  var _rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(_rnds8);
    return _rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  _rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return _rnds;
  };
}

module.exports = rng;


}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],1557:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var _rng = require('./rng');

// Maps for number <-> hex string conversion
var _byteToHex = [];
var _hexToByte = {};
for (var i = 0; i < 256; i++) {
  _byteToHex[i] = (i + 0x100).toString(16).substr(1);
  _hexToByte[_byteToHex[i]] = i;
}

// **`parse()` - Parse a UUID into it's component bytes**
function parse(s, buf, offset) {
  var i = (buf && offset) || 0, ii = 0;

  buf = buf || [];
  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
    if (ii < 16) { // Don't overflow!
      buf[i + ii++] = _hexToByte[oct];
    }
  });

  // Zero out remaining bytes if string was short
  while (ii < 16) {
    buf[i + ii++] = 0;
  }

  return buf;
}

// **`unparse()` - Convert UUID byte array (ala parse()) into a string**
function unparse(buf, offset) {
  var i = offset || 0, bth = _byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = _rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; n++) {
    b[i + n] = node[n];
  }

  return buf ? buf : unparse(b);
}

// **`v4()` - Generate random UUID**

// See https://github.com/broofa/node-uuid for API details
function v4(options, buf, offset) {
  // Deprecated - 'format' argument, as supported in v1.2
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || _rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ii++) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || unparse(rnds);
}

// Export public API
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
uuid.parse = parse;
uuid.unparse = unparse;

module.exports = uuid;

},{"./rng":1556}],1558:[function(require,module,exports){
// created by @HenrikJoreteg
var prefix;
var version;

if (window.mozRTCPeerConnection || navigator.mozGetUserMedia) {
    prefix = 'moz';
    version = parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);
} else if (window.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
    prefix = 'webkit';
    version = navigator.userAgent.match(/Chrom(e|ium)/) && parseInt(navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./)[2], 10);
}

var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
var MediaStream = window.webkitMediaStream || window.MediaStream;
var screenSharing = window.location.protocol === 'https:' &&
    ((prefix === 'webkit' && version >= 26) ||
     (prefix === 'moz' && version >= 33))
var AudioContext = window.AudioContext || window.webkitAudioContext;
var videoEl = document.createElement('video');
var supportVp8 = videoEl && videoEl.canPlayType && videoEl.canPlayType('video/webm; codecs="vp8", vorbis') === "probably";
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia;

// export support flags and constructors.prototype && PC
module.exports = {
    prefix: prefix,
    browserVersion: version,
    support: !!PC && supportVp8 && !!getUserMedia,
    // new support style
    supportRTCPeerConnection: !!PC,
    supportVp8: supportVp8,
    supportGetUserMedia: !!getUserMedia,
    supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
    supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
    supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
    supportScreenSharing: !!screenSharing,
    // old deprecated style. Dont use this anymore
    dataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
    webAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
    mediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
    screenSharing: !!screenSharing,
    // constructors
    AudioContext: AudioContext,
    PeerConnection: PC,
    SessionDescription: SessionDescription,
    IceCandidate: IceCandidate,
    MediaStream: MediaStream,
    getUserMedia: getUserMedia
};

},{}],1559:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;


module.exports = function (JXT) {
    var types = JXT.utils;

    // ----------------------------------------------------------------
    // Shortcuts for common withDefinition calls
    // ----------------------------------------------------------------
    
    JXT.withIq = function (cb) {
        this.withDefinition('iq', 'jabber:client', cb);
        this.withDefinition('iq', 'jabber:component:accept', cb);
    };

    JXT.withMessage = function (cb) {
        this.withDefinition('message', 'jabber:client', cb);
        this.withDefinition('message', 'jabber:component:accept', cb);
    };

    JXT.withPresence = function (cb) {
        this.withDefinition('presence', 'jabber:client', cb);
        this.withDefinition('presence', 'jabber:component:accept', cb);
    };

    JXT.withStreamFeatures = function (cb) {
        this.withDefinition('features', 'http://etherx.jabber.org/streams', cb);
    };

    JXT.withStanzaError = function (cb) {
        this.withDefinition('error', 'jabber:client', cb);
        this.withDefinition('error', 'jabber:component:accept', cb);
    };

    JXT.withDataForm = function (cb) {
        this.withDefinition('x', 'jabber:x:data', cb);
    };

    JXT.withPubsubItem = function (cb) {
        this.withDefinition('item', 'http://jabber.org/protocol/pubsub', cb);
        this.withDefinition('item', 'http://jabber.org/protocol/pubsub#event', cb);
    };


    // ----------------------------------------------------------------
    // Shortcuts for common getDefinition calls
    // ----------------------------------------------------------------
   
    JXT.getMessage = function () {
        return this.getDefinition('message', 'jabber:client');
    };

    JXT.getPresence = function () {
        return this.getDefinition('presence', 'jabber:client');
    };

    JXT.getIq = function () {
        return this.getDefinition('iq', 'jabber:client');
    };

    JXT.getStreamError = function () {
        return this.getDefinition('error', 'http://etherx.jabber.org/streams');
    };
   
    JXT.getComponentMessage = function () {
        return this.getDefinition('message', 'jabber:component:accept');
    };

    JXT.getComponentPresence = function () {
        return this.getDefinition('presence', 'jabber:component:accept');
    };

    JXT.getComponentIq = function () {
        return this.getDefinition('iq', 'jabber:component:accept');
    };


    // ----------------------------------------------------------------
    // Field types
    // ----------------------------------------------------------------


    JXT.utils.jidAttribute = function (attr, prepped) {
        return {
            get: function () {
                var jid = new JID(types.getAttribute(this.xml, attr));
                if (prepped) {
                    jid.prepped = true;
                }
                return jid;
            },
            set: function (value) {
                types.setAttribute(this.xml, attr, (value || '').toString());
            }
        };
    };
    
    JXT.utils.jidSub = function (NS, sub, prepped) {
        return {
            get: function () {
                var jid = new JID(types.getSubText(this.xml, NS, sub));
                if (prepped) {
                    jid.prepped = true;
                }
                return jid;
            },
            set: function (value) {
                types.setSubText(this.xml, NS, sub, (value || '').toString());
            }
        };
    };
    
    
    JXT.utils.tzoSub = types.field(
        function (xml, NS, sub, defaultVal) {
            var split, hrs, min;
            var sign = -1;
            var formatted = types.getSubText(xml, NS, sub);
    
            if (!formatted) {
                return defaultVal;
            }
    
            if (formatted.charAt(0) === '-') {
                sign = 1;
                formatted = formatted.slice(1);
            }
    
            split = formatted.split(':');
            hrs = parseInt(split[0], 10);
            min = parseInt(split[1], 10);
            return (hrs * 60 + min) * sign;
        },
        function (xml, NS, sub, value) {
            var hrs, min;
            var formatted = '-';
            if (typeof value === 'number') {
                if (value < 0) {
                    value = -value;
                    formatted = '+';
                }
                hrs = value / 60;
                min = value % 60;
                formatted += (hrs < 10 ? '0' : '') + hrs + ':' + (min < 10 ? '0' : '') + min;
            } else {
                formatted = value;
            }
            types.setSubText(xml, NS, sub, formatted);
        }
    );
};

},{"xmpp-jid":1604}],1560:[function(require,module,exports){
'use strict';

var ltx = require('ltx');
var extend = require('extend-object');
var uuid = require('node-uuid');

var types = require('./lib/types');
var helpers = require('./lib/helpers');
var stanzaConstructor = require('./lib/stanza');


function JXT() {
    this._LOOKUP = {};
    this._LOOKUP_EXT = {};
    this._TAGS = {};
    this._CB_DEFINITION = {};
    this._CB_TAG = {};
    this._ID = uuid.v4();
    this.utils = extend({}, types, helpers);
}

JXT.prototype.use = function (init) {
    if (!init['__JXT_LOADED_' + this._ID]) {
        init(this);
    }
    init['__JXT_LOADED_' + this._ID] = true;
    return this;
};

JXT.prototype.getDefinition = function (el, ns, required) {
    var JXTClass = this._LOOKUP[ns + '|' + el];
    if (required && !JXTClass) {
        throw new Error('Could not find definition for <' + el + ' xmlns="' + ns + '" />');
    }
    return JXTClass;
};

JXT.prototype.getExtensions = function (el, ns) {
    return this._LOOKUP_EXT[ns + '|' + el] || {};
};

JXT.prototype.withDefinition = function (el, ns, cb) {
    var name = ns + '|' + el;
    if (!this._CB_DEFINITION[name]) {
        this._CB_DEFINITION[name] = [];
    }
    this._CB_DEFINITION[name].push(cb);

    if (this._LOOKUP[name]) {
        cb(this._LOOKUP[name]);
    }
};

JXT.prototype.withTag = function (tag, cb) {
    if (!this._CB_TAG[tag]) {
        this._CB_TAG[tag] = [];
    }
    this._CB_TAG[tag].push(cb);

    this.tagged(tag).forEach(function (stanza) {
        cb(stanza);
    });
};

JXT.prototype.tagged = function (tag) {
    return this._TAGS[tag] || [];
};

JXT.prototype.build = function (xml) {
    var JXTClass = this._LOOKUP[xml.namespaceURI + '|' + xml.localName];
    if (JXTClass) {
        return new JXTClass(null, xml);
    }
};

JXT.prototype.parse = function (str) {
    var xml= ltx.parse(str);
    if (xml.nodeType !== 1) {
        return;
    }

    var JXTClass = this.getDefinition(xml.localName, xml.namespaceURI);
    if (JXTClass) {
        return new JXTClass(null, xml);
    }
};

JXT.prototype.extend = function (ParentJXT, ChildJXT, multiName) {
    var parentName = ParentJXT.prototype._NS + '|' + ParentJXT.prototype._EL;
    var name = ChildJXT.prototype._name;
    var qName = ChildJXT.prototype._NS + '|' + ChildJXT.prototype._EL;

    this._LOOKUP[qName] = ChildJXT;
    if (!this._LOOKUP_EXT[qName]) {
        this._LOOKUP_EXT[qName] = {};
    }
    if (!this._LOOKUP_EXT[parentName]) {
        this._LOOKUP_EXT[parentName] = {};
    }
    this._LOOKUP_EXT[parentName][name] = ChildJXT;

    this.add(ParentJXT, name, types.extension(ChildJXT));
    if (multiName) {
        this.add(ParentJXT, multiName, types.multiExtension(ChildJXT));
    }
};

JXT.prototype.add = function (ParentJXT, fieldName, field) {
    field.enumerable = true;
    Object.defineProperty(ParentJXT.prototype, fieldName, field);
};

JXT.prototype.define = function (opts) {
    var self = this;

    var Stanza = stanzaConstructor(this, opts);

    var ns = Stanza.prototype._NS;
    var el = Stanza.prototype._EL;
    var tags = Stanza.prototype._TAGS;

    var name = ns + '|' + el;
    this._LOOKUP[name] = Stanza;

    tags.forEach(function (tag) {
        if (!self._TAGS[tag]) {
            self._TAGS[tag] = [];
        }
        self._TAGS[tag].push(Stanza);
    });

    var fieldNames = Object.keys(opts.fields || {});
    fieldNames.forEach(function (fieldName) {
        self.add(Stanza, fieldName, opts.fields[fieldName]);
    });

    if (this._CB_DEFINITION[name]) {
        this._CB_DEFINITION[name].forEach(function (handler) {
            handler(Stanza);
        });
    }

    tags.forEach(function (tag) {
        if (self._CB_TAG[tag]) {
            self._CB_TAG[tag].forEach(function (handler) {
                handler(Stanza);
            });
        }
    });

    return Stanza;
};


// Expose methods on the required module itself


JXT.createRegistry = function () {
    return new JXT();
};

extend(JXT, helpers);
extend(JXT, types);

// Compatibility shim for JXT 1.x

var globalJXT = new JXT();

JXT.define = globalJXT.define.bind(globalJXT);
JXT.extend = globalJXT.extend.bind(globalJXT);
JXT.add = globalJXT.add.bind(globalJXT);
JXT.parse = globalJXT.parse.bind(globalJXT);
JXT.build = globalJXT.build.bind(globalJXT);
JXT.getExtensions = globalJXT.getExtensions.bind(globalJXT);
JXT.getDefinition = globalJXT.getDefinition.bind(globalJXT);
JXT.withDefinition = globalJXT.withDefinition.bind(globalJXT);
JXT.withTag = globalJXT.withTag.bind(globalJXT);
JXT.tagged = globalJXT.tagged.bind(globalJXT);

JXT.getGlobalJXT = function () {
    return globalJXT;
};

module.exports = JXT;

},{"./lib/helpers":1561,"./lib/stanza":1562,"./lib/types":1563,"extend-object":1566,"ltx":1569,"node-uuid":1573}],1561:[function(require,module,exports){
'use strict';

var ltx = require('ltx');

var XML_NS = exports.XML_NS = 'http://www.w3.org/XML/1998/namespace';


exports.createElement = function (NS, name, parentNS) {
    var el = new ltx.Element(name);
    if (!parentNS || parentNS !== NS) {
        exports.setAttribute(el, 'xmlns', NS);
    }
    return el;
};

var find = exports.find = function (xml, NS, selector) {
    var results = [];
    var children = xml.getElementsByTagName(selector);
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        if (child.namespaceURI === NS && child.parentNode === xml) {
            results.push(child);
        }
    }
    return results;
};

exports.findOrCreate = function (xml, NS, selector) {
    var existing = exports.find(xml, NS, selector);
    if (existing.length) {
        return existing[0];
    } else {
        var created = exports.createElement(NS, selector, xml.namespaceURI);
        xml.appendChild(created);
        return created;
    }
};

exports.getAttribute = function (xml, attr, defaultVal) {
    return xml.getAttribute(attr) || defaultVal || '';
};

exports.getAttributeNS = function (xml, NS, attr, defaultVal) {
    return xml.getAttributeNS(NS, attr) || defaultVal || '';
};

exports.setAttribute = function (xml, attr, value, force) {
    if (value || force) {
        xml.setAttribute(attr, value);
    } else {
        xml.removeAttribute(attr);
    }
};

exports.setAttributeNS = function (xml, NS, attr, value, force) {
    if (value || force) {
        xml.setAttributeNS(NS, attr, value);
    } else {
        xml.removeAttributeNS(NS, attr);
    }
};

exports.getBoolAttribute = function (xml, attr, defaultVal) {
    var val = xml.getAttribute(attr) || defaultVal || '';
    return val === 'true' || val === '1';
};

exports.setBoolAttribute = function (xml, attr, value) {
    if (value) {
        xml.setAttribute(attr, '1');
    } else {
        xml.removeAttribute(attr);
    }
};

exports.getSubAttribute = function (xml, NS, sub, attr, defaultVal) {
    var subs = find(xml, NS, sub);
    if (!subs) {
        return '';
    }

    for (var i = 0; i < subs.length; i++) {
        return subs[i].getAttribute(attr) || defaultVal || '';
    }

    return '';
};

exports.setSubAttribute = function (xml, NS, sub, attr, value) {
    var subs = find(xml, NS, sub);
    if (!subs.length) {
        if (value) {
            sub = exports.createElement(NS, sub, xml.namespaceURI);
            sub.setAttribute(attr, value);
            xml.appendChild(sub);
        }
    } else {
        for (var i = 0; i < subs.length; i++) {
            if (value) {
                subs[i].setAttribute(attr, value);
                return;
            } else {
                subs[i].removeAttribute(attr);
            }
        }
    }
};

exports.getBoolSubAttribute = function (xml, NS, sub, attr, defaultVal) {
    var val = xml.getSubAttribute(NS, sub, attr) || defaultVal || '';
    return val === 'true' || val === '1';
};

exports.setBoolSubAttribute = function (xml, NS, sub, attr, value) {
    value = value ? '1' : '';
    exports.setSubAttribute(xml, NS, sub, attr, value);
};

exports.getText = function (xml) {
    return xml.textContent;
};

exports.setText = function (xml, value) {
    xml.textContent = value;
};

exports.getSubText = exports.getTextSub = function (xml, NS, element, defaultVal) {
    var subs = find(xml, NS, element);

    defaultVal = defaultVal || '';

    if (!subs.length) {
        return defaultVal;
    }

    return subs[0].textContent || defaultVal;
};

exports.setSubText = exports.setTextSub = function (xml, NS, element, value) {
    var subs = find(xml, NS, element);
    if (subs.length) {
        for (var i = 0; i < subs.length; i++) {
            xml.removeChild(subs[i]);
        }
    }

    if (value) {
        var sub = exports.createElement(NS, element, xml.namespaceURI);
        if (value !== true) {
            sub.textContent = value;
        }
        xml.appendChild(sub);
    }
};

exports.getMultiSubText = function (xml, NS, element, extractor) {
    var subs = find(xml, NS, element);
    var results = [];

    extractor = extractor || function (sub) {
        return sub.textContent || '';
    };

    for (var i = 0; i < subs.length; i++) {
        results.push(extractor(subs[i]));
    }

    return results;
};

exports.setMultiSubText = function (xml, NS, element, value, builder) {
    var subs = find(xml, NS, element);
    var values = [];
    builder = builder || function (value) {
        if (value) {
            var sub = exports.createElement(NS, element, xml.namespaceURI);
            sub.textContent = value;
            xml.appendChild(sub);
        }
    };
    if (typeof value === 'string') {
        values = (value || '').split('\n');
    } else {
        values = value;
    }

    var i, len;
    for(i = 0, len = subs.length; i < len; i++) {
        xml.removeChild(subs[i]);
    }

    for(i = 0, len = values.length; i < len; i++) {
        builder(values[i]);
    }
};

exports.getMultiSubAttribute = function (xml, NS, element, attr) {
    return exports.getMultiSubText(xml, NS, element, function (sub) {
        return exports.getAttribute(sub, attr);
    });
};

exports.setMultiSubAttribute = function (xml, NS, element, attr, value) {
    exports.setMultiSubText(xml, NS, element, value, function (val) {
        var sub = exports.createElement(NS, element, xml.namespaceURI);
        exports.setAttribute(sub, attr, val);
        xml.appendChild(sub);
    });
};

exports.getSubLangText = function (xml, NS, element, defaultLang) {
    var subs = find(xml, NS, element);
    if (!subs.length) {
        return {};
    }

    var lang, sub;
    var results = {};
    var langs = [];

    for (var i = 0; i < subs.length; i++) {
        sub = subs[i];
        lang = sub.getAttributeNS(XML_NS, 'lang') || defaultLang;
        langs.push(lang);
        results[lang] = sub.textContent || '';
    }

    return results;
};

exports.setSubLangText = function (xml, NS, element, value, defaultLang) {
    var sub, lang;
    var subs = find(xml, NS, element);
    if (subs.length) {
        for (var i = 0; i < subs.length; i++) {
            xml.removeChild(subs[i]);
        }
    }

    if (typeof value === 'string') {
        sub = exports.createElement(NS, element, xml.namespaceURI);
        sub.textContent = value;
        xml.appendChild(sub);
    } else if (typeof value === 'object') {
        for (lang in value) {
            if (value.hasOwnProperty(lang)) {
                sub = exports.createElement(NS, element, xml.namespaceURI);
                if (lang !== defaultLang) {
                    sub.setAttributeNS(XML_NS, 'lang', lang);
                }
                sub.textContent = value[lang];
                xml.appendChild(sub);
            }
        }
    }
};

exports.getBoolSub = function (xml, NS, element) {
    var subs = find(xml, NS, element);
    return !!subs.length;
};

exports.setBoolSub = function (xml, NS, element, value) {
    var subs = find(xml, NS, element);
    if (!subs.length) {
        if (value) {
            var sub = exports.createElement(NS, element, xml.namespaceURI);
            xml.appendChild(sub);
        }
    } else {
        for (var i = 0; i < subs.length; i++) {
            if (value) {
                return;
            } else {
                xml.removeChild(subs[i]);
            }
        }
    }
};

},{"ltx":1569}],1562:[function(require,module,exports){
'use strict';

var helpers = require('./helpers');
var extend = require('extend-object');


var EXCLUDE = {
    constructor: true,
    parent: true,
    prototype: true,
    toJSON: true,
    toString: true,
    xml: true
};


module.exports = function (JXT, opts) {
    function Stanza(data, xml, parent) {
        var self = this;

        var parentNode = (xml || {}).parentNode || (parent || {}).xml;
        var parentNS = (parentNode || {}).namespaceURI;

        self.xml = xml || helpers.createElement(self._NS, self._EL, parentNS);

        Object.keys(self._PREFIXES).forEach(function (prefix) {
            var namespace = self._PREFIXES[prefix];
            self.xml.setAttribute('xmlns:' + prefix, namespace);
        });

        self._extensions = {};

        for (var i = 0, len = self.xml.childNodes.length; i < len; i++) {
            var child = self.xml.childNodes[i];
            var ChildJXT = JXT.getDefinition(child.localName, child.namespaceURI);
            if (ChildJXT !== undefined) {
                var name = ChildJXT.prototype._name;
                self._extensions[name] = new ChildJXT(null, child);
                self._extensions[name].parent = self;
            }
        }

        extend(self, data);

        if (opts.init) {
            opts.init.apply(self, [data]);
        }

        return self;
    }


    Stanza.prototype._name = opts.name;
    Stanza.prototype._eventname = opts.eventName;
    Stanza.prototype._NS = opts.namespace;
    Stanza.prototype._EL = opts.element || opts.name;
    Stanza.prototype._PREFIXES = opts.prefixes || {};
    Stanza.prototype._TAGS = opts.tags || [];

    Stanza.prototype.toString = function () {
        return this.xml.toString();
    };

    Stanza.prototype.toJSON = function () {
        var prop;
        var result = {};

        for (prop in this._extensions) {
            if (this._extensions[prop].toJSON && prop[0] !== '_') {
                result[prop] = this._extensions[prop].toJSON();
            }
        }

        for (prop in this) {
            var allowedName = !EXCLUDE[prop] && prop[0] !== '_';
            var isExtensionName = JXT.getExtensions(this._EL, this._NS)[prop];

            if (allowedName && !isExtensionName) {
                var val = this[prop];
                if (typeof val === 'function') {
                    continue;
                }
                var type = Object.prototype.toString.call(val);
                if (type.indexOf('Object') >= 0) {
                    if (Object.keys(val).length > 0) {
                        result[prop] = val;
                    }
                } else if (type.indexOf('Array') >= 0) {
                    if (val.length > 0) {
                        var vals = [];
                        for (var n in val) {
                            var nval = val[n];
                            if (nval.toJSON !== undefined) {
                                vals.push(nval.toJSON());
                            } else {
                                vals.push(nval);
                            }
                        }
                        result[prop] = vals;
                    }
                } else if (val !== undefined && val !== false && val !== '') {
                    result[prop] = val;
                }
            }
        }

        return result;
    };

    return Stanza;
};

},{"./helpers":1561,"extend-object":1566}],1563:[function(require,module,exports){
'use strict';

var fromB64 = require('atob');
var toB64 = require('btoa');

var helpers = require('./helpers');
var extend = require('extend-object');

var find = helpers.find;
var createElement = helpers.createElement;


var field = exports.field = function (getter, setter) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return {
            get: function () {
                return getter.apply(null, [this.xml].concat(args));
            },
            set: function (value) {
                setter.apply(null, ([this.xml].concat(args)).concat([value]));
            }
        };
    };
};

exports.boolAttribute = field(
    helpers.getBoolAttribute,
    helpers.setBoolAttribute);

exports.subAttribute = field(
    helpers.getSubAttribute,
    helpers.setSubAttribute);

exports.boolSubAttribute = field(
    helpers.getSubBoolAttribute,
    helpers.setSubBoolAttribute);

exports.text = field(
    helpers.getText,
    helpers.setText);

exports.textSub = exports.subText = field(
    helpers.getSubText,
    helpers.setSubText);

exports.multiTextSub = exports.multiSubText = field(
    helpers.getMultiSubText,
    helpers.setMultiSubText);

exports.multiSubAttribute  = field(
    helpers.getMultiSubAttribute,
    helpers.setMultiSubAttribute);

exports.langTextSub = exports.subLangText = field(
    helpers.getSubLangText,
    helpers.setSubLangText);

exports.boolSub = field(
    helpers.getBoolSub,
    helpers.setBoolSub);

exports.langAttribute = field(
    function (xml) {
        return xml.getAttributeNS(helpers.XML_NS, 'lang') || '';
    },
    function (xml, value) {
        xml.setAttributeNS(helpers.XML_NS, 'lang', value);
    }
);

exports.b64Text = field(
    function (xml) {
        if (xml.textContent && xml.textContent !== '=') {
            return fromB64(xml.textContent);
        }
        return '';
    },
    function (xml, value) {
        if (typeof value === 'string') {
            xml.textContent = toB64(value) || '=';
        } else {
            xml.textContent = '';
        }
    }
);

exports.dateAttribute = function (attr, now) {
    return {
        get: function () {
            var data = helpers.getAttribute(this.xml, attr);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setAttribute(this.xml, attr, value);
        }
    };
};

exports.dateSub = function (NS, sub, now) {
    return {
        get: function () {
            var data = helpers.getSubText(this.xml, NS, sub);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setSubText(this.xml, NS, sub, value);
        }
    };
};

exports.dateSubAttribute = function (NS, sub, attr, now) {
    return {
        get: function () {
            var data = helpers.getSubAttribute(this.xml, NS, sub, attr);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setSubAttribute(this.xml, NS, sub, attr, value);
        }
    };
};

exports.numberAttribute = function (attr, isFloat, defaultVal) {
    return {
        get: function () {
            var parse = isFloat ? parseFloat : parseInt;
            var data = helpers.getAttribute(this.xml, attr, '');
            if (!data) {
                return defaultVal;
            }
            var parsed = parse(data, 10);
            if (isNaN(parsed)) {
                return defaultVal;
            }

            return parsed;
        },
        set: function (value) {
            helpers.setAttribute(this.xml, attr, value.toString());
        }
    };
};

exports.numberSub = function (NS, sub, isFloat, defaultVal) {
    return {
        get: function () {
            var parse = isFloat ? parseFloat : parseInt;
            var data = helpers.getSubText(this.xml, NS, sub, '');
            if (!data) {
                return defaultVal;
            }

            var parsed = parse(data, 10);
            if (isNaN(parsed)) {
                return defaultVal;
            }

            return parsed;
        },
        set: function (value) {
            helpers.setSubText(this.xml, NS, sub, value.toString());
        }
    };
};

exports.attribute = function (name, defaultVal) {
    return {
        get: function () {
            return helpers.getAttribute(this.xml, name, defaultVal);
        },
        set: function (value) {
            helpers.setAttribute(this.xml, name, value);
        }
    };
};

exports.attributeNS = function (NS, name, defaultVal) {
    return {
        get: function () {
            return helpers.getAttributeNS(this.xml, NS, name, defaultVal);
        },
        set: function (value) {
            helpers.setAttributeNS(this.xml, NS, name, value);
        }
    };
};

exports.extension = function (ChildJXT) {
    return {
        get: function () {
            var self = this;
            var name = ChildJXT.prototype._name;
            if (!this._extensions[name]) {
                var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
                if (!existing.length) {
                    this._extensions[name] = new ChildJXT({}, null, self);
                    this.xml.appendChild(this._extensions[name].xml);
                } else {
                    this._extensions[name] = new ChildJXT(null, existing[0], self);
                }
                this._extensions[name].parent = this;
            }
            return this._extensions[name];
        },
        set: function (value) {
            if (value) {
                var child = this[ChildJXT.prototype._name];
                if (value === true) {
                    value = {};
                }
                extend(child, value);
            }
        }
    };
};

exports.multiExtension = function (ChildJXT) {
    return {
        get: function () {
            var self = this;
            var data = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
            var results = [];

            for (var i = 0, len = data.length; i < len; i++) {
                results.push(new ChildJXT({}, data[i], self));
            }

            return results;
        },
        set: function (value) {
            value = value || [];

            var self = this;
            var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

            var i, len;
            for (i = 0, len = existing.length; i < len; i++) {
                self.xml.removeChild(existing[i]);
            }

            for (i = 0, len = value.length; i < len; i++) {
                var content = new ChildJXT(value[i], null, self);
                self.xml.appendChild(content.xml);
            }
        }
    };
};

exports.enumSub = function (NS, enumValues) {
    return {
        get: function () {
            var self = this;
            var result = [];
            enumValues.forEach(function (enumVal) {
                var exists = find(self.xml, NS, enumVal);
                if (exists.length) {
                    result.push(exists[0].nodeName);
                }
            });
            return result[0] || '';
        },
        set: function (value) {
            var self = this;
            enumValues.forEach(function (enumVal) {
                var exists = find(self.xml, NS, enumVal);
                if (exists.length) {
                    self.xml.removeChild(exists[0]);
                }
            });

            if (value) {
                var condition = createElement(NS, value);
                this.xml.appendChild(condition);
            }
        }
    };
};

exports.subExtension = function (name, NS, sub, ChildJXT) {
    return {
        get: function () {
            if (!this._extensions[name]) {
                var wrapper = find(this.xml, NS, sub);
                if (!wrapper.length) {
                    wrapper= createElement(NS, sub, this._NS);
                    this.xml.appendChild(wrapper);
                } else {
                    wrapper = wrapper[0];
                }

                var existing = find(wrapper, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
                if (!existing.length) {
                    this._extensions[name] = new ChildJXT({}, null, {xml: wrapper});
                    wrapper.appendChild(this._extensions[name].xml);
                } else {
                    this._extensions[name] = new ChildJXT(null, existing[0], {xml: wrapper});
                }
                this._extensions[name].parent = this;
            }
            return this._extensions[name];
        },
        set: function (value) {
            var wrapper = find(this.xml, NS, sub);
            if (wrapper.length && !value) {
                this.xml.removeChild(wrapper[0]);
            }

            if (value) {
                var child = this[name];
                if (value === true) {
                    value = {};
                }
                extend(child, value);
            }
        }
    };
};

exports.subMultiExtension = function (NS, sub, ChildJXT) {
    return {
        get: function () {
            var self = this;
            var results = [];
            var existing = find(this.xml, NS, sub);
            if (!existing.length) {
                return results;
            }
            existing = existing[0];
            var data = find(existing, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

            data.forEach(function (xml) {
                results.push(new ChildJXT({}, xml, self));
            });
            return results;
        },
        set: function (values) {
            var self = this;
            var existing = find(this.xml, NS, sub);
            if (existing.length) {
                self.xml.removeChild(existing[0]);
            }

            if (!values.length) {
                return;
            }

            existing = createElement(NS, sub, this._NS);

            values.forEach(function (value) {
                var content = new ChildJXT(value, null, self);
                existing.appendChild(content.xml);
            });

            self.xml.appendChild(existing);
        }
    };
};

},{"./helpers":1561,"atob":1564,"btoa":1565,"extend-object":1566}],1564:[function(require,module,exports){
(function (Buffer){
(function () {
  "use strict";

  function atob(str) {
    return new Buffer(str, 'base64').toString('binary');
  }

  module.exports = atob;
}());

}).call(this,require("buffer").Buffer)
},{"buffer":9}],1565:[function(require,module,exports){
(function (Buffer){
(function () {
  "use strict";

  function btoa(str) {
    var buffer
      ;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = new Buffer(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());

}).call(this,require("buffer").Buffer)
},{"buffer":9}],1566:[function(require,module,exports){
module.exports=require(1487)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/jingle/node_modules/extend-object/extend-object.js":1487}],1567:[function(require,module,exports){
'use strict';

var util = require('util')
  , Element = require('./element').Element

function DOMElement(name, attrs) {
    Element.call(this, name, attrs)

    this.nodeType = 1
    this.nodeName = this.localName
}

util.inherits(DOMElement, Element)

DOMElement.prototype._getElement = function(name, attrs) {
    var element = new DOMElement(name, attrs)
    return element
}

Object.defineProperty(DOMElement.prototype, 'localName', {
    get: function () {
        return this.getName()
    }
})

Object.defineProperty(DOMElement.prototype, 'namespaceURI', {
    get: function () {
        return this.getNS()
    }
})

Object.defineProperty(DOMElement.prototype, 'parentNode', {
    get: function () {
        return this.parent
    }
})

Object.defineProperty(DOMElement.prototype, 'childNodes', {
    get: function () {
        return this.children
    }
})

Object.defineProperty(DOMElement.prototype, 'textContent', {
    get: function () {
        return this.getText()
    },
    set: function (value) {
        this.children.push(value)
    }
})

DOMElement.prototype.getElementsByTagName = function (name) {
    return this.getChildren(name)
}

DOMElement.prototype.getAttribute = function (name) {
    return this.getAttr(name)
}

DOMElement.prototype.setAttribute = function (name, value) {
    this.attr(name, value)
}

DOMElement.prototype.getAttributeNS = function (ns, name) {
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        return this.getAttr(['xml', name].join(':'))
    }
    return this.getAttr(name, ns)
}

DOMElement.prototype.setAttributeNS = function (ns, name, value) {
    var prefix
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        prefix = 'xml'
    } else {
        var nss = this.getXmlns()
        prefix = nss[ns] || ''
    }
    if (prefix) {
        this.attr([prefix, name].join(':'), value)
    }
}

DOMElement.prototype.removeAttribute = function (name) {
    this.attr(name, null)
}

DOMElement.prototype.removeAttributeNS = function (ns, name) {
    var prefix
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        prefix = 'xml'
    } else {
        var nss = this.getXmlns()
        prefix = nss[ns] || ''
    }
    if (prefix) {
        this.attr([prefix, name].join(':'), null)
    }
}

DOMElement.prototype.appendChild = function (el) {
    this.cnode(el)
}

DOMElement.prototype.removeChild = function (el) {
    this.remove(el)
}

module.exports = DOMElement

},{"./element":1568,"util":43}],1568:[function(require,module,exports){
'use strict';

/**
 * This cheap replica of DOM/Builder puts me to shame :-)
 *
 * Attributes are in the element.attrs object. Children is a list of
 * either other Elements or Strings for text content.
 **/
function Element(name, attrs) {
    this.name = name
    this.parent = null
    this.attrs = attrs || {}
    this.children = []
}

/*** Accessors ***/

/**
 * if (element.is('message', 'jabber:client')) ...
 **/
Element.prototype.is = function(name, xmlns) {
    return (this.getName() === name) &&
        (!xmlns || (this.getNS() === xmlns))
}

/* without prefix */
Element.prototype.getName = function() {
    if (this.name.indexOf(':') >= 0)
        return this.name.substr(this.name.indexOf(':') + 1)
    else
        return this.name
}

/**
 * retrieves the namespace of the current element, upwards recursively
 **/
Element.prototype.getNS = function() {
    if (this.name.indexOf(':') >= 0) {
        var prefix = this.name.substr(0, this.name.indexOf(':'))
        return this.findNS(prefix)
    } else {
        return this.findNS()
    }
}

/**
 * find the namespace to the given prefix, upwards recursively
 **/
Element.prototype.findNS = function(prefix) {
    if (!prefix) {
        /* default namespace */
        if (this.attrs.xmlns)
            return this.attrs.xmlns
        else if (this.parent)
            return this.parent.findNS()
    } else {
        /* prefixed namespace */
        var attr = 'xmlns:' + prefix
        if (this.attrs[attr])
            return this.attrs[attr]
        else if (this.parent)
            return this.parent.findNS(prefix)
    }
}

/**
 * Recursiverly gets all xmlns defined, in the form of {url:prefix}
 **/
Element.prototype.getXmlns = function() {
    var namespaces = {}

    if (this.parent)
        namespaces = this.parent.getXmlns()

    for (var attr in this.attrs) {
        var m = attr.match('xmlns:?(.*)')
        if (this.attrs.hasOwnProperty(attr) && m) {
            namespaces[this.attrs[attr]] = m[1]
        }
    }
    return namespaces
}


/**
 * xmlns can be null, returns the matching attribute.
 **/
Element.prototype.getAttr = function(name, xmlns) {
    if (!xmlns)
        return this.attrs[name]

    var namespaces = this.getXmlns()

    if (!namespaces[xmlns])
        return null

    return this.attrs[[namespaces[xmlns], name].join(':')]
}

/**
 * xmlns can be null
 **/
Element.prototype.getChild = function(name, xmlns) {
    return this.getChildren(name, xmlns)[0]
}

/**
 * xmlns can be null
 **/
Element.prototype.getChildren = function(name, xmlns) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (child.getName &&
            (child.getName() === name) &&
            (!xmlns || (child.getNS() === xmlns)))
            result.push(child)
    }
    return result
}

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildByAttr = function(attr, val, xmlns, recursive) {
    return this.getChildrenByAttr(attr, val, xmlns, recursive)[0]
}

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildrenByAttr = function(attr, val, xmlns, recursive) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (child.attrs &&
            (child.attrs[attr] === val) &&
            (!xmlns || (child.getNS() === xmlns)))
            result.push(child)
        if (recursive && child.getChildrenByAttr) {
            result.push(child.getChildrenByAttr(attr, val, xmlns, true))
        }
    }
    if (recursive) result = [].concat.apply([], result)
    return result
}

Element.prototype.getChildrenByFilter = function(filter, recursive) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (filter(child))
            result.push(child)
        if (recursive && child.getChildrenByFilter){
            result.push(child.getChildrenByFilter(filter, true))
        }
    }
    if (recursive) {
        result = [].concat.apply([], result)
    }
    return result
}

Element.prototype.getText = function() {
    var text = ''
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if ((typeof child === 'string') || (typeof child === 'number')) {
            text += child
        }
    }
    return text
}

Element.prototype.getChildText = function(name, xmlns) {
    var child = this.getChild(name, xmlns)
    return child ? child.getText() : null
}

/**
 * Return all direct descendents that are Elements.
 * This differs from `getChildren` in that it will exclude text nodes,
 * processing instructions, etc.
 */
Element.prototype.getChildElements = function() {
    return this.getChildrenByFilter(function(child) {
        return child instanceof Element
    })
}

/*** Builder ***/

/** returns uppermost parent */
Element.prototype.root = function() {
    if (this.parent)
        return this.parent.root()
    else
        return this
}
Element.prototype.tree = Element.prototype.root

/** just parent or itself */
Element.prototype.up = function() {
    if (this.parent)
        return this.parent
    else
        return this
}

Element.prototype._getElement = function(name, attrs) {
    var element = new Element(name, attrs)
    return element
}

/** create child node and return it */
Element.prototype.c = function(name, attrs) {
    return this.cnode(this._getElement(name, attrs))
}

Element.prototype.cnode = function(child) {
    this.children.push(child)
    child.parent = this
    return child
}

/** add text node and return element */
Element.prototype.t = function(text) {
    this.children.push(text)
    return this
}

/*** Manipulation ***/

/**
 * Either:
 *   el.remove(childEl)
 *   el.remove('author', 'urn:...')
 */
Element.prototype.remove = function(el, xmlns) {
    var filter
    if (typeof el === 'string') {
        /* 1st parameter is tag name */
        filter = function(child) {
            return !(child.is &&
                 child.is(el, xmlns))
        }
    } else {
        /* 1st parameter is element */
        filter = function(child) {
            return child !== el
        }
    }

    this.children = this.children.filter(filter)

    return this
}

/**
 * To use in case you want the same XML data for separate uses.
 * Please refrain from this practise unless you know what you are
 * doing. Building XML with ltx is easy!
 */
Element.prototype.clone = function() {
    var clone = this._getElement(this.name, {})
    for (var k in this.attrs) {
        if (this.attrs.hasOwnProperty(k))
            clone.attrs[k] = this.attrs[k]
    }
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        clone.cnode(child.clone ? child.clone() : child)
    }
    return clone
}

Element.prototype.text = function(val) {
    if (val && this.children.length === 1) {
        this.children[0] = val
        return this
    }
    return this.getText()
}

Element.prototype.attr = function(attr, val) {
    if (((typeof val !== 'undefined') || (val === null))) {
        if (!this.attrs) {
            this.attrs = {}
        }
        this.attrs[attr] = val
        return this
    }
    return this.attrs[attr]
}

/*** Serialization ***/

Element.prototype.toString = function() {
    var s = ''
    this.write(function(c) {
        s += c
    })
    return s
}

Element.prototype.toJSON = function() {
    return {
        name: this.name,
        attrs: this.attrs,
        children: this.children.map(function(child) {
            return child && child.toJSON ? child.toJSON() : child;
        })
    }
}

Element.prototype._addChildren = function(writer) {
    writer('>')
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        /* Skip null/undefined */
        if (child || (child === 0)) {
            if (child.write) {
                child.write(writer)
            } else if (typeof child === 'string') {
                writer(escapeXmlText(child))
            } else if (child.toString) {
                writer(escapeXmlText(child.toString(10)))
            }
        }
    }
    writer('</')
    writer(this.name)
    writer('>')
}

Element.prototype.write = function(writer) {
    writer('<')
    writer(this.name)
    for (var k in this.attrs) {
        var v = this.attrs[k]
        if (v || (v === '') || (v === 0)) {
            writer(' ')
            writer(k)
            writer('="')
            if (typeof v !== 'string') {
                v = v.toString(10)
            }
            writer(escapeXml(v))
            writer('"')
        }
    }
    if (this.children.length === 0) {
        writer('/>')
    } else {
        this._addChildren(writer)
    }
}

function escapeXml(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;').
        replace(/"/g, '&quot;').
        replace(/"/g, '&apos;')
}

function escapeXmlText(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;')
}

exports.Element = Element
exports.escapeXml = escapeXml

},{}],1569:[function(require,module,exports){
'use strict';

/* Cause browserify to bundle SAX parsers: */
var parse = require('./parse')

parse.availableSaxParsers.push(parse.bestSaxParser = require('./sax/sax_ltx'))

/* SHIM */
module.exports = require('./index')
},{"./index":1570,"./parse":1571,"./sax/sax_ltx":1572}],1570:[function(require,module,exports){
'use strict';

var parse = require('./parse')

/**
 * The only (relevant) data structure
 */
exports.Element = require('./dom-element')

/**
 * Helper
 */
exports.escapeXml = require('./element').escapeXml

/**
 * DOM parser interface
 */
exports.parse = parse.parse
exports.Parser = parse.Parser

/**
 * SAX parser interface
 */
exports.availableSaxParsers = parse.availableSaxParsers
exports.bestSaxParser = parse.bestSaxParser

},{"./dom-element":1567,"./element":1568,"./parse":1571}],1571:[function(require,module,exports){
'use strict';

var events = require('events')
  , util = require('util')
  , DOMElement = require('./dom-element')


exports.availableSaxParsers = []
exports.bestSaxParser = null

var saxParsers = [
    './sax/sax_expat.js',
    './sax/sax_ltx.js',
    /*'./sax_easysax.js', './sax_node-xml.js',*/
    './sax/sax_saxjs.js'
]

saxParsers.forEach(function(modName) {
    var mod
    try {
        mod = require(modName)
    } catch (e) {
        /* Silently missing libraries drop for debug:
        console.error(e.stack || e)
         */
    }
    if (mod) {
        exports.availableSaxParsers.push(mod)
        if (!exports.bestSaxParser) {
            exports.bestSaxParser = mod
        }
    }
})

exports.Parser = function(saxParser) {
    events.EventEmitter.call(this)
    var self = this

    var ParserMod = saxParser || exports.bestSaxParser
    if (!ParserMod) {
        throw new Error('No SAX parser available')
    }
    this.parser = new ParserMod()

    var el
    this.parser.addListener('startElement', function(name, attrs) {
        var child = new DOMElement(name, attrs)
        if (!el) {
            el = child
        } else {
            el = el.cnode(child)
        }
    })
    this.parser.addListener('endElement', function(name) {
        /* jshint -W035 */
        if (!el) {
            /* Err */
        } else if (name === el.name) {
            if (el.parent) {
                el = el.parent
            } else if (!self.tree) {
                self.tree = el
                el = undefined
            }
        }
        /* jshint +W035 */
    })
    this.parser.addListener('text', function(str) {
        if (el) {
            el.t(str)
        }
    })
    this.parser.addListener('error', function(e) {
        self.error = e
        self.emit('error', e)
    })
}

util.inherits(exports.Parser, events.EventEmitter)

exports.Parser.prototype.write = function(data) {
    this.parser.write(data)
}

exports.Parser.prototype.end = function(data) {
    this.parser.end(data)

    if (!this.error) {
        if (this.tree) {
            this.emit('tree', this.tree)
        } else {
            this.emit('error', new Error('Incomplete document'))
        }
    }
}

exports.parse = function(data, saxParser) {
    var p = new exports.Parser(saxParser)
    var result = null
      , error = null

    p.on('tree', function(tree) {
        result = tree
    })
    p.on('error', function(e) {
        error = e
    })

    p.write(data)
    p.end()

    if (error) {
        throw error
    } else {
        return result
    }
}

},{"./dom-element":1567,"events":13,"util":43}],1572:[function(require,module,exports){
'use strict';

var util = require('util')
  , events = require('events')

var STATE_TEXT = 0,
    STATE_IGNORE_TAG = 1,
    STATE_TAG_NAME = 2,
    STATE_TAG = 3,
    STATE_ATTR_NAME = 4,
    STATE_ATTR_EQ = 5,
    STATE_ATTR_QUOT = 6,
    STATE_ATTR_VALUE = 7

var SaxLtx = module.exports = function SaxLtx() {
    events.EventEmitter.call(this)

    var state = STATE_TEXT, remainder
    var tagName, attrs, endTag, selfClosing, attrQuote
    var recordStart = 0
    var attrName

    this._handleTagOpening = function(endTag, tagName, attrs) {
        if (!endTag) {
            this.emit('startElement', tagName, attrs)
            if (selfClosing) {
                this.emit('endElement', tagName)
            }
        } else {
            this.emit('endElement', tagName)
        }
    }

    this.write = function(data) {
        /* jshint -W071 */
        /* jshint -W074 */
        if (typeof data !== 'string') {
            data = data.toString()
        }
        var pos = 0

        /* Anything from previous write()? */
        if (remainder) {
            data = remainder + data
            pos += remainder.length
            remainder = null
        }

        function endRecording() {
            if (typeof recordStart === 'number') {
                var recorded = data.slice(recordStart, pos)
                recordStart = undefined
                return recorded
            }
        }

        for(; pos < data.length; pos++) {
            var c = data.charCodeAt(pos)
            //console.log("state", state, "c", c, data[pos])
            switch(state) {
            case STATE_TEXT:
                if (c === 60 /* < */) {
                    var text = endRecording()
                    if (text) {
                        this.emit('text', unescapeXml(text))
                    }
                    state = STATE_TAG_NAME
                    recordStart = pos + 1
                    attrs = {}
                }
                break
            case STATE_TAG_NAME:
                if (c === 47 /* / */ && recordStart === pos) {
                    recordStart = pos + 1
                    endTag = true
                } else if (c === 33 /* ! */ || c === 63 /* ? */) {
                    recordStart = undefined
                    state = STATE_IGNORE_TAG
                } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
                    tagName = endRecording()
                    pos--
                    state = STATE_TAG
                }
                break
            case STATE_IGNORE_TAG:
                if (c === 62 /* > */) {
                    state = STATE_TEXT
                }
                break
            case STATE_TAG:
                if (c === 62 /* > */) {
                    this._handleTagOpening(endTag, tagName, attrs)
                    tagName = undefined
                    attrs = undefined
                    endTag = undefined
                    selfClosing = undefined
                    state = STATE_TEXT
                    recordStart = pos + 1
                } else if (c === 47 /* / */) {
                    selfClosing = true
                } else if (c > 32) {
                    recordStart = pos
                    state = STATE_ATTR_NAME
                }
                break
            case STATE_ATTR_NAME:
                if (c <= 32 || c === 61 /* = */) {
                    attrName = endRecording()
                    pos--
                    state = STATE_ATTR_EQ
                }
                break
            case STATE_ATTR_EQ:
                if (c === 61 /* = */) {
                    state = STATE_ATTR_QUOT
                }
                break
            case STATE_ATTR_QUOT:
                if (c === 34 /* " */ || c === 39 /* ' */) {
                    attrQuote = c
                    state = STATE_ATTR_VALUE
                    recordStart = pos + 1
                }
                break
            case STATE_ATTR_VALUE:
                if (c === attrQuote) {
                    var value = unescapeXml(endRecording())
                    attrs[attrName] = value
                    attrName = undefined
                    state = STATE_TAG
                }
                break
            }
        }

        if (typeof recordStart === 'number' &&
            recordStart <= data.length) {

            remainder = data.slice(recordStart)
            recordStart = 0
        }
    }

    /*var origEmit = this.emit
    this.emit = function() {
    console.log('ltx', arguments)
    origEmit.apply(this, arguments)
    }*/
}
util.inherits(SaxLtx, events.EventEmitter)


SaxLtx.prototype.end = function(data) {
    if (data) {
        this.write(data)
    }

    /* Uh, yeah */
    this.write = function() {}
}

function unescapeXml(s) {
    return s.
        replace(/\&(amp|#38);/g, '&').
        replace(/\&(lt|#60);/g, '<').
        replace(/\&(gt|#62);/g, '>').
        replace(/\&(quot|#34);/g, '"').
        replace(/\&(apos|#39);/g, '\'').
        replace(/\&(nbsp|#160);/g, '\n')
}

},{"events":13,"util":43}],1573:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(_global.require) == 'function') {
    try {
      var _rb = _global.require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
 

  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

},{}],1574:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * ANONYMOUS `Mechanism` constructor.
   *
   * This class implements the ANONYMOUS SASL mechanism.
   *
   * The ANONYMOUS SASL mechanism provides support for permitting anonymous
   * access to various services
   *
   * References:
   *  - [RFC 4505](http://tools.ietf.org/html/rfc4505)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'ANONYMOUS';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using optional trace information.
   *
   * Options:
   *  - `trace`  trace information (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    return cred.trace || '';
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
  };

  exports = module.exports = Mechanism;
  
}));

},{}],1575:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports,
            module,
            require('./lib/mechanism'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports',
            'module',
            './lib/mechanism'], factory);
  }
}(this, function(exports, module, Mechanism) {

  exports = module.exports = Mechanism;
  exports.Mechanism = Mechanism;
  
}));

},{"./lib/mechanism":1574}],1576:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * EXTERNAL `Mechanism` constructor.
   *
   * This class implements the EXTERNAL SASL mechanism.
   *
   * The EXTERNAL SASL mechanism provides support for authentication using
   * credentials established by external means. 
   *
   * References:
   *  - [RFC 4422](http://tools.ietf.org/html/rfc4422)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'EXTERNAL';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using given credential.
   *
   * Options:
   *  - `authzid`   authorization identity (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    return cred.authzid || '';
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
  };

  exports = module.exports = Mechanism;
  
}));

},{}],1577:[function(require,module,exports){
arguments[4][1575][0].apply(exports,arguments)
},{"./lib/mechanism":1576,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/sasl-anonymous/main.js":1575}],1578:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * PLAIN `Mechanism` constructor.
   *
   * This class implements the PLAIN SASL mechanism.
   *
   * The PLAIN SASL mechanism provides support for exchanging a clear-text
   * username and password.  This mechanism should not be used without adequate
   * security provided by an underlying transport layer. 
   *
   * References:
   *  - [RFC 4616](http://tools.ietf.org/html/rfc4616)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'PLAIN';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using given credential.
   *
   * Options:
   *  - `username`
   *  - `password`
   *  - `authzid`   authorization identity (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    var str = '';
    str += cred.authzid || '';
    str += '\0';
    str += cred.username;
    str += '\0';
    str += cred.password;
    return str;
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @return {Mechanism} for chaining
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
    return this;
  };

  exports = module.exports = Mechanism;
  
}));

},{}],1579:[function(require,module,exports){
arguments[4][1575][0].apply(exports,arguments)
},{"./lib/mechanism":1578,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/sasl-anonymous/main.js":1575}],1580:[function(require,module,exports){
(function (Buffer){
var bitops = require('./lib/bitops');
var utils = require('./lib/utils');

var RESP = {};
var CLIENT_KEY = 'Client Key';
var SERVER_KEY = 'Server Key';


function Mechanism(options) {
    options = options || {};
    this._genNonce = options.genNonce || utils.genNonce;
    this._stage = 'initial';
}

// Conform to the SASL lib's expectations
Mechanism.Mechanism = Mechanism;


Mechanism.prototype.name = 'SCRAM-SHA-1';
Mechanism.prototype.clientFirst = true;


Mechanism.prototype.response = function (cred) {
    return RESP[this._stage](this, cred);
};

Mechanism.prototype.challenge = function (chal) {
    var values = utils.parse(chal);

    this._salt = new Buffer(values.s || '', 'base64');
    this._iterationCount = parseInt(values.i, 10);
    this._nonce = values.r;
    this._verifier = values.v;
    this._error = values.e;
    this._challenge = chal;

    return this;
};


RESP.initial = function (mech, cred) {
    mech._cnonce = mech._genNonce();

    var authzid = '';
    if (cred.authzid) {
        authzid = 'a=' + utils.saslname(cred.authzid);
    }

    mech._gs2Header = 'n,' + authzid + ',';

    var nonce = 'r=' + mech._cnonce;
    var username = 'n=' + utils.saslname(cred.username || '');

    mech._clientFirstMessageBare = username + ',' + nonce;
    var result = mech._gs2Header + mech._clientFirstMessageBare;

    mech._stage = 'challenge';

    return result;
};


RESP.challenge = function (mech, cred) {
    var gs2Header = new Buffer(mech._gs2Header).toString('base64');

    mech._clientFinalMessageWithoutProof = 'c=' + gs2Header + ',r=' + mech._nonce;

    var saltedPassword, clientKey, serverKey;

    // If our cached salt is the same, we can reuse cached credentials to speed
    // up the hashing process.
    if (cred.salt && Buffer.compare(cred.salt, mech._salt) === 0) {
        if (cred.clientKey && cred.serverKey) {
            clientKey = cred.clientKey;
            serverKey = cred.serverKey;
        } else if (cred.saltedPassword) {
            saltedPassword = cred.saltedPassword;
            clientKey = bitops.HMAC(saltedPassword, CLIENT_KEY);
            serverKey = bitops.HMAC(saltedPassword, SERVER_KEY);
        }
    } else {
        saltedPassword = bitops.Hi(cred.password || '', mech._salt, mech._iterationCount);
        clientKey = bitops.HMAC(saltedPassword, CLIENT_KEY);
        serverKey = bitops.HMAC(saltedPassword, SERVER_KEY);
    }

    var storedKey = bitops.H(clientKey);
    var authMessage = mech._clientFirstMessageBare + ',' +
                      mech._challenge + ',' +
                      mech._clientFinalMessageWithoutProof;
    var clientSignature = bitops.HMAC(storedKey, authMessage);

    var clientProof = bitops.XOR(clientKey, clientSignature).toString('base64');

    mech._serverSignature = bitops.HMAC(serverKey, authMessage);

    var result = mech._clientFinalMessageWithoutProof + ',p=' + clientProof;

    mech._stage = 'final';

    mech.cache = {
        salt: mech._salt,
        saltedPassword: saltedPassword,
        clientKey: clientKey,
        serverKey: serverKey
    };

    return result;
};

RESP.final = function () {
    // TODO: Signal errors
    return '';
};



module.exports = Mechanism;

}).call(this,require("buffer").Buffer)
},{"./lib/bitops":1581,"./lib/utils":1582,"buffer":9}],1581:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
var createHmac = require('create-hmac');
var xor = require('bitwise-xor');


exports.XOR = xor;

exports.H = function (text) {
    return createHash('sha1').update(text).digest();
};

exports.HMAC = function (key, msg) {
    return createHmac('sha1', key).update(msg).digest();
};

exports.Hi = function (text, salt, iterations) {
    var ui1 = exports.HMAC(text, Buffer.concat([salt, new Buffer([0, 0, 0, 1], 'binary')]));
    var ui = ui1;
    for (var i = 0; i < iterations - 1; i++) {
        ui1 = exports.HMAC(text, ui1);
        ui = exports.XOR(ui, ui1);
    }

    return ui;
};


}).call(this,require("buffer").Buffer)
},{"bitwise-xor":1583,"buffer":9,"create-hash":1584,"create-hmac":1597}],1582:[function(require,module,exports){
var randomBytes = require('randombytes');


exports.parse = function (chal) {
    var dtives = {};
    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
    for (var i = 0, len = tokens.length; i < len; i++) {
        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
        if (dtiv) {
            dtives[dtiv[1]] = dtiv[2];
        }
    }
    return dtives;
};

exports.saslname = function (name) {
    var escaped = [];
    var curr = '';
    for (var i = 0; i < name.length; i++) {
        curr = name[i];
        if (curr === ',') {
            escaped.push('=2C');
        } else if (curr === '=') {
            escaped.push('=3D');
        } else {
            escaped.push(curr);
        }
    }
    return escaped.join('');
};

exports.genNonce = function (len) {
    return randomBytes((len || 32) / 2).toString('hex');
};

},{"randombytes":1599}],1583:[function(require,module,exports){
(function (Buffer){
module.exports = xor

function xor(a, b) {
  if (!Buffer.isBuffer(a)) a = new Buffer(a)
  if (!Buffer.isBuffer(b)) b = new Buffer(b)
  var res = []
  if (a.length > b.length) {
    for (var i = 0; i < b.length; i++) {
      res.push(a[i] ^ b[i])
    }
  } else {
    for (var i = 0; i < a.length; i++) {
      res.push(a[i] ^ b[i])
    }
  }
  return new Buffer(res);
}

}).call(this,require("buffer").Buffer)
},{"buffer":9}],1584:[function(require,module,exports){
module.exports=require(1449)
},{"./md5":1586,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/browser.js":1449,"buffer":9,"inherits":1587,"ripemd160":1588,"sha.js":1590,"stream":39}],1585:[function(require,module,exports){
module.exports=require(1450)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/helpers.js":1450,"buffer":9}],1586:[function(require,module,exports){
module.exports=require(1451)
},{"./helpers":1585,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/md5.js":1451}],1587:[function(require,module,exports){
module.exports=require(19)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/node_modules/inherits/inherits_browser.js":19}],1588:[function(require,module,exports){
module.exports=require(1453)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":1453,"buffer":9}],1589:[function(require,module,exports){
module.exports=require(1454)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/hash.js":1454,"buffer":9}],1590:[function(require,module,exports){
module.exports=require(1455)
},{"./sha":1591,"./sha1":1592,"./sha224":1593,"./sha256":1594,"./sha384":1595,"./sha512":1596,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/index.js":1455}],1591:[function(require,module,exports){
module.exports=require(1456)
},{"./hash":1589,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha.js":1456,"buffer":9,"inherits":1587}],1592:[function(require,module,exports){
module.exports=require(1457)
},{"./hash":1589,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha1.js":1457,"buffer":9,"inherits":1587}],1593:[function(require,module,exports){
module.exports=require(1458)
},{"./hash":1589,"./sha256":1594,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha224.js":1458,"buffer":9,"inherits":1587}],1594:[function(require,module,exports){
module.exports=require(1459)
},{"./hash":1589,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha256.js":1459,"buffer":9,"inherits":1587}],1595:[function(require,module,exports){
module.exports=require(1460)
},{"./hash":1589,"./sha512":1596,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha384.js":1460,"buffer":9,"inherits":1587}],1596:[function(require,module,exports){
module.exports=require(1461)
},{"./hash":1589,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/create-hash/node_modules/sha.js/sha512.js":1461,"buffer":9,"inherits":1587}],1597:[function(require,module,exports){
module.exports=require(1484)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/iana-hashes/node_modules/create-hmac/browser.js":1484,"buffer":9,"create-hash/browser":1584,"inherits":1598,"stream":39}],1598:[function(require,module,exports){
module.exports=require(19)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/browserify/node_modules/inherits/inherits_browser.js":19}],1599:[function(require,module,exports){
module.exports=require(1462)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-xmpp/node_modules/stanza.io/node_modules/alt-sasl-digest-md5/node_modules/randombytes/browser.js":1462,"_process":22,"buffer":9}],1600:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {
  
  /**
   * `Factory` constructor.
   *
   * @api public
   */
  function Factory() {
    this._mechs = [];
  }
  
  /**
   * Utilize the given `mech` with optional `name`, overridding the mechanism's
   * default name.
   *
   * Examples:
   *
   *     factory.use(FooMechanism);
   *
   *     factory.use('XFOO', FooMechanism);
   *
   * @param {String|Mechanism} name
   * @param {Mechanism} mech
   * @return {Factory} for chaining
   * @api public
   */
  Factory.prototype.use = function(name, mech) {
    if (!mech) {
      mech = name;
      name = mech.prototype.name;
    }
    this._mechs.push({ name: name, mech: mech });
    return this;
  };
  
  /**
   * Create a new mechanism from supported list of `mechs`.
   *
   * If no mechanisms are supported, returns `null`.
   *
   * Examples:
   *
   *     var mech = factory.create(['FOO', 'BAR']);
   *
   * @param {Array} mechs
   * @return {Mechanism}
   * @api public
   */
  Factory.prototype.create = function(mechs) {
    for (var i = 0, len = this._mechs.length; i < len; i++) {
      for (var j = 0, jlen = mechs.length; j < jlen; j++) {
        var entry = this._mechs[i];
        if (entry.name == mechs[j]) {
          return new entry.mech();
        }
      }
    }
    return null;
  };

  exports = module.exports = Factory;
  
}));

},{}],1601:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports,
            module,
            require('./lib/factory'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports',
            'module',
            './lib/factory'], factory);
  }
}(this, function(exports, module, Factory) {
  
  exports = module.exports = Factory;
  exports.Factory = Factory;
  
}));

},{"./lib/factory":1600}],1602:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],1603:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based 
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {
    
});

emitter.on('somenamespace*', function (eventName, payloads) {
    
});

Please note that callbacks triggered by wildcard registered events also get 
the event name as the first argument.
*/
module.exports = WildEmitter;

function WildEmitter() {
    this.isWildEmitter = true;
    this.callbacks = {};
}

// Listen on the given `event` with `fn`. Store a group name if present.
WildEmitter.prototype.on = function (event, groupName, fn) {
    var hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
};

// Adds an `event` listener that will be invoked a single
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.off(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
};

// Unbinds an entire group
WildEmitter.prototype.releaseGroup = function (groupName) {
    var item, i, len, handlers;
    for (item in this.callbacks) {
        handlers = this.callbacks[item];
        for (i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i]._groupName === groupName) {
                //console.log('removing');
                // remove it and shorten the array we're looping through
                handlers.splice(i, 1);
                i--;
                len--;
            }
        }
    }
    return this;
};

// Remove the given callback for `event` or all
// registered callbacks.
WildEmitter.prototype.off = function (event, fn) {
    var callbacks = this.callbacks[event],
        i;

    if (!callbacks) return this;

    // remove all handlers
    if (arguments.length === 1) {
        delete this.callbacks[event];
        return this;
    }

    // remove specific handler
    i = callbacks.indexOf(fn);
    callbacks.splice(i, 1);
    if (callbacks.length === 0) {
        delete this.callbacks[event];
    }
    return this;
};

/// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
    var args = [].slice.call(arguments, 1),
        callbacks = this.callbacks[event],
        specialCallbacks = this.getWildcardCallbacks(event),
        i,
        len,
        item,
        listeners;

    if (callbacks) {
        listeners = callbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, args);
            } else {
                break;
            }
        }
    }

    if (specialCallbacks) {
        len = specialCallbacks.length;
        listeners = specialCallbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, [event].concat(args));
            } else {
                break;
            }
        }
    }

    return this;
};

// Helper for for finding special wildcard event handlers that match the event
WildEmitter.prototype.getWildcardCallbacks = function (eventName) {
    var item,
        split,
        result = [];

    for (item in this.callbacks) {
        split = item.split('*');
        if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
            result = result.concat(this.callbacks[item]);
        }
    }
    return result;
};

},{}],1604:[function(require,module,exports){
'use strict';

var StringPrep = require('./lib/stringprep');

// All of our StringPrep fallbacks work correctly
// in the ASCII range, so we can reliably mark
// ASCII-only JIDs as prepped.
var ASCII = /^[\x00-\x7F]*$/;



function bareJID(local, domain) {
    if (local) {
        return local + '@' + domain;
    }
    return domain;
}

function fullJID(local, domain, resource) {
    if (resource) {
        return bareJID(local, domain) + '/' + resource;
    }
    return bareJID(local, domain);
}


exports.prep = function (data) {
    var local = data.local;
    var domain = data.domain;
    var resource = data.resource;
    var unescapedLocal = local;

    if (local) {
        local = StringPrep.nodeprep(local);
        unescapedLocal = exports.unescape(local);
    }

    if (resource) {
        resource = StringPrep.resourceprep(resource);
    }

    if (domain[domain.length - 1] === '.') {
        domain = domain.slice(0, domain.length - 1);
    }

    domain = StringPrep.nameprep(domain.split('.').map(StringPrep.toUnicode).join('.'));

    return {
        prepped: data.prepped || StringPrep.available,
        local: local,
        domain: domain,
        resource: resource,
        bare: bareJID(local, domain),
        full: fullJID(local, domain, resource),
        unescapedLocal: unescapedLocal,
        unescapedBare: bareJID(unescapedLocal, domain),
        unescapedFull: fullJID(unescapedLocal, domain, resource)
    };
};

exports.parse = function (jid, trusted) {
    var local = '';
    var domain = '';
    var resource = '';

    trusted = trusted || ASCII.test(jid);

    var resourceStart = jid.indexOf('/');
    if (resourceStart > 0) {
        resource = jid.slice(resourceStart + 1);
        jid = jid.slice(0, resourceStart);
    }

    var localEnd = jid.indexOf('@');
    if (localEnd > 0) {
        local = jid.slice(0, localEnd);
        jid = jid.slice(localEnd + 1);
    }

    domain = jid;

    var preppedJID = exports.prep({
        local: local,
        domain: domain,
        resource: resource,
    });

    preppedJID.prepped = preppedJID.prepped || trusted;

    return preppedJID;
};

exports.equal = function (jid1, jid2, requirePrep) {
    jid1 = new exports.JID(jid1);
    jid2 = new exports.JID(jid2);
    if (arguments.length === 2) {
        requirePrep = true;
    }
    return jid1.local === jid2.local &&
           jid1.domain === jid2.domain &&
           jid1.resource === jid2.resource &&
           (requirePrep ? jid1.prepped && jid2.prepped : true);
};

exports.equalBare = function (jid1, jid2, requirePrep) {
    jid1 = new exports.JID(jid1);
    jid2 = new exports.JID(jid2);
    if (arguments.length === 2) {
        requirePrep = true;
    }
    return jid1.local === jid2.local &&
           jid1.domain === jid2.domain &&
           (requirePrep ? jid1.prepped && jid2.prepped : true);
};

exports.isBare = function (jid) {
    jid = new exports.JID(jid);

    var hasResource = !!jid.resource;

    return !hasResource;
};

exports.isFull = function (jid) {
    jid = new exports.JID(jid);

    var hasResource = !!jid.resource;

    return hasResource;
};

exports.escape = function (val) {
    return val.replace(/^\s+|\s+$/g, '')
              .replace(/\\5c/g, '\\5c5c')
              .replace(/\\20/g, '\\5c20')
              .replace(/\\22/g, '\\5c22')
              .replace(/\\26/g, '\\5c26')
              .replace(/\\27/g, '\\5c27')
              .replace(/\\2f/g, '\\5c2f')
              .replace(/\\3a/g, '\\5c3a')
              .replace(/\\3c/g, '\\5c3c')
              .replace(/\\3e/g, '\\5c3e')
              .replace(/\\40/g, '\\5c40')
              .replace(/ /g, '\\20')
              .replace(/\"/g, '\\22')
              .replace(/\&/g, '\\26')
              .replace(/\'/g, '\\27')
              .replace(/\//g, '\\2f')
              .replace(/:/g, '\\3a')
              .replace(/</g, '\\3c')
              .replace(/>/g, '\\3e')
              .replace(/@/g, '\\40');
};

exports.unescape = function (val) {
    return val.replace(/\\20/g, ' ')
              .replace(/\\22/g, '"')
              .replace(/\\26/g, '&')
              .replace(/\\27/g, '\'')
              .replace(/\\2f/g, '/')
              .replace(/\\3a/g, ':')
              .replace(/\\3c/g, '<')
              .replace(/\\3e/g, '>')
              .replace(/\\40/g, '@')
              .replace(/\\5c/g, '\\');
};


exports.create = function (local, domain, resource) {
    return new exports.JID(local, domain, resource);
};

exports.JID = function JID(localOrJID, domain, resource) {
    var parsed = {};
    if (localOrJID && !domain && !resource) {
        if (typeof localOrJID === 'string') {
            parsed = exports.parse(localOrJID);
        } else if (localOrJID._isJID || localOrJID instanceof exports.JID) {
            parsed = localOrJID;
        } else {
            throw new Error('Invalid argument type');
        }
    } else if (domain) {
        var trusted = ASCII.test(localOrJID) && ASCII.test(domain);
        if (resource) {
            trusted = trusted && ASCII.test(resource);
        }

        parsed = exports.prep({
            local: exports.escape(localOrJID),
            domain: domain,
            resource: resource,
            prepped: trusted
        });
    } else {
        parsed = {};
    }

    this._isJID = true;

    this.local = parsed.local || '';
    this.domain = parsed.domain || '';
    this.resource = parsed.resource || '';
    this.bare = parsed.bare || '';
    this.full = parsed.full || '';

    this.unescapedLocal = parsed.unescapedLocal || '';
    this.unescapedBare = parsed.unescapedBare || '';
    this.unescapedFull = parsed.unescapedFull || '';

    this.prepped = parsed.prepped;
};

exports.JID.prototype.toString = function () {
    return this.full;
};

exports.JID.prototype.toJSON = function () {
    return this.full;
};

},{"./lib/stringprep":1605}],1605:[function(require,module,exports){
'use strict';

var punycode = require('punycode');


exports.available = false;

exports.toUnicode = punycode.toUnicode;

exports.nameprep = function (str) {
    return str.toLowerCase();
};

exports.nodeprep = function (str) {
    return str.toLowerCase();
};

exports.resourceprep = function (str) {
    return str;
};

},{"punycode":23}],1606:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/config.js":50}],1607:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/js/styles.js":51}],1608:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/adapter.js":52}],1609:[function(require,module,exports){
module.exports=require(53)
},{"./adapter":1608,"./bdsft":1610,"./constants":1613,"./cookieconfig":1614,"./cookieprop":1615,"./dateformat":1618,"./debug":1619,"./element":1620,"./eventbus":1621,"./factory":1622,"./icon":1623,"./loader":1624,"./popup":1625,"./prop":1626,"./urlconfig":1628,"./utils":1629,"./visibleprop":1630,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/app.js":53}],1610:[function(require,module,exports){
module.exports=require(54)
},{"./app":1609,"./binding":1611,"./classesbinding":1612,"./databinder":1617,"./stylesmanager":1627,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/bdsft.js":54,"jquery":1654}],1611:[function(require,module,exports){
module.exports=require(55)
},{"./bdsft":1610,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/binding.js":55}],1612:[function(require,module,exports){
module.exports=require(56)
},{"./binding":1611,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/classesbinding.js":56}],1613:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/constants.js":57}],1614:[function(require,module,exports){
module.exports=require(58)
},{"./bdsft":1610,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieconfig.js":58,"jquery":1654,"jquery.cookie":1653}],1615:[function(require,module,exports){
module.exports=require(59)
},{"./constants":1613,"./prop":1626,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/cookieprop.js":59,"jquery":1654,"jquery.cookie":1653}],1616:[function(require,module,exports){
module.exports=require(60)
},{"./constants":1613,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/css.js":60,"ejs":1635}],1617:[function(require,module,exports){
module.exports=require(61)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/databinder.js":61,"event-emitter":1638}],1618:[function(require,module,exports){
module.exports=require(62)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/dateformat.js":62}],1619:[function(require,module,exports){
module.exports=require(63)
},{"../js/config":1606,"./bdsft":1610,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/debug.js":63,"debug":1631,"stacktrace-js":1656}],1620:[function(require,module,exports){
module.exports=require(64)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/element.js":64}],1621:[function(require,module,exports){
module.exports=require(65)
},{"./bdsft":1610,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/eventbus.js":65,"event-emitter":1638}],1622:[function(require,module,exports){
module.exports=require(66)
},{"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/factory.js":66,"jquery":1654}],1623:[function(require,module,exports){
module.exports=require(67)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/icon.js":67}],1624:[function(require,module,exports){
module.exports=require(68)
},{"../":1609,"./constants":1613,"./factory":1622,"./stylesmanager":1627,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/loader.js":68,"deep-extend":1634}],1625:[function(require,module,exports){
module.exports=require(69)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/popup.js":69,"jquery":1654}],1626:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/prop.js":70,"observe-js":1655}],1627:[function(require,module,exports){
module.exports=require(71)
},{"../js/styles":1607,"./constants":1613,"./css":1616,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/stylesmanager.js":71}],1628:[function(require,module,exports){
module.exports=require(72)
},{"../js/config":1606,"./bdsft":1610,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/urlconfig.js":72}],1629:[function(require,module,exports){
module.exports=require(73)
},{"./adapter":1608,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/utils.js":73,"jquery":1654}],1630:[function(require,module,exports){
module.exports=require(74)
},{"./constants":1613,"./prop":1626,"./utils":1629,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/lib/visibleprop.js":74}],1631:[function(require,module,exports){
module.exports=require(75)
},{"./debug":1632,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/browser.js":75}],1632:[function(require,module,exports){
module.exports=require(76)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/debug.js":76,"ms":1633}],1633:[function(require,module,exports){
module.exports=require(77)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/debug/node_modules/ms/index.js":77}],1634:[function(require,module,exports){
module.exports=require(78)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/deep-extend/lib/deep-extend.js":78,"buffer":9}],1635:[function(require,module,exports){
module.exports=require(79)
},{"./filters":1636,"./utils":1637,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/ejs.js":79,"fs":7,"path":21}],1636:[function(require,module,exports){
module.exports=require(80)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/filters.js":80}],1637:[function(require,module,exports){
module.exports=require(81)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/ejs/lib/utils.js":81}],1638:[function(require,module,exports){
module.exports=require(82)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/index.js":82,"d":1639,"es5-ext/object/valid-callable":1648}],1639:[function(require,module,exports){
module.exports=require(83)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/d/index.js":83,"es5-ext/object/assign":1640,"es5-ext/object/is-callable":1643,"es5-ext/object/normalize-options":1647,"es5-ext/string/#/contains":1650}],1640:[function(require,module,exports){
module.exports=require(84)
},{"./is-implemented":1641,"./shim":1642,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/index.js":84}],1641:[function(require,module,exports){
module.exports=require(85)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/is-implemented.js":85}],1642:[function(require,module,exports){
module.exports=require(86)
},{"../keys":1644,"../valid-value":1649,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/assign/shim.js":86}],1643:[function(require,module,exports){
module.exports=require(87)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/is-callable.js":87}],1644:[function(require,module,exports){
module.exports=require(88)
},{"./is-implemented":1645,"./shim":1646,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/index.js":88}],1645:[function(require,module,exports){
module.exports=require(89)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/is-implemented.js":89}],1646:[function(require,module,exports){
module.exports=require(90)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/keys/shim.js":90}],1647:[function(require,module,exports){
module.exports=require(91)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/normalize-options.js":91}],1648:[function(require,module,exports){
module.exports=require(92)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-callable.js":92}],1649:[function(require,module,exports){
module.exports=require(93)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/object/valid-value.js":93}],1650:[function(require,module,exports){
module.exports=require(94)
},{"./is-implemented":1651,"./shim":1652,"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/index.js":94}],1651:[function(require,module,exports){
module.exports=require(95)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/is-implemented.js":95}],1652:[function(require,module,exports){
module.exports=require(96)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/event-emitter/node_modules/es5-ext/string/#/contains/shim.js":96}],1653:[function(require,module,exports){
module.exports=require(97)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery.cookie/jquery.cookie.js":97,"jquery":1654}],1654:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/jquery/dist/jquery.js":98}],1655:[function(require,module,exports){
module.exports=require(99)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/observe-js/src/observe.js":99}],1656:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/wrtc/widget/node_modules/webrtc-audio/node_modules/webrtc-core/node_modules/stacktrace-js/stacktrace.js":100}]},{},[1]);
