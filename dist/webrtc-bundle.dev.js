(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
ClientConfig = {

    // Enable Client Features
    enableHD: false,
    enableCallControl: true,
    enableCallTimer: true,
    enableCallHistory: true,
    enableFullScreen: true,
    enableSelfView: true,
    enableCallStats: true,
    enableDialpad: true,
    enableMute: true,
    enableMessages: true,
    enableRegistrationIcon: true,
    enableConnectionIcon: true,
    enableWindowDrag: true,
    enableAutoAcceptReInvite: true,
    enableConnectLocalMedia: true,
    enableIms: false,
    enableSettings: false,
    enableAutoAnswer: false,
    enableTransfer: true,
    enableHold: true,
    pAssertedIdentity: '<sip:webguest@broadsoftlabs.com>',

    // Client Variables
    allowOutside: true,
    disableICE: true,
    volumeClick: 1,
    volumeDTMF: 1,
      // the following 5 attributes have to be configured for this webrtc client to be functional:
      websocketsServers: [{'ws_uri':'wss://webrtc-gw.broadsoftlabs.com:8443', 'weight':0}],
      stunServer: '64.212.220.81',
      stunPort: 3478,
      domainFrom: 'broadsoftlabs.com',
      domainTo: 'broadsoftlabs.com',
    endCallURL: false,
    bandwidthLow: 128,
    bandwidthMed: 512,
    bandwidthHigh: 2048,
    expires: 365,
    debug: false,
    register: false,
    encodingResolution: "640x480",
    displayResolution: "640x480",
    view: "audioVideo",
    selfViewLocation: "bl",

    // Client Messages
    messageProgress: "Ringing",
    messageOutsideDomain: "Invalid Destination",
    messageStarted: "Call Started",
    messageHold: "Call placed on hold",
    messageResume: "Call removed from hold",
    messageEnded: "Call Ended",
    messageCall: "Performing NAT Tests",
    messageConnected: "Connected",
    messageConnectionFailed: "Connection failed",
    messageUnregistered: "Unregistered",
    messageRegistered: "Registration successful",
    messageRegistrationFailed: "Registration failed",
    messageEmptyDestination: "Invalid Destination",
    messageGetUserMedia: "Unable to Access Camera and/or Microphone"
};

module.exports = ClientConfig;
},{}],2:[function(require,module,exports){
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define([], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory();
    } else if (typeof root === 'undefined' || root !== Object(root)) {
        throw new Error('templatizer: window does not exist or is not an object');
    } else {
        root.templatizer = factory();
    }
}(this, function () {
    var jade=function(){function e(e){return null!=e&&""!==e}function n(t){return(Array.isArray(t)?t.map(n):t&&"object"==typeof t?Object.keys(t).filter(function(e){return t[e]}):[t]).filter(e).join(" ")}var t={};return t.merge=function r(n,t){if(1===arguments.length){for(var a=n[0],i=1;i<n.length;i++)a=r(a,n[i]);return a}var o=n["class"],s=t["class"];(o||s)&&(o=o||[],s=s||[],Array.isArray(o)||(o=[o]),Array.isArray(s)||(s=[s]),n["class"]=o.concat(s).filter(e));for(var l in t)"class"!=l&&(n[l]=t[l]);return n},t.joinClasses=n,t.cls=function(e,r){for(var a=[],i=0;i<e.length;i++)a.push(r&&r[i]?t.escape(n([e[i]])):n(e[i]));var o=n(a);return o.length?' class="'+o+'"':""},t.style=function(e){return e&&"object"==typeof e?Object.keys(e).map(function(n){return n+":"+e[n]}).join(";"):e},t.attr=function(e,n,r,a){return"style"===e&&(n=t.style(n)),"boolean"==typeof n||null==n?n?" "+(a?e:e+'="'+e+'"'):"":0==e.indexOf("data")&&"string"!=typeof n?(-1!==JSON.stringify(n).indexOf("&")&&console.warn("Since Jade 2.0.0, ampersands (`&`) in data attributes will be escaped to `&amp;`"),n&&"function"==typeof n.toISOString&&console.warn("Jade will eliminate the double quotes around dates in ISO form after 2.0.0")," "+e+"='"+JSON.stringify(n).replace(/'/g,"&apos;")+"'"):r?(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+t.escape(n)+'"'):(n&&"function"==typeof n.toISOString&&console.warn("Jade will stringify dates in ISO form after 2.0.0")," "+e+'="'+n+'"')},t.attrs=function(e,r){var a=[],i=Object.keys(e);if(i.length)for(var o=0;o<i.length;++o){var s=i[o],l=e[s];"class"==s?(l=n(l))&&a.push(" "+s+'="'+l+'"'):a.push(t.attr(s,l,!1,r))}return a.join("")},t.escape=function(e){var n=String(e).replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");return n===""+e?e:n},t.rethrow=function a(e,n,t,r){if(!(e instanceof Error))throw e;if(!("undefined"==typeof window&&n||r))throw e.message+=" on line "+t,e;try{r=r||require("fs").readFileSync(n,"utf8")}catch(i){a(e,null,t)}var o=3,s=r.split("\n"),l=Math.max(t-o,0),f=Math.min(s.length,t+o),o=s.slice(l,f).map(function(e,n){var r=n+l+1;return(r==t?"  > ":"    ")+r+"| "+e}).join("\n");throw e.path=n,e.message=(n||"Jade")+":"+t+"\n"+o+"\n\n"+e.message,e},t}();

    var templatizer = {};


    // authentication.jade compiled template
    templatizer["authentication"] = function tmpl_authentication() {
        return '<div class="authPopup fadeable popup"><span>User ID</span><br/><input type="text" value="" class="userid"/><br/><span>Auth User ID</span><br/><input type="text" value="" class="authUserid"/><br/><span>Password</span><br/><input type="password" value="" class="password"/><br/><br/><div class="alert"></div><button type="button" class="ok button">Sign in</button></div>';
    };

    // client.jade compiled template
    templatizer["client"] = function tmpl_client() {
        return '<div class="wrapper"><div id="unsupported" class="unsupported"></div><div id="whiteboard_unsupported" class="unsupported"></div><div id="screen_sharing_unsupported" class="unsupported">Could not retrieve screen capture. Do you have it enabled?<br/>Open link to check : <span>chrome://flags/#enable-usermedia-screen-capture</span></div><noscript><div id="javascript_disabled" class="unsupported">JavaScript must be enabled to load the WebRTC client</div></noscript><div id="conversejs"></div><div id="client" class="client"><div class="main"><div class="errorPopup"></div></div></div></div>';
    };

    // connectionstatus.jade compiled template
    templatizer["connectionstatus"] = function tmpl_connectionstatus() {
        return '<div class="connection-status connectedIcon"><span title="Websockets Status" class="icon-link"></span></div><div class="connection-status registeredIcon"><span title="Registered" class="icon-link"></span></div>';
    };

    // dialpad.jade compiled template
    templatizer["dialpad"] = function tmpl_dialpad() {
        return '<div class="dialpad fadeable popup"><div class="callControl destination-container"><input type="text" onclick="this.focus();this.select()" class="destination"/><button title="Call History" class="historyButton"><i class="icon-clock"></i></button><hr/></div><div class="button-row"><button class="keys">1</button><button class="keys">2</button><button class="keys">3</button></div><div class="button-row"><button class="keys">4</button><button class="keys">5</button><button class="keys">6</button></div><div class="button-row"><button class="keys">7</button><button class="keys">8</button><button class="keys">9</button></div><div class="button-row"><button class="keys btn-star">*</button><button class="keys">0</button><button class="keys">#</button></div><div class="dialpad-control-bar"><div class="call main-button"><a href="">Call</a></div></div></div>';
    };

    // fileshare.jade compiled template
    templatizer["fileshare"] = function tmpl_fileshare() {
        return '<div class="fileshare-container table"><div class="cell"><div class="file_share fadeable"><span>Share File:</span><br/><input type="file" class="file"/><div class="status"></div></div></div></div>';
    };

    // history.jade compiled template
    templatizer["history"] = function tmpl_history() {
        return '<div class="callHistory"><div class="content"></div><div class="classHistoryActions"><!--<span class="historyBack">\n<a href="" title="Previous" class="icon-arrow-up-thick"></a>\n</span>--><span class="historyClear"><a href="" title="Clear History">Clear</a></span><span class="historyClose"><a href="" title="Close History">Close</a></span><!--<span class="historyForward">\n<a href="" title="Next" class="icon-arrow-down-thick"></a>\n</span>--></div><div class="callHistoryDetails popup"><div id="history-dt-close-container"><span class="historyDetailsClose cell"><a href="" title="Close" class="icon-cancel3"></a></span></div><div class="table"><div class="row"><div class="cell">Resolution In : </div><div class="resolutionIn cell default-color"></div></div><div class="row"><div class="cell">Resolution Out : </div><div class="resolutionOut cell default-color"></div></div><div class="row"><div class="cell">Bitrate In : </div><div class="bitrateIn cell default-color"></div></div><div class="row"><div class="cell">Bitrate Out : </div><div class="bitrateOut cell default-color"></div></div><div class="row"><div class="cell">Frame Rate In : </div><div class="frameRateIn cell default-color"></div></div><div class="row"><div class="cell">Frame Rate Out : </div><div class="frameRateOut cell default-color"></div></div><div class="row"><div class="cell">Audio Lost : </div><div class="audioLostPer cell default-color">%</div></div><div class="row"><div class="cell">Video Out : </div><div class="videoLostPer cell default-color">%</div></div><div class="row"><div class="cell">Jitter : </div><div class="jitter cell default-color"></div></div></div><div class="actions table"><a href="" title="Call" class="callLink cell"></a></div></div><div class="historyRowSample"><div class="row"><a href="" title="Number" class="hist-destination"></a><span class="hist-direction"></span><span class="hist-date"></span><span class="hist-length"></span><span class="hist-details-arrow icon-angle-right"></span></div></div></div>';
    };

    // incomingcall.jade compiled template
    templatizer["incomingcall"] = function tmpl_incomingcall() {
        return '<div class="callPopup fadeable popup"><span class="incomingCallTitle">Incoming Call</span><span class="incomingCallName"></span><span class="incomingCallUser"></span><div class="table"><div class="cell"><button type="button" class="acceptIncomingCall button">Accept</button><button type="button" class="holdAndAnswerButton button">Hold And Answer</button><button type="button" class="dropAndAnswerButton button">Drop And Answer</button></div><div id="rejectIncomingCallContainer" class="cell"><button type="button" class="rejectIncomingCall button">Reject</button></div></div></div>';
    };

    // messages.jade compiled template
    templatizer["messages"] = function tmpl_messages() {
        return '<div class="messages"><div class="alert"></div><div class="success"></div><div class="warning"></div><div class="normal"></div></div>';
    };

    // quality.jade compiled template
    templatizer["quality"] = function tmpl_quality() {
        return '<div class="quality quality1"><span title="Call Quality" class="icon-quality icon-quality1"></span></div><div class="quality quality2"><span title="Call Quality" class="icon-quality icon-quality2"></span></div><div class="quality quality3"><span title="Call Quality" class="icon-quality icon-quality3"></span></div><div class="quality quality4"><span title="Call Quality" class="icon-quality icon-quality4"></span></div>';
    };

    // reinvite.jade compiled template
    templatizer["reinvite"] = function tmpl_reinvite() {
        return '<div class="reInvitePopup fadeable popup"><span class="title">ReInvite</span><br/><br/><span class="incomingCallName"></span><br/><span class="incomingCallUser"></span><br/><br/><button type="button" class="acceptReInviteCall button">Accept</button><button type="button" class="rejectReInviteCall button">Reject</button></div>';
    };

    // settings.jade compiled template
    templatizer["settings"] = function tmpl_settings() {
        return '<div class="settingsPopup table collapse fixed fadeable popup"><div class="row"><ul class="tabs"><li><a href="#tab1" class="configure"><span class="icon-cog"></span>Configure</a></li><li><a href="#tab2" class="layout"><span class="icon-th"></span>Layout</a></li></ul><div id="tab1"><div class="displayNameRow row"><span class="cell">Display Name</span><input type="text" value="" class="displayName cell"/></div><div class="authenticationUseridRow row"><span class="cell">Auth User ID</span><input type="text" value="" class="authenticationUserid cell"/></div><div class="useridRow row"><span class="cell">User ID</span><input type="text" value="" class="userid cell"/></div><div class="passwordRow row"><span class="cell">Password</span><input type="password" value="" class="password cell"/></div><div class="hdRow row"><span class="cell">Start in HD</span><input type="checkbox" class="hd cell"/><br/></div><div class="autoAnswerRow row"><span class="cell">Auto Answer</span><input type="checkbox" class="autoAnswer cell"/></div><div class="bandwidthRow row"><span class="cell">Bandwidth</span><span class="cell"><input type="text" maxlength="4" value="" placeholder="low" class="bandwidthLow short"/><input type="text" maxlength="4" value="" placeholder="medium" class="bandwidthMed short"/><input type="text" maxlength="4" value="" placeholder="high" class="bandwidthHigh short"/></span></div><div class="row"><span class="cell"><a href="" title="Sign In" class="btn signIn">Sign In</a><a href="" title="Sign Out" class="btn signOut">Sign Out</a></span></div></div><div id="tab2"><div class="selfViewDisableRow row"><span class="cell">Disable Self View</span><input type="checkbox" class="selfViewDisable cell"/></div><div class="resolutionRow"><div class="row"><span class="resolutionTypeRow cell">Mode</span><select class="resolutionType cell"></select></div><div class="row"><span class="resolutionDisplayRow cell">Resolution</span><span class="cell"><select class="resolutionDisplayStandard resolutionSubType"></select><select class="resolutionDisplayWidescreen resolutionSubType"></select></span></div><div class="row"><span class="resolutionEncodingRow cell">Encoding</span><span class="cell"><select class="resolutionEncodingStandard resolutionSubType"></select><select class="resolutionEncodingWidescreen resolutionSubType"></select></span></div></div><div class="row"><span class="cell"><a href="" title="Save Settings" class="btn save">Save Settings</a><a href="" title="Reset Settings" class="clear">Reset Settings</a></span></div></div></div></div>';
    };

    // sms.jade compiled template
    templatizer["sms"] = function tmpl_sms() {
        return '<div class="sms"><div class="view"><div class="table fixed loginForm"><div class="row"><label class="cell">Name:</label><input type="text" name="name" placeholder="Email or TN" class="cell name"/></div><div class="row"><label class="cell">Password:</label><input type="password" name="password" class="cell password"/></div><div class="row"><div class="cell"></div><input type="button" value="Log In" class="cell login"/></div></div><div class="inbox"><fieldset><legend>Inbox</legend><div class="inner"><div class="table fixed"><div class="row"><div class="cell title status">Status</div><div class="cell title time">Received</div><div class="cell title from">From</div><div class="cell title body">Message</div><div class="cell title actions"></div></div><div class="inboxContent"></div></div></div></fieldset></div><div class="sendForm"><div><div><span>To</span><input type="text" placeholder="US Phone Number" class="sendTo"/><span>Text</span><input type="text" placeholder="Message to Send" class="sendBody"/><input type="button" value="Send SMS" class="sendButton"/></div></div></div><div id="sample" class="inboxItem inboxItemSample row"><div class="status cell"></div><div class="time cell"></div><div class="from cell"></div><div class="body cell"><div class="image"><a href="" target="_blank"><span></span><img src=""/></a></div><div class="video"><video controls=""></video></div><div class="audio"><audio controls=""></audio></div><div class="text"></div></div><div class="actions cell"><a href="javascript:;" title="Delete SMS" class="icon-trash icon-highlightable"></a></div></div></div><div class="status"><span class="statusContent"></span></div></div>';
    };

    // stats.jade compiled template
    templatizer["stats"] = function tmpl_stats() {
        return '<div class="stats"><div class="statsContainer"></div><div class="table fixed collapse"><div class="heading"><div class="cell">Video Stats</div><div class="cell">Audio Stats</div></div><div class="row"><div class="cell">Bitrate out: <a href="javascript:;" data-type="video" data-var="kiloBitsSentPerSecond" class="statsVar"></a> kb/s</div><div class="cell">Bitrate out: <a href="javascript:;" data-type="audio" data-var="kiloBitsSentPerSecond" class="statsVar"></a> kb/s</div></div><div class="row"><div class="cell">Bitrate in: <a href="javascript:;" data-type="video" data-var="kiloBitsReceivedPerSecond" class="statsVar"></a> kb/s</div><div class="cell">Bitrate in: <a href="javascript:;" data-type="audio" data-var="kiloBitsReceivedPerSecond" class="statsVar"></a> kb/s</div></div><div class="row"><div class="cell">Lost: <a href="javascript:;" data-type="video" data-var="packetsLost" class="statsVar"></a> packets (<a href="javascript:;" data-type="video" data-var="packetsLostPer" class="statsVar"></a> %)</div><div class="cell">Lost: <a href="javascript:;" data-type="audio" data-var="packetsLost" class="statsVar"></a> packets (<a href="javascript:;" data-type="audio" data-var="packetsLostPer" class="statsVar"></a> %)</div></div><div class="row"><div class="cell">Frame rate out: <a href="javascript:;" data-type="video" data-var="googFrameRateSent" class="statsVar"></a> in: <a href="javascript:;" data-type="video" data-var="googFrameRateReceived" class="statsVar"></a></div><div class="cell">Audio Level out: <a href="javascript:;" data-type="audio" data-var="audioInputLevel" class="statsVar"></a> in: <a href="javascript:;" data-type="audio" data-var="audioOutputLevel" class="statsVar"></a></div></div><div class="row spacer"></div><div class="heading"><div class="cell">Resolution</div><div class="cell">Link</div></div><div class="row"><div class="cell">In: <span data-type="video" data-var="googFrameWidthReceived" class="statsVar"></span> x <span data-type="video" data-var="googFrameHeightReceived" class="statsVar"></span> Out: <span data-type="video" data-var="googFrameWidthSent" class="statsVar"></span> x <span data-type="video" data-var="googFrameHeightSent" class="statsVar"></span></div><div class="cell"><span class="statsDelay">Delay: <a href="javascript:;" data-type="audio" data-var="googRtt" class="statsVar"></a></span> Jitter: <a href="javascript:;" data-type="audio" data-var="googJitterReceived" class="statsVar"></a></div></div><div class="row spacer"></div></div></div>';
    };

    // timer.jade compiled template
    templatizer["timer"] = function tmpl_timer() {
        return '<div class="timer fadeable"></div>';
    };

    // transfer.jade compiled template
    templatizer["transfer"] = function tmpl_transfer() {
        return '<div class="transferPopup fadeable popup"><div class="title">Transfer</div><div><input type="text" placeholder="To Target" class="target"/><input type="checkbox" class="typeAttended"/>Attended</div><div class="actions"><button type="button" class="accept button">Transfer</button><button type="button" class="reject button">Cancel</button></div></div>';
    };

    // video.jade compiled template
    templatizer["video"] = function tmpl_video() {
        return '<div class="video"><span class="icon-facetime-video watermark-icon"></span><video autoplay="autoplay" class="remote"></video><div class="localVideo fadeable"><div class="inner"><video autoplay="autoplay" muted="true" class="local"></video></div></div></div>';
    };

    // videobar.jade compiled template
    templatizer["videobar"] = function tmpl_videobar() {
        return '<div class="videoBar"><div class="table fixed collapse"><div class="cell leftSpacer"></div><div class="cell cell-selfView"><div class="selfViewDisable icon fadeable"><a href="" title="Disable Self View" class="icon-selfViewDisable"></a></div><div class="selfViewEnable icon fadeable"><a href="" title="Enable Self View" class="icon-selfViewEnable"></a></div></div><div class="cell cell-dialpad"><div class="dialpadIconShow icon fadeable"><a href="" title="Show Dialpad" class="icon-dialpadShow"></a></div><div class="dialpadIconHide icon fadeable"><a href="" title="Hide Dialpad" class="icon-dialpadHide"></a></div></div><div class="cell cell-muteAudio"><div class="icon fadeable muteAudioIcon"><a href="" title="Mute Audio" class="icon-muteAudio"></a></div><div class="icon fadeable unmuteAudioIcon"><a href="" title="Unmute Audio" class="icon-unmuteAudio"></a></div></div><div class="cell cell-hold"><div class="hold icon fadeable"><a href="" title="Hold Call" class="icon-hold"></a></div><div class="resume icon fadeable"><a href="" title="Resume Call" class="icon-resume"></a></div></div><div class="cell cell-hangup"><div class="hangup icon fadeable"><a href="" title="Hangup" class="icon-hangup"></a><div class="subtitle">End Conference</div></div></div><div class="cell cell-transfer"><div class="transfer icon fadeable"><a href="" title="Transfer" class="icon-transfer"></a></div></div><div class="cell cell-shareScreen"><div class="icon fadeable shareScreen"><a href="" title="Share Screen" class="icon-screen-sharing"></a></div><div class="icon fadeable stopShareScreen"><a href="" title="Stop Share Screen" class="icon-screen-sharing-off"></a></div></div><div class="cell cellTimer"></div><div class="cell cell-settings"><div class="settings icon fadeable"><a href="" title="Settings" class="icon-settings"></a></div></div><div class="cell cell-fullScreen"><div class="fullScreenExpand icon fadeable"><a href="" title="Expand Full Screen" class="icon-fullScreenExpand"></a></div><div class="fullScreenContract icon fadeable"><a href="" title="Contract Full Screen" class="icon-fullScreenContract"></a></div></div><div class="cell rightSpacer"></div></div></div>';
    };

    // whiteboard.jade compiled template
    templatizer["whiteboard"] = function tmpl_whiteboard() {
        return '<div class="whiteboard"><div class="tools"><a href=".canvas" data-tool="marker" class="tooltype">Marker</a><a href=".canvas" data-tool="eraser" class="tooltype">Eraser</a></div><canvas width="600" height="400" class="canvas"></canvas></div>';
    };

    // xmpp.jade compiled template
    templatizer["xmpp"] = function tmpl_xmpp() {
        return '<div class="xmpp"><div class="table fixed loginForm"><div class="row"><label class="cell">Name:</label><input type="text" name="name" placeholder="Email" class="cell name"/></div><div class="row"><label class="cell">Password:</label><input type="password" name="password" class="cell password"/></div><div class="row"><div class="cell"></div><input type="button" value="Log In" class="cell login"/></div></div><div class="content"></div><div class="messages"></div></div>';
    };

    return templatizer;
}));
},{"fs":3}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
module.exports=require(3)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/lib/_empty.js":3}],5:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('is-array')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192 // not used by this implementation

var kMaxLength = 0x3fffffff

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new TypeError('must start with number, buffer, array or string')

  if (this.length > kMaxLength)
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
      'size: 0x' + kMaxLength.toString(16) + ' bytes')

  var buf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer.TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer.TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b))
    throw new TypeError('Arguments must be Buffers')

  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function (list, totalLength) {
  if (!isArray(list)) throw new TypeError('Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    case 'hex':
      ret = str.length >>> 1
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    default:
      ret = str.length
  }
  return ret
}

// pre-set for values that may exist in the future
Buffer.prototype.length = undefined
Buffer.prototype.parent = undefined

// toString(encoding, start=0, end=buffer.length)
Buffer.prototype.toString = function (encoding, start, end) {
  var loweredCase = false

  start = start >>> 0
  end = end === undefined || end === Infinity ? this.length : end >>> 0

  if (!encoding) encoding = 'utf8'
  if (start < 0) start = 0
  if (end > this.length) end = this.length
  if (end <= start) return ''

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'binary':
        return binarySlice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase)
          throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.equals = function (b) {
  if(!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max)
      str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new Error('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(byte)) throw new Error('Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length, 2)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new TypeError('Unknown encoding: ' + encoding)
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0)
    throw new RangeError('offset is not uint')
  if (offset + ext > length)
    throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
      ((this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      this[offset + 3])
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80))
    return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16) |
      (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
      (this[offset + 1] << 16) |
      (this[offset + 2] << 8) |
      (this[offset + 3])
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  if (!noAssert)
    checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = value
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = value
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = value
  return offset + 1
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
  } else objectWriteUInt16(this, value, offset, true)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = value
  } else objectWriteUInt16(this, value, offset, false)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else objectWriteUInt32(this, value, offset, true)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert)
    checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = value
  } else objectWriteUInt32(this, value, offset, false)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (value > max || value < min) throw new TypeError('value is out of bounds')
  if (offset + ext > buf.length) throw new TypeError('index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert)
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  if (end < start) throw new TypeError('sourceEnd < sourceStart')
  if (target_start < 0 || target_start >= target.length)
    throw new TypeError('targetStart out of bounds')
  if (start < 0 || start >= source.length) throw new TypeError('sourceStart out of bounds')
  if (end < 0 || end > source.length) throw new TypeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (end < start) throw new TypeError('end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  if (start < 0 || start >= this.length) throw new TypeError('start out of bounds')
  if (end < 0 || end > this.length) throw new TypeError('end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr.constructor = Buffer
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length, unitSize) {
  if (unitSize) length -= length % unitSize;
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

},{"base64-js":6,"ieee754":7,"is-array":8}],6:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],7:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],8:[function(require,module,exports){

/**
 * isArray
 */

var isArray = Array.isArray;

/**
 * toString
 */

var str = Object.prototype.toString;

/**
 * Whether or not the given `val`
 * is an array.
 *
 * example:
 *
 *        isArray([]);
 *        // > true
 *        isArray(arguments);
 *        // > false
 *        isArray('');
 *        // > false
 *
 * @param {mixed} val
 * @return {bool}
 */

module.exports = isArray || function (val) {
  return !! val && '[object Array]' == str.call(val);
};

},{}],9:[function(require,module,exports){
'use strict';

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')

exports.createHash = exports.Hash = require('create-hash')

exports.createHmac = exports.Hmac = require('create-hmac')

var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(Object.keys(require('browserify-sign/algos')))
exports.getHashes = function () {
  return hashes;
}

var p = require('pbkdf2-compat')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-aes');
[
  'Cipher',
  'createCipher',
  'Cipheriv',
  'createCipheriv',
  'Decipher',
  'createDecipher',
  'Decipheriv',
  'createDecipheriv',
  'getCiphers',
  'listCiphers'
].forEach(function (key) {
  exports[key] = aes[key];
})

var dh = require('diffie-hellman');
[
  'DiffieHellmanGroup',
  'createDiffieHellmanGroup',
  'getDiffieHellman',
  'createDiffieHellman',
  'DiffieHellman'
].forEach(function (key) {
  exports[key] = dh[key];
})

require('browserify-sign/inject')(module.exports, exports);
require('create-ecdh/inject')(module.exports, exports);
require('public-encrypt/inject')(module.exports, exports);

// the least I can do is make error messages for the rest of the node.js/crypto api.
[
  'createCredentials',
  'privateEncrypt',
  'publicDecrypt'
].forEach(function (name) {
  exports[name] = function () {
    throw new Error([
      'sorry, ' + name + ' is not implemented yet',
      'we accept pull requests',
      'https://github.com/crypto-browserify/crypto-browserify'
    ].join('\n'));
  }
})

},{"browserify-aes":13,"browserify-sign/algos":28,"browserify-sign/inject":29,"create-ecdh/inject":75,"create-hash":97,"create-hmac":108,"diffie-hellman":109,"pbkdf2-compat":116,"public-encrypt/inject":117,"randombytes":144}],10:[function(require,module,exports){
(function (Buffer){
var md5 = require('create-hash/md5');
module.exports = EVP_BytesToKey;
function EVP_BytesToKey(password, keyLen, ivLen) {
  if (!Buffer.isBuffer(password)) {
    password = new Buffer(password, 'binary');
  }
  keyLen = keyLen/8;
  ivLen = ivLen || 0;
  var ki = 0;
  var ii = 0;
  var key = new Buffer(keyLen);
  var iv = new Buffer(ivLen);
  var addmd = 0;
  var md_buf;
  var i;
  var bufs =  [];
  while (true) {
    if(addmd++ > 0) {
       bufs.push(md_buf);
    }
    bufs.push(password);
    md_buf = md5(Buffer.concat(bufs));
    bufs = [];
    i = 0;
    if(keyLen > 0) {
      while(true) {
        if(keyLen === 0) {
          break;
        }
        if(i === md_buf.length) {
          break;
        }
        key[ki++] = md_buf[i];
        keyLen--;
        i++;
       }
    }
    if(ivLen > 0 && i !== md_buf.length) {
      while(true) {
        if(ivLen === 0) {
          break;
        }
        if(i === md_buf.length) {
          break;
        }
       iv[ii++] = md_buf[i];
       ivLen--;
       i++;
     }
   }
   if(keyLen === 0 && ivLen === 0) {
      break;
    }
  }
  for(i=0;i<md_buf.length;i++) {
    md_buf[i] = 0;
  }
  return {
    key: key,
    iv: iv
  };
}
}).call(this,require("buffer").Buffer)
},{"buffer":5,"create-hash/md5":99}],11:[function(require,module,exports){
(function (Buffer){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec

// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var uint_max = Math.pow(2, 32);
function fixup_uint32(x) {
    var ret, x_pos;
    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
    return ret;
}
function scrub_vec(v) {
  var i, _i, _ref;
  for (i = _i = 0, _ref = v.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
    v[i] = 0;
  }
  return false;
}

function Global() {
  var i;
  this.SBOX = [];
  this.INV_SBOX = [];
  this.SUB_MIX = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 4; i = ++_i) {
      _results.push([]);
    }
    return _results;
  })();
  this.INV_SUB_MIX = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 4; i = ++_i) {
      _results.push([]);
    }
    return _results;
  })();
  this.init();
  this.RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
}

Global.prototype.init = function() {
  var d, i, sx, t, x, x2, x4, x8, xi, _i;
  d = (function() {
    var _i, _results;
    _results = [];
    for (i = _i = 0; _i < 256; i = ++_i) {
      if (i < 128) {
        _results.push(i << 1);
      } else {
        _results.push((i << 1) ^ 0x11b);
      }
    }
    return _results;
  })();
  x = 0;
  xi = 0;
  for (i = _i = 0; _i < 256; i = ++_i) {
    sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
    this.SBOX[x] = sx;
    this.INV_SBOX[sx] = x;
    x2 = d[x];
    x4 = d[x2];
    x8 = d[x4];
    t = (d[sx] * 0x101) ^ (sx * 0x1010100);
    this.SUB_MIX[0][x] = (t << 24) | (t >>> 8);
    this.SUB_MIX[1][x] = (t << 16) | (t >>> 16);
    this.SUB_MIX[2][x] = (t << 8) | (t >>> 24);
    this.SUB_MIX[3][x] = t;
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
    this.INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
    this.INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
    this.INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
    this.INV_SUB_MIX[3][sx] = t;
    if (x === 0) {
      x = xi = 1;
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]];
      xi ^= d[d[xi]];
    }
  }
  return true;
};

var G = new Global();


AES.blockSize = 4 * 4;

AES.prototype.blockSize = AES.blockSize;

AES.keySize = 256 / 8;

AES.prototype.keySize = AES.keySize;

 function bufferToArray(buf) {
  var len = buf.length/4;
  var out = new Array(len);
  var i = -1;
  while (++i < len) {
    out[i] = buf.readUInt32BE(i * 4);
  }
  return out;
 }
function AES(key) {
  this._key = bufferToArray(key);
  this._doReset();
}

AES.prototype._doReset = function() {
  var invKsRow, keySize, keyWords, ksRow, ksRows, t, _i, _j;
  keyWords = this._key;
  keySize = keyWords.length;
  this._nRounds = keySize + 6;
  ksRows = (this._nRounds + 1) * 4;
  this._keySchedule = [];
  for (ksRow = _i = 0; 0 <= ksRows ? _i < ksRows : _i > ksRows; ksRow = 0 <= ksRows ? ++_i : --_i) {
    this._keySchedule[ksRow] = ksRow < keySize ? keyWords[ksRow] : (t = this._keySchedule[ksRow - 1], (ksRow % keySize) === 0 ? (t = (t << 8) | (t >>> 24), t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff], t ^= G.RCON[(ksRow / keySize) | 0] << 24) : keySize > 6 && ksRow % keySize === 4 ? t = (G.SBOX[t >>> 24] << 24) | (G.SBOX[(t >>> 16) & 0xff] << 16) | (G.SBOX[(t >>> 8) & 0xff] << 8) | G.SBOX[t & 0xff] : void 0, this._keySchedule[ksRow - keySize] ^ t);
  }
  this._invKeySchedule = [];
  for (invKsRow = _j = 0; 0 <= ksRows ? _j < ksRows : _j > ksRows; invKsRow = 0 <= ksRows ? ++_j : --_j) {
    ksRow = ksRows - invKsRow;
    t = this._keySchedule[ksRow - (invKsRow % 4 ? 0 : 4)];
    this._invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : G.INV_SUB_MIX[0][G.SBOX[t >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[(t >>> 16) & 0xff]] ^ G.INV_SUB_MIX[2][G.SBOX[(t >>> 8) & 0xff]] ^ G.INV_SUB_MIX[3][G.SBOX[t & 0xff]];
  }
  return true;
};

AES.prototype.encryptBlock = function(M) {
  M = bufferToArray(new Buffer(M));
  var out = this._doCryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX);
  var buf = new Buffer(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
};

AES.prototype.decryptBlock = function(M) {
  M = bufferToArray(new Buffer(M));
  var temp = [M[3], M[1]];
  M[1] = temp[0];
  M[3] = temp[1];
  var out = this._doCryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX);
  var buf = new Buffer(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[3], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[1], 12);
  return buf;
};

AES.prototype.scrub = function() {
  scrub_vec(this._keySchedule);
  scrub_vec(this._invKeySchedule);
  scrub_vec(this._key);
};

AES.prototype._doCryptBlock = function(M, keySchedule, SUB_MIX, SBOX) {
  var ksRow, round, s0, s1, s2, s3, t0, t1, t2, t3, _i, _ref;

  s0 = M[0] ^ keySchedule[0];
  s1 = M[1] ^ keySchedule[1];
  s2 = M[2] ^ keySchedule[2];
  s3 = M[3] ^ keySchedule[3];
  ksRow = 4;
  for (round = _i = 1, _ref = this._nRounds; 1 <= _ref ? _i < _ref : _i > _ref; round = 1 <= _ref ? ++_i : --_i) {
    t0 = SUB_MIX[0][s0 >>> 24] ^ SUB_MIX[1][(s1 >>> 16) & 0xff] ^ SUB_MIX[2][(s2 >>> 8) & 0xff] ^ SUB_MIX[3][s3 & 0xff] ^ keySchedule[ksRow++];
    t1 = SUB_MIX[0][s1 >>> 24] ^ SUB_MIX[1][(s2 >>> 16) & 0xff] ^ SUB_MIX[2][(s3 >>> 8) & 0xff] ^ SUB_MIX[3][s0 & 0xff] ^ keySchedule[ksRow++];
    t2 = SUB_MIX[0][s2 >>> 24] ^ SUB_MIX[1][(s3 >>> 16) & 0xff] ^ SUB_MIX[2][(s0 >>> 8) & 0xff] ^ SUB_MIX[3][s1 & 0xff] ^ keySchedule[ksRow++];
    t3 = SUB_MIX[0][s3 >>> 24] ^ SUB_MIX[1][(s0 >>> 16) & 0xff] ^ SUB_MIX[2][(s1 >>> 8) & 0xff] ^ SUB_MIX[3][s2 & 0xff] ^ keySchedule[ksRow++];
    s0 = t0;
    s1 = t1;
    s2 = t2;
    s3 = t3;
  }
  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
  return [
    fixup_uint32(t0),
    fixup_uint32(t1),
    fixup_uint32(t2),
    fixup_uint32(t3)
  ];

};




  exports.AES = AES;
}).call(this,require("buffer").Buffer)
},{"buffer":5}],12:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes');
var Transform = require('./cipherBase');
var inherits = require('inherits');
var GHASH = require('./ghash');
var xor = require('./xor');
inherits(StreamCipher, Transform);
module.exports = StreamCipher;

function StreamCipher(mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv);
  }
  Transform.call(this);
  this._finID = Buffer.concat([iv, new Buffer([0, 0, 0, 1])]);
  iv = Buffer.concat([iv, new Buffer([0, 0, 0, 2])]);
  this._cipher = new aes.AES(key);
  this._prev = new Buffer(iv.length);
  this._cache = new Buffer('');
  this._secCache = new Buffer('');
  this._decrypt = decrypt;
  this._alen = 0;
  this._len = 0;
  iv.copy(this._prev);
  this._mode = mode;
  var h = new Buffer(4);
  h.fill(0);
  this._ghash = new GHASH(this._cipher.encryptBlock(h));
  this._authTag = null;
  this._called = false;
}
StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16);
    if (rump <16) {
      rump = new Buffer(rump);
      rump.fill(0);
      this._ghash.update(rump);
    }
  }
  this._called = true;
  var out = this._mode.encrypt(this, chunk);
  if (this._decrypt) {
    this._ghash.update(chunk);
  } else {
    this._ghash.update(out);
  }
  this._len += chunk.length;
  return out;
};
StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) {
    throw new Error('Unsupported state or unable to authenticate data');
  }
  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt) {
    if (xorTest(tag, this._authTag)) {
      throw new Error('Unsupported state or unable to authenticate data');
    }
  } else {
    this._authTag = tag;
  }
  this._cipher.scrub();
};
StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (!this._decrypt && Buffer.isBuffer(this._authTag)) {
    return this._authTag;
  } else {
    throw new Error('Attempting to get auth tag in unsupported state');
  }
};
StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (this._decrypt) {
    this._authTag = tag;
  } else {
    throw new Error('Attempting to set auth tag in unsupported state');
  }
};
StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (!this._called) {
    this._ghash.update(buf);
    this._alen += buf.length;
  } else {
    throw new Error('Attempting to set AAD in unsupported state');
  }
};
function xorTest(a, b) {
  var out = 0;
  if (a.length !== b.length) {
    out++;
  }
  var len = Math.min(a.length, b.length);
  var i = -1;
  while (++i < len) {
    out += (a[i] ^ b[i]);
  }
  return out;
}



}).call(this,require("buffer").Buffer)
},{"./aes":11,"./cipherBase":14,"./ghash":17,"./xor":27,"buffer":5,"inherits":146}],13:[function(require,module,exports){
var ciphers = require('./encrypter');
exports.createCipher = exports.Cipher = ciphers.createCipher;
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv;
var deciphers = require('./decrypter');
exports.createDecipher = exports.Decipher = deciphers.createDecipher;
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv;
var modes = require('./modes');
function getCiphers () {
  return Object.keys(modes);
}
exports.listCiphers = exports.getCiphers = getCiphers;

},{"./decrypter":15,"./encrypter":16,"./modes":18}],14:[function(require,module,exports){
(function (Buffer){
var Transform = require('stream').Transform;
var inherits = require('inherits');

module.exports = CipherBase;
inherits(CipherBase, Transform);
function CipherBase() {
  Transform.call(this);
}
CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = new Buffer(data, inputEnc);
  }
  var outData = this._update(data);
  if (outputEnc) {
    outData = outData.toString(outputEnc);
  }
  return outData;
};
CipherBase.prototype._transform = function (data, _, next) {
  this.push(this._update(data));
  next();
};
CipherBase.prototype._flush = function (next) {
  try {
    this.push(this._final());
  } catch(e) {
    return next(e);
  }
  next();
};
CipherBase.prototype.final = function (outputEnc) {
  var outData = this._final() || new Buffer('');
  if (outputEnc) {
    outData = outData.toString(outputEnc);
  }
  return outData;
};
}).call(this,require("buffer").Buffer)
},{"buffer":5,"inherits":146,"stream":163}],15:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes');
var Transform = require('./cipherBase');
var inherits = require('inherits');
var modes = require('./modes');
var StreamCipher = require('./streamCipher');
var AuthCipher = require('./authCipher');
var ebtk = require('./EVP_BytesToKey');

inherits(Decipher, Transform);
function Decipher(mode, key, iv) {
  if (!(this instanceof Decipher)) {
    return new Decipher(mode, key, iv);
  }
  Transform.call(this);
  this._cache = new Splitter();
  this._last = void 0;
  this._cipher = new aes.AES(key);
  this._prev = new Buffer(iv.length);
  iv.copy(this._prev);
  this._mode = mode;
  this._autopadding = true;
}
Decipher.prototype._update = function (data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk);
    out.push(thing);
  }
  return Buffer.concat(out);
};
Decipher.prototype._final = function () {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk));
  } else if (chunk) {
    throw new Error('data not multiple of block length');
  }
};
Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
};
function Splitter() {
   if (!(this instanceof Splitter)) {
    return new Splitter();
  }
  this.cache = new Buffer('');
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function (autoPadding) {
  var out;
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16);
      this.cache = this.cache.slice(16);
      return out;
    }
  }
  return null;
};
Splitter.prototype.flush = function () {
  if (this.cache.length) {
    return this.cache;
  }
};
function unpad(last) {
  var padded = last[15];
  var i = -1;
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data');
    }
  }
  if (padded === 16) {
    return;
  }
  return last.slice(0, 16 - padded);
}

var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
};


function createDecipheriv(suite, password, iv) {
  var config = modes[suite.toLowerCase()];
  if (!config) {
    throw new TypeError('invalid suite type');
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv);
  }
  if (typeof password === 'string') {
    password = new Buffer(password);
  }
  if (password.length !== config.key/8) {
    throw new TypeError('invalid key length ' + password.length);
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length);
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv, true);
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv, true);
  }
  return new Decipher(modelist[config.mode], password, iv);
}

function createDecipher (suite, password) {
  var config = modes[suite.toLowerCase()];
  if (!config) {
    throw new TypeError('invalid suite type');
  }
  var keys = ebtk(password, config.key, config.iv);
  return createDecipheriv(suite, keys.key, keys.iv);
}
exports.createDecipher = createDecipher;
exports.createDecipheriv = createDecipheriv;
}).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":10,"./aes":11,"./authCipher":12,"./cipherBase":14,"./modes":18,"./modes/cbc":19,"./modes/cfb":20,"./modes/cfb1":21,"./modes/cfb8":22,"./modes/ctr":23,"./modes/ecb":24,"./modes/ofb":25,"./streamCipher":26,"buffer":5,"inherits":146}],16:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes');
var Transform = require('./cipherBase');
var inherits = require('inherits');
var modes = require('./modes');
var ebtk = require('./EVP_BytesToKey');
var StreamCipher = require('./streamCipher');
var AuthCipher = require('./authCipher');
inherits(Cipher, Transform);
function Cipher(mode, key, iv) {
  if (!(this instanceof Cipher)) {
    return new Cipher(mode, key, iv);
  }
  Transform.call(this);
  this._cache = new Splitter();
  this._cipher = new aes.AES(key);
  this._prev = new Buffer(iv.length);
  iv.copy(this._prev);
  this._mode = mode;
  this._autopadding = true;
}
Cipher.prototype._update = function (data) {
  this._cache.add(data);
  var chunk;
  var thing;
  var out = [];
  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk);
    out.push(thing);
  }
  return Buffer.concat(out);
};
Cipher.prototype._final = function () {
  var chunk = this._cache.flush();
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk);
    this._cipher.scrub();
    return chunk;
  } else if (chunk.toString('hex') !== '10101010101010101010101010101010') {
    this._cipher.scrub();
    throw new Error('data not multiple of block length');
  }
};
Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo;
};

function Splitter() {
   if (!(this instanceof Splitter)) {
    return new Splitter();
  }
  this.cache = new Buffer('');
}
Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data]);
};

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    return out;
  }
  return null;
};
Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length;
  var padBuff = new Buffer(len);

  var i = -1;
  while (++i < len) {
    padBuff.writeUInt8(len, i);
  }
  var out = Buffer.concat([this.cache, padBuff]);
  return out;
};
var modelist = {
  ECB: require('./modes/ecb'),
  CBC: require('./modes/cbc'),
  CFB: require('./modes/cfb'),
  CFB8: require('./modes/cfb8'),
  CFB1: require('./modes/cfb1'),
  OFB: require('./modes/ofb'),
  CTR: require('./modes/ctr'),
  GCM: require('./modes/ctr')
};

function createCipheriv(suite, password, iv) {
  var config = modes[suite.toLowerCase()];
  if (!config) {
    throw new TypeError('invalid suite type');
  }
  if (typeof iv === 'string') {
    iv = new Buffer(iv);
  }
  if (typeof password === 'string') {
    password = new Buffer(password);
  }
  if (password.length !== config.key/8) {
    throw new TypeError('invalid key length ' + password.length);
  }
  if (iv.length !== config.iv) {
    throw new TypeError('invalid iv length ' + iv.length);
  }
  if (config.type === 'stream') {
    return new StreamCipher(modelist[config.mode], password, iv);
  } else if (config.type === 'auth') {
    return new AuthCipher(modelist[config.mode], password, iv);
  }
  return new Cipher(modelist[config.mode], password, iv);
}
function createCipher (suite, password) {
  var config = modes[suite.toLowerCase()];
  if (!config) {
    throw new TypeError('invalid suite type');
  }
  var keys = ebtk(password, config.key, config.iv);
  return createCipheriv(suite, keys.key, keys.iv);
}

exports.createCipheriv = createCipheriv;
exports.createCipher = createCipher;
}).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":10,"./aes":11,"./authCipher":12,"./cipherBase":14,"./modes":18,"./modes/cbc":19,"./modes/cfb":20,"./modes/cfb1":21,"./modes/cfb8":22,"./modes/ctr":23,"./modes/ecb":24,"./modes/ofb":25,"./streamCipher":26,"buffer":5,"inherits":146}],17:[function(require,module,exports){
(function (Buffer){
var zeros = new Buffer(16);
zeros.fill(0);
module.exports = GHASH;
function GHASH(key){
  this.h = key;
  this.state = new Buffer(16);
  this.state.fill(0);
  this.cache = new Buffer('');
}
// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1;
  while (++i < block.length) {
   this.state[i] ^= block[i];
  }
  this._multiply();
};

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h);
  var Zi = [0, 0, 0, 0];
  var j, xi, lsb_Vi;
  var i = -1;
  while (++i < 128) {
    xi = (this.state[~~(i/8)] & (1 << (7-i%8))) !== 0;
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi = xor(Zi, Vi);
    }

    // Store the value of LSB(V_i)
    lsb_Vi = (Vi[3] & 1) !== 0;

    // V_i+1 = V_i >> 1
    for (j=3; j>0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j-1]&1) << 31);
    }
    Vi[0] = Vi[0] >>> 1;

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsb_Vi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24);
    }
  }
  this.state = fromArray(Zi);
};
GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf]);
  var chunk;
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16);
    this.cache = this.cache.slice(16);
    this.ghash(chunk);
  }
};
GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, zeros], 16));
  }
  this.ghash(fromArray([
     0, abl,
     0, bl
   ]));
  return this.state;
};

function toArray(buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ];
}
function fromArray(out) {
  out = out.map(fixup_uint32);
  var buf = new Buffer(16);
  buf.writeUInt32BE(out[0], 0);
  buf.writeUInt32BE(out[1], 4);
  buf.writeUInt32BE(out[2], 8);
  buf.writeUInt32BE(out[3], 12);
  return buf;
}
var uint_max = Math.pow(2, 32);
function fixup_uint32(x) {
    var ret, x_pos;
    ret = x > uint_max || x < 0 ? (x_pos = Math.abs(x) % uint_max, x < 0 ? uint_max - x_pos : x_pos) : x;
    return ret;
}
function xor(a, b) {
  return [
    a[0] ^ b[0],
    a[1] ^ b[1],
    a[2] ^ b[2],
    a[3] ^ b[3],
  ];
}
}).call(this,require("buffer").Buffer)
},{"buffer":5}],18:[function(require,module,exports){
exports['aes-128-ecb'] = {
  cipher: 'AES',
  key: 128,
  iv: 0,
  mode: 'ECB',
  type: 'block'
};
exports['aes-192-ecb'] = {
  cipher: 'AES',
  key: 192,
  iv: 0,
  mode: 'ECB',
  type: 'block'
};
exports['aes-256-ecb'] = {
  cipher: 'AES',
  key: 256,
  iv: 0,
  mode: 'ECB',
  type: 'block'
};
exports['aes-128-cbc'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CBC',
  type: 'block'
};
exports['aes-192-cbc'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CBC',
  type: 'block'
};
exports['aes-256-cbc'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CBC',
  type: 'block'
};
exports['aes128'] = exports['aes-128-cbc'];
exports['aes192'] = exports['aes-192-cbc'];
exports['aes256'] = exports['aes-256-cbc'];
exports['aes-128-cfb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
};
exports['aes-192-cfb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
};
exports['aes-256-cfb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB',
  type: 'stream'
};
exports['aes-128-cfb8'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
};
exports['aes-192-cfb8'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
};
exports['aes-256-cfb8'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB8',
  type: 'stream'
};
exports['aes-128-cfb1'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
};
exports['aes-192-cfb1'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
};
exports['aes-256-cfb1'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CFB1',
  type: 'stream'
};
exports['aes-128-ofb'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
};
exports['aes-192-ofb'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
};
exports['aes-256-ofb'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'OFB',
  type: 'stream'
};
exports['aes-128-ctr'] = {
  cipher: 'AES',
  key: 128,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
};
exports['aes-192-ctr'] = {
  cipher: 'AES',
  key: 192,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
};
exports['aes-256-ctr'] = {
  cipher: 'AES',
  key: 256,
  iv: 16,
  mode: 'CTR',
  type: 'stream'
};
exports['aes-128-gcm'] = {
  cipher: 'AES',
  key: 128,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
};
exports['aes-192-gcm'] = {
  cipher: 'AES',
  key: 192,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
};
exports['aes-256-gcm'] = {
  cipher: 'AES',
  key: 256,
  iv: 12,
  mode: 'GCM',
  type: 'auth'
};
},{}],19:[function(require,module,exports){
var xor = require('../xor');
exports.encrypt = function (self, block) {
  var data = xor(block, self._prev);
  self._prev = self._cipher.encryptBlock(data);
  return self._prev;
};
exports.decrypt = function (self, block) {
  var pad = self._prev;
  self._prev = block;
  var out = self._cipher.decryptBlock(block);
  return xor(out, pad);
};
},{"../xor":27}],20:[function(require,module,exports){
(function (Buffer){
var xor = require('../xor');
exports.encrypt = function (self, data, decrypt) {
  var out = new Buffer('');
  var len;
  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev);
      self._prev = new Buffer('');
    }
    if (self._cache.length <= data.length) {
      len = self._cache.length;
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
      data = data.slice(len);
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
      break;
    }
  }
  return out;
};
function encryptStart(self, data, decrypt) {
  var len = data.length;
  var out = xor(data, self._cache);
  self._cache = self._cache.slice(len);
  self._prev = Buffer.concat([self._prev, decrypt?data:out]);
  return out;
}
}).call(this,require("buffer").Buffer)
},{"../xor":27,"buffer":5}],21:[function(require,module,exports){
(function (Buffer){

function encryptByte(self, byte, decrypt) {
  var pad;
  var i = -1;
  var len = 8;
  var out = 0;
  var bit, value;
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev);
    bit = (byte & (1 << (7-i))) ? 0x80:0;
    value = pad[0] ^ bit;
    out += ((value&0x80) >> (i%8));
    self._prev = shiftIn(self._prev, decrypt?bit:value);
  }
  return out;
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = new Buffer(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }
  return out;
};
function shiftIn(buffer, value) {
  var len = buffer.length;
  var i = -1;
  var out = new Buffer(buffer.length);
  buffer = Buffer.concat([buffer, new Buffer([value])]);
  while(++i < len) {
    out[i] = buffer[i]<<1 | buffer[i+1]>>(7);
  }
  return out;
}
}).call(this,require("buffer").Buffer)
},{"buffer":5}],22:[function(require,module,exports){
(function (Buffer){
function encryptByte(self, byte, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev);
  var out = pad[0] ^ byte;
  self._prev = Buffer.concat([self._prev.slice(1), new Buffer([decrypt?byte:out])]);
  return out;
}
exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length;
  var out = new Buffer(len);
  var i = -1;
  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt);
  }
  return out;
};
}).call(this,require("buffer").Buffer)
},{"buffer":5}],23:[function(require,module,exports){
(function (Buffer){
var xor = require('../xor');
function getBlock(self) {
  var out = self._cipher.encryptBlock(self._prev);
  incr32(self._prev);
  return out;
}
exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)]);
  }
  var pad = self._cache.slice(0, chunk.length);
  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};
function incr32(iv) {
  var len = iv.length;
  var item;
  while (len--) {
    item = iv.readUInt8(len);
    if (item === 255) {
      iv.writeUInt8(0, len);
    } else {
      item++;
      iv.writeUInt8(item, len);
      break;
    }
  }
}
}).call(this,require("buffer").Buffer)
},{"../xor":27,"buffer":5}],24:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block);
};
exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block);
};
},{}],25:[function(require,module,exports){
(function (Buffer){
var xor = require('../xor');
function getBlock(self) {
  self._prev = self._cipher.encryptBlock(self._prev);
  return self._prev;
}
exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)]);
  }
  var pad = self._cache.slice(0, chunk.length);
  self._cache = self._cache.slice(chunk.length);
  return xor(chunk, pad);
};
}).call(this,require("buffer").Buffer)
},{"../xor":27,"buffer":5}],26:[function(require,module,exports){
(function (Buffer){
var aes = require('./aes');
var Transform = require('./cipherBase');
var inherits = require('inherits');

inherits(StreamCipher, Transform);
module.exports = StreamCipher;
function StreamCipher(mode, key, iv, decrypt) {
  if (!(this instanceof StreamCipher)) {
    return new StreamCipher(mode, key, iv);
  }
  Transform.call(this);
  this._cipher = new aes.AES(key);
  this._prev = new Buffer(iv.length);
  this._cache = new Buffer('');
  this._secCache = new Buffer('');
  this._decrypt = decrypt;
  iv.copy(this._prev);
  this._mode = mode;
}
StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt);
};
StreamCipher.prototype._final = function () {
  this._cipher.scrub();
};
}).call(this,require("buffer").Buffer)
},{"./aes":11,"./cipherBase":14,"buffer":5,"inherits":146}],27:[function(require,module,exports){
(function (Buffer){
module.exports = xor;
function xor(a, b) {
  var len = Math.min(a.length, b.length);
  var out = new Buffer(len);
  var i = -1;
  while (++i < len) {
    out.writeUInt8(a[i] ^ b[i], i);
  }
  return out;
}
}).call(this,require("buffer").Buffer)
},{"buffer":5}],28:[function(require,module,exports){
(function (Buffer){
exports['RSA-SHA224'] = exports.sha224WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha224',
  id: new Buffer('302d300d06096086480165030402040500041c', 'hex')
};
exports['RSA-SHA256'] = exports.sha256WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha256',
  id: new Buffer('3031300d060960864801650304020105000420', 'hex')
};
exports['RSA-SHA384'] = exports.sha384WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha384',
  id: new Buffer('3041300d060960864801650304020205000430', 'hex')
};
exports['RSA-SHA512'] = exports.sha512WithRSAEncryption = {
  sign: 'rsa',
  hash: 'sha512',
  id: new Buffer('3051300d060960864801650304020305000440', 'hex')
};
exports['RSA-SHA1'] = {
	sign: 'rsa',
	hash: 'sha1',
	id: new Buffer('3021300906052b0e03021a05000414', 'hex')
};
exports['ecdsa-with-SHA1'] = {
	sign: 'ecdsa',
	hash: 'sha1',
	id: new Buffer('', 'hex')
};
exports.DSA = exports['DSA-SHA1'] = exports['DSA-SHA'] = {
  sign: 'dsa',
  hash: 'sha1',
  id: new Buffer('', 'hex')
};
exports['DSA-SHA224'] = exports['DSA-WITH-SHA224'] = {
  sign: 'dsa',
  hash: 'sha224',
  id: new Buffer('', 'hex')
};
exports['DSA-SHA256'] = exports['DSA-WITH-SHA256'] = {
  sign: 'dsa',
  hash: 'sha256',
  id: new Buffer('', 'hex')
};
exports['DSA-SHA384'] = exports['DSA-WITH-SHA384'] = {
  sign: 'dsa',
  hash: 'sha384',
  id: new Buffer('', 'hex')
};
exports['DSA-SHA512'] = exports['DSA-WITH-SHA512'] = {
  sign: 'dsa',
  hash: 'sha512',
  id: new Buffer('', 'hex')
};
exports['DSA-RIPEMD160'] = {
  sign: 'dsa',
  hash: 'rmd160',
  id: new Buffer('', 'hex')
};
exports['RSA-RIPEMD160'] = exports.ripemd160WithRSA = {
  sign: 'rsa',
  hash: 'rmd160',
  id: new Buffer('3021300906052b2403020105000414', 'hex')
};
exports['RSA-MD5'] = exports.md5WithRSAEncryption = {
  sign: 'rsa',
  hash: 'md5',
  id: new Buffer('3020300c06082a864886f70d020505000410', 'hex')
};
}).call(this,require("buffer").Buffer)
},{"buffer":5}],29:[function(require,module,exports){
(function (Buffer){
var sign = require('./sign');
var verify = require('./verify');
var stream = require('stream');
var inherits = require('inherits');
var _algos = require('./algos');
var algos = {};
Object.keys(_algos).forEach(function (key) {
	algos[key] = algos[key.toLowerCase()] = _algos[key];
});
'use strict';
module.exports = function (exports, crypto) {
	exports.createSign = exports.Sign = createSign;
	function createSign(algorithm) {

		return new Sign(algorithm, crypto);
	}
	exports.createVerify = exports.Verify = createVerify;
	function createVerify(algorithm) {
		return new Verify(algorithm, crypto);
	}
};
inherits(Sign, stream.Writable);
function Sign(algorithm, crypto) {
	stream.Writable.call(this);
	var data = algos[algorithm];
	if (!data) {
		throw new Error('Unknown message digest');
	}
	this._hashType = data.hash;
	this._hash = crypto.createHash(data.hash);
	this._tag = data.id;
	this._crypto = crypto;
}
Sign.prototype._write = function _write(data, _, done) {
	this._hash.update(data);
	done();
};
Sign.prototype.update = function update(data) {
	this.write(data);
	return this;
};

Sign.prototype.sign = function signMethod(key, enc) {
	this.end();
	var hash = this._hash.digest();
	var sig = sign(Buffer.concat([this._tag, hash]), key, this._hashType, this._crypto);
	if (enc) {
		sig = sig.toString(enc);
	}
	return sig;
};

inherits(Verify, stream.Writable);
function Verify(algorithm, crypto) {
	stream.Writable.call(this);
	var data = algos[algorithm];
	if (!data) {
		throw new Error('Unknown message digest');
	}
	this._hash = crypto.createHash(data.hash);
	this._tag = data.id;
}
Verify.prototype._write = function _write(data, _, done) {
	this._hash.update(data);
	done();
};
Verify.prototype.update = function update(data) {
	this.write(data);
	return this;
};

Verify.prototype.verify = function verifyMethod(key, sig, enc) {
	this.end();
	var hash = this._hash.digest();
	if (!Buffer.isBuffer(sig)) {
		sig = new Buffer(sig, enc);
	}
	return verify(sig, Buffer.concat([this._tag, hash]), key);
};
}).call(this,require("buffer").Buffer)
},{"./algos":28,"./sign":72,"./verify":73,"buffer":5,"inherits":146,"stream":163}],30:[function(require,module,exports){
// Utils

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
}

// Could use `inherits` module, but don't want to move from single file
// architecture yet.
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor
  var TempCtor = function () {}
  TempCtor.prototype = superCtor.prototype
  ctor.prototype = new TempCtor()
  ctor.prototype.constructor = ctor
}

// BN

function BN(number, base, endian) {
  // May be `new BN(bn)` ?
  if (number !== null &&
      typeof number === 'object' &&
      Array.isArray(number.words)) {
    return number;
  }

  this.sign = false;
  this.words = null;
  this.length = 0;

  // Reduction context
  this.red = null;

  if (base === 'le' || base === 'be') {
    endian = base;
    base = 10;
  }

  if (number !== null)
    this._init(number || 0, base || 10, endian || 'be');
}
if (typeof module === 'object')
  module.exports = BN;

BN.BN = BN;
BN.wordSize = 26;

BN.prototype._init = function init(number, base, endian) {
  if (typeof number === 'number') {
    if (number < 0) {
      this.sign = true;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    }
    return;
  } else if (typeof number === 'object') {
    return this._initArray(number, base, endian);
  }
  if (base === 'hex')
    base = 16;
  assert(base === (base | 0) && base >= 2 && base <= 36);

  number = number.toString().replace(/\s+/g, '');
  var start = 0;
  if (number[0] === '-')
    start++;

  if (base === 16)
    this._parseHex(number, start);
  else
    this._parseBase(number, base, start);

  if (number[0] === '-')
    this.sign = true;

  this.strip();
};

BN.prototype._initArray = function _initArray(number, base, endian) {
  // Perhaps a Uint8Array
  assert(typeof number.length === 'number');
  this.length = Math.ceil(number.length / 3);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  var off = 0;
  if (endian === 'be') {
    for (var i = number.length - 1, j = 0; i >= 0; i -= 3) {
      var w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  } else if (endian === 'le') {
    for (var i = 0, j = 0; i < number.length; i += 3) {
      var w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
      this.words[j] |= (w << off) & 0x3ffffff;
      this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
      off += 24;
      if (off >= 26) {
        off -= 26;
        j++;
      }
    }
  }
  return this.strip();
};

function parseHex(str, start, end) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r <<= 4;

    // 'a' - 'f'
    if (c >= 49 && c <= 54)
      r |= c - 49 + 0xa;

    // 'A' - 'F'
    else if (c >= 17 && c <= 22)
      r |= c - 17 + 0xa;

    // '0' - '9'
    else
      r |= c & 0xf;
  }
  return r;
}

BN.prototype._parseHex = function _parseHex(number, start) {
  // Create possibly bigger array to ensure that it fits the number
  this.length = Math.ceil((number.length - start) / 6);
  this.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    this.words[i] = 0;

  // Scan 24-bit chunks and add them to the number
  var off = 0;
  for (var i = number.length - 6, j = 0; i >= start; i -= 6) {
    var w = parseHex(number, i, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
    off += 24;
    if (off >= 26) {
      off -= 26;
      j++;
    }
  }
  if (i + 6 !== start) {
    var w = parseHex(number, start, i + 6);
    this.words[j] |= (w << off) & 0x3ffffff;
    this.words[j + 1] |= w >>> (26 - off) & 0x3fffff;
  }
  this.strip();
};

function parseBase(str, start, end, mul) {
  var r = 0;
  var len = Math.min(str.length, end);
  for (var i = start; i < len; i++) {
    var c = str.charCodeAt(i) - 48;

    r *= mul;

    // 'a'
    if (c >= 49)
      r += c - 49 + 0xa;

    // 'A'
    else if (c >= 17)
      r += c - 17 + 0xa;

    // '0' - '9'
    else
      r += c;
  }
  return r;
}

BN.prototype._parseBase = function _parseBase(number, base, start) {
  // Initialize as zero
  this.words = [ 0 ];
  this.length = 1;

  // Find length of limb in base
  for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base)
    limbLen++;
  limbLen--;
  limbPow = (limbPow / base) | 0;

  var total = number.length - start;
  var mod = total % limbLen;
  var end = Math.min(total, total - mod) + start;

  var word = 0;
  for (var i = start; i < end; i += limbLen) {
    word = parseBase(number, i, i + limbLen, base);

    this.imuln(limbPow);
    this.words[0] += word;
  }

  if (mod !== 0) {
    var pow = 1;
    var word = parseBase(number, i, number.length, base);

    for (var i = 0; i < mod; i++)
      pow *= base;
    this.imuln(pow);
    this.words[0] += word;
  }
};

BN.prototype.copy = function copy(dest) {
  dest.words = new Array(this.length);
  for (var i = 0; i < this.length; i++)
    dest.words[i] = this.words[i];
  dest.length = this.length;
  dest.sign = this.sign;
  dest.red = this.red;
};

BN.prototype.clone = function clone() {
  var r = new BN(null);
  this.copy(r);
  return r;
};

// Remove leading `0` from `this`
BN.prototype.strip = function strip() {
  while (this.length > 1 && this.words[this.length - 1] === 0)
    this.length--;
  return this._normSign();
};

BN.prototype._normSign = function _normSign() {
  // -0 = 0
  if (this.length === 1 && this.words[0] === 0)
    this.sign = false;
  return this;
};

BN.prototype.inspect = function inspect() {
  return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
};

/*

var zeros = [];
var groupSizes = [];
var groupBases = [];

var s = '';
var i = -1;
while (++i < BN.wordSize) {
  zeros[i] = s;
  s += '0';
}
groupSizes[0] = 0;
groupSizes[1] = 0;
groupBases[0] = 0;
groupBases[1] = 0;
var base = 2 - 1;
while (++base < 36 + 1) {
  var groupSize = 0;
  var groupBase = 1;
  // TODO: <=
  while (groupBase < (1 << BN.wordSize) / base) {
    groupBase *= base;
    groupSize += 1;
  }
  groupSizes[base] = groupSize;
  groupBases[base] = groupBase;
}

*/

var zeros = [
  '',
  '0',
  '00',
  '000',
  '0000',
  '00000',
  '000000',
  '0000000',
  '00000000',
  '000000000',
  '0000000000',
  '00000000000',
  '000000000000',
  '0000000000000',
  '00000000000000',
  '000000000000000',
  '0000000000000000',
  '00000000000000000',
  '000000000000000000',
  '0000000000000000000',
  '00000000000000000000',
  '000000000000000000000',
  '0000000000000000000000',
  '00000000000000000000000',
  '000000000000000000000000',
  '0000000000000000000000000'
];

var groupSizes = [
  0, 0,
  25, 16, 12, 11, 10, 9, 8,
  8, 7, 7, 7, 7, 6, 6,
  6, 6, 6, 6, 6, 5, 5,
  5, 5, 5, 5, 5, 5, 5,
  5, 5, 5, 5, 5, 5, 5
];

var groupBases = [
  0, 0,
  33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
  43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
  16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
  6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
  24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
];

BN.prototype.toString = function toString(base, padding) {
  base = base || 10;
  if (base === 16 || base === 'hex') {
    var out = '';
    var off = 0;
    var padding = padding | 0 || 1;
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = this.words[i];
      var word = (((w << off) | carry) & 0xffffff).toString(16);
      carry = (w >>> (24 - off)) & 0xffffff;
      if (carry !== 0 || i !== this.length - 1)
        out = zeros[6 - word.length] + word + out;
      else
        out = word + out;
      off += 2;
      if (off >= 26) {
        off -= 26;
        i--;
      }
    }
    if (carry !== 0)
      out = carry.toString(16) + out;
    while (out.length % padding !== 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else if (base === (base | 0) && base >= 2 && base <= 36) {
    // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
    var groupSize = groupSizes[base];
    // var groupBase = Math.pow(base, groupSize);
    var groupBase = groupBases[base];
    var out = '';
    var c = this.clone();
    c.sign = false;
    while (c.cmpn(0) !== 0) {
      var r = c.modn(groupBase).toString(base);
      c = c.idivn(groupBase);

      if (c.cmpn(0) !== 0)
        out = zeros[groupSize - r.length] + r + out;
      else
        out = r + out;
    }
    if (this.cmpn(0) === 0)
      out = '0' + out;
    if (this.sign)
      out = '-' + out;
    return out;
  } else {
    assert(false, 'Base should be between 2 and 36');
  }
};

BN.prototype.toJSON = function toJSON() {
  return this.toString(16);
};

BN.prototype.toArray = function toArray() {
  this.strip();
  var res = new Array(this.byteLength());
  res[0] = 0;

  var q = this.clone();
  for (var i = 0; q.cmpn(0) !== 0; i++) {
    var b = q.andln(0xff);
    q.ishrn(8);

    // Assume big-endian
    res[res.length - i - 1] = b;
  }

  return res;
};

/*
function genCountBits(bits) {
  var arr = [];

  for (var i = bits - 1; i >= 0; i--) {
    var bit = '0x' + (1 << i).toString(16);
    arr.push('w >= ' + bit + ' ? ' + (i + 1));
  }

  return new Function('w', 'return ' + arr.join(' :\n') + ' :\n0;');
};

BN.prototype._countBits = genCountBits(26);
*/

// Sadly chrome apps could not contain `new Function()` calls
BN.prototype._countBits = function _countBits(w) {
  return w >= 0x2000000 ? 26 :
         w >= 0x1000000 ? 25 :
         w >= 0x800000 ? 24 :
         w >= 0x400000 ? 23 :
         w >= 0x200000 ? 22 :
         w >= 0x100000 ? 21 :
         w >= 0x80000 ? 20 :
         w >= 0x40000 ? 19 :
         w >= 0x20000 ? 18 :
         w >= 0x10000 ? 17 :
         w >= 0x8000 ? 16 :
         w >= 0x4000 ? 15 :
         w >= 0x2000 ? 14 :
         w >= 0x1000 ? 13 :
         w >= 0x800 ? 12 :
         w >= 0x400 ? 11 :
         w >= 0x200 ? 10 :
         w >= 0x100 ? 9 :
         w >= 0x80 ? 8 :
         w >= 0x40 ? 7 :
         w >= 0x20 ? 6 :
         w >= 0x10 ? 5 :
         w >= 0x8 ? 4 :
         w >= 0x4 ? 3 :
         w >= 0x2 ? 2 :
         w >= 0x1 ? 1 :
         0;
};

// Return number of used bits in a BN
BN.prototype.bitLength = function bitLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  var hi = this._countBits(w);
  return (this.length - 1) * 26 + hi;
};

BN.prototype.byteLength = function byteLength() {
  var hi = 0;
  var w = this.words[this.length - 1];
  return Math.ceil(this.bitLength() / 8);
};

// Return negative clone of `this`
BN.prototype.neg = function neg() {
  if (this.cmpn(0) === 0)
    return this.clone();

  var r = this.clone();
  r.sign = !this.sign;
  return r;
};

// Add `num` to `this` in-place
BN.prototype.iadd = function iadd(num) {
  // negative + positive
  if (this.sign && !num.sign) {
    this.sign = false;
    var r = this.isub(num);
    this.sign = !this.sign;
    return this._normSign();

  // positive + negative
  } else if (!this.sign && num.sign) {
    num.sign = false;
    var r = this.isub(num);
    num.sign = true;
    return r._normSign();
  }

  // a.length > b.length
  var a;
  var b;
  if (this.length > num.length) {
    a = this;
    b = num;
  } else {
    a = num;
    b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] + b.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] + carry;
    this.words[i] = r & 0x3ffffff;
    carry = r >>> 26;
  }

  this.length = a.length;
  if (carry !== 0) {
    this.words[this.length] = carry;
    this.length++;
  // Copy the rest of the words
  } else if (a !== this) {
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  }

  return this;
};

// Add `num` to `this`
BN.prototype.add = function add(num) {
  if (num.sign && !this.sign) {
    num.sign = false;
    var res = this.sub(num);
    num.sign = true;
    return res;
  } else if (!num.sign && this.sign) {
    this.sign = false;
    var res = num.sub(this);
    this.sign = true;
    return res;
  }

  if (this.length > num.length)
    return this.clone().iadd(num);
  else
    return num.clone().iadd(this);
};

// Subtract `num` from `this` in-place
BN.prototype.isub = function isub(num) {
  // this - (-num) = this + num
  if (num.sign) {
    num.sign = false;
    var r = this.iadd(num);
    num.sign = true;
    return r._normSign();

  // -this - num = -(this + num)
  } else if (this.sign) {
    this.sign = false;
    this.iadd(num);
    this.sign = true;
    return this._normSign();
  }

  // At this point both numbers are positive
  var cmp = this.cmp(num);

  // Optimization - zeroify
  if (cmp === 0) {
    this.sign = false;
    this.length = 1;
    this.words[0] = 0;
    return this;
  }

  // a > b
  if (cmp > 0) {
    var a = this;
    var b = num;
  } else {
    var a = num;
    var b = this;
  }

  var carry = 0;
  for (var i = 0; i < b.length; i++) {
    var r = a.words[i] - b.words[i] - carry;
    if (r < 0) {
      r += 0x4000000;
      carry = 1;
    } else {
      carry = 0;
    }
    this.words[i] = r;
  }
  for (; carry !== 0 && i < a.length; i++) {
    var r = a.words[i] - carry;
    if (r < 0) {
      r += 0x4000000;
      carry = 1;
    } else {
      carry = 0;
    }
    this.words[i] = r;
  }

  // Copy rest of the words
  if (carry === 0 && i < a.length && a !== this)
    for (; i < a.length; i++)
      this.words[i] = a.words[i];
  this.length = Math.max(this.length, i);

  if (a !== this)
    this.sign = true;

  return this.strip();
};

// Subtract `num` from `this`
BN.prototype.sub = function sub(num) {
  return this.clone().isub(num);
};

/*
// NOTE: This could be potentionally used to generate loop-less multiplications
function _genCombMulTo(alen, blen) {
  var len = alen + blen - 1;
  var src = [
    'var a = this.words, b = num.words, o = out.words, c = 0, w, ' +
        'mask = 0x3ffffff, shift = 0x4000000;',
    'out.length = ' + len + ';'
  ];
  for (var k = 0; k < len; k++) {
    var minJ = Math.max(0, k - alen + 1);
    var maxJ = Math.min(k, blen - 1);

    for (var j = minJ; j <= maxJ; j++) {
      var i = k - j;
      var mul = 'a[' + i + '] * b[' + j + ']';

      if (j === minJ) {
        src.push('w = ' + mul + ' + c;');
        src.push('c = (w / shift) | 0;');
      } else {
        src.push('w += ' + mul + ';');
        src.push('c += (w / shift) | 0;');
      }
      src.push('w &= mask;');
    }
    src.push('o[' + k + '] = w;');
  }
  src.push('if (c !== 0) {',
           '  o[' + k + '] = c;',
           '  out.length++;',
           '}',
           'return out;');

  return src.join('\n');
}
*/

BN.prototype._smallMulTo = function _smallMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = carry >>> 26;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;
    }
    out.words[k] = rword;
    carry = ncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype._bigMulTo = function _bigMulTo(num, out) {
  out.sign = num.sign !== this.sign;
  out.length = this.length + num.length;

  var carry = 0;
  var hncarry = 0;
  for (var k = 0; k < out.length - 1; k++) {
    // Sum all words with the same `i + j = k` and accumulate `ncarry`,
    // note that ncarry could be >= 0x3ffffff
    var ncarry = hncarry;
    hncarry = 0;
    var rword = carry & 0x3ffffff;
    var maxJ = Math.min(k, num.length - 1);
    for (var j = Math.max(0, k - this.length + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i] | 0;
      var b = num.words[j] | 0;
      var r = a * b;

      var lo = r & 0x3ffffff;
      ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
      lo = (lo + rword) | 0;
      rword = lo & 0x3ffffff;
      ncarry = (ncarry + (lo >>> 26)) | 0;

      hncarry += ncarry >>> 26;
      ncarry &= 0x3ffffff;
    }
    out.words[k] = rword;
    carry = ncarry;
    ncarry = hncarry;
  }
  if (carry !== 0) {
    out.words[k] = carry;
  } else {
    out.length--;
  }

  return out.strip();
};

BN.prototype.mulTo = function mulTo(num, out) {
  var res;
  if (this.length + num.length < 63)
    res = this._smallMulTo(num, out);
  else
    res = this._bigMulTo(num, out);
  return res;
};

// Multiply `this` by `num`
BN.prototype.mul = function mul(num) {
  var out = new BN(null);
  out.words = new Array(this.length + num.length);
  return this.mulTo(num, out);
};

// In-place Multiplication
BN.prototype.imul = function imul(num) {
  if (this.cmpn(0) === 0 || num.cmpn(0) === 0) {
    this.words[0] = 0;
    this.length = 1;
    return this;
  }

  var tlen = this.length;
  var nlen = num.length;

  this.sign = num.sign !== this.sign;
  this.length = this.length + num.length;
  this.words[this.length - 1] = 0;

  var lastCarry = 0;
  for (var k = this.length - 2; k >= 0; k--) {
    // Sum all words with the same `i + j = k` and accumulate `carry`,
    // note that carry could be >= 0x3ffffff
    var carry = 0;
    var rword = 0;
    var maxJ = Math.min(k, nlen - 1);
    for (var j = Math.max(0, k - tlen + 1); j <= maxJ; j++) {
      var i = k - j;
      var a = this.words[i];
      var b = num.words[j];
      var r = a * b;

      var lo = r & 0x3ffffff;
      carry += (r / 0x4000000) | 0;
      lo += rword;
      rword = lo & 0x3ffffff;
      carry += lo >>> 26;
    }
    this.words[k] = rword;
    this.words[k + 1] += carry;
    carry = 0;
  }

  // Propagate overflows
  var carry = 0;
  for (var i = 1; i < this.length; i++) {
    var w = this.words[i] + carry;
    this.words[i] = w & 0x3ffffff;
    carry = w >>> 26;
  }

  return this.strip();
};

BN.prototype.imuln = function imuln(num) {
  assert(typeof num === 'number');

  // Carry
  var carry = 0;
  for (var i = 0; i < this.length; i++) {
    var w = this.words[i] * num;
    var lo = (w & 0x3ffffff) + carry;
    carry = (w / 0x4000000) | 0;
    this.words[i] = lo;
  }

  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }

  return this;
};

// `this` * `this`
BN.prototype.sqr = function sqr() {
  return this.mul(this);
};

// `this` * `this` in-place
BN.prototype.isqr = function isqr() {
  return this.mul(this);
};

// Shift-left in-place
BN.prototype.ishln = function ishln(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;
  var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);

  var o = this.clone();
  if (r !== 0) {
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var newCarry = this.words[i] & carryMask;
      var c = (this.words[i] - newCarry) << r;
      this.words[i] = c | carry;
      carry = newCarry >>> (26 - r);
    }
    if (carry) {
      this.words[i] = carry;
      this.length++;
    }
  }

  if (s !== 0) {
    for (var i = this.length - 1; i >= 0; i--)
      this.words[i + s] = this.words[i];
    for (var i = 0; i < s; i++)
      this.words[i] = 0;
    this.length += s;
  }

  return this.strip();
};

// Shift-right in-place
// NOTE: `hint` is a lowest bit before trailing zeroes
// NOTE: if `extended` is true - { lo: ..., hi: } object will be returned
BN.prototype.ishrn = function ishrn(bits, hint, extended) {
  assert(typeof bits === 'number' && bits >= 0);
  if (hint)
    hint = (hint - (hint % 26)) / 26;
  else
    hint = 0;

  var r = bits % 26;
  var s = Math.min((bits - r) / 26, this.length);
  var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
  var maskedWords = extended;

  hint -= s;
  hint = Math.max(0, hint);

  // Extended mode, copy masked part
  if (maskedWords) {
    for (var i = 0; i < s; i++)
      maskedWords.words[i] = this.words[i];
    maskedWords.length = s;
  }

  if (s === 0) {
    // No-op, we should not move anything at all
  } else if (this.length > s) {
    this.length -= s;
    for (var i = 0; i < this.length; i++)
      this.words[i] = this.words[i + s];
  } else {
    this.words[0] = 0;
    this.length = 1;
  }

  var carry = 0;
  for (var i = this.length - 1; i >= 0 && (carry !== 0 || i >= hint); i--) {
    var word = this.words[i];
    this.words[i] = (carry << (26 - r)) | (word >>> r);
    carry = word & mask;
  }

  // Push carried bits as a mask
  if (maskedWords && carry !== 0)
    maskedWords.words[maskedWords.length++] = carry;

  if (this.length === 0) {
    this.words[0] = 0;
    this.length = 1;
  }

  this.strip();
  if (extended)
    return { hi: this, lo: maskedWords };

  return this;
};

// Shift-left
BN.prototype.shln = function shln(bits) {
  return this.clone().ishln(bits);
};

// Shift-right
BN.prototype.shrn = function shrn(bits) {
  return this.clone().ishrn(bits);
};

// Test if n bit is set
BN.prototype.testn = function testn(bit) {
  assert(typeof bit === 'number' && bit >= 0);
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    return false;
  }

  // Check bit and return
  var w = this.words[s];

  return !!(w & q);
};

// Return only lowers bits of number (in-place)
BN.prototype.imaskn = function imaskn(bits) {
  assert(typeof bits === 'number' && bits >= 0);
  var r = bits % 26;
  var s = (bits - r) / 26;

  assert(!this.sign, 'imaskn works only with positive numbers');

  if (r !== 0)
    s++;
  this.length = Math.min(s, this.length);

  if (r !== 0) {
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    this.words[this.length - 1] &= mask;
  }

  return this.strip();
};

// Return only lowers bits of number
BN.prototype.maskn = function maskn(bits) {
  return this.clone().imaskn(bits);
};

// Add plain number `num` to `this`
BN.prototype.iaddn = function iaddn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.isubn(-num);

  // Possible sign change
  if (this.sign) {
    if (this.length === 1 && this.words[0] < num) {
      this.words[0] = num - this.words[0];
      this.sign = false;
      return this;
    }

    this.sign = false;
    this.isubn(num);
    this.sign = true;
    return this;
  }
  this.words[0] += num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
    this.words[i] -= 0x4000000;
    if (i === this.length - 1)
      this.words[i + 1] = 1;
    else
      this.words[i + 1]++;
  }
  this.length = Math.max(this.length, i + 1);

  return this;
};

// Subtract plain number `num` from `this`
BN.prototype.isubn = function isubn(num) {
  assert(typeof num === 'number');
  if (num < 0)
    return this.iaddn(-num);

  if (this.sign) {
    this.sign = false;
    this.iaddn(num);
    this.sign = true;
    return this;
  }

  this.words[0] -= num;

  // Carry
  for (var i = 0; i < this.length && this.words[i] < 0; i++) {
    this.words[i] += 0x4000000;
    this.words[i + 1] -= 1;
  }

  return this.strip();
};

BN.prototype.addn = function addn(num) {
  return this.clone().iaddn(num);
};

BN.prototype.subn = function subn(num) {
  return this.clone().isubn(num);
};

BN.prototype.iabs = function iabs() {
  this.sign = false;

  return this
};

BN.prototype.abs = function abs() {
  return this.clone().iabs();
};

BN.prototype._wordDiv = function _wordDiv(num, mode) {
  var shift = this.length - num.length;

  var a = this.clone();
  var b = num;

  var q = mode !== 'mod' && new BN(0);
  var sign = false;

  // Approximate quotient at each step
  while (a.length > b.length) {
    // NOTE: a.length is always >= 2, because of the condition .div()
    var hi = a.words[a.length - 1] * 0x4000000 + a.words[a.length - 2];
    var sq = (hi / b.words[b.length - 1]);
    var sqhi = (sq / 0x4000000) | 0;
    var sqlo = sq & 0x3ffffff;
    sq = new BN(null);
    sq.words = [ sqlo, sqhi ];
    sq.length = 2;

    // Collect quotient
    var shift = (a.length - b.length - 1) * 26;
    if (q) {
      var t = sq.shln(shift);
      if (a.sign)
        q.isub(t);
      else
        q.iadd(t);
    }

    sq = sq.mul(b).ishln(shift);
    if (a.sign)
      a.iadd(sq)
    else
      a.isub(sq);
  }
  // At this point a.length <= b.length
  while (a.ucmp(b) >= 0) {
    // NOTE: a.length is always >= 2, because of the condition above
    var hi = a.words[a.length - 1];
    var sq = new BN((hi / b.words[b.length - 1]) | 0);
    var shift = (a.length - b.length) * 26;

    if (q) {
      var t = sq.shln(shift);
      if (a.sign)
        q.isub(t);
      else
        q.iadd(t);
    }

    sq = sq.mul(b).ishln(shift);

    if (a.sign)
      a.iadd(sq);
    else
      a.isub(sq);
  }

  if (a.sign) {
    if (q)
      q.isubn(1);
    a.iadd(b);
  }
  return { div: q ? q : null, mod: a };
};

BN.prototype.divmod = function divmod(num, mode) {
  assert(num.cmpn(0) !== 0);

  if (this.sign && !num.sign) {
    var res = this.neg().divmod(num, mode);
    var div;
    var mod;
    if (mode !== 'mod')
      div = res.div.neg();
    if (mode !== 'div')
      mod = res.mod.cmpn(0) === 0 ? res.mod : num.sub(res.mod);
    return {
      div: div,
      mod: mod
    };
  } else if (!this.sign && num.sign) {
    var res = this.divmod(num.neg(), mode);
    var div;
    if (mode !== 'mod')
      div = res.div.neg();
    return { div: div, mod: res.mod };
  } else if (this.sign && num.sign) {
    return this.neg().divmod(num.neg(), mode);
  }

  // Both numbers are positive at this point

  // Strip both numbers to approximate shift value
  if (num.length > this.length || this.cmp(num) < 0)
    return { div: new BN(0), mod: this };

  // Very short reduction
  if (num.length === 1) {
    if (mode === 'div')
      return { div: this.divn(num.words[0]), mod: null };
    else if (mode === 'mod')
      return { div: null, mod: new BN(this.modn(num.words[0])) };
    return {
      div: this.divn(num.words[0]),
      mod: new BN(this.modn(num.words[0]))
    };
  }

  return this._wordDiv(num, mode);
};

// Find `this` / `num`
BN.prototype.div = function div(num) {
  return this.divmod(num, 'div').div;
};

// Find `this` % `num`
BN.prototype.mod = function mod(num) {
  return this.divmod(num, 'mod').mod;
};

// Find Round(`this` / `num`)
BN.prototype.divRound = function divRound(num) {
  var dm = this.divmod(num);

  // Fast case - exact division
  if (dm.mod.cmpn(0) === 0)
    return dm.div;

  var mod = dm.div.sign ? dm.mod.isub(num) : dm.mod;

  var half = num.shrn(1);
  var r2 = num.andln(1);
  var cmp = mod.cmp(half);

  // Round down
  if (cmp < 0 || r2 === 1 && cmp === 0)
    return dm.div;

  // Round up
  return dm.div.sign ? dm.div.isubn(1) : dm.div.iaddn(1);
};

BN.prototype.modn = function modn(num) {
  assert(num <= 0x3ffffff);
  var p = (1 << 26) % num;

  var acc = 0;
  for (var i = this.length - 1; i >= 0; i--)
    acc = (p * acc + this.words[i]) % num;

  return acc;
};

// In-place division by number
BN.prototype.idivn = function idivn(num) {
  assert(num <= 0x3ffffff);

  var carry = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var w = this.words[i] + carry * 0x4000000;
    this.words[i] = (w / num) | 0;
    carry = w % num;
  }

  return this.strip();
};

BN.prototype.divn = function divn(num) {
  return this.clone().idivn(num);
};

BN.prototype._egcd = function _egcd(x1, p) {
  assert(!p.sign);
  assert(p.cmpn(0) !== 0);

  var a = this;
  var b = p.clone();

  if (a.sign)
    a = a.mod(p);
  else
    a = a.clone();

  var x2 = new BN(0);
  while (b.isEven())
    b.ishrn(1);
  var delta = b.clone();
  while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
    while (a.isEven()) {
      a.ishrn(1);
      if (x1.isEven())
        x1.ishrn(1);
      else
        x1.iadd(delta).ishrn(1);
    }
    while (b.isEven()) {
      b.ishrn(1);
      if (x2.isEven())
        x2.ishrn(1);
      else
        x2.iadd(delta).ishrn(1);
    }
    if (a.cmp(b) >= 0) {
      a.isub(b);
      x1.isub(x2);
    } else {
      b.isub(a);
      x2.isub(x1);
    }
  }
  if (a.cmpn(1) === 0)
    return x1;
  else
    return x2;
};

BN.prototype.gcd = function gcd(num) {
  if (this.cmpn(0) === 0)
    return num.clone();
  if (num.cmpn(0) === 0)
    return this.clone();

  var a = this.clone();
  var b = num.clone();
  a.sign = false;
  b.sign = false;

  // Remove common factor of two
  for (var shift = 0; a.isEven() && b.isEven(); shift++) {
    a.ishrn(1);
    b.ishrn(1);
  }

  while (a.isEven())
    a.ishrn(1);

  do {
    while (b.isEven())
      b.ishrn(1);

    // Swap `a` and `b` to make `a` always bigger than `b`
    if (a.cmp(b) < 0) {
      var t = a;
      a = b;
      b = t;
    }
    a.isub(a.div(b).mul(b));
  } while (a.cmpn(0) !== 0 && b.cmpn(0) !== 0);
  if (a.cmpn(0) === 0)
    return b.ishln(shift);
  else
    return a.ishln(shift);
};

// Invert number in the field F(num)
BN.prototype.invm = function invm(num) {
  return this._egcd(new BN(1), num).mod(num);
};

BN.prototype.isEven = function isEven(num) {
  return (this.words[0] & 1) === 0;
};

BN.prototype.isOdd = function isOdd(num) {
  return (this.words[0] & 1) === 1;
};

// And first word and num
BN.prototype.andln = function andln(num) {
  return this.words[0] & num;
};

// Increment at the bit position in-line
BN.prototype.bincn = function bincn(bit) {
  assert(typeof bit === 'number');
  var r = bit % 26;
  var s = (bit - r) / 26;
  var q = 1 << r;

  // Fast case: bit is much higher than all existing words
  if (this.length <= s) {
    for (var i = this.length; i < s + 1; i++)
      this.words[i] = 0;
    this.words[s] |= q;
    this.length = s + 1;
    return this;
  }

  // Add bit and propagate, if needed
  var carry = q;
  for (var i = s; carry !== 0 && i < this.length; i++) {
    var w = this.words[i];
    w += carry;
    carry = w >>> 26;
    w &= 0x3ffffff;
    this.words[i] = w;
  }
  if (carry !== 0) {
    this.words[i] = carry;
    this.length++;
  }
  return this;
};

BN.prototype.cmpn = function cmpn(num) {
  var sign = num < 0;
  if (sign)
    num = -num;

  if (this.sign && !sign)
    return -1;
  else if (!this.sign && sign)
    return 1;

  num &= 0x3ffffff;
  this.strip();

  var res;
  if (this.length > 1) {
    res = 1;
  } else {
    var w = this.words[0];
    res = w === num ? 0 : w < num ? -1 : 1;
  }
  if (this.sign)
    res = -res;
  return res;
};

// Compare two numbers and return:
// 1 - if `this` > `num`
// 0 - if `this` == `num`
// -1 - if `this` < `num`
BN.prototype.cmp = function cmp(num) {
  if (this.sign && !num.sign)
    return -1;
  else if (!this.sign && num.sign)
    return 1;

  var res = this.ucmp(num);
  if (this.sign)
    return -res;
  else
    return res;
};

// Unsigned comparison
BN.prototype.ucmp = function ucmp(num) {
  // At this point both numbers have the same sign
  if (this.length > num.length)
    return 1;
  else if (this.length < num.length)
    return -1;

  var res = 0;
  for (var i = this.length - 1; i >= 0; i--) {
    var a = this.words[i];
    var b = num.words[i];

    if (a === b)
      continue;
    if (a < b)
      res = -1;
    else if (a > b)
      res = 1;
    break;
  }
  return res;
};

//
// A reduce context, could be using montgomery or something better, depending
// on the `m` itself.
//
BN.red = function red(num) {
  return new Red(num);
};

BN.prototype.toRed = function toRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  assert(!this.sign, 'red works only with positives');
  return ctx.convertTo(this)._forceRed(ctx);
};

BN.prototype.fromRed = function fromRed() {
  assert(this.red, 'fromRed works only with numbers in reduction context');
  return this.red.convertFrom(this);
};

BN.prototype._forceRed = function _forceRed(ctx) {
  this.red = ctx;
  return this;
};

BN.prototype.forceRed = function forceRed(ctx) {
  assert(!this.red, 'Already a number in reduction context');
  return this._forceRed(ctx);
};

BN.prototype.redAdd = function redAdd(num) {
  assert(this.red, 'redAdd works only with red numbers');
  return this.red.add(this, num);
};

BN.prototype.redIAdd = function redIAdd(num) {
  assert(this.red, 'redIAdd works only with red numbers');
  return this.red.iadd(this, num);
};

BN.prototype.redSub = function redSub(num) {
  assert(this.red, 'redSub works only with red numbers');
  return this.red.sub(this, num);
};

BN.prototype.redISub = function redISub(num) {
  assert(this.red, 'redISub works only with red numbers');
  return this.red.isub(this, num);
};

BN.prototype.redShl = function redShl(num) {
  assert(this.red, 'redShl works only with red numbers');
  return this.red.shl(this, num);
};

BN.prototype.redMul = function redMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.mul(this, num);
};

BN.prototype.redIMul = function redIMul(num) {
  assert(this.red, 'redMul works only with red numbers');
  this.red._verify2(this, num);
  return this.red.imul(this, num);
};

BN.prototype.redSqr = function redSqr() {
  assert(this.red, 'redSqr works only with red numbers');
  this.red._verify1(this);
  return this.red.sqr(this);
};

BN.prototype.redISqr = function redISqr() {
  assert(this.red, 'redISqr works only with red numbers');
  this.red._verify1(this);
  return this.red.isqr(this);
};

// Square root over p
BN.prototype.redSqrt = function redSqrt() {
  assert(this.red, 'redSqrt works only with red numbers');
  this.red._verify1(this);
  return this.red.sqrt(this);
};

BN.prototype.redInvm = function redInvm() {
  assert(this.red, 'redInvm works only with red numbers');
  this.red._verify1(this);
  return this.red.invm(this);
};

// Return negative clone of `this` % `red modulo`
BN.prototype.redNeg = function redNeg() {
  assert(this.red, 'redNeg works only with red numbers');
  this.red._verify1(this);
  return this.red.neg(this);
};

BN.prototype.redPow = function redPow(num) {
  assert(this.red && !num.red, 'redPow(normalNum)');
  this.red._verify1(this);
  return this.red.pow(this, num);
};

// Prime numbers with efficient reduction
var primes = {
  k256: null,
  p224: null,
  p192: null,
  p25519: null
};

// Pseudo-Mersenne prime
function MPrime(name, p) {
  // P = 2 ^ N - K
  this.name = name;
  this.p = new BN(p, 16);
  this.n = this.p.bitLength();
  this.k = new BN(1).ishln(this.n).isub(this.p);

  this.tmp = this._tmp();
}

MPrime.prototype._tmp = function _tmp() {
  var tmp = new BN(null);
  tmp.words = new Array(Math.ceil(this.n / 13));
  return tmp;
};

MPrime.prototype.ireduce = function ireduce(num) {
  // Assumes that `num` is less than `P^2`
  // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
  var r = num;
  var rlen;

  do {
    var pair = r.ishrn(this.n, 0, this.tmp);
    r = this.imulK(pair.hi);
    r = r.iadd(pair.lo);
    rlen = r.bitLength();
  } while (rlen > this.n);

  var cmp = rlen < this.n ? -1 : r.cmp(this.p);
  if (cmp === 0) {
    r.words[0] = 0;
    r.length = 1;
  } else if (cmp > 0) {
    r.isub(this.p);
  } else {
    r.strip();
  }

  return r;
};

MPrime.prototype.imulK = function imulK(num) {
  return num.imul(this.k);
};

function K256() {
  MPrime.call(
    this,
    'k256',
    'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
}
inherits(K256, MPrime);

K256.prototype.imulK = function imulK(num) {
  // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
  num.words[num.length] = 0;
  num.words[num.length + 1] = 0;
  num.length += 2;

  var uhi = 0;
  var hi = 0;
  var lo = 0;
  for (var i = 0; i < num.length; i++) {
    var w = num.words[i];
    hi += w * 0x40;
    lo += w * 0x3d1;
    hi += (lo / 0x4000000) | 0;
    uhi += (hi / 0x4000000) | 0;
    hi &= 0x3ffffff;
    lo &= 0x3ffffff;

    num.words[i] = lo;

    lo = hi;
    hi = uhi;
    uhi = 0;
  }

  // Fast length reduction
  if (num.words[num.length - 1] === 0)
    num.length--;
  if (num.words[num.length - 1] === 0)
    num.length--;
  return num;
};

function P224() {
  MPrime.call(
    this,
    'p224',
    'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
}
inherits(P224, MPrime);

function P192() {
  MPrime.call(
    this,
    'p192',
    'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
}
inherits(P192, MPrime);

function P25519() {
  // 2 ^ 255 - 19
  MPrime.call(
    this,
    '25519',
    '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
}
inherits(P25519, MPrime);

P25519.prototype.imulK = function imulK(num) {
  // K = 0x13
  var carry = 0;
  for (var i = 0; i < num.length; i++) {
    var hi = num.words[i] * 0x13 + carry;
    var lo = hi & 0x3ffffff;
    hi >>>= 26;

    num.words[i] = lo;
    carry = hi;
  }
  if (carry !== 0)
    num.words[num.length++] = carry;
  return num;
};

// Exported mostly for testing purposes, use plain name instead
BN._prime = function prime(name) {
  // Cached version of prime
  if (primes[name])
    return primes[name];

  var prime;
  if (name === 'k256')
    prime = new K256();
  else if (name === 'p224')
    prime = new P224();
  else if (name === 'p192')
    prime = new P192();
  else if (name === 'p25519')
    prime = new P25519();
  else
    throw new Error('Unknown prime ' + name);
  primes[name] = prime;

  return prime;
}

//
// Base reduction engine
//
function Red(m) {
  if (typeof m === 'string') {
    var prime = BN._prime(m);
    this.m = prime.p;
    this.prime = prime;
  } else {
    this.m = m;
    this.prime = null;
  }
}

Red.prototype._verify1 = function _verify1(a) {
  assert(!a.sign, 'red works only with positives');
  assert(a.red, 'red works only with red numbers');
};

Red.prototype._verify2 = function _verify2(a, b) {
  assert(!a.sign && !b.sign, 'red works only with positives');
  assert(a.red && a.red === b.red,
         'red works only with red numbers');
};

Red.prototype.imod = function imod(a) {
  if (this.prime)
    return this.prime.ireduce(a)._forceRed(this);
  return a.mod(this.m)._forceRed(this);
};

Red.prototype.neg = function neg(a) {
  var r = a.clone();
  r.sign = !r.sign;
  return r.iadd(this.m)._forceRed(this);
};

Red.prototype.add = function add(a, b) {
  this._verify2(a, b);

  var res = a.add(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res._forceRed(this);
};

Red.prototype.iadd = function iadd(a, b) {
  this._verify2(a, b);

  var res = a.iadd(b);
  if (res.cmp(this.m) >= 0)
    res.isub(this.m);
  return res;
};

Red.prototype.sub = function sub(a, b) {
  this._verify2(a, b);

  var res = a.sub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res._forceRed(this);
};

Red.prototype.isub = function isub(a, b) {
  this._verify2(a, b);

  var res = a.isub(b);
  if (res.cmpn(0) < 0)
    res.iadd(this.m);
  return res;
};

Red.prototype.shl = function shl(a, num) {
  this._verify1(a);
  return this.imod(a.shln(num));
};

Red.prototype.imul = function imul(a, b) {
  this._verify2(a, b);
  return this.imod(a.imul(b));
};

Red.prototype.mul = function mul(a, b) {
  this._verify2(a, b);
  return this.imod(a.mul(b));
};

Red.prototype.isqr = function isqr(a) {
  return this.imul(a, a);
};

Red.prototype.sqr = function sqr(a) {
  return this.mul(a, a);
};

Red.prototype.sqrt = function sqrt(a) {
  if (a.cmpn(0) === 0)
    return a.clone();

  var mod3 = this.m.andln(3);
  assert(mod3 % 2 === 1);

  // Fast case
  if (mod3 === 3) {
    var pow = this.m.add(new BN(1)).ishrn(2);
    var r = this.pow(a, pow);
    return r;
  }

  // Tonelli-Shanks algorithm (Totally unoptimized and slow)
  //
  // Find Q and S, that Q * 2 ^ S = (P - 1)
  var q = this.m.subn(1);
  var s = 0;
  while (q.cmpn(0) !== 0 && q.andln(1) === 0) {
    s++;
    q.ishrn(1);
  }
  assert(q.cmpn(0) !== 0);

  var one = new BN(1).toRed(this);
  var nOne = one.redNeg();

  // Find quadratic non-residue
  // NOTE: Max is such because of generalized Riemann hypothesis.
  var lpow = this.m.subn(1).ishrn(1);
  var z = this.m.bitLength();
  z = new BN(2 * z * z).toRed(this);
  while (this.pow(z, lpow).cmp(nOne) !== 0)
    z.redIAdd(nOne);

  var c = this.pow(z, q);
  var r = this.pow(a, q.addn(1).ishrn(1));
  var t = this.pow(a, q);
  var m = s;
  while (t.cmp(one) !== 0) {
    var tmp = t;
    for (var i = 0; tmp.cmp(one) !== 0; i++)
      tmp = tmp.redSqr();
    assert(i < m);
    var b = this.pow(c, new BN(1).ishln(m - i - 1));

    r = r.redMul(b);
    c = b.redSqr();
    t = t.redMul(c);
    m = i;
  }

  return r;
};

Red.prototype.invm = function invm(a) {
  var inv = a._egcd(new BN(1), this.m);
  if (inv.sign) {
    inv.sign = false;
    return this.imod(inv).redNeg();
  } else {
    return this.imod(inv);
  }
};

Red.prototype.pow = function pow(a, num) {
  var w = [];
  var q = num.clone();
  while (q.cmpn(0) !== 0) {
    w.push(q.andln(1));
    q.ishrn(1);
  }

  // Skip leading zeroes
  var res = a;
  for (var i = 0; i < w.length; i++, res = this.sqr(res))
    if (w[i] !== 0)
      break;

  if (++i < w.length) {
    for (var q = this.sqr(res); i < w.length; i++, q = this.sqr(q)) {
      if (w[i] === 0)
        continue;
      res = this.mul(res, q);
    }
  }

  return res;
};

Red.prototype.convertTo = function convertTo(num) {
  return num.clone();
};

Red.prototype.convertFrom = function convertFrom(num) {
  var res = num.clone();
  res.red = null;
  return res;
};

//
// Montgomery method engine
//

BN.mont = function mont(num) {
  return new Mont(num);
};

function Mont(m) {
  Red.call(this, m);

  this.shift = this.m.bitLength();
  if (this.shift % 26 !== 0)
    this.shift += 26 - (this.shift % 26);
  this.r = new BN(1).ishln(this.shift);
  this.r2 = this.imod(this.r.sqr());
  this.rinv = this.r.invm(this.m);

  // TODO(indutny): simplify it
  this.minv = this.rinv.mul(this.r)
                       .sub(new BN(1))
                       .div(this.m)
                       .neg()
                       .mod(this.r);
}
inherits(Mont, Red);

Mont.prototype.convertTo = function convertTo(num) {
  return this.imod(num.shln(this.shift));
};

Mont.prototype.convertFrom = function convertFrom(num) {
  var r = this.imod(num.mul(this.rinv));
  r.red = null;
  return r;
};

Mont.prototype.imul = function imul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0) {
    a.words[0] = 0;
    a.length = 1;
    return a;
  }

  var t = a.imul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.mul = function mul(a, b) {
  if (a.cmpn(0) === 0 || b.cmpn(0) === 0)
    return new BN(0)._forceRed(this);

  var t = a.mul(b);
  var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
  var u = t.isub(c).ishrn(this.shift);
  var res = u;
  if (u.cmp(this.m) >= 0)
    res = u.isub(this.m);
  else if (u.cmpn(0) < 0)
    res = u.iadd(this.m);

  return res._forceRed(this);
};

Mont.prototype.invm = function invm(a) {
  // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
  var res = this.imod(a.invm(this.m).mul(this.r2));
  return res._forceRed(this);
};

},{}],31:[function(require,module,exports){
(function (Buffer){
var bn = require('bn.js');
module.exports = crt;
function blind(priv, crypto) {
  var r = getr(priv, crypto);
  var blinder = r.toRed(bn.mont(priv.modulus))
  .redPow(new bn(priv.publicExponent)).fromRed();
  return {
    blinder: blinder,
    unblinder:r.invm(priv.modulus)
  };
}
function crt(msg, priv, crypto) {
  var blinds = blind(priv, crypto);
  var len = priv.modulus.byteLength();
  var mod = bn.mont(priv.modulus);
  var blinded = new bn(msg).mul(blinds.blinder).mod(priv.modulus);
  var c1 = blinded.toRed(bn.mont(priv.prime1));
  var c2 = blinded.toRed(bn.mont(priv.prime2));
  var qinv = priv.coefficient;
  var p = priv.prime1;
  var q = priv.prime2;
  var m1 = c1.redPow(priv.exponent1);
  var m2 = c2.redPow(priv.exponent2);
  m1 = m1.fromRed();
  m2 = m2.fromRed();
  var h = m1.isub(m2).imul(qinv).mod(p);
  h.imul(q);
  m2.iadd(h);
  var out = new Buffer(m2.imul(blinds.unblinder).mod(priv.modulus).toArray());
  if (out.length < len) {
    var prefix = new Buffer(len - out.length);
    prefix.fill(0);
    out = Buffer.concat([prefix, out], len);
  }
  return out;
}
crt.getr = getr;
function getr(priv, crypto) {
  var len = priv.modulus.byteLength();
  var r = new bn(crypto.randomBytes(len));
  while (r.cmp(priv.modulus) >=  0 || !r.mod(priv.prime1) || !r.mod(priv.prime2)) {
    r = new bn(crypto.randomBytes(len));
  }
  return r;
}
}).call(this,require("buffer").Buffer)
},{"bn.js":30,"buffer":5}],32:[function(require,module,exports){
var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.hmacDRBG = require('./elliptic/hmac-drbg');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');

},{"../package.json":51,"./elliptic/curve":35,"./elliptic/curves":38,"./elliptic/ec":39,"./elliptic/hmac-drbg":42,"./elliptic/utils":43,"brorand":44}],33:[function(require,module,exports){
var bn = require('bn.js');
var elliptic = require('../../elliptic');

var getNAF = elliptic.utils.getNAF;
var getJSF = elliptic.utils.getJSF;
var assert = elliptic.utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn.red(conf.prime) : bn.mont(this.p);

  // Useful for many curves
  this.zero = new bn(0).toRed(this.red);
  this.one = new bn(1).toRed(this.red);
  this.two = new bn(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate(point) {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  for (var j = 0; j < naf.length; j += doubles.step) {
    var nafW = 0;
    for (var k = j + doubles.step - 1; k >= j; k--)
      nafW = (nafW << 1) + naf[k];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (var j = 0; j < repr.length; j++) {
      var nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var k = 0; i >= 0 && naf[i] === 0; i--)
      k++;
    if (i >= 0)
      k++;
    acc = acc.dblp(k);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
                                                       points,
                                                       coeffs,
                                                       len) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  for (var i = 0; i < len; i++) {
    var p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (var i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a]);
      naf[b] = getNAF(coeffs[b], wndWidth[b]);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b] /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (var j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (var i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (var j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (var j = 0; j < len; j++) {
      var z = tmp[j];
      var p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (var i = 0; i < len; i++)
    wnd[i] = null;
  return acc.toP();
};

BaseCurve.BasePoint = BasePoint;

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BasePoint.prototype.precompute = function precompute(power, _beta) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../../elliptic":32,"bn.js":30}],34:[function(require,module,exports){
var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var getNAF = elliptic.utils.getNAF;
var assert = elliptic.utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = conf.a != 1;
  this.mOneA = this.twisted && conf.a == -1;
  this.extended = this.mOneA;

  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).mod(this.red.m).toRed(this.red);
  this.c = new bn(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new bn(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = conf.c == 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(odd, x) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y = rhs.redMul(lhs.redInvm()).redSqrt();
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y, curve.one);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = z ? new bn(z, 16) : this.curve.one;
    this.t = t && new bn(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
         this.y.cmp(this.z) === 0;
};

Point.prototype._extDbl = function _extDbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#doubling-dbl-2008-bbjlp
  // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  if (this.curve.twisted) {
    // E = a * C
    var e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      var nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      var ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      var nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      var h = this.z.redSqr();
      // J = F - 2 * H
      var j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      var nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      var ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      var nz = f.redMul(j);
    }
  } else {
    // E = C + D
    var e = c.redAdd(d);
    // H = (c * Z1)^2
    var h = this.curve._mulC(redMul(this.z)).redSqr();
    // J = E - 2 * H
    var j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    var nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    var ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    var nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // http://hyperelliptic.org/EFD/g1p/auto-twisted-projective.html#addition-add-2008-bbjlp
  // http://hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    var ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    var nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    var ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    var nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this.precomputed && this.precomputed.doubles)
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
                          this.y,
                          this.z,
                          this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../../elliptic":32,"../curve":35,"bn.js":30,"inherits":146}],35:[function(require,module,exports){
var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":33,"./edwards":34,"./mont":36,"./short":37}],36:[function(require,module,exports){
var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var getNAF = elliptic.utils.getNAF;
var assert = elliptic.utils.assert;

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.i4 = new bn(4).toRed(this.red).redInvm();
  this.two = new bn(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
}

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new bn(x, 16);
    this.z = new bn(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add(p) {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.ishrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../../elliptic":32,"../curve":35,"bn.js":30,"inherits":146}],37:[function(require,module,exports){
var curve = require('../curve');
var elliptic = require('../../elliptic');
var bn = require('bn.js');
var inherits = require('inherits');
var Base = curve.base;

var getNAF = elliptic.utils.getNAF;
var assert = elliptic.utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new bn(conf.a, 16).toRed(this.red);
  this.b = new bn(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn(vec.a, 16),
        b: new bn(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn.mont(num);
  var tinv = new bn(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var one = new bn(1).toRed(red);

  var s = new bn(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.shrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn(1);
  var y1 = new bn(0);
  var x2 = new bn(0);
  var y2 = new bn(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    var r = v.sub(q.mul(u));
    var x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.sign) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.sign) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 }
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromX = function pointFromX(odd, x) {
  x = new bn(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;
  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);
    var p = points[i];
    var beta = p._getBeta();

    if (split.k1.sign) {
      split.k1.sign = !split.k1.sign;
      p = p.neg(true);
    }
    if (split.k2.sign) {
      split.k2.sign = !split.k2.sign;
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }
  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2);

  // Clean-up references to points and coefficients
  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }
  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    function endoMul(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    }
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16 ,2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn(k, 16);

  if (this.precomputed && this.precomputed.doubles)
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    function negate(p) {
      return p.neg();
    }
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn(0);
  } else {
    this.x = new bn(x, 16);
    this.y = new bn(y, 16);
    this.z = new bn(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (var i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (var i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  // Z = 1
  if (this.zOne) {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    var nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    var nz = this.y.redAdd(this.y);
  } else {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    var nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    var ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    var nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  // Z = 1
  if (this.zOne) {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    var nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    var ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    var nz = this.y.redAdd(this.y);
  } else {
    // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    var nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    var nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    var ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // http://hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../../elliptic":32,"../curve":35,"bn.js":30,"inherits":146}],38:[function(require,module,exports){
var curves = exports;

var hash = require('hash.js');
var bn = require('bn.js');
var elliptic = require('../elliptic');

var assert = elliptic.utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new elliptic.curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new elliptic.curve.edwards(options);
  else
    this.curve = new elliptic.curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811'
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34'
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5'
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '0',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9'
  ]
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658'
  ]
});

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    {
      'doubles': {
        'step': 4,
        'points': [
          [
            'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
            'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'
          ],
          [
            '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
            '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'
          ],
          [
            '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
            'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'
          ],
          [
            '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
            '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'
          ],
          [
            '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
            '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'
          ],
          [
            '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
            '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'
          ],
          [
            'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
            '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'
          ],
          [
            '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
            'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'
          ],
          [
            'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
            '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'
          ],
          [
            'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
            'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'
          ],
          [
            'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
            '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'
          ],
          [
            '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
            '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'
          ],
          [
            '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
            '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'
          ],
          [
            '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
            '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'
          ],
          [
            '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
            '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'
          ],
          [
            '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
            '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'
          ],
          [
            '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
            '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'
          ],
          [
            '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
            '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'
          ],
          [
            '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
            'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'
          ],
          [
            'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
            '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'
          ],
          [
            'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
            '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'
          ],
          [
            '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
            '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'
          ],
          [
            '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
            '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'
          ],
          [
            'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
            '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'
          ],
          [
            '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
            'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'
          ],
          [
            'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
            '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'
          ],
          [
            'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
            'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'
          ],
          [
            'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
            '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'
          ],
          [
            'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
            'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'
          ],
          [
            'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
            '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'
          ],
          [
            '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
            'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'
          ],
          [
            '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
            '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'
          ],
          [
            'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
            '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'
          ],
          [
            '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
            'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'
          ],
          [
            'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
            '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'
          ],
          [
            'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
            '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'
          ],
          [
            'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
            'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'
          ],
          [
            '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
            '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'
          ],
          [
            '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
            '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'
          ],
          [
            '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
            'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'
          ],
          [
            '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
            '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'
          ],
          [
            'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
            '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'
          ],
          [
            '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
            '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'
          ],
          [
            '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
            'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'
          ],
          [
            '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
            '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'
          ],
          [
            'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
            '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'
          ],
          [
            '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
            'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'
          ],
          [
            'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
            'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'
          ],
          [
            'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
            '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'
          ],
          [
            '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
            'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'
          ],
          [
            '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
            'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'
          ],
          [
            'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
            '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'
          ],
          [
            'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
            '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'
          ],
          [
            'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
            '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'
          ],
          [
            '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
            'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'
          ],
          [
            '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
            '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'
          ],
          [
            'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
            'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'
          ],
          [
            '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
            'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'
          ],
          [
            '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
            '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'
          ],
          [
            '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
            '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'
          ],
          [
            'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
            'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'
          ],
          [
            '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
            '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'
          ],
          [
            '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
            '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'
          ],
          [
            'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
            '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'
          ],
          [
            'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
            'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82'
          ]
        ]
      },
      'naf': {
        'wnd': 7,
        'points': [
          [
            'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
            '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'
          ],
          [
            '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
            'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'
          ],
          [
            '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
            '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'
          ],
          [
            'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
            'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'
          ],
          [
            '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
            'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'
          ],
          [
            'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
            'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'
          ],
          [
            'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
            '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'
          ],
          [
            'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
            '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'
          ],
          [
            '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
            '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'
          ],
          [
            '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
            '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'
          ],
          [
            '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
            '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'
          ],
          [
            '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
            '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'
          ],
          [
            'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
            'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'
          ],
          [
            'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
            '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'
          ],
          [
            '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
            'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'
          ],
          [
            '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
            'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'
          ],
          [
            '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
            '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'
          ],
          [
            '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
            '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'
          ],
          [
            '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
            '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'
          ],
          [
            '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
            'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'
          ],
          [
            'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
            'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'
          ],
          [
            '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
            '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'
          ],
          [
            '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
            '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'
          ],
          [
            'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
            'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'
          ],
          [
            '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
            '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'
          ],
          [
            'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
            'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'
          ],
          [
            'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
            'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'
          ],
          [
            '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
            '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'
          ],
          [
            '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
            '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'
          ],
          [
            '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
            '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'
          ],
          [
            'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
            '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'
          ],
          [
            '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
            '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'
          ],
          [
            'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
            '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'
          ],
          [
            '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
            'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'
          ],
          [
            '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
            'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'
          ],
          [
            'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
            'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'
          ],
          [
            '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
            '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'
          ],
          [
            '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
            'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'
          ],
          [
            'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
            'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'
          ],
          [
            '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
            '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'
          ],
          [
            '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
            'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'
          ],
          [
            '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
            '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'
          ],
          [
            '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
            'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'
          ],
          [
            'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
            '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'
          ],
          [
            '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
            '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'
          ],
          [
            '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
            'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'
          ],
          [
            '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
            'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'
          ],
          [
            'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
            'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'
          ],
          [
            'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
            'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'
          ],
          [
            '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
            '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'
          ],
          [
            '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
            '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'
          ],
          [
            'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
            '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'
          ],
          [
            'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
            'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'
          ],
          [
            '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
            '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'
          ],
          [
            '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
            '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'
          ],
          [
            'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
            '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'
          ],
          [
            '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
            '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'
          ],
          [
            'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
            'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'
          ],
          [
            '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
            'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'
          ],
          [
            '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
            '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'
          ],
          [
            'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
            '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'
          ],
          [
            'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
            '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'
          ],
          [
            '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
            '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'
          ],
          [
            '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
            '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'
          ],
          [
            '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
            'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'
          ],
          [
            '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
            'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'
          ],
          [
            '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
            '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'
          ],
          [
            '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
            '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'
          ],
          [
            '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
            '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'
          ],
          [
            '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
            'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'
          ],
          [
            'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
            'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'
          ],
          [
            '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
            'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'
          ],
          [
            'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
            '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'
          ],
          [
            'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
            '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'
          ],
          [
            'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
            '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'
          ],
          [
            'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
            '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'
          ],
          [
            '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
            'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'
          ],
          [
            '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
            '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'
          ],
          [
            '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
            'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'
          ],
          [
            'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
            'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'
          ],
          [
            'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
            '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'
          ],
          [
            'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
            'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'
          ],
          [
            'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
            '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'
          ],
          [
            '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
            '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'
          ],
          [
            'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
            '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'
          ],
          [
            'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
            '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'
          ],
          [
            '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
            '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'
          ],
          [
            '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
            'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'
          ],
          [
            'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
            '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'
          ],
          [
            'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
            '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'
          ],
          [
            'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
            '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'
          ],
          [
            '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
            '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'
          ],
          [
            'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
            'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'
          ],
          [
            '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
            'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'
          ],
          [
            'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
            'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'
          ],
          [
            'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
            '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'
          ],
          [
            '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
            'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'
          ],
          [
            'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
            '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'
          ],
          [
            'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
            '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'
          ],
          [
            'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
            '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'
          ],
          [
            '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
            'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'
          ],
          [
            '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
            'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'
          ],
          [
            'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
            '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'
          ],
          [
            '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
            'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'
          ],
          [
            '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
            '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'
          ],
          [
            '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
            'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'
          ],
          [
            'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
            'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'
          ],
          [
            '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
            'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'
          ],
          [
            '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
            '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'
          ],
          [
            '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
            'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'
          ],
          [
            '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
            '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'
          ],
          [
            'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
            'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'
          ],
          [
            '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
            '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'
          ],
          [
            'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
            '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'
          ],
          [
            '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
            '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'
          ],
          [
            'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
            'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'
          ],
          [
            'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
            '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'
          ],
          [
            'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
            'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'
          ],
          [
            '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
            'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'
          ],
          [
            '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
            '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'
          ],
          [
            '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
            'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'
          ],
          [
            '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
            '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'
          ],
          [
            '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
            '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'
          ],
          [
            '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
            'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'
          ],
          [
            '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
            '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'
          ],
          [
            '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
            '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'
          ],
          [
            '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
            '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9'
          ]
        ]
      }
    }
  ]
});

},{"../elliptic":32,"bn.js":30,"hash.js":45}],39:[function(require,module,exports){
var bn = require('bn.js');
var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(elliptic.curves.hasOwnProperty(options), 'Unknown curve ' + options);

    options = elliptic.curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof elliptic.curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.shrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(priv, pub) {
  return new KeyPair(this, priv, pub);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    pers: options.pers,
    entropy: options.entropy || elliptic.rand(this.hash.hmacStrength),
    nonce: this.n.toArray()
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn(2));
  do {
    var priv = new bn(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyPair(priv);
  } while (true);
};

EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.shrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, options) {
  key = this.keyPair(key, 'hex');
  msg = this._truncateToN(new bn(msg, 16));
  if (!options)
    options = {};

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray();
  for (var i = bkey.length; i < 21; i++)
    bkey.unshift(0);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray();
  for (var i = nonce.length; i < bytes; i++)
    nonce.unshift(0);

  // Instantiate Hmac_DRBG
  var drbg = new elliptic.hmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn(1));
  do {
    var k = new bn(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var r = kp.getX().mod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg)).mod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0)
      s = this.n.sub(s);

    return new Signature(r, s);
  } while (true);
};

EC.prototype.verify = function verify(msg, signature, key) {
  msg = this._truncateToN(new bn(msg, 16));
  key = this.keyPair(key, 'hex');
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).mod(this.n);
  var u2 = sinv.mul(r).mod(this.n);

  var p = this.g.mulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  return p.getX().mod(this.n).cmp(r) === 0;
};

},{"../../elliptic":32,"./key":40,"./signature":41,"bn.js":30}],40:[function(require,module,exports){
var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function KeyPair(ec, priv, pub) {
  if (priv instanceof KeyPair)
    return priv;
  if (pub instanceof KeyPair)
    return pub;

  if (!priv) {
    priv = pub;
    pub = null;
  }
  if (priv !== null && typeof priv === 'object') {
    if (priv.x) {
      // KeyPair(public)
      pub = priv;
      priv = null;
    } else if (priv.priv || priv.pub) {
      // KeyPair({ priv: ..., pub: ... })
      pub = priv.pub;
      priv = priv.priv;
    }
  }

  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(public, 'hex')
  if (this._importPublicHex(priv, pub))
    return;

  if (pub === 'hex')
    pub = null;

  // KeyPair(priv, pub)
  if (priv)
    this._importPrivate(priv);
  if (pub)
    this._importPublic(pub);
}
module.exports = KeyPair;

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!enc)
    return this.pub;

  var len = this.ec.curve.p.byteLength();
  var x = this.pub.getX().toArray();

  for (var i = x.length; i < len; i++)
    x.unshift(0);

  if (compact) {
    var res = [ this.pub.getY().isEven() ? 0x02 : 0x03 ].concat(x);
  } else {
    var y = this.pub.getY().toArray();
    for (var i = y.length; i < len; i++)
      y.unshift(0);
    var res = [ 0x04 ].concat(x, y);
  }
  return utils.encode(res, enc);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key) {
  this.priv = new bn(key, 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.mod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key) {
  this.pub = this.ec.curve.point(key.x, key.y);
};

KeyPair.prototype._importPublicHex = function _importPublic(key, enc) {
  key = utils.toArray(key, enc);
  var len = this.ec.curve.p.byteLength();
  if (key[0] === 0x04 && key.length - 1 === 2 * len) {
    this.pub = this.ec.curve.point(
      key.slice(1, 1 + len),
      key.slice(1 + len, 1 + 2 * len));
  } else if ((key[0] === 0x02 || key[0] === 0x03) && key.length - 1 === len) {
    this.pub = this.ec.curve.pointFromX(key[0] === 0x03,
                                        key.slice(1, 1 +len));
  } else {
    return false;
  }

  return true;
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg) {
  return this.ec.sign(msg, this);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../../elliptic":32,"bn.js":30}],41:[function(require,module,exports){
var bn = require('bn.js');

var elliptic = require('../../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function Signature(r, s) {
  if (r instanceof Signature)
    return r;

  if (this._importDER(r, s))
    return;

  assert(r && s, 'Signature without r or s');
  this.r = new bn(r, 16);
  this.s = new bn(s, 16);
}
module.exports = Signature;

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  if (data.length < 6 || data[0] !== 0x30 || data[2] !== 0x02)
    return false;
  var total = data[1];
  if (1 + total > data.length)
    return false;
  var rlen = data[3];
  // Short length notation
  if (rlen >= 0x80)
    return false;
  if (4 + rlen + 2 >= data.length)
    return false;
  if (data[4 + rlen] !== 0x02)
    return false;
  var slen = data[5 + rlen];
  // Short length notation
  if (slen >= 0x80)
    return false;
  if (4 + rlen + 2 + slen > data.length)
    return false;

  this.r = new bn(data.slice(4, 4 + rlen));
  this.s = new bn(data.slice(4 + rlen + 2, 4 + rlen + 2 + slen));

  return true;
};

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  var total = r.length + s.length + 4;
  var res = [ 0x30, total, 0x02, r.length ];
  res = res.concat(r, [ 0x02, s.length ], s);
  return utils.encode(res, enc);
};

},{"../../elliptic":32,"bn.js":30}],42:[function(require,module,exports){
var hash = require('hash.js');
var elliptic = require('../elliptic');
var utils = elliptic.utils;
var assert = utils.assert;

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this.reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc);
  var nonce = utils.toArray(options.nonce, options.nonceEnc);
  var pers = utils.toArray(options.pers, options.persEnc);
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this.reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toBuffer(entropy, entropyEnc);
  add = utils.toBuffer(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this.reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this.reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc);
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this.reseed++;
  return utils.encode(res, enc);
};

},{"../elliptic":32,"hash.js":45}],43:[function(require,module,exports){
var bn = require('bn.js');

var utils = exports;

utils.assert = function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
};

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

// Represent num in a w-NAF form
function getNAF(num, w) {
  var naf = [];
  var ws = 1 << (w + 1);
  var k = num.clone();
  while (k.cmpn(1) >= 0) {
    var z;
    if (k.isOdd()) {
      var mod = k.andln(ws - 1);
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }
    naf.push(z);

    // Optimization, shift by word if possible
    var shift = (k.cmpn(0) !== 0 && k.andln(ws - 1) === 0) ? (w + 1) : 1;
    for (var i = 1; i < shift; i++)
      naf.push(0);
    k.ishrn(shift);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    []
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {

    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      var m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      var m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.ishrn(1);
    k2.ishrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

},{"bn.js":30}],44:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

if (typeof window === 'object') {
  if (window.crypto && window.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (window.msCrypto && window.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      window.msCrypto.getRandomValues(arr);
      return arr;
    };
  } else {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker
  try {
    var crypto = require('cry' + 'pto');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
    // Emulate crypto API using randy
    Rand.prototype._rand = function _rand(n) {
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
  }
}

},{}],45:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":46,"./hash/hmac":47,"./hash/ripemd":48,"./hash/sha":49,"./hash/utils":50}],46:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"../hash":45}],47:[function(require,module,exports){
var hmac = exports;

var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (var i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"../hash":45}],48:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = hash.common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13,
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6,
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"../hash":45}],49:[function(require,module,exports){
var hash = require('../hash');
var utils = hash.utils;
var assert = utils.assert;

var rotr32 = utils.rotr32;
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = hash.common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
             0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
exports.sha256 = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [ 0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
             0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
exports.sha224 = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [ 0x6a09e667, 0xf3bcc908,
             0xbb67ae85, 0x84caa73b,
             0x3c6ef372, 0xfe94f82b,
             0xa54ff53a, 0x5f1d36f1,
             0x510e527f, 0xade682d1,
             0x9b05688c, 0x2b3e6c1f,
             0x1f83d9ab, 0xfb41bd6b,
             0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
exports.sha512 = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(c0_hi, c0_lo,
                      c1_hi, c1_lo,
                      c2_hi, c2_lo,
                      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo,
                          c1_hi, c1_lo,
                          c2_hi, c2_lo,
                          c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo,
                           c1_hi, c1_lo,
                           c2_hi, c2_lo,
                           c3_hi, c3_lo,
                           c4_hi, c4_lo);

    var c0_hi = s0_512_hi(ah, al);
    var c0_lo = s0_512_lo(ah, al);
    var c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    var c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [ 0xcbbb9d5d, 0xc1059ed8,
             0x629a292a, 0x367cd507,
             0x9159015a, 0x3070dd17,
             0x152fecd8, 0xf70e5939,
             0x67332667, 0xffc00b31,
             0x8eb44a87, 0x68581511,
             0xdb0c2e0d, 0x64f98fa7,
             0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
exports.sha384 = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe,
             0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
exports.sha1 = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (var i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}

function p32(x, y, z) {
  return x ^ y ^ z;
}

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}

function ch64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh, zl) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../hash":45}],50:[function(require,module,exports){
var utils = exports;
var inherits = require('inherits');

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
utils.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
utils.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
utils.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
utils.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
utils.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
utils.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
utils.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
utils.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
utils.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
utils.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
utils.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
utils.sum32_5 = sum32_5;

function assert(cond, msg) {
  if (!cond)
    throw new Error(msg || 'Assertion failed');
}
utils.assert = assert;

utils.inherits = inherits;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
};
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
};
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
};
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
};
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
};
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
};
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
};
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
};
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
};
exports.shr64_lo = shr64_lo;

},{"inherits":146}],51:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "1.0.1",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "scripts": {
    "test": "mocha --reporter=spec test/*-test.js"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": {
    "name": "Fedor Indutny",
    "email": "fedor@indutny.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "browserify": "^3.44.2",
    "mocha": "^1.18.2",
    "uglify-js": "^2.4.13"
  },
  "dependencies": {
    "bn.js": "^1.0.0",
    "brorand": "^1.0.1",
    "hash.js": "^1.0.0",
    "inherits": "^2.0.1"
  },
  "readme": "# Elliptic [![Build Status](https://secure.travis-ci.org/indutny/elliptic.png)](http://travis-ci.org/indutny/elliptic)\n\nFast elliptic-curve cryptography in a plain javascript implementation.\n\nNOTE: Please take a look at http://safecurves.cr.yp.to/ before choosing a curve\nfor your cryptography operations.\n\n## Incentive\n\nECC is much slower than regular RSA cryptography, the JS implementations are\neven more slower.\n\n## Benchmarks\n\n```bash\n$ node benchmarks/index.js\nBenchmarking: sign\nelliptic#sign x 262 ops/sec ±0.51% (177 runs sampled)\neccjs#sign x 55.91 ops/sec ±0.90% (144 runs sampled)\n------------------------\nFastest is elliptic#sign\n========================\nBenchmarking: verify\nelliptic#verify x 113 ops/sec ±0.50% (166 runs sampled)\neccjs#verify x 48.56 ops/sec ±0.36% (125 runs sampled)\n------------------------\nFastest is elliptic#verify\n========================\nBenchmarking: gen\nelliptic#gen x 294 ops/sec ±0.43% (176 runs sampled)\neccjs#gen x 62.25 ops/sec ±0.63% (129 runs sampled)\n------------------------\nFastest is elliptic#gen\n========================\nBenchmarking: ecdh\nelliptic#ecdh x 136 ops/sec ±0.85% (156 runs sampled)\n------------------------\nFastest is elliptic#ecdh\n========================\n```\n\n## API\n\n### ECDSA\n\n```javascript\nvar EC = require('elliptic').ec;\n\n// Create and initialize EC context\n// (better do it once and reuse it)\nvar ec = new EC('secp256k1');\n\n// Generate keys\nvar key = ec.genKeyPair();\n\n// Sign message (must be an array, or it'll be treated as a hex sequence)\nvar msg = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ];\nvar signature = key.sign(msg);\n\n// Export DER encoded signature in Array\nvar derSign = signature.toDER();\n\n// Verify signature\nconsole.log(key.verify(msg, derSign));\n```\n\n### ECDH\n\n```javascript\n// Generate keys\nvar key1 = ec.genKeyPair();\nvar key2 = ec.genKeyPair();\n\nvar shared1 = key1.derive(key2.getPublic());\nvar shared2 = key2.derive(key1.getPublic());\n\nconsole.log('Both shared secrets are BN instances');\nconsole.log(shared1.toString(16));\nconsole.log(shared2.toString(16));\n```\n\nNOTE: `.derive()` returns a [BN][1] instance.\n\n## Supported curves\n\nElliptic.js support following curve types:\n\n* Short Weierstrass\n* Montgomery\n* Edwards\n* Twisted Edwards\n\nFollowing curve 'presets' are embedded into the library:\n\n* `secp256k1`\n* `p192`\n* `p224`\n* `p256`\n* `curve25519`\n* `ed25519`\n\nNOTE: That `curve25519` could not be used for ECDSA, use `ed25519` instead.\n\n### Implementation details\n\nECDSA is using deterministic `k` value generation as per [RFC6979][0]. Most of\nthe curve operations are performed on non-affine coordinates (either projective\nor extended), various windowing techniques are used for different cases.\n\nAll operations are performed in reduction context using [bn.js][1], hashing is\nprovided by [hash.js][2]\n\n#### LICENSE\n\nThis software is licensed under the MIT License.\n\nCopyright Fedor Indutny, 2014.\n\nPermission is hereby granted, free of charge, to any person obtaining a\ncopy of this software and associated documentation files (the\n\"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to permit\npersons to whom the Software is furnished to do so, subject to the\nfollowing conditions:\n\nThe above copyright notice and this permission notice shall be included\nin all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\nOR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\nDAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\nOTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\nUSE OR OTHER DEALINGS IN THE SOFTWARE.\n\n[0]: http://tools.ietf.org/html/rfc6979\n[1]: https://github.com/indutny/bn.js\n[2]: https://github.com/indutny/hash.js\n",
  "readmeFilename": "README.md",
  "_id": "elliptic@1.0.1",
  "_from": "elliptic@^1.0.0"
}

},{}],52:[function(require,module,exports){
(function (Buffer){

module.exports = function evp(crypto, password, salt, keyLen) {
  keyLen = keyLen/8;
  var ki = 0;
  var ii = 0;
  var key = new Buffer(keyLen);
  var addmd = 0;
  var md, md_buf;
  var i;
  while (true) {
    md = crypto.createHash('md5');
    if(addmd++ > 0) {
       md.update(md_buf);
    }
    md.update(password);
    md.update(salt);
    md_buf = md.digest();
    i = 0;
    if(keyLen > 0) {
      while(true) {
        if(keyLen === 0) {
          break;
        }
        if(i === md_buf.length) {
          break;
        }
        key[ki++] = md_buf[i++];
        keyLen--;
       }
    }
   if(keyLen === 0) {
      break;
    }
  }
  for(i=0;i<md_buf.length;i++) {
    md_buf[i] = 0;
  }
  return key;
};
}).call(this,require("buffer").Buffer)
},{"buffer":5}],53:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],54:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.

var asn1 = require('asn1.js');
var rfc3280 = require('asn1.js-rfc3280');

var RSAPrivateKey = asn1.define('RSAPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  );
});
exports.RSAPrivateKey = RSAPrivateKey;

var RSAPublicKey = asn1.define('RSAPublicKey', function() {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  );
});
exports.RSAPublicKey = RSAPublicKey;

var PublicKey = rfc3280.SubjectPublicKeyInfo;
exports.PublicKey = PublicKey;
var ECPublicKey =  asn1.define('ECPublicKey', function() {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('curve').objid()
    ),
    this.key('subjectPrivateKey').bitstr()
  );
});
exports.ECPublicKey = ECPublicKey;
var ECPrivateWrap =  asn1.define('ECPrivateWrap', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('curve').objid()
    ),
    this.key('subjectPrivateKey').octstr()
  );
});
exports.ECPrivateWrap = ECPrivateWrap;

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(rfc3280.AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  );
});
exports.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function() {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  );
});
var dsaParams = asn1.define('dsaParams', function() {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').seq().obj(
        this.key('p').int(),
        this.key('q').int(),
        this.key('g').int()
      )
  );
});
exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPublicKey = asn1.define('DSAPublicKey', function() {
  this.seq().obj(
    this.key('algorithm').use(dsaParams),
    this.key('subjectPublicKey').bitstr()
  );
});
exports.DSAPublicKey = DSAPublicKey;
var DSAPrivateWrap =  asn1.define('DSAPrivateWrap', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('parameters').seq().obj(
        this.key('p').int(),
        this.key('q').int(),
        this.key('g').int()
      )
    ),
    this.key('subjectPrivateKey').octstr()
  );
});
exports.DSAPrivateWrap = DSAPrivateWrap;
var DSAPrivateKey = asn1.define('DSAPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  );
});
exports.DSAPrivateKey = DSAPrivateKey;

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int();
});
var ECPrivateKey = asn1.define('ECPrivateKey', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  );
});
exports.ECPrivateKey = ECPrivateKey;
var ECParameters = asn1.define('ECParameters', function() {
  this.choice({
    namedCurve: this.objid()
  });
});

var ECPrivateKey2 = asn1.define('ECPrivateKey2', function() {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('publicKey').seq().obj(
      this.key('key').bitstr()
    )
  );
});
exports.ECPrivateKey2 = ECPrivateKey2;

exports.signature = asn1.define('signature', function() {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  );
});
},{"asn1.js":58,"asn1.js-rfc3280":57}],55:[function(require,module,exports){
(function (Buffer){
var findProc = /Proc-Type: 4,ENCRYPTED\n\r?DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)\n\r?\n\r?([0-9A-z\n\r\+\/\=]+)\n\r?/m;
var startRegex = /^-----BEGIN (.*)-----\n/;
var evp = require('./EVP_BytesToKey');
module.exports = function (okey, password, crypto) {
  var key = okey.toString();
  var match = key.match(findProc);
  if (!match) {
    return okey;
  }
  var suite = 'aes' + match[1];
  var iv = new Buffer(match[2], 'hex');
  var cipherText = new Buffer(match[3].replace(/\n\r?/g, ''), 'base64');
  var cipherKey = evp(crypto, password, iv.slice(0,8), parseInt(match[1]));
  var out = [];
  var cipher = crypto.createDecipheriv(suite, cipherKey, iv);
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  var decrypted = Buffer.concat(out).toString('base64');
  var tag = key.match(startRegex)[1];
  return '-----BEGIN ' + tag + "-----\n" + wrap(decrypted) + "\n" + '-----END ' + tag + "-----\n";
};
// http://stackoverflow.com/a/7033705
function wrap(str) {
  var chunks = [];
  while (str) {
    if (str.length < 64) {
      chunks.push(str);
      break;
    }
    else {
      chunks.push(str.slice(0, 64));
      str = str.slice(64);
    }
  }
  return chunks.join("\n");
}
}).call(this,require("buffer").Buffer)
},{"./EVP_BytesToKey":52,"buffer":5}],56:[function(require,module,exports){
(function (Buffer){
var pemstrip = require('pemstrip');
var asn1 = require('./asn1');
var aesid = require('./aesid.json');
var fixProc = require('./fixProc');
module.exports = parseKeys;

function parseKeys(buffer, crypto) {
  var password;
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase;
    buffer = buffer.key;
  }
  if (typeof buffer === 'string') {
    buffer = new Buffer(buffer);
  }
  if (password) {
    buffer = fixProc(buffer, password, crypto);
  }
  var stripped = pemstrip.strip(buffer);
  var type = stripped.tag;
  var data = new Buffer(stripped.base64, 'base64');
  var subtype,ndata;
  switch (type) {
    case 'PUBLIC KEY':
      ndata = asn1.PublicKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
        case '1.2.840.10045.2.1':
          return {
            type: 'ec',
            data:  asn1.ECPublicKey.decode(data, 'der')
          };
        case '1.2.840.10040.4.1':
          ndata = asn1.DSAPublicKey.decode(data, 'der');
          ndata.algorithm.parameters.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
          return {
            type: 'dsa',
            data: ndata.algorithm.parameters
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der');
      data = decrypt(crypto, data, password);
      //falling through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der');
      subtype = ndata.algorithm.algorithm.join('.');
      switch(subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
        case '1.2.840.10045.2.1':
          ndata =  asn1.ECPrivateWrap.decode(data, 'der');
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          };
        case '1.2.840.10040.4.1':
          ndata =  asn1.DSAPrivateWrap.decode(data, 'der');
          ndata.algorithm.parameters.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
          return {
            type: 'dsa',
            params: ndata.algorithm.parameters
          };
        default: throw new Error('unknown key id ' +  subtype);
      }
      throw new Error('unknown key type ' +  type);
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der');
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der');
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      };
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der');
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      };
    default: throw new Error('unknown key type ' +  type);
  }
}
parseKeys.signature = asn1.signature;
function decrypt(crypto, data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt;
  var iters = data.algorithm.decrypt.kde.kdeparams.iters;
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
  var iv = data.algorithm.decrypt.cipher.iv;
  var cipherText = data.subjectPrivateKey;
  var keylen = parseInt(algo.split('-')[1], 10)/8;
  var key = crypto.pbkdf2Sync(password, salt, iters, keylen);
  var cipher = crypto.createDecipheriv(algo, key, iv);
  var out = [];
  out.push(cipher.update(cipherText));
  out.push(cipher.final());
  return Buffer.concat(out);
}
}).call(this,require("buffer").Buffer)
},{"./aesid.json":53,"./asn1":54,"./fixProc":55,"buffer":5,"pemstrip":71}],57:[function(require,module,exports){
try {
  var asn1 = require('asn1.js');
} catch (e) {
  var asn1 = require('../' + '..');
}

var CRLReason = asn1.define('CRLReason', function() {
  this.enum({
    0: 'unspecified',
    1: 'keyCompromise',
    2: 'CACompromise',
    3: 'affiliationChanged',
    4: 'superseded',
    5: 'cessationOfOperation',
    6: 'certificateHold',
    8: 'removeFromCRL',
    9: 'privilegeWithdrawn',
    10: 'AACompromise'
  });
});
exports.CRLReason = CRLReason;

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function() {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional().any()
  );
});
exports.AlgorithmIdentifier = AlgorithmIdentifier;

var Certificate = asn1.define('Certificate', function() {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signature').bitstr()
  );
});
exports.Certificate = Certificate;

var TBSCertificate = asn1.define('TBSCertificate', function() {
  this.seq().obj(
    this.key('version').def('v1').explicit(0).use(Version),
    this.key('serialNumber').use(CertificateSerialNumber),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),

    // TODO(indutny): validate that version is v2 or v3
    this.key('issuerUniqueID').optional().explicit(1).use(UniqueIdentifier),
    this.key('subjectUniqueID').optional().explicit(2).use(UniqueIdentifier),

    // TODO(indutny): validate that version is v3
    this.key('extensions').optional().explicit(3).use(Extensions)
  );
});
exports.TBSCertificate = TBSCertificate;

var Version = asn1.define('Version', function() {
  this.int({
    0: 'v1',
    1: 'v2',
    2: 'v3'
  });
});
exports.Version = Version;

var CertificateSerialNumber = asn1.define('CertificateSerialNumber',
                                          function() {
  this.int();
});
exports.CertificateSerialNumber = CertificateSerialNumber;

var Validity = asn1.define('Validity', function() {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  );
});
exports.Validity = Validity;

var Time = asn1.define('Time', function() {
  this.choice({
    utcTime: this.utctime(),
    genTime: this.gentime()
  });
});
exports.Time = Time;

var UniqueIdentifier = asn1.define('UniqueIdentifier', function() {
  this.bitstr();
});
exports.UniqueIdentifier = UniqueIdentifier;

var SubjectPublicKeyInfo = asn1.define('SubjectPublicKeyInfo', function() {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  );
});
exports.SubjectPublicKeyInfo = SubjectPublicKeyInfo;

var Extensions = asn1.define('Extensions', function() {
  this.seqof(Extension);
});
exports.Extensions = Extensions;

var Extension = asn1.define('Extension', function() {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  );
});
exports.Extension = Extension;

var Name = asn1.define('Name', function() {
  this.choice({
    rdn: this.use(RDNSequence)
  });
});
exports.Name = Name;

var RDNSequence = asn1.define('RDNSequence', function() {
  this.seqof(RelativeDistinguishedName);
});
exports.RDNSequence = RDNSequence;

var RelativeDistinguishedName = asn1.define('RelativeDistinguishedName',
                                            function() {
  this.setof(AttributeTypeAndValue);
});
exports.RelativeDistinguishedName = RelativeDistinguishedName;

var AttributeTypeAndValue = asn1.define('AttributeTypeAndValue', function() {
  this.seq().obj(
    this.key('type').use(AttributeType),
    this.key('value').use(AttributeValue)
  );
});
exports.AttributeTypeAndValue = AttributeTypeAndValue;

var AttributeType = asn1.define('AttributeType', function() {
  this.objid();
});
exports.AttributeType = AttributeType;

var AttributeValue = asn1.define('AttributeValue', function() {
  this.any();
});
exports.AttributeValue = AttributeValue;

},{"asn1.js":58}],58:[function(require,module,exports){
var asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":59,"./asn1/base":61,"./asn1/constants":65,"./asn1/decoders":67,"./asn1/encoders":69,"bn.js":30}],59:[function(require,module,exports){
var asn1 = require('../asn1');
var inherits = require('inherits');
var vm = require('vm');

var api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
};

Entity.prototype._createNamed = function createNamed(base) {
  var named = vm.runInThisContext('(function ' + this.name + '(entity) {\n' +
    '  this._initNamed(entity);\n' +
    '})');
  inherits(named, base);
  named.prototype._initNamed = function initnamed(entity) {
    base.call(this, entity);
  };

  return new named(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"../asn1":58,"inherits":146,"vm":166}],60:[function(require,module,exports){
var inherits = require('inherits');
var Reporter = require('../base').Reporter;
var Buffer = require('buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  var res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
}

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  var res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
}

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
}

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!(item instanceof EncoderBuffer))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = new Buffer(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base":61,"buffer":5,"inherits":146}],61:[function(require,module,exports){
var base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":60,"./node":62,"./reporter":63}],62:[function(require,module,exports){
var Reporter = require('../base').Reporter;
var EncoderBuffer = require('../base').EncoderBuffer;
var assert = require('minimalistic-assert');

// Supported tags
var tags = [
  'seq', 'seqof', 'set', 'setof', 'octstr', 'bitstr', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'ia5str'
];

// Public methods list
var methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any'
].concat(tags);

// Overrided methods list
var overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent) {
  var state = {};
  this._baseState = state;

  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

var stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit'
];

Node.prototype.clone = function clone() {
  var state = this._baseState;
  var cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  var res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  var state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      var clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  var state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  var state = this._baseState;

  // Filter children and args
  var children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      var res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        var value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    var state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    var state = this._baseState;
    var args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  var state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  var state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  var state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  var state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  var state = this._baseState;
  var args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  var state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  var state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  var state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input));

  var result = state['default'];
  var present = true;

  var prevKey;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    present = this._peekTag(
      input,
      state.explicit !== null ? state.explicit :
          state.implicit !== null ? state.implicit :
              state.tag || 0
    );
    if (input.isError(present))
      return present;
  }

  // Push object on stack
  var prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      var explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      if (state.any)
        var save = input.save();
      var body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    // Select proper method for tag
    if (state.any)
      result = result;
    else if (state.choice === null)
      result = this._decodeGeneric(state.tag, input);
    else
      result = this._decodeChoice(input);

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      var fail = state.children.some(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input);
      });
      if (fail)
        return err;
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input) {
  var state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0]);
  else if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._decodeStr(input, tag);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1]);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag);
  else if (tag === 'null_')
    return this._decodeNull(input);
  else if (tag === 'bool')
    return this._decodeBool(input);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0]);
  else if (state.use !== null)
    return this._getUse(state.use, input._reporterState.obj)._decode(input);
  else
    return input.error('unknown tag: ' + tag);

  return null;
};

Node.prototype._getUse = function _getUse(entity, obj) {

  var state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input) {
  var state = this._baseState;
  var result = null;
  var match = false;

  Object.keys(state.choice).some(function(key) {
    var save = input.save();
    var node = state.choice[key];
    try {
      var value = node._decode(input);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  var state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  var result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  var state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  var result = null;
  var present = true;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default']
    else
      return;
  }

  // For error reporting
  var prevKey;

  // Encode children first
  var content = null;
  var primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      var prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      var res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });

    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      var child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        var state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  var result;
  if (!state.any && state.choice === null) {
    var tag = state.implicit !== null ? state.implicit : state.tag;
    var cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be ommited only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  var state = this._baseState;

  var node = state.choice[data.type];
  if (!node) {
    assert(
        false,
        data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  var state = this._baseState;

  if (tag === 'octstr' || tag === 'bitstr' || tag === 'ia5str')
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else
    throw new Error('Unsupported tag: ' + tag);
};

},{"../base":61,"minimalistic-assert":70}],63:[function(require,module,exports){
var inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  var state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.enterObject = function enterObject() {
  var state = this._reporterState;

  var prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  var state = this._reporterState;

  var now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  var err;
  var state = this._reporterState;

  var inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  var state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
};
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  Error.captureStackTrace(this, ReporterError);

  return this;
};

},{"inherits":146}],64:[function(require,module,exports){
var constants = require('../constants');

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = constants._reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = constants._reverse(exports.tag);

},{"../constants":65}],65:[function(require,module,exports){
var constants = exports;

// Helper
constants._reverse = function reverse(map) {
  var res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    var value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":64}],66:[function(require,module,exports){
var inherits = require('inherits');

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!(data instanceof base.DecoderBuffer))
    data = new base.DecoderBuffer(data, options);

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag) {
  if (buffer.isEmpty())
    return false;

  var state = buffer.save();
  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  var decodedTag = derDecodeTag(buffer,
                                'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  var len = derDecodeLen(buffer,
                         decodedTag.primitive,
                         'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  var state = buffer.start();
  var res = this._skipUntilEnd(
      buffer,
      'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  return buffer.cut(state);
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  while (true) {
    var tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    var len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    var res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len)
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder) {
  var result = [];
  while (!buffer.isEmpty()) {
    var possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    var res = decoder.decode(buffer, 'der');
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'bitstr') {
    var unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;

    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'ia5str') {
    return buffer.raw().toString();
  } else {
    return this.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  var identifiers = [];
  var ident = 0;
  while (!buffer.isEmpty()) {
    var subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  var first = (identifiers[0] / 40) | 0;
  var second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values)
    result = values[result.join(' ')];

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  var str = buffer.raw().toString();
  if (tag === 'gentime') {
    var year = str.slice(0, 4) | 0;
    var mon = str.slice(4, 6) | 0;
    var day = str.slice(6, 8) | 0;
    var hour = str.slice(8, 10) | 0;
    var min = str.slice(10, 12) | 0;
    var sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    var year = str.slice(0, 2) | 0;
    var mon = str.slice(2, 4) | 0;
    var day = str.slice(4, 6) | 0;
    var hour = str.slice(6, 8) | 0;
    var min = str.slice(8, 10) | 0;
    var sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return this.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull(buffer) {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  var res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  var res = 0;

  // Bigint, return as it is (assume big endian)
  var raw = buffer.raw();
  if (raw.length > 3)
    return new bignum(raw);

  while (!buffer.isEmpty()) {
    res <<= 8;
    var i = buffer.readUInt8();
    if (buffer.isError(i))
      return i;
    res |= i;
  }

  if (values)
    res = values[res] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  var tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  var cls = der.tagClass[tag >> 6];
  var primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    var oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  var tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  var len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  var num = len & 0x7f;
  if (num >= 4)
    return buf.error('length octect is too long');

  len = 0;
  for (var i = 0; i < num; i++) {
    len <<= 8;
    var j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../../asn1":58,"inherits":146}],67:[function(require,module,exports){
var decoders = exports;

decoders.der = require('./der');

},{"./der":66}],68:[function(require,module,exports){
var inherits = require('inherits');
var Buffer = require('buffer').Buffer;

var asn1 = require('../../asn1');
var base = asn1.base;
var bignum = asn1.bignum;

// Import DER constants
var der = asn1.constants.der;

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
};
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  base.Node.call(this, 'der', parent);
}
inherits(DERNode, base.Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
                                                              primitive,
                                                              cls,
                                                              content) {
  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    var header = new Buffer(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  var lenOctets = 1;
  for (var i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  var header = new Buffer(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'octstr')
    return this._createEncoderBuffer(str);
  else if (tag === 'bitstr')
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  else if (tag === 'ia5str')
    return this._createEncoderBuffer(str);
  return this.reporter.error('Encoding of string type: ' + tag +
                             ' unsupported');
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/\s+/g);
    for (var i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  var size = 0;
  for (var i = 0; i < id.length; i++) {
    var ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  var objid = new Buffer(size);
  var offset = objid.length - 1;
  for (var i = id.length - 1; i >= 0; i--) {
    var ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num <= 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  var str;
  var date = new Date(time);

  if (tag === 'gentime') {
    str = [
      date.getFullYear(),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      date.getFullYear() % 100,
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (bignum !== null && num instanceof bignum) {
    var numArray = num.toArray();
    if(num.sign === false && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = new Buffer(numArray);
  }

  if (Buffer.isBuffer(num)) {
    var size = num.length;
    if (num.length === 0)
      size++;

    var out = new Buffer(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  var size = 1;
  for (var i = num; i >= 0x100; i >>= 8)
    size++;

  var out = new Array(size);
  for (var i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(new Buffer(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  var state = this._baseState;
  var i;
  if (state['default'] === null)
    return false;

  var data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  var res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../../asn1":58,"buffer":5,"inherits":146}],69:[function(require,module,exports){
var encoders = exports;

encoders.der = require('./der');

},{"./der":68}],70:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],71:[function(require,module,exports){
exports.strip = function strip(artifact) {
  artifact = artifact.toString()
  var startRegex = /^-----BEGIN (.*)-----\n/;
  var match = startRegex.exec(artifact);
  var tag = match[1];
  var endRegex = new RegExp("\n-----END " + tag + "-----(\n*)$");
  var base64 = artifact.slice(match[0].length).replace(endRegex, "").replace(/\n/g, "");
  return {tag: tag, base64: base64};
};

// http://stackoverflow.com/a/7033705
var wrap = function wrap(str, l) {
  var chunks = [];
  while (str) {
    if (str.length < l) {
      chunks.push(str);
      break;
    }
    else {
      chunks.push(str.substr(0, l));
      str = str.substr(l);
    }
  }
  return chunks.join("\n");
}

exports.assemble = function assemble(info) {
  var tag = info.tag;
  var base64 = info.base64;
  var startLine = "-----BEGIN " + tag + "-----";
  var endLine = "-----END " + tag + "-----";
  return startLine + "\n" + wrap(base64, 64) + "\n" + endLine + "\n";
}
},{}],72:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var parseKeys = require('parse-asn1');
var bn = require('bn.js');
var elliptic = require('elliptic');
var crt = require("browserify-rsa");
module.exports = sign;
function sign(hash, key, hashType, crypto) {
  var priv = parseKeys(key, crypto);
  if (priv.curve) {
    return ecSign(hash, priv, crypto);
  } else if (priv.type === 'dsa') {
    return dsaSign(hash, priv, hashType, crypto);
  }
  var len = priv.modulus.byteLength();
  var pad = [ 0, 1 ];
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff);
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  
  var out = crt(pad, priv, crypto);
  return out;
}
function ecSign(hash, priv, crypto) {
  elliptic.rand = crypto.randomBytes;
  var curve;
  if (priv.curve.join('.')  === '1.3.132.0.10') {
    curve = new elliptic.ec('secp256k1');
  }
  var key = curve.genKeyPair();
  key._importPrivate(priv.privateKey);
  var out = key.sign(hash);
  return new Buffer(out.toDER());
}
function dsaSign(hash, priv, algo, crypto) {
  var x = priv.params.priv_key;
  var p = priv.params.p;
  var q = priv.params.q;
  var montq = bn.mont(q);
  var g = priv.params.g;
  var r = new bn(0);
  var k;
  var H = bits2int(hash, q).mod(q);
  var s = false;
  var kv = getKay(x, q, hash, algo, crypto);
  while (s === false) {
    k = makeKey(q, kv, algo, crypto);
    r = makeR(g, k, p, q);
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
    if (!s.cmpn(0)) {
      s = false;
      r = new bn(0);
    }
  }
  return toDER(r,s);
}
function toDER(r, s) {
  r = r.toArray();
  s = s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [0].concat(s);

  var total = r.length + s.length + 4;
  var res = [ 0x30, total, 0x02, r.length ];
  res = res.concat(r, [ 0x02, s.length ], s);
  return new Buffer(res);
}
module.exports.getKay = getKay;
function getKay(x, q, hash, algo, crypto) {
  x = new Buffer(x.toArray());
  if (x.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - x.length);
    zeros.fill(0);
    x = Buffer.concat([zeros, x]);
  }
  var hlen = hash.length;
  var hbits = bits2octets(hash, q);
  var v = new Buffer(hlen);
  v.fill(1);
  var k = new Buffer(hlen);
  k.fill(0);
  k = crypto.createHmac(algo, k)
    .update(v)
    .update(new Buffer([0]))
    .update(x)
    .update(hbits)
    .digest();
  v = crypto.createHmac(algo, k)
    .update(v)
    .digest();
  k = crypto.createHmac(algo, k)
    .update(v)
    .update(new Buffer([1]))
    .update(x)
    .update(hbits)
    .digest();
  v = crypto.createHmac(algo, k)
    .update(v)
    .digest();
  return {
    k:k,
    v:v
  };
}
function bits2int(obits, q) {
  bits = new bn(obits);
  var shift = obits.length * 8 - q.bitLength();
  if (shift > 0) {
    bits.ishrn(shift);
  }
  return bits;
}
function bits2octets (bits, q) {
  bits = bits2int(bits, q);
  bits = bits.mod(q);
  var out = new Buffer(bits.toArray());
  if (out.length < q.byteLength()) {
    var zeros = new Buffer(q.byteLength() - out.length);
    zeros.fill(0);
    out = Buffer.concat([zeros, out]);
  }
  return out;
}
module.exports.makeKey = makeKey;
function makeKey(q, kv, algo, crypto) {
  var t;
  var k;
  while (true) {
    t = new Buffer('');
    while (t.length * 8 < q.bitLength()) {
      kv.v = crypto.createHmac(algo, kv.k)
        .update(kv.v)
        .digest();
      t = Buffer.concat([t, kv.v]);
    }
    k = bits2int(t, q);
    kv.k =  crypto.createHmac(algo, kv.k)
        .update(kv.v)
        .update(new Buffer([0]))
        .digest();
    kv.v = crypto.createHmac(algo, kv.k)
        .update(kv.v)
        .digest();
    if (k.cmp(q) === -1) {
      return k;
    }
  }
}
function makeR(g, k, p, q) {
  return g.toRed(bn.mont(p)).redPow(k).fromRed().mod(q);
}
}).call(this,require("buffer").Buffer)
},{"bn.js":30,"browserify-rsa":31,"buffer":5,"elliptic":32,"parse-asn1":56}],73:[function(require,module,exports){
(function (Buffer){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var parseKeys = require('parse-asn1');
var elliptic = require('elliptic');
var bn = require('bn.js');
module.exports = verify;
function verify(sig, hash, key) {
  var pub = parseKeys(key);
  if (pub.type === 'ec') {
    return ecVerify(sig, hash, pub);
  } else if (pub.type === 'dsa') {
    return dsaVerify(sig, hash, pub);
  }
  var len = pub.modulus.byteLength();
  var pad = [ 0, 1 ];
  while (hash.length + pad.length + 1 < len) {
    pad.push(0xff);
  }
  pad.push(0x00);
  var i = -1;
  while (++i < hash.length) {
    pad.push(hash[i]);
  }
  pad = hash;
  var red = bn.mont(pub.modulus);
  sig = new bn(sig).toRed(red);

  sig = sig.redPow(new bn(pub.publicExponent));

  sig = new Buffer(sig.fromRed().toArray());
  sig = sig.slice(sig.length - hash.length);
  var out = 0;
  len = sig.length;
  i = -1;
  while (++i < len) {
    out += (sig[i] ^ hash[i]);
  }
  return !out;
}
function ecVerify(sig, hash, pub) {
  var curve;
  if (pub.data.algorithm.curve.join('.')  === '1.3.132.0.10') {
    curve = new elliptic.ec('secp256k1');
  }
  var pubkey = pub.data.subjectPrivateKey.data;
  return curve.verify(hash.toString('hex'), sig.toString('hex'), pubkey.toString('hex'));
}
function dsaVerify(sig, hash, pub) {
  var p = pub.data.p;
  var q = pub.data.q;
  var g = pub.data.g;
  var y = pub.data.pub_key;
  var unpacked = parseKeys.signature.decode(sig, 'der');
  var s = unpacked.s;
  var r = unpacked.r;
  checkValue(s, q);
  checkValue(r, q);
  var montq = bn.mont(q);
  var montp = bn.mont(p);
  var w =  s.invm(q);
  var v = g.toRed(montp)
  .redPow(new bn(hash).mul(w).mod(q))
  .fromRed()
  .mul(
    y.toRed(montp)
    .redPow(r.mul(w).mod(q))
    .fromRed()
  ).mod(p).mod(q);
  return !v.cmp(r);
}
function checkValue(b, q) {
  if (b.cmpn(0) <= 0) {
    throw new Error('invalid sig');
  }
  if (b.cmp(q) >= q) {
    throw new Error('invalid sig');
  }
}
}).call(this,require("buffer").Buffer)
},{"bn.js":30,"buffer":5,"elliptic":32,"parse-asn1":56}],74:[function(require,module,exports){
(function (Buffer){
var elliptic = require('elliptic');
var BN = require('bn.js');
module.exports = ECDH;

function ECDH(curve, crypto) {
	elliptic.rand = crypto.randomBytes;
	this.curve = new elliptic.ec(curve);
	this.keys = void 0;
}
ECDH.prototype.generateKeys = function (enc, format) {
	this.keys = this.curve.genKeyPair();
	return this.getPublicKey(enc, format);
};

ECDH.prototype.computeSecret = function (other, inenc, enc) {
	inenc = inenc || 'utf8';
	if (!Buffer.isBuffer(other)) {
		other = new Buffer(other, inenc);
	}
	other = new BN(other);
	other = other.toString(16);
	var otherPub = this.curve.keyPair(other, 'hex').getPublic();
	var out = otherPub.mul(this.keys.getPrivate()).getX();
	return returnValue(out, enc);
};
ECDH.prototype.getPublicKey = function (enc, format) {
	var key = this.keys.getPublic(format === 'compressed', true);
	if (format === 'hybrid') {
		if (key[key.length - 1] % 2) {
			key[0] = 7;
		} else {
			key [0] = 6;
		}
	}
	return returnValue(key, enc);
};
ECDH.prototype.getPrivateKey = function (enc) {
	return returnValue(this.keys.getPrivate(), enc);
};

ECDH.prototype.setPublicKey = function (pub, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(pub)) {
		pub = new Buffer(pub, enc);
	}
	var pkey = new BN(pub);
	pkey = pkey.toArray();
	this.keys._importPublicHex(pkey);
};
ECDH.prototype.setPrivateKey = function (priv, enc) {
	enc = enc || 'utf8';
	if (!Buffer.isBuffer(priv)) {
		priv = new Buffer(priv, enc);
	}
	var _priv = new BN(priv);
	_priv = _priv.toString(16);
	this.keys._importPrivate(_priv);
};
function returnValue(bn, enc) {
	if (!Array.isArray(bn)) {
		bn = bn.toArray();
	}
	var buf = new Buffer(bn);
	if (!enc) {
		return buf;
	} else {
		return buf.toString(enc);
	}
}
}).call(this,require("buffer").Buffer)
},{"bn.js":76,"buffer":5,"elliptic":77}],75:[function(require,module,exports){
var ECDH = require('./ecdh');
module.exports = function (crypto, exports) {
	exports.createECDH = function (curve) {
		return new ECDH(curve, crypto);
	};
};
},{"./ecdh":74}],76:[function(require,module,exports){
module.exports=require(30)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js":30}],77:[function(require,module,exports){
module.exports=require(32)
},{"../package.json":96,"./elliptic/curve":80,"./elliptic/curves":83,"./elliptic/ec":84,"./elliptic/hmac-drbg":87,"./elliptic/utils":88,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic.js":32,"brorand":89}],78:[function(require,module,exports){
module.exports=require(33)
},{"../../elliptic":77,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/base.js":33,"bn.js":76}],79:[function(require,module,exports){
module.exports=require(34)
},{"../../elliptic":77,"../curve":80,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/edwards.js":34,"bn.js":76,"inherits":146}],80:[function(require,module,exports){
module.exports=require(35)
},{"./base":78,"./edwards":79,"./mont":81,"./short":82,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/index.js":35}],81:[function(require,module,exports){
module.exports=require(36)
},{"../../elliptic":77,"../curve":80,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/mont.js":36,"bn.js":76,"inherits":146}],82:[function(require,module,exports){
module.exports=require(37)
},{"../../elliptic":77,"../curve":80,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curve/short.js":37,"bn.js":76,"inherits":146}],83:[function(require,module,exports){
module.exports=require(38)
},{"../elliptic":77,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/curves.js":38,"bn.js":76,"hash.js":90}],84:[function(require,module,exports){
module.exports=require(39)
},{"../../elliptic":77,"./key":85,"./signature":86,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/index.js":39,"bn.js":76}],85:[function(require,module,exports){
module.exports=require(40)
},{"../../elliptic":77,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/key.js":40,"bn.js":76}],86:[function(require,module,exports){
module.exports=require(41)
},{"../../elliptic":77,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/ec/signature.js":41,"bn.js":76}],87:[function(require,module,exports){
module.exports=require(42)
},{"../elliptic":77,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/hmac-drbg.js":42,"hash.js":90}],88:[function(require,module,exports){
module.exports=require(43)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/lib/elliptic/utils.js":43,"bn.js":76}],89:[function(require,module,exports){
module.exports=require(44)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/brorand/index.js":44}],90:[function(require,module,exports){
module.exports=require(45)
},{"./hash/common":91,"./hash/hmac":92,"./hash/ripemd":93,"./hash/sha":94,"./hash/utils":95,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash.js":45}],91:[function(require,module,exports){
module.exports=require(46)
},{"../hash":90,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/common.js":46}],92:[function(require,module,exports){
module.exports=require(47)
},{"../hash":90,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/hmac.js":47}],93:[function(require,module,exports){
module.exports=require(48)
},{"../hash":90,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/ripemd.js":48}],94:[function(require,module,exports){
module.exports=require(49)
},{"../hash":90,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/sha.js":49}],95:[function(require,module,exports){
module.exports=require(50)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/hash.js/lib/hash/utils.js":50,"inherits":146}],96:[function(require,module,exports){
module.exports=require(51)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/package.json":51}],97:[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('sha.js')

var md5 = require('./md5')
var rmd160 = require('ripemd160')
var Transform = require('stream').Transform;
var inherits = require('inherits')

module.exports = function (alg) {
  if('md5' === alg) return new HashNoConstructor(md5)
  if('rmd160' === alg) return new HashNoConstructor(rmd160)
  return new Hash(createHash(alg))
}
inherits(HashNoConstructor, Transform)

function HashNoConstructor(hash) {
  Transform.call(this);
  this._hash = hash
  this.buffers = []
}

HashNoConstructor.prototype._transform = function (data, _, done) {
  this.buffers.push(data)
  done()
}
HashNoConstructor.prototype._flush = function (done) {
  var buf = Buffer.concat(this.buffers)
  var r = this._hash(buf)
  this.buffers = null
  this.push(r)
  done()
}
HashNoConstructor.prototype.update = function (data, enc) {
  this.write(data, enc)
  return this
}

HashNoConstructor.prototype.digest = function (enc) {
  this.end()
  var outData = new Buffer('')
  var chunk
  while ((chunk = this.read())) {
    outData = Buffer.concat([outData, chunk])
  }
  if (enc) {
    outData = outData.toString(enc)
  }
  return outData
}

inherits(Hash, Transform)

function Hash(hash) {
  Transform.call(this);
  this._hash = hash
}

Hash.prototype._transform = function (data, _, done) {
  this._hash.update(data)
  done()
}
Hash.prototype._flush = function (done) {
  this.push(this._hash.digest())
  this._hash = null
  done()
}
Hash.prototype.update = function (data, enc) {
  this.write(data, enc)
  return this
}

Hash.prototype.digest = function (enc) {
  this.end()
  var outData = new Buffer('')
  var chunk
  while ((chunk = this.read())) {
    outData = Buffer.concat([outData, chunk])
  }
  if (enc) {
    outData = outData.toString(enc)
  }
  return outData
}
}).call(this,require("buffer").Buffer)
},{"./md5":99,"buffer":5,"inherits":146,"ripemd160":100,"sha.js":102,"stream":163}],98:[function(require,module,exports){
(function (Buffer){
'use strict';
var intSize = 4;
var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);
var chrsz = 8;

function toArray(buf, bigEndian) {
  if ((buf.length % intSize) !== 0) {
    var len = buf.length + (intSize - (buf.length % intSize));
    buf = Buffer.concat([buf, zeroBuffer], len);
  }

  var arr = [];
  var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;
  for (var i = 0; i < buf.length; i += intSize) {
    arr.push(fn.call(buf, i));
  }
  return arr;
}

function toBuffer(arr, size, bigEndian) {
  var buf = new Buffer(size);
  var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;
  for (var i = 0; i < arr.length; i++) {
    fn.call(buf, arr[i], i * 4, true);
  }
  return buf;
}

function hash(buf, fn, hashSize, bigEndian) {
  if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);
  var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);
  return toBuffer(arr, hashSize, bigEndian);
}
exports.hash = hash;
}).call(this,require("buffer").Buffer)
},{"buffer":5}],99:[function(require,module,exports){
'use strict';
/*
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.1 Copyright (C) Paul Johnston 1999 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

var helpers = require('./helpers');

/*
 * Calculate the MD5 of an array of little-endian words, and a bit length
 */
function core_md5(x, len)
{
  /* append padding */
  x[len >> 5] |= 0x80 << ((len) % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var a =  1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d =  271733878;

  for(var i = 0; i < x.length; i += 16)
  {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;

    a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);
    d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);
    c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);
    b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);
    a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);
    d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);
    c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);
    b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);
    a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);
    d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);
    c = md5_ff(c, d, a, b, x[i+10], 17, -42063);
    b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);
    a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);
    d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);
    c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);
    b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);

    a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);
    d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);
    c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);
    b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);
    a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);
    d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);
    c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);
    b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);
    a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);
    d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);
    c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);
    b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);
    a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);
    d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);
    c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);
    b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);

    a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);
    d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);
    c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);
    b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);
    a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);
    d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);
    c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);
    b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);
    a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);
    d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);
    c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);
    b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);
    a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);
    d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);
    c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);
    b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);

    a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);
    d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);
    c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);
    b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);
    a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);
    d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);
    c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);
    b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);
    a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);
    d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);
    c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);
    b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);
    a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);
    d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);
    c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);
    b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
  }
  return Array(a, b, c, d);

}

/*
 * These functions implement the four basic operations the algorithm uses.
 */
function md5_cmn(q, a, b, x, s, t)
{
  return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);
}
function md5_ff(a, b, c, d, x, s, t)
{
  return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
}
function md5_gg(a, b, c, d, x, s, t)
{
  return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
}
function md5_hh(a, b, c, d, x, s, t)
{
  return md5_cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5_ii(a, b, c, d, x, s, t)
{
  return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
}

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */
function safe_add(x, y)
{
  var lsw = (x & 0xFFFF) + (y & 0xFFFF);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xFFFF);
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function bit_rol(num, cnt)
{
  return (num << cnt) | (num >>> (32 - cnt));
}

module.exports = function md5(buf) {
  return helpers.hash(buf, core_md5, 16);
};
},{"./helpers":98}],100:[function(require,module,exports){
(function (Buffer){
/*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
/** @preserve
(c) 2012 by Cédric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// constants table
var zl = [
    0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
    7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
    3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
    1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
    4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]

var zr = [
    5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
    6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
    15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
    8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
    12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]

var sl = [
     11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
    7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
    11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
      11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
    9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]

var sr = [
    8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
    9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
    9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
    15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
    8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]


var hl =  [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
var hr =  [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

function bytesToWords(bytes) {
  var words = []
  for (var i = 0, b = 0; i < bytes.length; i++, b += 8) {
    words[b >>> 5] |= bytes[i] << (24 - b % 32)
  }
  return words
}

function wordsToBytes(words) {
  var bytes = []
  for (var b = 0; b < words.length * 32; b += 8) {
    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF)
  }
  return bytes
}

function processBlock(H, M, offset) {
  // swap endian
  for (var i = 0; i < 16; i++) {
    var offset_i = offset + i;
    var M_offset_i = M[offset_i]

    // Swap
    M[offset_i] = (
        (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
        (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
    )
  }

  // Working variables
  var al, bl, cl, dl, el
  var ar, br, cr, dr, er

  ar = al = H[0]
  br = bl = H[1]
  cr = cl = H[2]
  dr = dl = H[3]
  er = el = H[4]

  // computation
  var t
  for (var i = 0; i < 80; i += 1) {
    t = (al +  M[offset+zl[i]])|0
    if (i<16){
        t +=  f1(bl,cl,dl) + hl[0]
    } else if (i<32) {
        t +=  f2(bl,cl,dl) + hl[1]
    } else if (i<48) {
        t +=  f3(bl,cl,dl) + hl[2]
    } else if (i<64) {
        t +=  f4(bl,cl,dl) + hl[3]
    } else {// if (i<80) {
        t +=  f5(bl,cl,dl) + hl[4]
    }
    t = t|0
    t =  rotl(t,sl[i])
    t = (t+el)|0
    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = t

    t = (ar + M[offset+zr[i]])|0
    if (i<16) {
      t +=  f5(br,cr,dr) + hr[0]
    } else if (i<32) {
      t +=  f4(br,cr,dr) + hr[1]
    } else if (i<48) {
      t +=  f3(br,cr,dr) + hr[2]
    } else if (i<64) {
      t +=  f2(br,cr,dr) + hr[3]
    } else {// if (i<80) {
      t +=  f1(br,cr,dr) + hr[4]
    }

    t = t|0
    t =  rotl(t,sr[i]) 
    t = (t+er)|0
    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = t
  }

  // intermediate hash value
  t    = (H[1] + cl + dr)|0
  H[1] = (H[2] + dl + er)|0
  H[2] = (H[3] + el + ar)|0
  H[3] = (H[4] + al + br)|0
  H[4] = (H[0] + bl + cr)|0
  H[0] =  t
}

function f1(x, y, z) {
  return ((x) ^ (y) ^ (z))
}

function f2(x, y, z) {
  return (((x)&(y)) | ((~x)&(z)))
}

function f3(x, y, z) {
  return (((x) | (~(y))) ^ (z))
}

function f4(x, y, z) {
  return (((x) & (z)) | ((y)&(~(z))))
}

function f5(x, y, z) {
  return ((x) ^ ((y) |(~(z))))
}

function rotl(x,n) {
  return (x<<n) | (x>>>(32-n))
}

function ripemd160(message) {
  var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

  if (typeof message == 'string')
    message = new Buffer(message, 'utf8')

  var m = bytesToWords(message)

  var nBitsLeft = message.length * 8
  var nBitsTotal = message.length * 8

  // Add padding
  m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32)
  m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
      (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
      (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
  )

  for (var i=0 ; i<m.length; i += 16) {
    processBlock(H, m, i)
  }

  // swap endian
  for (var i = 0; i < 5; i++) {
      // shortcut
    var H_i = H[i]

    // Swap
    H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
          (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00)
  }

  var digestbytes = wordsToBytes(H)
  return new Buffer(digestbytes)
}

module.exports = ripemd160

}).call(this,require("buffer").Buffer)
},{"buffer":5}],101:[function(require,module,exports){
(function (Buffer){
//prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = new Buffer(blockSize) //new Uint32Array(blockSize/4)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
  this._s = 0
}

Hash.prototype.update = function (data, enc) {
  if ("string" === typeof data) {
    enc = enc || "utf8"
    data = new Buffer(data, enc)
  }

  var l = this._len += data.length
  var s = this._s || 0
  var f = 0
  var buffer = this._block

  while (s < l) {
    var t = Math.min(data.length, f + this._blockSize - (s % this._blockSize))
    var ch = (t - f)

    for (var i = 0; i < ch; i++) {
      buffer[(s % this._blockSize) + i] = data[i + f]
    }

    s += ch
    f += ch

    if ((s % this._blockSize) === 0) {
      this._update(buffer)
    }
  }
  this._s = s

  return this
}

Hash.prototype.digest = function (enc) {
  // Suppose the length of the message M, in bits, is l
  var l = this._len * 8

  // Append the bit 1 to the end of the message
  this._block[this._len % this._blockSize] = 0x80

  // and then k zero bits, where k is the smallest non-negative solution to the equation (l + 1 + k) === finalSize mod blockSize
  this._block.fill(0, this._len % this._blockSize + 1)

  if (l % (this._blockSize * 8) >= this._finalSize * 8) {
    this._update(this._block)
    this._block.fill(0)
  }

  // to this append the block which is equal to the number l written in binary
  // TODO: handle case where l is > Math.pow(2, 29)
  this._block.writeInt32BE(l, this._blockSize - 4)

  var hash = this._update(this._block) || this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

}).call(this,require("buffer").Buffer)
},{"buffer":5}],102:[function(require,module,exports){
var exports = module.exports = function (alg) {
  var Alg = exports[alg.toLowerCase()]
  if(!Alg) throw new Error(alg + ' is not supported (we accept pull requests)')
  return new Alg()
}


exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha1":103,"./sha224":104,"./sha256":105,"./sha384":106,"./sha512":107}],103:[function(require,module,exports){
(function (Buffer){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')

var W = new Array(80)

function Sha1() {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

/*
 * Bitwise rotate a 32-bit number to the left.
 */
function rol(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d
  var e = this._e

  var j = 0, k

  function calcW() { return rol(W[j - 3] ^ W[j -  8] ^ W[j - 14] ^ W[j - 16], 1) }
  function loop(w, f) {
    W[j] = w

    var t = rol(a, 5) + f + e + w + k

    e = d
    d = c
    c = rol(b, 30)
    b = a
    a = t
    j++
  }

  k = 1518500249
  while (j < 16) loop(M.readInt32BE(j * 4), (b & c) | ((~b) & d))
  while (j < 20) loop(calcW(), (b & c) | ((~b) & d))
  k = 1859775393
  while (j < 40) loop(calcW(), b ^ c ^ d)
  k = -1894007588
  while (j < 60) loop(calcW(), (b & c) | (b & d) | (c & d))
  k = -899497514
  while (j < 80) loop(calcW(), b ^ c ^ d)

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = new Buffer(20)

  H.writeInt32BE(this._a|0, 0)
  H.writeInt32BE(this._b|0, 4)
  H.writeInt32BE(this._c|0, 8)
  H.writeInt32BE(this._d|0, 12)
  H.writeInt32BE(this._e|0, 16)

  return H
}

module.exports = Sha1


}).call(this,require("buffer").Buffer)
},{"./hash":101,"buffer":5,"inherits":146}],104:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var SHA256 = require('./sha256')
var Hash = require('./hash')

var W = new Array(64)

function Sha224() {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, SHA256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8|0
  this._b = 0x367cd507|0
  this._c = 0x3070dd17|0
  this._d = 0xf70e5939|0
  this._e = 0xffc00b31|0
  this._f = 0x68581511|0
  this._g = 0x64f98fa7|0
  this._h = 0xbefa4fa4|0

  return this
}

Sha224.prototype._hash = function () {
  var H = new Buffer(28)

  H.writeInt32BE(this._a,  0)
  H.writeInt32BE(this._b,  4)
  H.writeInt32BE(this._c,  8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

}).call(this,require("buffer").Buffer)
},{"./hash":101,"./sha256":105,"buffer":5,"inherits":146}],105:[function(require,module,exports){
(function (Buffer){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256() {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667|0
  this._b = 0xbb67ae85|0
  this._c = 0x3c6ef372|0
  this._d = 0xa54ff53a|0
  this._e = 0x510e527f|0
  this._f = 0x9b05688c|0
  this._g = 0x1f83d9ab|0
  this._h = 0x5be0cd19|0

  return this
}

function S (X, n) {
  return (X >>> n) | (X << (32 - n));
}

function R (X, n) {
  return (X >>> n);
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z));
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
}

function Sigma0256 (x) {
  return (S(x, 2) ^ S(x, 13) ^ S(x, 22));
}

function Sigma1256 (x) {
  return (S(x, 6) ^ S(x, 11) ^ S(x, 25));
}

function Gamma0256 (x) {
  return (S(x, 7) ^ S(x, 18) ^ R(x, 3));
}

function Gamma1256 (x) {
  return (S(x, 17) ^ S(x, 19) ^ R(x, 10));
}

Sha256.prototype._update = function(M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var j = 0

  function calcW() { return Gamma1256(W[j - 2]) + W[j - 7] + Gamma0256(W[j - 15]) + W[j - 16] }
  function loop(w) {
    W[j] = w

    var T1 = h + Sigma1256(e) + Ch(e, f, g) + K[j] + w
    var T2 = Sigma0256(a) + Maj(a, b, c);

    h = g;
    g = f;
    f = e;
    e = d + T1;
    d = c;
    c = b;
    b = a;
    a = T1 + T2;

    j++
  }

  while (j < 16) loop(M.readInt32BE(j * 4))
  while (j < 64) loop(calcW())

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
};

Sha256.prototype._hash = function () {
  var H = new Buffer(32)

  H.writeInt32BE(this._a,  0)
  H.writeInt32BE(this._b,  4)
  H.writeInt32BE(this._c,  8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

}).call(this,require("buffer").Buffer)
},{"./hash":101,"buffer":5,"inherits":146}],106:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var SHA512 = require('./sha512');
var Hash = require('./hash')

var W = new Array(160)

function Sha384() {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._a = 0xcbbb9d5d|0
  this._b = 0x629a292a|0
  this._c = 0x9159015a|0
  this._d = 0x152fecd8|0
  this._e = 0x67332667|0
  this._f = 0x8eb44a87|0
  this._g = 0xdb0c2e0d|0
  this._h = 0x47b5481d|0

  this._al = 0xc1059ed8|0
  this._bl = 0x367cd507|0
  this._cl = 0x3070dd17|0
  this._dl = 0xf70e5939|0
  this._el = 0xffc00b31|0
  this._fl = 0x68581511|0
  this._gl = 0x64f98fa7|0
  this._hl = 0xbefa4fa4|0

  return this
}

Sha384.prototype._hash = function () {
  var H = new Buffer(48)

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)

  return H
}

module.exports = Sha384

}).call(this,require("buffer").Buffer)
},{"./hash":101,"./sha512":107,"buffer":5,"inherits":146}],107:[function(require,module,exports){
(function (Buffer){
var inherits = require('inherits')
var Hash = require('./hash')

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512() {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._a = 0x6a09e667|0
  this._b = 0xbb67ae85|0
  this._c = 0x3c6ef372|0
  this._d = 0xa54ff53a|0
  this._e = 0x510e527f|0
  this._f = 0x9b05688c|0
  this._g = 0x1f83d9ab|0
  this._h = 0x5be0cd19|0

  this._al = 0xf3bcc908|0
  this._bl = 0x84caa73b|0
  this._cl = 0xfe94f82b|0
  this._dl = 0x5f1d36f1|0
  this._el = 0xade682d1|0
  this._fl = 0x2b3e6c1f|0
  this._gl = 0xfb41bd6b|0
  this._hl = 0x137e2179|0

  return this
}

function S (X, Xl, n) {
  return (X >>> n) | (Xl << (32 - n))
}

function Ch (x, y, z) {
  return ((x & y) ^ ((~x) & z));
}

function Maj (x, y, z) {
  return ((x & y) ^ (x & z) ^ (y & z));
}

Sha512.prototype._update = function(M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  var i = 0, j = 0
  var Wi, Wil
  function calcW() {
    var x  = W[j - 15*2]
    var xl = W[j - 15*2 + 1]
    var gamma0  = S(x, xl, 1) ^ S(x, xl, 8) ^ (x >>> 7)
    var gamma0l = S(xl, x, 1) ^ S(xl, x, 8) ^ S(xl, x, 7)

    x  = W[j - 2*2]
    xl = W[j - 2*2 + 1]
    var gamma1  = S(x, xl, 19) ^ S(xl, x, 29) ^ (x >>> 6)
    var gamma1l = S(xl, x, 19) ^ S(x, xl, 29) ^ S(xl, x, 6)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7  = W[j - 7*2]
    var Wi7l = W[j - 7*2 + 1]

    var Wi16  = W[j - 16*2]
    var Wi16l = W[j - 16*2 + 1]

    Wil = gamma0l + Wi7l
    Wi  = gamma0  + Wi7 + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0)
    Wil = Wil + gamma1l
    Wi  = Wi  + gamma1  + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0)
    Wil = Wil + Wi16l
    Wi  = Wi  + Wi16 + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0)
  }

  function loop() {
    W[j] = Wi
    W[j + 1] = Wil

    var maj = Maj(a, b, c)
    var majl = Maj(al, bl, cl)

    var sigma0h = S(a, al, 28) ^ S(al, a, 2) ^ S(al, a, 7)
    var sigma0l = S(al, a, 28) ^ S(a, al, 2) ^ S(a, al, 7)
    var sigma1h = S(e, el, 14) ^ S(e, el, 18) ^ S(el, e, 9)
    var sigma1l = S(el, e, 14) ^ S(el, e, 18) ^ S(e, el, 9)

    // t1 = h + sigma1 + ch + K[i] + W[i]
    var Ki = K[j]
    var Kil = K[j + 1]

    var ch = Ch(e, f, g)
    var chl = Ch(el, fl, gl)

    var t1l = hl + sigma1l
    var t1 = h + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0)
    t1l = t1l + chl
    t1 = t1 + ch + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0)
    t1l = t1l + Kil
    t1 = t1 + Ki + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0)
    t1l = t1l + Wil
    t1 = t1 + Wi + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0)

    // t2 = sigma0 + maj
    var t2l = sigma0l + majl
    var t2 = sigma0h + maj + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0)

    h  = g
    hl = gl
    g  = f
    gl = fl
    f  = e
    fl = el
    el = (dl + t1l) | 0
    e  = (d + t1 + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
    d  = c
    dl = cl
    c  = b
    cl = bl
    b  = a
    bl = al
    al = (t1l + t2l) | 0
    a  = (t1 + t2 + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0

    i++
    j += 2
  }

  while (i < 16) {
    Wi = M.readInt32BE(j * 4)
    Wil = M.readInt32BE(j * 4 + 4)

    loop()
  }

  while (i < 80) {
    calcW()
    loop()
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._a = (this._a + a + ((this._al >>> 0) < (al >>> 0) ? 1 : 0)) | 0
  this._b = (this._b + b + ((this._bl >>> 0) < (bl >>> 0) ? 1 : 0)) | 0
  this._c = (this._c + c + ((this._cl >>> 0) < (cl >>> 0) ? 1 : 0)) | 0
  this._d = (this._d + d + ((this._dl >>> 0) < (dl >>> 0) ? 1 : 0)) | 0
  this._e = (this._e + e + ((this._el >>> 0) < (el >>> 0) ? 1 : 0)) | 0
  this._f = (this._f + f + ((this._fl >>> 0) < (fl >>> 0) ? 1 : 0)) | 0
  this._g = (this._g + g + ((this._gl >>> 0) < (gl >>> 0) ? 1 : 0)) | 0
  this._h = (this._h + h + ((this._hl >>> 0) < (hl >>> 0) ? 1 : 0)) | 0
}

Sha512.prototype._hash = function () {
  var H = new Buffer(64)

  function writeInt64BE(h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._a, this._al, 0)
  writeInt64BE(this._b, this._bl, 8)
  writeInt64BE(this._c, this._cl, 16)
  writeInt64BE(this._d, this._dl, 24)
  writeInt64BE(this._e, this._el, 32)
  writeInt64BE(this._f, this._fl, 40)
  writeInt64BE(this._g, this._gl, 48)
  writeInt64BE(this._h, this._hl, 56)

  return H
}

module.exports = Sha512

}).call(this,require("buffer").Buffer)
},{"./hash":101,"buffer":5,"inherits":146}],108:[function(require,module,exports){
(function (Buffer){
'use strict';
var createHash = require('create-hash/browser');
var inherits = require('inherits')

var Transform = require('stream').Transform

var ZEROS = new Buffer(128)
ZEROS.fill(0)

function Hmac(alg, key) {
  Transform.call(this)

  if (typeof key === 'string') {
    key = new Buffer(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = createHash(alg).update(key).digest()

  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = new Buffer(blocksize)
  var opad = this._opad = new Buffer(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = createHash(alg).update(ipad)
}

inherits(Hmac, Transform)

Hmac.prototype.update = function (data, enc) {
  this._hash.update(data, enc)

  return this
}

Hmac.prototype._transform = function (data, _, next) {
  this._hash.update(data)

  next()
}

Hmac.prototype._flush = function (next) {
  this.push(this.digest())

  next()
}

Hmac.prototype.digest = function (enc) {
  var h = this._hash.digest()

  return createHash(this._alg).update(this._opad).update(h).digest(enc)
}

module.exports = function createHmac(alg, key) {
  return new Hmac(alg, key)
}

}).call(this,require("buffer").Buffer)
},{"buffer":5,"create-hash/browser":97,"inherits":146,"stream":163}],109:[function(require,module,exports){
(function (Buffer){
var generatePrime = require('./lib/generatePrime');
var primes = require('./lib/primes');

var DH = require('./lib/dh');

function getDiffieHellman(mod) {
  var prime = new Buffer(primes[mod].prime, 'hex');
  var gen = new Buffer(primes[mod].gen, 'hex');

  return new DH(prime, gen);
}

function createDiffieHellman(prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || (typeof enc === 'string' && ['hex', 'binary', 'base64'].indexOf(enc) === -1)) {
    genc = generator;
    generator = enc;
    enc = undefined;
  }

  enc = enc || 'binary';
  genc = genc || 'binary';
  generator = generator || new Buffer([2]);

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc);
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true);
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc);
  }

  return new DH(prime, generator, true);
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman;
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman;

}).call(this,require("buffer").Buffer)
},{"./lib/dh":110,"./lib/generatePrime":111,"./lib/primes":112,"buffer":5}],110:[function(require,module,exports){
(function (Buffer){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;
  
  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;
    
    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      } 
      break;
    default: 
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function defineError (self, error) {
  try {
    Object.defineProperty(self, 'verifyError', {
      enumerable: true,
      value: error,
      writable: false
    });
  } catch(e) {
    self.verifyError = error;
  }
}
function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = void 0;
  this._priv = void 0;
  
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
    defineError(this, checkPrime(this.__prime, generator));
  } else {
    defineError(this, 8);
  }
}

DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}
}).call(this,require("buffer").Buffer)
},{"./generatePrime":111,"bn.js":113,"buffer":5,"miller-rabin":114,"randombytes":144}],111:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);
  var runs, comp;
  function generateRandom(bits) {
    runs = -1;
    var out = new BN(randomBytes(Math.ceil(bits / 8)));
    while (out.bitLength() > bits) {
      out.ishrn(1);
    }
    if (out.isEven()) {
      out.iadd(ONE);
    }
    if (!out.testn(1)) {
      out.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (out.mod(TWENTYFOUR).cmp(ELEVEN)) {
        out.iadd(FOUR);
      }
      comp = {
        major: [TWENTYFOUR],
        minor: [TWELVE]
      };
    } else if (!gen.cmp(FIVE)) {
      rem = out.mod(TEN);
      while (rem.cmp(THREE)) {
        out.iadd(FOUR);
        rem = out.mod(TEN);
      }
      comp = {
        major: [FOUR, SIXTEEN],
        minor: [TWO, EIGHT]
      };
    } else {
      comp = {
        major: [FOUR],
        minor: [TWO]
      };
    }
    return out;
  }
  var num = generateRandom(bits);

  var n2 = num.shrn(1);

  while (true) {
    while (num.bitLength() > bits) {
      num = generateRandom(bits);
      n2 = num.shrn(1);
    }
    runs++;
    if (simpleSieve(n2) &&  simpleSieve(num) &&
      fermatTest(n2) &&  fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
    num.iadd(comp.major[runs%comp.major.length]);
    n2.iadd(comp.minor[runs%comp.minor.length]);
  }

}
},{"bn.js":113,"miller-rabin":114,"randombytes":144}],112:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],113:[function(require,module,exports){
module.exports=require(30)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js":30}],114:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._rand = function _rand(n) {
  var len = n.bitLength();
  var buf = this.rand.generate(Math.ceil(len / 8));

  // Set low bits
  buf[0] |= 3;

  // Mask high bits
  var mask = len & 0x7;
  if (mask !== 0)
    buf[buf.length - 1] >>= 7 - mask;

  return new bn(buf);
}

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  var n2 = n1.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._rand(n2);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return prime;
};

},{"bn.js":113,"brorand":115}],115:[function(require,module,exports){
module.exports=require(44)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/elliptic/node_modules/brorand/index.js":44}],116:[function(require,module,exports){
(function (Buffer){
var createHmac = require('create-hmac')

exports.pbkdf2 = pbkdf2
function pbkdf2 (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  if (typeof callback !== 'function') {
    throw new Error('No callback provided to pbkdf2')
  }

  var result = pbkdf2Sync(password, salt, iterations, keylen, digest)
  setTimeout(function () {
    callback(undefined, result)
  })
}

exports.pbkdf2Sync = pbkdf2Sync
function pbkdf2Sync (password, salt, iterations, keylen, digest) {
  if (typeof iterations !== 'number')
    throw new TypeError('Iterations not a number')

  if (iterations < 0)
    throw new TypeError('Bad iterations')

  if (typeof keylen !== 'number')
    throw new TypeError('Key length not a number')

  if (keylen < 0)
    throw new TypeError('Bad key length')

  digest = digest || 'sha1'

  if (!Buffer.isBuffer(password)) password = new Buffer(password)
  if (!Buffer.isBuffer(salt)) salt = new Buffer(salt)

  var hLen
  var l = 1
  var DK = new Buffer(keylen)
  var block1 = new Buffer(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var r
  var T

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)
    var U = createHmac(digest, password).update(block1).digest()

    if (!hLen) {
      hLen = U.length
      T = new Buffer(hLen)
      l = Math.ceil(keylen / hLen)
      r = keylen - (l - 1) * hLen

      if (keylen > (Math.pow(2, 32) - 1) * hLen)
        throw new TypeError('keylen exceeds maximum length')
    }

    U.copy(T, 0, 0, hLen)

    for (var j = 1; j < iterations; j++) {
      U = createHmac(digest, password).update(U).digest()

      for (var k = 0; k < hLen; k++) {
        T[k] ^= U[k]
      }
    }

    var destPos = (i - 1) * hLen
    var len = (i === l ? r : hLen)
    T.copy(DK, destPos, 0, len)
  }

  return DK
}

}).call(this,require("buffer").Buffer)
},{"buffer":5,"create-hmac":108}],117:[function(require,module,exports){

module.exports = function (exports, crypto) {
  exports.publicEncrypt = require('./publicEncrypt')(crypto);
  exports.privateDecrypt = require('./privateDecrypt')(crypto);
};
},{"./privateDecrypt":141,"./publicEncrypt":142}],118:[function(require,module,exports){
(function (Buffer){
module.exports = function (seed, len, crypto) {
  var t = new Buffer('');
  var  i = 0, c;
  while (t.length < len) {
    c = i2ops(i++);
    t = Buffer.concat([t, crypto.createHash('sha1').update(seed).update(c).digest()]);
  }
  return t.slice(0, len);
};

function i2ops(c) {
  var out = new Buffer(4);
  out.writeUInt32BE(c,0);
  return out;
}
}).call(this,require("buffer").Buffer)
},{"buffer":5}],119:[function(require,module,exports){
module.exports=require(30)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/bn.js/lib/bn.js":30}],120:[function(require,module,exports){
module.exports=require(31)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/browserify-rsa/index.js":31,"bn.js":119,"buffer":5}],121:[function(require,module,exports){
module.exports=require(52)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/EVP_BytesToKey.js":52,"buffer":5}],122:[function(require,module,exports){
module.exports=require(53)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/aesid.json":53}],123:[function(require,module,exports){
module.exports=require(54)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/asn1.js":54,"asn1.js":127,"asn1.js-rfc3280":126}],124:[function(require,module,exports){
module.exports=require(55)
},{"./EVP_BytesToKey":121,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/fixProc.js":55,"buffer":5}],125:[function(require,module,exports){
module.exports=require(56)
},{"./aesid.json":122,"./asn1":123,"./fixProc":124,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/index.js":56,"buffer":5,"pemstrip":140}],126:[function(require,module,exports){
module.exports=require(57)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js-rfc3280/index.js":57,"asn1.js":127}],127:[function(require,module,exports){
module.exports=require(58)
},{"./asn1/api":128,"./asn1/base":130,"./asn1/constants":134,"./asn1/decoders":136,"./asn1/encoders":138,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1.js":58,"bn.js":119}],128:[function(require,module,exports){
module.exports=require(59)
},{"../asn1":127,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/api.js":59,"inherits":146,"vm":166}],129:[function(require,module,exports){
module.exports=require(60)
},{"../base":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/buffer.js":60,"buffer":5,"inherits":146}],130:[function(require,module,exports){
module.exports=require(61)
},{"./buffer":129,"./node":131,"./reporter":132,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/index.js":61}],131:[function(require,module,exports){
module.exports=require(62)
},{"../base":130,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/node.js":62,"minimalistic-assert":139}],132:[function(require,module,exports){
module.exports=require(63)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/base/reporter.js":63,"inherits":146}],133:[function(require,module,exports){
module.exports=require(64)
},{"../constants":134,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/der.js":64}],134:[function(require,module,exports){
module.exports=require(65)
},{"./der":133,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/constants/index.js":65}],135:[function(require,module,exports){
module.exports=require(66)
},{"../../asn1":127,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/der.js":66,"inherits":146}],136:[function(require,module,exports){
module.exports=require(67)
},{"./der":135,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/decoders/index.js":67}],137:[function(require,module,exports){
module.exports=require(68)
},{"../../asn1":127,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/der.js":68,"buffer":5,"inherits":146}],138:[function(require,module,exports){
module.exports=require(69)
},{"./der":137,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/lib/asn1/encoders/index.js":69}],139:[function(require,module,exports){
module.exports=require(70)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/asn1.js/node_modules/minimalistic-assert/index.js":70}],140:[function(require,module,exports){
module.exports=require(71)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/browserify-sign/node_modules/parse-asn1/node_modules/pemstrip/index.js":71}],141:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var crt = require('browserify-rsa');
module.exports = function (crypto) {
  return privateDecrypt;
  function privateDecrypt(private_key, enc) {
    var padding;
    if (private_key.padding) {
      padding = private_key.padding;
    } else {
      padding = 4;
    }
    
    var key = parseKeys(private_key, crypto);
    var k = key.modulus.byteLength();
    if (enc.length > k || new bn(enc).cmp(key.modulus) >= 0) {
      throw new Error('decryption error');
    }
    var msg = crt(enc, key, crypto);
    var zBuffer = new Buffer(k - msg.length);
    zBuffer.fill(0);
    msg = Buffer.concat([zBuffer, msg], k);
    if (padding === 4) {
      return oaep(key, msg, crypto);
    } else if (padding === 1) {
      return pkcs1(key, msg, crypto);
    } else if (padding === 3) {
      return msg;
    } else {
      throw new Error('unknown padding');
    }
  }
};

function oaep(key, msg, crypto){
  var n = key.modulus;
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = crypto.createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (msg[0] !== 0) {
    throw new Error('decryption error');
  }
  var maskedSeed = msg.slice(1, hLen + 1);
  var maskedDb =  msg.slice(hLen + 1);
  var seed = xor(maskedSeed, mgf(maskedDb, hLen, crypto));
  var db = xor(maskedDb, mgf(seed, k - hLen - 1, crypto));
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error');
  }
  var i = hLen;
  while (db[i] === 0) {
    i++;
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error');
  }
  return db.slice(i);
}

function pkcs1(key, msg, crypto){
  var p1 = msg.slice(0, 2);
  var i = 2;
  var status = 0;
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++;
      break;
    }
  }
  var ps = msg.slice(2, i - 1);
  var p2 = msg.slice(i - 1, i);

  if (p1.toString('hex') !== '0002') {
    status++;
  }
  if (ps.length < 8) {
    status++;
  }
  return  msg.slice(i);
}
function compare(a, b){
  var dif = 0;
  var len = a.length;
  if (a.length !== b.length) {
    dif++;
    len = Math.min(a.length, b.length);
  }
  var i = -1;
  while (++i < len) {
    dif += (a[i] ^ b[i]);
  }
  return dif;
}
}).call(this,require("buffer").Buffer)
},{"./mgf":118,"./xor":143,"bn.js":119,"browserify-rsa":120,"buffer":5,"parse-asn1":125}],142:[function(require,module,exports){
(function (Buffer){
var parseKeys = require('parse-asn1');
var mgf = require('./mgf');
var xor = require('./xor');
var bn = require('bn.js');
var constants = {
  RSA_PKCS1_OAEP_PADDING: 4,
  RSA_PKCS1_PADDIN: 1,
  RSA_NO_PADDING: 3
};

module.exports = function (crypto) {
  return publicEncrypt;
  function publicEncrypt(public_key, msg) {
    var padding;
    if (public_key.padding) {
      padding = public_key.padding;
    } else {
      padding = 4;
    }
    var key = parseKeys(public_key);
    var paddedMsg;
    if (padding === 4) {
      paddedMsg = oaep(key, msg, crypto);
    } else if (padding === 1) {
      paddedMsg = pkcs1(key, msg, crypto);
    } else if (padding === 3) {
      paddedMsg = new bn(msg);
      if (paddedMsg.cmp(key.modulus) >= 0) {
        throw new Error('data too long for modulus');
      }
    } else {
      throw new Error('unknown padding');
    }
    var enc = paddedMsg
      .toRed(bn.mont(key.modulus))
      .redPow(new bn(key.publicExponent))
      .fromRed()
      .toArray();
    return new Buffer(enc);
  }
};

function oaep(key, msg, crypto){
  var k = key.modulus.byteLength();
  var mLen = msg.length;
  var iHash = crypto.createHash('sha1').update(new Buffer('')).digest();
  var hLen = iHash.length;
  var hLen2 = 2 * hLen;
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long');
  }
  var ps = new Buffer(k - mLen - hLen2 - 2);
  ps.fill(0);
  var dblen = k - hLen - 1;
  var seed = crypto.randomBytes(hLen);
  var maskedDb = xor(Buffer.concat([iHash, ps, new Buffer([1]), msg], dblen), mgf(seed, dblen, crypto));
  var maskedSeed = xor(seed, mgf(maskedDb, hLen, crypto));
  return new bn(Buffer.concat([new Buffer([0]), maskedSeed, maskedDb], k));
}
function pkcs1(key, msg, crypto){
  var mLen = msg.length;
  var k = key.modulus.byteLength();
  if (mLen > k - 11) {
    throw new Error('message too long');
  }
  var ps = nonZero(k - mLen - 3, crypto);
  return new bn(Buffer.concat([new Buffer([0, 2]), ps, new Buffer([0]), msg], k));
}
function nonZero(len, crypto) {
  var out = new Buffer(len);
  var i = 0;
  var cache = crypto.randomBytes(len*2);
  var cur = 0;
  var num;
  while (i < len) {
    if (cur === cache.length) {
      cache = crypto.randomBytes(len*2);
      cur = 0;
    }
    num = cache[cur++];
    if (num) {
      out[i++] = num;
    }
  }
  return out;
}
}).call(this,require("buffer").Buffer)
},{"./mgf":118,"./xor":143,"bn.js":119,"buffer":5,"parse-asn1":125}],143:[function(require,module,exports){
module.exports = function xor(a, b) {
  var len = a.length;
  var i = -1;
  while (++i < len) {
    a[i] ^= b[i];
  }
  return a
};
},{}],144:[function(require,module,exports){
(function (process,global,Buffer){
'use strict';

var crypto = global.crypto || global.msCrypto
if(crypto && crypto.getRandomValues) {
  module.exports = randomBytes;
} else {
  module.exports = oldBrowser;
}
function randomBytes(size, cb) {
  var bytes = new Buffer(size); //in browserify, this is an extended Uint8Array
    /* This will not work in older browsers.
     * See https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
     */

  crypto.getRandomValues(bytes);
  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes);
    });
  }
  return bytes;
}
function oldBrowser() {
  throw new Error(
      'secure random number generation not supported by this browser\n'+
      'use chrome, FireFox or Internet Explorer 11'
    )
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"_process":149,"buffer":5}],145:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        len = arguments.length;
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    len = arguments.length;
    args = new Array(len - 1);
    for (i = 1; i < len; i++)
      args[i - 1] = arguments[i];

    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    var m;
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.listenerCount = function(emitter, type) {
  var ret;
  if (!emitter._events || !emitter._events[type])
    ret = 0;
  else if (isFunction(emitter._events[type]))
    ret = 1;
  else
    ret = emitter._events[type].length;
  return ret;
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],146:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],147:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],148:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))
},{"_process":149}],149:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],150:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],151:[function(require,module,exports){
module.exports = require("./lib/_stream_duplex.js")

},{"./lib/_stream_duplex.js":152}],152:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

module.exports = Duplex;

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}
/*</replacement>*/


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

forEach(objectKeys(Writable.prototype), function(method) {
  if (!Duplex.prototype[method])
    Duplex.prototype[method] = Writable.prototype[method];
});

function Duplex(options) {
  if (!(this instanceof Duplex))
    return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false)
    this.readable = false;

  if (options && options.writable === false)
    this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false)
    this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended)
    return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  process.nextTick(this.end.bind(this));
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

}).call(this,require('_process'))
},{"./_stream_readable":154,"./_stream_writable":156,"_process":149,"core-util-is":157,"inherits":146}],153:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough))
    return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function(chunk, encoding, cb) {
  cb(null, chunk);
};

},{"./_stream_transform":155,"core-util-is":157,"inherits":146}],154:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/


/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Readable.ReadableState = ReadableState;

var EE = require('events').EventEmitter;

/*<replacement>*/
if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

var Stream = require('stream');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var StringDecoder;

util.inherits(Readable, Stream);

function ReadableState(options, stream) {
  options = options || {};

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.buffer = [];
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = false;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // In streams that never have any data, and do push(null) right away,
  // the consumer can miss the 'end' event if they do some I/O before
  // consuming the stream.  So, we don't emit('end') until some reading
  // happens.
  this.calledRead = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;


  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // when piping, we only care about 'readable' events that happen
  // after read()ing all the bytes and not getting any pushback.
  this.ranOut = false;

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder)
      StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  Stream.call(this);
}

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function(chunk, encoding) {
  var state = this._readableState;

  if (typeof chunk === 'string' && !state.objectMode) {
    encoding = encoding || state.defaultEncoding;
    if (encoding !== state.encoding) {
      chunk = new Buffer(chunk, encoding);
      encoding = '';
    }
  }

  return readableAddChunk(this, state, chunk, encoding, false);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function(chunk) {
  var state = this._readableState;
  return readableAddChunk(this, state, chunk, '', true);
};

function readableAddChunk(stream, state, chunk, encoding, addToFront) {
  var er = chunkInvalid(state, chunk);
  if (er) {
    stream.emit('error', er);
  } else if (chunk === null || chunk === undefined) {
    state.reading = false;
    if (!state.ended)
      onEofChunk(stream, state);
  } else if (state.objectMode || chunk && chunk.length > 0) {
    if (state.ended && !addToFront) {
      var e = new Error('stream.push() after EOF');
      stream.emit('error', e);
    } else if (state.endEmitted && addToFront) {
      var e = new Error('stream.unshift() after end event');
      stream.emit('error', e);
    } else {
      if (state.decoder && !addToFront && !encoding)
        chunk = state.decoder.write(chunk);

      // update the buffer info.
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront) {
        state.buffer.unshift(chunk);
      } else {
        state.reading = false;
        state.buffer.push(chunk);
      }

      if (state.needReadable)
        emitReadable(stream);

      maybeReadMore(stream, state);
    }
  } else if (!addToFront) {
    state.reading = false;
  }

  return needMoreData(state);
}



// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended &&
         (state.needReadable ||
          state.length < state.highWaterMark ||
          state.length === 0);
}

// backwards compatibility.
Readable.prototype.setEncoding = function(enc) {
  if (!StringDecoder)
    StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
};

// Don't raise the hwm > 128MB
var MAX_HWM = 0x800000;
function roundUpToNextPowerOf2(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2
    n--;
    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
    n++;
  }
  return n;
}

function howMuchToRead(n, state) {
  if (state.length === 0 && state.ended)
    return 0;

  if (state.objectMode)
    return n === 0 ? 0 : 1;

  if (n === null || isNaN(n)) {
    // only flow one buffer at a time
    if (state.flowing && state.buffer.length)
      return state.buffer[0].length;
    else
      return state.length;
  }

  if (n <= 0)
    return 0;

  // If we're asking for more than the target buffer level,
  // then raise the water mark.  Bump up to the next highest
  // power of 2, to prevent increasing it excessively in tiny
  // amounts.
  if (n > state.highWaterMark)
    state.highWaterMark = roundUpToNextPowerOf2(n);

  // don't have that much.  return null, unless we've ended.
  if (n > state.length) {
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    } else
      return state.length;
  }

  return n;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function(n) {
  var state = this._readableState;
  state.calledRead = true;
  var nOrig = n;
  var ret;

  if (typeof n !== 'number' || n > 0)
    state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 &&
      state.needReadable &&
      (state.length >= state.highWaterMark || state.ended)) {
    emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    ret = null;

    // In cases where the decoder did not receive enough data
    // to produce a full chunk, then immediately received an
    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
    // howMuchToRead will see this and coerce the amount to
    // read to zero (because it's looking at the length of the
    // first <Buffer > in state.buffer), and we'll end up here.
    //
    // This can only happen via state.decoder -- no other venue
    // exists for pushing a zero-length chunk into state.buffer
    // and triggering this behavior. In this case, we return our
    // remaining data and end the stream, if appropriate.
    if (state.length > 0 && state.decoder) {
      ret = fromList(n, state);
      state.length -= ret.length;
    }

    if (state.length === 0)
      endReadable(this);

    return ret;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;

  // if we currently have less than the highWaterMark, then also read some
  if (state.length - n <= state.highWaterMark)
    doRead = true;

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading)
    doRead = false;

  if (doRead) {
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0)
      state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
  }

  // If _read called its callback synchronously, then `reading`
  // will be false, and we need to re-evaluate how much data we
  // can return to the user.
  if (doRead && !state.reading)
    n = howMuchToRead(nOrig, state);

  if (n > 0)
    ret = fromList(n, state);
  else
    ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  }

  state.length -= n;

  // If we have nothing in the buffer, then we want to know
  // as soon as we *do* get something into the buffer.
  if (state.length === 0 && !state.ended)
    state.needReadable = true;

  // If we happened to read() exactly the remaining amount in the
  // buffer, and the EOF has been seen at this point, then make sure
  // that we emit 'end' on the very next tick.
  if (state.ended && !state.endEmitted && state.length === 0)
    endReadable(this);

  return ret;
};

function chunkInvalid(state, chunk) {
  var er = null;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}


function onEofChunk(stream, state) {
  if (state.decoder && !state.ended) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // if we've ended and we have some data left, then emit
  // 'readable' now to make sure it gets picked up.
  if (state.length > 0)
    emitReadable(stream);
  else
    endReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (state.emittedReadable)
    return;

  state.emittedReadable = true;
  if (state.sync)
    process.nextTick(function() {
      emitReadable_(stream);
    });
  else
    emitReadable_(stream);
}

function emitReadable_(stream) {
  stream.emit('readable');
}


// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(function() {
      maybeReadMore_(stream, state);
    });
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended &&
         state.length < state.highWaterMark) {
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;
    else
      len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function(n) {
  this.emit('error', new Error('not implemented'));
};

Readable.prototype.pipe = function(dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;

  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
              dest !== process.stdout &&
              dest !== process.stderr;

  var endFn = doEnd ? onend : cleanup;
  if (state.endEmitted)
    process.nextTick(endFn);
  else
    src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable) {
    if (readable !== src) return;
    cleanup();
  }

  function onend() {
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  function cleanup() {
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', cleanup);

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (!dest._writableState || dest._writableState.needDrain)
      ondrain();
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    unpipe();
    dest.removeListener('error', onerror);
    if (EE.listenerCount(dest, 'error') === 0)
      dest.emit('error', er);
  }
  // This is a brutally ugly hack to make sure that our error handler
  // is attached before any userland ones.  NEVER DO THIS.
  if (!dest._events || !dest._events.error)
    dest.on('error', onerror);
  else if (isArray(dest._events.error))
    dest._events.error.unshift(onerror);
  else
    dest._events.error = [onerror, dest._events.error];



  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    // the handler that waits for readable events after all
    // the data gets sucked out in flow.
    // This would be easier to follow with a .once() handler
    // in flow(), but that is too slow.
    this.on('readable', pipeOnReadable);

    state.flowing = true;
    process.nextTick(function() {
      flow(src);
    });
  }

  return dest;
};

function pipeOnDrain(src) {
  return function() {
    var dest = this;
    var state = src._readableState;
    state.awaitDrain--;
    if (state.awaitDrain === 0)
      flow(src);
  };
}

function flow(src) {
  var state = src._readableState;
  var chunk;
  state.awaitDrain = 0;

  function write(dest, i, list) {
    var written = dest.write(chunk);
    if (false === written) {
      state.awaitDrain++;
    }
  }

  while (state.pipesCount && null !== (chunk = src.read())) {

    if (state.pipesCount === 1)
      write(state.pipes, 0, null);
    else
      forEach(state.pipes, write);

    src.emit('data', chunk);

    // if anyone needs a drain, then we have to wait for that.
    if (state.awaitDrain > 0)
      return;
  }

  // if every destination was unpiped, either before entering this
  // function, or in the while loop, then stop flowing.
  //
  // NB: This is a pretty rare edge case.
  if (state.pipesCount === 0) {
    state.flowing = false;

    // if there were data event listeners added, then switch to old mode.
    if (EE.listenerCount(src, 'data') > 0)
      emitDataEvents(src);
    return;
  }

  // at this point, no one needed a drain, so we just ran out of data
  // on the next readable event, start it over again.
  state.ranOut = true;
}

function pipeOnReadable() {
  if (this._readableState.ranOut) {
    this._readableState.ranOut = false;
    flow(this);
  }
}


Readable.prototype.unpipe = function(dest) {
  var state = this._readableState;

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0)
    return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes)
      return this;

    if (!dest)
      dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;
    if (dest)
      dest.emit('unpipe', this);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    this.removeListener('readable', pipeOnReadable);
    state.flowing = false;

    for (var i = 0; i < len; i++)
      dests[i].emit('unpipe', this);
    return this;
  }

  // try to find the right one.
  var i = indexOf(state.pipes, dest);
  if (i === -1)
    return this;

  state.pipes.splice(i, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1)
    state.pipes = state.pipes[0];

  dest.emit('unpipe', this);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function(ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data' && !this._readableState.flowing)
    emitDataEvents(this);

  if (ev === 'readable' && this.readable) {
    var state = this._readableState;
    if (!state.readableListening) {
      state.readableListening = true;
      state.emittedReadable = false;
      state.needReadable = true;
      if (!state.reading) {
        this.read(0);
      } else if (state.length) {
        emitReadable(this, state);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function() {
  emitDataEvents(this);
  this.read(0);
  this.emit('resume');
};

Readable.prototype.pause = function() {
  emitDataEvents(this, true);
  this.emit('pause');
};

function emitDataEvents(stream, startPaused) {
  var state = stream._readableState;

  if (state.flowing) {
    // https://github.com/isaacs/readable-stream/issues/16
    throw new Error('Cannot switch to old mode now.');
  }

  var paused = startPaused || false;
  var readable = false;

  // convert to an old-style stream.
  stream.readable = true;
  stream.pipe = Stream.prototype.pipe;
  stream.on = stream.addListener = Stream.prototype.on;

  stream.on('readable', function() {
    readable = true;

    var c;
    while (!paused && (null !== (c = stream.read())))
      stream.emit('data', c);

    if (c === null) {
      readable = false;
      stream._readableState.needReadable = true;
    }
  });

  stream.pause = function() {
    paused = true;
    this.emit('pause');
  };

  stream.resume = function() {
    paused = false;
    if (readable)
      process.nextTick(function() {
        stream.emit('readable');
      });
    else
      this.read(0);
    this.emit('resume');
  };

  // now make it start, just in case it hadn't already.
  stream.emit('readable');
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function(stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function() {
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length)
        self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function(chunk) {
    if (state.decoder)
      chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    //if (state.objectMode && util.isNullOrUndefined(chunk))
    if (state.objectMode && (chunk === null || chunk === undefined))
      return;
    else if (!state.objectMode && (!chunk || !chunk.length))
      return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (typeof stream[i] === 'function' &&
        typeof this[i] === 'undefined') {
      this[i] = function(method) { return function() {
        return stream[method].apply(stream, arguments);
      }}(i);
    }
  }

  // proxy certain important events.
  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
  forEach(events, function(ev) {
    stream.on(ev, self.emit.bind(self, ev));
  });

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function(n) {
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};



// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
function fromList(n, state) {
  var list = state.buffer;
  var length = state.length;
  var stringMode = !!state.decoder;
  var objectMode = !!state.objectMode;
  var ret;

  // nothing in the list, definitely empty.
  if (list.length === 0)
    return null;

  if (length === 0)
    ret = null;
  else if (objectMode)
    ret = list.shift();
  else if (!n || n >= length) {
    // read it all, truncate the array.
    if (stringMode)
      ret = list.join('');
    else
      ret = Buffer.concat(list, length);
    list.length = 0;
  } else {
    // read just some of it.
    if (n < list[0].length) {
      // just take a part of the first list item.
      // slice is the same for buffers and strings.
      var buf = list[0];
      ret = buf.slice(0, n);
      list[0] = buf.slice(n);
    } else if (n === list[0].length) {
      // first list is a perfect match
      ret = list.shift();
    } else {
      // complex case.
      // we have enough to cover it, but it spans past the first buffer.
      if (stringMode)
        ret = '';
      else
        ret = new Buffer(n);

      var c = 0;
      for (var i = 0, l = list.length; i < l && c < n; i++) {
        var buf = list[0];
        var cpy = Math.min(n - c, buf.length);

        if (stringMode)
          ret += buf.slice(0, cpy);
        else
          buf.copy(ret, c, 0, cpy);

        if (cpy < buf.length)
          list[0] = buf.slice(cpy);
        else
          list.shift();

        c += cpy;
      }
    }
  }

  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0)
    throw new Error('endReadable called on non-empty stream');

  if (!state.endEmitted && state.calledRead) {
    state.ended = true;
    process.nextTick(function() {
      // Check that we didn't get one last unshift.
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit('end');
      }
    });
  }
}

function forEach (xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf (xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}

}).call(this,require('_process'))
},{"_process":149,"buffer":5,"core-util-is":157,"events":145,"inherits":146,"isarray":147,"stream":163,"string_decoder/":158}],155:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);


function TransformState(options, stream) {
  this.afterTransform = function(er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb)
    return stream.emit('error', new Error('no writecb in Transform class'));

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined)
    stream.push(data);

  if (cb)
    cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}


function Transform(options) {
  if (!(this instanceof Transform))
    return new Transform(options);

  Duplex.call(this, options);

  var ts = this._transformState = new TransformState(options, this);

  // when the writable side finishes, then flush out anything remaining.
  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  this.once('finish', function() {
    if ('function' === typeof this._flush)
      this._flush(function(er) {
        done(stream, er);
      });
    else
      done(stream);
  });
}

Transform.prototype.push = function(chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function(chunk, encoding, cb) {
  throw new Error('not implemented');
};

Transform.prototype._write = function(chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform ||
        rs.needReadable ||
        rs.length < rs.highWaterMark)
      this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function(n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};


function done(stream, er) {
  if (er)
    return stream.emit('error', er);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var rs = stream._readableState;
  var ts = stream._transformState;

  if (ws.length)
    throw new Error('calling transform done when ws.length != 0');

  if (ts.transforming)
    throw new Error('calling transform done when still transforming');

  return stream.push(null);
}

},{"./_stream_duplex":152,"core-util-is":157,"inherits":146}],156:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, cb), and it'll handle all
// the drain event emission and buffering.

module.exports = Writable;

/*<replacement>*/
var Buffer = require('buffer').Buffer;
/*</replacement>*/

Writable.WritableState = WritableState;


/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Stream = require('stream');

util.inherits(Writable, Stream);

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
}

function WritableState(options, stream) {
  options = options || {};

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  // cast to ints.
  this.highWaterMark = ~~this.highWaterMark;

  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, becuase any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function(er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.buffer = [];

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;
}

function Writable(options) {
  var Duplex = require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, though they're not
  // instanceof Writable, they're instanceof Readable.
  if (!(this instanceof Writable) && !(this instanceof Duplex))
    return new Writable(options);

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function() {
  this.emit('error', new Error('Cannot pipe. Not readable.'));
};


function writeAfterEnd(stream, state, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  process.nextTick(function() {
    cb(er);
  });
}

// If we get something that is not a buffer, string, null, or undefined,
// and we're not in objectMode, then that's an error.
// Otherwise stream chunks are all considered to be of length=1, and the
// watermarks determine how many objects to keep in the buffer, rather than
// how many bytes or characters.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  if (!Buffer.isBuffer(chunk) &&
      'string' !== typeof chunk &&
      chunk !== null &&
      chunk !== undefined &&
      !state.objectMode) {
    var er = new TypeError('Invalid non-string/buffer chunk');
    stream.emit('error', er);
    process.nextTick(function() {
      cb(er);
    });
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function(chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  else if (!encoding)
    encoding = state.defaultEncoding;

  if (typeof cb !== 'function')
    cb = function() {};

  if (state.ended)
    writeAfterEnd(this, state, cb);
  else if (validChunk(this, state, chunk, cb))
    ret = writeOrBuffer(this, state, chunk, encoding, cb);

  return ret;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode &&
      state.decodeStrings !== false &&
      typeof chunk === 'string') {
    chunk = new Buffer(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, chunk, encoding, cb) {
  chunk = decodeChunk(state, chunk, encoding);
  if (Buffer.isBuffer(chunk))
    encoding = 'buffer';
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret)
    state.needDrain = true;

  if (state.writing)
    state.buffer.push(new WriteReq(chunk, encoding, cb));
  else
    doWrite(stream, state, len, chunk, encoding, cb);

  return ret;
}

function doWrite(stream, state, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  if (sync)
    process.nextTick(function() {
      cb(er);
    });
  else
    cb(er);

  stream._writableState.errorEmitted = true;
  stream.emit('error', er);
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er)
    onwriteError(stream, state, sync, er, cb);
  else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(stream, state);

    if (!finished && !state.bufferProcessing && state.buffer.length)
      clearBuffer(stream, state);

    if (sync) {
      process.nextTick(function() {
        afterWrite(stream, state, finished, cb);
      });
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished)
    onwriteDrain(stream, state);
  cb();
  if (finished)
    finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}


// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;

  for (var c = 0; c < state.buffer.length; c++) {
    var entry = state.buffer[c];
    var chunk = entry.chunk;
    var encoding = entry.encoding;
    var cb = entry.callback;
    var len = state.objectMode ? 1 : chunk.length;

    doWrite(stream, state, len, chunk, encoding, cb);

    // if we didn't call the onwrite immediately, then
    // it means that we need to wait until it does.
    // also, that means that the chunk and cb are currently
    // being processed, so move the buffer counter past them.
    if (state.writing) {
      c++;
      break;
    }
  }

  state.bufferProcessing = false;
  if (c < state.buffer.length)
    state.buffer = state.buffer.slice(c);
  else
    state.buffer.length = 0;
}

Writable.prototype._write = function(chunk, encoding, cb) {
  cb(new Error('not implemented'));
};

Writable.prototype.end = function(chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (typeof chunk !== 'undefined' && chunk !== null)
    this.write(chunk, encoding);

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished)
    endWritable(this, state, cb);
};


function needFinish(stream, state) {
  return (state.ending &&
          state.length === 0 &&
          !state.finished &&
          !state.writing);
}

function finishMaybe(stream, state) {
  var need = needFinish(stream, state);
  if (need) {
    state.finished = true;
    stream.emit('finish');
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished)
      process.nextTick(cb);
    else
      stream.once('finish', cb);
  }
  state.ended = true;
}

}).call(this,require('_process'))
},{"./_stream_duplex":152,"_process":149,"buffer":5,"core-util-is":157,"inherits":146,"stream":163}],157:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

function isBuffer(arg) {
  return Buffer.isBuffer(arg);
}
exports.isBuffer = isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
}).call(this,require("buffer").Buffer)
},{"buffer":5}],158:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":5}],159:[function(require,module,exports){
module.exports = require("./lib/_stream_passthrough.js")

},{"./lib/_stream_passthrough.js":153}],160:[function(require,module,exports){
var Stream = require('stream'); // hack to fix a circular dependency issue when used with browserify
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = Stream;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":152,"./lib/_stream_passthrough.js":153,"./lib/_stream_readable.js":154,"./lib/_stream_transform.js":155,"./lib/_stream_writable.js":156,"stream":163}],161:[function(require,module,exports){
module.exports = require("./lib/_stream_transform.js")

},{"./lib/_stream_transform.js":155}],162:[function(require,module,exports){
module.exports = require("./lib/_stream_writable.js")

},{"./lib/_stream_writable.js":156}],163:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":145,"inherits":146,"readable-stream/duplex.js":151,"readable-stream/passthrough.js":159,"readable-stream/readable.js":160,"readable-stream/transform.js":161,"readable-stream/writable.js":162}],164:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],165:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":164,"_process":149,"inherits":146}],166:[function(require,module,exports){
var indexOf = require('indexof');

var Object_keys = function (obj) {
    if (Object.keys) return Object.keys(obj)
    else {
        var res = [];
        for (var key in obj) res.push(key)
        return res;
    }
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

var defineProp = (function() {
    try {
        Object.defineProperty({}, '_', {});
        return function(obj, name, value) {
            Object.defineProperty(obj, name, {
                writable: true,
                enumerable: false,
                configurable: true,
                value: value
            })
        };
    } catch(e) {
        return function(obj, name, value) {
            obj[name] = value;
        };
    }
}());

var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

function Context() {}
Context.prototype = {};

var Script = exports.Script = function NodeScript (code) {
    if (!(this instanceof Script)) return new Script(code);
    this.code = code;
};

Script.prototype.runInContext = function (context) {
    if (!(context instanceof Context)) {
        throw new TypeError("needs a 'context' argument.");
    }
    
    var iframe = document.createElement('iframe');
    if (!iframe.style) iframe.style = {};
    iframe.style.display = 'none';
    
    document.body.appendChild(iframe);
    
    var win = iframe.contentWindow;
    var wEval = win.eval, wExecScript = win.execScript;

    if (!wEval && wExecScript) {
        // win.eval() magically appears when this is called in IE:
        wExecScript.call(win, 'null');
        wEval = win.eval;
    }
    
    forEach(Object_keys(context), function (key) {
        win[key] = context[key];
    });
    forEach(globals, function (key) {
        if (context[key]) {
            win[key] = context[key];
        }
    });
    
    var winKeys = Object_keys(win);

    var res = wEval.call(win, this.code);
    
    forEach(Object_keys(win), function (key) {
        // Avoid copying circular objects like `top` and `window` by only
        // updating existing context properties or new properties in the `win`
        // that was only introduced after the eval.
        if (key in context || indexOf(winKeys, key) === -1) {
            context[key] = win[key];
        }
    });

    forEach(globals, function (key) {
        if (!(key in context)) {
            defineProp(context, key, win[key]);
        }
    });
    
    document.body.removeChild(iframe);
    
    return res;
};

Script.prototype.runInThisContext = function () {
    return eval(this.code); // maybe...
};

Script.prototype.runInNewContext = function (context) {
    var ctx = Script.createContext(context);
    var res = this.runInContext(ctx);

    forEach(Object_keys(ctx), function (key) {
        context[key] = ctx[key];
    });

    return res;
};

forEach(Object_keys(Script.prototype), function (name) {
    exports[name] = Script[name] = function (code) {
        var s = Script(code);
        return s[name].apply(s, [].slice.call(arguments, 1));
    };
});

exports.createScript = function (code) {
    return exports.Script(code);
};

exports.createContext = Script.createContext = function (context) {
    var copy = new Context();
    if(typeof context === 'object') {
        forEach(Object_keys(context), function (key) {
            copy[key] = context[key];
        });
    }
    return copy;
};

},{"indexof":167}],167:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],168:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;

/**
 * Use chrome.storage.local if we are in an app
 */

var storage;

if (typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined')
  storage = chrome.storage.local;
else
  storage = window.localStorage;

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      storage.removeItem('debug');
    } else {
      storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

},{"./debug":169}],169:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":170}],170:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  var match = /^((?:\d+)?\.?\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 's':
      return n * s;
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],171:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2012 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var utils = require('./utils')
  , path = require('path')
  , dirname = path.dirname
  , extname = path.extname
  , join = path.join
  , fs = require('fs')
  , read = fs.readFileSync;

/**
 * Filters.
 *
 * @type Object
 */

var filters = exports.filters = require('./filters');

/**
 * Intermediate js cache.
 *
 * @type Object
 */

var cache = {};

/**
 * Clear intermediate js cache.
 *
 * @api public
 */

exports.clearCache = function(){
  cache = {};
};

/**
 * Translate filtered code into function calls.
 *
 * @param {String} js
 * @return {String}
 * @api private
 */

function filtered(js) {
  return js.substr(1).split('|').reduce(function(js, filter){
    var parts = filter.split(':')
      , name = parts.shift()
      , args = parts.join(':') || '';
    if (args) args = ', ' + args;
    return 'filters.' + name + '(' + js + args + ')';
  });
};

/**
 * Re-throw the given `err` in context to the
 * `str` of ejs, `filename`, and `lineno`.
 *
 * @param {Error} err
 * @param {String} str
 * @param {String} filename
 * @param {String} lineno
 * @api private
 */

function rethrow(err, str, filename, lineno){
  var lines = str.split('\n')
    , start = Math.max(lineno - 3, 0)
    , end = Math.min(lines.length, lineno + 3);

  // Error context
  var context = lines.slice(start, end).map(function(line, i){
    var curr = i + start + 1;
    return (curr == lineno ? ' >> ' : '    ')
      + curr
      + '| '
      + line;
  }).join('\n');

  // Alter exception message
  err.path = filename;
  err.message = (filename || 'ejs') + ':'
    + lineno + '\n'
    + context + '\n\n'
    + err.message;

  throw err;
}

/**
 * Parse the given `str` of ejs, returning the function body.
 *
 * @param {String} str
 * @return {String}
 * @api public
 */

var parse = exports.parse = function(str, options){
  var options = options || {}
    , open = options.open || exports.open || '<%'
    , close = options.close || exports.close || '%>'
    , filename = options.filename
    , compileDebug = options.compileDebug !== false
    , buf = "";

  buf += 'var buf = [];';
  if (false !== options._with) buf += '\nwith (locals || {}) { (function(){ ';
  buf += '\n buf.push(\'';

  var lineno = 1;

  var consumeEOL = false;
  for (var i = 0, len = str.length; i < len; ++i) {
    var stri = str[i];
    if (str.slice(i, open.length + i) == open) {
      i += open.length

      var prefix, postfix, line = (compileDebug ? '__stack.lineno=' : '') + lineno;
      switch (str[i]) {
        case '=':
          prefix = "', escape((" + line + ', ';
          postfix = ")), '";
          ++i;
          break;
        case '-':
          prefix = "', (" + line + ', ';
          postfix = "), '";
          ++i;
          break;
        default:
          prefix = "');" + line + ';';
          postfix = "; buf.push('";
      }

      var end = str.indexOf(close, i);

      if (end < 0){
        throw new Error('Could not find matching close tag "' + close + '".');
      }

      var js = str.substring(i, end)
        , start = i
        , include = null
        , n = 0;

      if ('-' == js[js.length-1]){
        js = js.substring(0, js.length - 2);
        consumeEOL = true;
      }

      if (0 == js.trim().indexOf('include')) {
        var name = js.trim().slice(7).trim();
        if (!filename) throw new Error('filename option is required for includes');
        var path = resolveInclude(name, filename);
        include = read(path, 'utf8');
        include = exports.parse(include, { filename: path, _with: false, open: open, close: close, compileDebug: compileDebug });
        buf += "' + (function(){" + include + "})() + '";
        js = '';
      }

      while (~(n = js.indexOf("\n", n))) n++, lineno++;
      if (js.substr(0, 1) == ':') js = filtered(js);
      if (js) {
        if (js.lastIndexOf('//') > js.lastIndexOf('\n')) js += '\n';
        buf += prefix;
        buf += js;
        buf += postfix;
      }
      i += end - start + close.length - 1;

    } else if (stri == "\\") {
      buf += "\\\\";
    } else if (stri == "'") {
      buf += "\\'";
    } else if (stri == "\r") {
      // ignore
    } else if (stri == "\n") {
      if (consumeEOL) {
        consumeEOL = false;
      } else {
        buf += "\\n";
        lineno++;
      }
    } else {
      buf += stri;
    }
  }

  if (false !== options._with) buf += "'); })();\n} \nreturn buf.join('');";
  else buf += "');\nreturn buf.join('');";
  return buf;
};

/**
 * Compile the given `str` of ejs into a `Function`.
 *
 * @param {String} str
 * @param {Object} options
 * @return {Function}
 * @api public
 */

var compile = exports.compile = function(str, options){
  options = options || {};
  var escape = options.escape || utils.escape;

  var input = JSON.stringify(str)
    , compileDebug = options.compileDebug !== false
    , client = options.client
    , filename = options.filename
        ? JSON.stringify(options.filename)
        : 'undefined';

  if (compileDebug) {
    // Adds the fancy stack trace meta info
    str = [
      'var __stack = { lineno: 1, input: ' + input + ', filename: ' + filename + ' };',
      rethrow.toString(),
      'try {',
      exports.parse(str, options),
      '} catch (err) {',
      '  rethrow(err, __stack.input, __stack.filename, __stack.lineno);',
      '}'
    ].join("\n");
  } else {
    str = exports.parse(str, options);
  }

  if (options.debug) console.log(str);
  if (client) str = 'escape = escape || ' + escape.toString() + ';\n' + str;

  try {
    var fn = new Function('locals, filters, escape, rethrow', str);
  } catch (err) {
    if ('SyntaxError' == err.name) {
      err.message += options.filename
        ? ' in ' + filename
        : ' while compiling ejs';
    }
    throw err;
  }

  if (client) return fn;

  return function(locals){
    return fn.call(this, locals, filters, escape, rethrow);
  }
};

/**
 * Render the given `str` of ejs.
 *
 * Options:
 *
 *   - `locals`          Local variables object
 *   - `cache`           Compiled functions are cached, requires `filename`
 *   - `filename`        Used by `cache` to key caches
 *   - `scope`           Function execution context
 *   - `debug`           Output generated function body
 *   - `open`            Open tag, defaulting to "<%"
 *   - `close`           Closing tag, defaulting to "%>"
 *
 * @param {String} str
 * @param {Object} options
 * @return {String}
 * @api public
 */

exports.render = function(str, options){
  var fn
    , options = options || {};

  if (options.cache) {
    if (options.filename) {
      fn = cache[options.filename] || (cache[options.filename] = compile(str, options));
    } else {
      throw new Error('"cache" option requires "filename".');
    }
  } else {
    fn = compile(str, options);
  }

  options.__proto__ = options.locals;
  return fn.call(options.scope, options);
};

/**
 * Render an EJS file at the given `path` and callback `fn(err, str)`.
 *
 * @param {String} path
 * @param {Object|Function} options or callback
 * @param {Function} fn
 * @api public
 */

exports.renderFile = function(path, options, fn){
  var key = path + ':string';

  if ('function' == typeof options) {
    fn = options, options = {};
  }

  options.filename = path;

  var str;
  try {
    str = options.cache
      ? cache[key] || (cache[key] = read(path, 'utf8'))
      : read(path, 'utf8');
  } catch (err) {
    fn(err);
    return;
  }
  fn(null, exports.render(str, options));
};

/**
 * Resolve include `name` relative to `filename`.
 *
 * @param {String} name
 * @param {String} filename
 * @return {String}
 * @api private
 */

function resolveInclude(name, filename) {
  var path = join(dirname(filename), name);
  var ext = extname(name);
  if (!ext) path += '.ejs';
  return path;
}

// express support

exports.__express = exports.renderFile;

/**
 * Expose to require().
 */

if (require.extensions) {
  require.extensions['.ejs'] = function (module, filename) {
    filename = filename || module.filename;
    var options = { filename: filename, client: true }
      , template = fs.readFileSync(filename).toString()
      , fn = compile(template, options);
    module._compile('module.exports = ' + fn.toString() + ';', filename);
  };
} else if (require.registerExtension) {
  require.registerExtension('.ejs', function(src) {
    return compile(src, {});
  });
}

},{"./filters":172,"./utils":173,"fs":3,"path":148}],172:[function(require,module,exports){
/*!
 * EJS - Filters
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * First element of the target `obj`.
 */

exports.first = function(obj) {
  return obj[0];
};

/**
 * Last element of the target `obj`.
 */

exports.last = function(obj) {
  return obj[obj.length - 1];
};

/**
 * Capitalize the first letter of the target `str`.
 */

exports.capitalize = function(str){
  str = String(str);
  return str[0].toUpperCase() + str.substr(1, str.length);
};

/**
 * Downcase the target `str`.
 */

exports.downcase = function(str){
  return String(str).toLowerCase();
};

/**
 * Uppercase the target `str`.
 */

exports.upcase = function(str){
  return String(str).toUpperCase();
};

/**
 * Sort the target `obj`.
 */

exports.sort = function(obj){
  return Object.create(obj).sort();
};

/**
 * Sort the target `obj` by the given `prop` ascending.
 */

exports.sort_by = function(obj, prop){
  return Object.create(obj).sort(function(a, b){
    a = a[prop], b = b[prop];
    if (a > b) return 1;
    if (a < b) return -1;
    return 0;
  });
};

/**
 * Size or length of the target `obj`.
 */

exports.size = exports.length = function(obj) {
  return obj.length;
};

/**
 * Add `a` and `b`.
 */

exports.plus = function(a, b){
  return Number(a) + Number(b);
};

/**
 * Subtract `b` from `a`.
 */

exports.minus = function(a, b){
  return Number(a) - Number(b);
};

/**
 * Multiply `a` by `b`.
 */

exports.times = function(a, b){
  return Number(a) * Number(b);
};

/**
 * Divide `a` by `b`.
 */

exports.divided_by = function(a, b){
  return Number(a) / Number(b);
};

/**
 * Join `obj` with the given `str`.
 */

exports.join = function(obj, str){
  return obj.join(str || ', ');
};

/**
 * Truncate `str` to `len`.
 */

exports.truncate = function(str, len, append){
  str = String(str);
  if (str.length > len) {
    str = str.slice(0, len);
    if (append) str += append;
  }
  return str;
};

/**
 * Truncate `str` to `n` words.
 */

exports.truncate_words = function(str, n){
  var str = String(str)
    , words = str.split(/ +/);
  return words.slice(0, n).join(' ');
};

/**
 * Replace `pattern` with `substitution` in `str`.
 */

exports.replace = function(str, pattern, substitution){
  return String(str).replace(pattern, substitution || '');
};

/**
 * Prepend `val` to `obj`.
 */

exports.prepend = function(obj, val){
  return Array.isArray(obj)
    ? [val].concat(obj)
    : val + obj;
};

/**
 * Append `val` to `obj`.
 */

exports.append = function(obj, val){
  return Array.isArray(obj)
    ? obj.concat(val)
    : obj + val;
};

/**
 * Map the given `prop`.
 */

exports.map = function(arr, prop){
  return arr.map(function(obj){
    return obj[prop];
  });
};

/**
 * Reverse the given `obj`.
 */

exports.reverse = function(obj){
  return Array.isArray(obj)
    ? obj.reverse()
    : String(obj).split('').reverse().join('');
};

/**
 * Get `prop` of the given `obj`.
 */

exports.get = function(obj, prop){
  return obj[prop];
};

/**
 * Packs the given `obj` into json string
 */
exports.json = function(obj){
  return JSON.stringify(obj);
};

},{}],173:[function(require,module,exports){

/*!
 * EJS
 * Copyright(c) 2010 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Escape the given string of `html`.
 *
 * @param {String} html
 * @return {String}
 * @api private
 */

exports.escape = function(html){
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/'/g, '&#39;')
    .replace(/"/g, '&quot;');
};
 

},{}],174:[function(require,module,exports){
'use strict';

var isEmpty = require('es5-ext/object/is-empty')
  , value   = require('es5-ext/object/valid-value')

  , hasOwnProperty = Object.prototype.hasOwnProperty;

module.exports = function (obj/*, type*/) {
	var type;
	value(obj);
	type = arguments[1];
	if (arguments.length > 1) {
		return hasOwnProperty.call(obj, '__ee__') && Boolean(obj.__ee__[type]);
	}
	return obj.hasOwnProperty('__ee__') && !isEmpty(obj.__ee__);
};

},{"es5-ext/object/is-empty":181,"es5-ext/object/valid-value":187}],175:[function(require,module,exports){
'use strict';

var d        = require('d')
  , callable = require('es5-ext/object/valid-callable')

  , apply = Function.prototype.apply, call = Function.prototype.call
  , create = Object.create, defineProperty = Object.defineProperty
  , defineProperties = Object.defineProperties
  , hasOwnProperty = Object.prototype.hasOwnProperty
  , descriptor = { configurable: true, enumerable: false, writable: true }

  , on, once, off, emit, methods, descriptors, base;

on = function (type, listener) {
	var data;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) {
		data = descriptor.value = create(null);
		defineProperty(this, '__ee__', descriptor);
		descriptor.value = null;
	} else {
		data = this.__ee__;
	}
	if (!data[type]) data[type] = listener;
	else if (typeof data[type] === 'object') data[type].push(listener);
	else data[type] = [data[type], listener];

	if(type === 'connected') {
		console.log('data[type] : ', data[type]);		
	}
	return this;
};

once = function (type, listener) {
	var once, self;

	callable(listener);
	self = this;
	on.call(this, type, once = function () {
		off.call(self, type, once);
		apply.call(listener, this, arguments);
	});

	once.__eeOnceListener__ = listener;
	return this;
};

off = function (type, listener) {
	var data, listeners, candidate, i;

	callable(listener);

	if (!hasOwnProperty.call(this, '__ee__')) return this;
	data = this.__ee__;
	if (!data[type]) return this;
	listeners = data[type];

	if (typeof listeners === 'object') {
		for (i = 0; (candidate = listeners[i]); ++i) {
			if ((candidate === listener) ||
					(candidate.__eeOnceListener__ === listener)) {
				if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
				else listeners.splice(i, 1);
			}
		}
	} else {
		if ((listeners === listener) ||
				(listeners.__eeOnceListener__ === listener)) {
			delete data[type];
		}
	}

	return this;
};

emit = function (type) {
	var i, l, listener, listeners, args;

	if (!hasOwnProperty.call(this, '__ee__')) return;
	listeners = this.__ee__[type];
	if (!listeners) return;

	if (typeof listeners === 'object') {
		l = arguments.length;
		args = new Array(l - 1);
		for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

		listeners = listeners.slice();
		for (i = 0; (listener = listeners[i]); ++i) {
			apply.call(listener, this, args);
		}
	} else {
		switch (arguments.length) {
		case 1:
			call.call(listeners, this);
			break;
		case 2:
			call.call(listeners, this, arguments[1]);
			break;
		case 3:
			call.call(listeners, this, arguments[1], arguments[2]);
			break;
		default:
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) {
				args[i - 1] = arguments[i];
			}
			apply.call(listeners, this, args);
		}
	}
};

methods = {
	on: on,
	once: once,
	off: off,
	emit: emit
};

descriptors = {
	on: d(on),
	once: d(once),
	off: d(off),
	emit: d(emit)
};

base = defineProperties({}, descriptors);

module.exports = exports = function (o) {
	return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
};
exports.methods = methods;

},{"d":176,"es5-ext/object/valid-callable":186}],176:[function(require,module,exports){
'use strict';

var assign        = require('es5-ext/object/assign')
  , normalizeOpts = require('es5-ext/object/normalize-options')
  , isCallable    = require('es5-ext/object/is-callable')
  , contains      = require('es5-ext/string/#/contains')

  , d;

d = module.exports = function (dscr, value/*, options*/) {
	var c, e, w, options, desc;
	if ((arguments.length < 2) || (typeof dscr !== 'string')) {
		options = value;
		value = dscr;
		dscr = null;
	} else {
		options = arguments[2];
	}
	if (dscr == null) {
		c = w = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
		w = contains.call(dscr, 'w');
	}

	desc = { value: value, configurable: c, enumerable: e, writable: w };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

d.gs = function (dscr, get, set/*, options*/) {
	var c, e, options, desc;
	if (typeof dscr !== 'string') {
		options = set;
		set = get;
		get = dscr;
		dscr = null;
	} else {
		options = arguments[3];
	}
	if (get == null) {
		get = undefined;
	} else if (!isCallable(get)) {
		options = get;
		get = set = undefined;
	} else if (set == null) {
		set = undefined;
	} else if (!isCallable(set)) {
		options = set;
		set = undefined;
	}
	if (dscr == null) {
		c = true;
		e = false;
	} else {
		c = contains.call(dscr, 'c');
		e = contains.call(dscr, 'e');
	}

	desc = { get: get, set: set, configurable: c, enumerable: e };
	return !options ? desc : assign(normalizeOpts(options), desc);
};

},{"es5-ext/object/assign":177,"es5-ext/object/is-callable":180,"es5-ext/object/normalize-options":185,"es5-ext/string/#/contains":188}],177:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.assign
	: require('./shim');

},{"./is-implemented":178,"./shim":179}],178:[function(require,module,exports){
'use strict';

module.exports = function () {
	var assign = Object.assign, obj;
	if (typeof assign !== 'function') return false;
	obj = { foo: 'raz' };
	assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
	return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
};

},{}],179:[function(require,module,exports){
'use strict';

var keys  = require('../keys')
  , value = require('../valid-value')

  , max = Math.max;

module.exports = function (dest, src/*, …srcn*/) {
	var error, i, l = max(arguments.length, 2), assign;
	dest = Object(value(dest));
	assign = function (key) {
		try { dest[key] = src[key]; } catch (e) {
			if (!error) error = e;
		}
	};
	for (i = 1; i < l; ++i) {
		src = arguments[i];
		keys(src).forEach(assign);
	}
	if (error !== undefined) throw error;
	return dest;
};

},{"../keys":182,"../valid-value":187}],180:[function(require,module,exports){
// Deprecated

'use strict';

module.exports = function (obj) { return typeof obj === 'function'; };

},{}],181:[function(require,module,exports){
'use strict';

var value = require('./valid-value')

  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function (obj) {
	var i;
	value(obj);
	for (i in obj) { //jslint: ignore
		if (propertyIsEnumerable.call(obj, i)) return false;
	}
	return true;
};

},{"./valid-value":187}],182:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? Object.keys
	: require('./shim');

},{"./is-implemented":183,"./shim":184}],183:[function(require,module,exports){
'use strict';

module.exports = function () {
	try {
		Object.keys('primitive');
		return true;
	} catch (e) { return false; }
};

},{}],184:[function(require,module,exports){
'use strict';

var keys = Object.keys;

module.exports = function (object) {
	return keys(object == null ? object : Object(object));
};

},{}],185:[function(require,module,exports){
'use strict';

var forEach = Array.prototype.forEach, create = Object.create;

var process = function (src, obj) {
	var key;
	for (key in src) obj[key] = src[key];
};

module.exports = function (options/*, …options*/) {
	var result = create(null);
	forEach.call(arguments, function (options) {
		if (options == null) return;
		process(Object(options), result);
	});
	return result;
};

},{}],186:[function(require,module,exports){
'use strict';

module.exports = function (fn) {
	if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
	return fn;
};

},{}],187:[function(require,module,exports){
'use strict';

module.exports = function (value) {
	if (value == null) throw new TypeError("Cannot use null or undefined");
	return value;
};

},{}],188:[function(require,module,exports){
'use strict';

module.exports = require('./is-implemented')()
	? String.prototype.contains
	: require('./shim');

},{"./is-implemented":189,"./shim":190}],189:[function(require,module,exports){
'use strict';

var str = 'razdwatrzy';

module.exports = function () {
	if (typeof str.contains !== 'function') return false;
	return ((str.contains('dwa') === true) && (str.contains('foo') === false));
};

},{}],190:[function(require,module,exports){
'use strict';

var indexOf = String.prototype.indexOf;

module.exports = function (searchString/*, position*/) {
	return indexOf.call(this, searchString, arguments[1]) > -1;
};

},{}],191:[function(require,module,exports){
var grammar = module.exports = {
  v: [{
      name: 'version',
      reg: /^(\d*)$/
  }],
  o: [{ //o=- 20518 0 IN IP4 203.0.113.1
    // NB: sessionId will be a String in most cases because it is huge
    name: 'origin',
    reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
    names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
    format: "%s %s %d %s IP%d %s"
  }],
  // default parsing of these only (though some of these feel outdated)
  s: [{ name: 'name' }],
  i: [{ name: 'description' }],
  u: [{ name: 'uri' }],
  e: [{ name: 'email' }],
  p: [{ name: 'phone' }],
  z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly..
  r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
  //k: [{}], // outdated thing ignored
  t: [{ //t=0 0
    name: 'timing',
    reg: /^(\d*) (\d*)/,
    names: ['start', 'stop'],
    format: "%d %d"
  }],
  c: [{ //c=IN IP4 10.47.197.26
      name: 'connection',
      reg: /^IN IP(\d) (\S*)/,
      names: ['version', 'ip'],
      format: "IN IP%d %s"
  }],
  b: [{ //b=AS:4000
      push: 'bandwidth',
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ['type', 'limit'],
      format: "%s:%s"
  }],
  m: [{ //m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w\/]*)(?: (.*))?/,
      names: ['type', 'port', 'protocol', 'payloads'],
      format: "%s %d %s %s"
  }],
  a: [
    { //a=rtpmap:110 opus/48000/2
      push: 'rtp',
      reg: /^rtpmap:(\d*) ([\w\-]*)\/(\d*)(?:\s*\/(\S*))?/,
      names: ['payload', 'codec', 'rate', 'encoding'],
      format: function (o) {
        return (o.encoding) ?
          "rtpmap:%d %s/%s/%s":
          "rtpmap:%d %s/%s";
      }
    },
    { //a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
      push: 'fmtp',
      reg: /^fmtp:(\d*) (\S*)/,
      names: ['payload', 'config'],
      format: "fmtp:%d %s"
    },
    { //a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: "control:%s"
    },
    { //a=rtcp:65179 IN IP4 193.84.77.194
      name: 'rtcp',
      reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
      names: ['port', 'netType', 'ipVer', 'address'],
      format: function (o) {
        return (o.address != null) ?
          "rtcp:%d %s IP%d %s":
          "rtcp:%d";
      }
    },
    { //a=rtcp-fb:98 trr-int 100
      push: 'rtcpFbTrrInt',
      reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
      names: ['payload', 'value'],
      format: "rtcp-fb:%d trr-int %d"
    },
    { //a=rtcp-fb:98 nack rpsi
      push: 'rtcpFb',
      reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
      names: ['payload', 'type', 'subtype'],
      format: function (o) {
        return (o.subtype != null) ?
          "rtcp-fb:%s %s %s":
          "rtcp-fb:%s %s";
      }
    },
    { //a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
      //a=extmap:1/recvonly URI-gps-string
      push: 'ext',
      reg: /^extmap:([\w_\/]*) (\S*)(?: (\S*))?/,
      names: ['value', 'uri', 'config'], // value may include "/direction" suffix
      format: function (o) {
        return (o.config != null) ?
          "extmap:%s %s %s":
          "extmap:%s %s"
      }
    },
    {
      //a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
      push: 'crypto',
      reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
      names: ['id', 'suite', 'config', 'sessionConfig'],
      format: function (o) {
        return (o.sessionConfig != null) ?
          "crypto:%d %s %s %s":
          "crypto:%d %s %s";
      }
    },
    { //a=setup:actpass
      name: 'setup',
      reg: /^setup:(\w*)/,
      format: "setup:%s"
    },
    { //a=mid:1
      name: 'mid',
      reg: /^mid:(\w*)/,
      format: "mid:%s"
    },
    { //a=ptime:20
      name: 'ptime',
      reg: /^ptime:(\d*)/,
      format: "ptime:%d"
    },
    { //a=maxptime:60
      name: 'maxptime',
      reg: /^maxptime:(\d*)/,
      format: "maxptime:%d"
    },
    { //a=sendrecv
      name: 'direction',
      reg: /^(sendrecv|recvonly|sendonly|inactive)/,
      format: "%s"
    },
    { //a=ice-ufrag:F7gI
      name: 'iceUfrag',
      reg: /^ice-ufrag:(\S*)/,
      format: "ice-ufrag:%s"
    },
    { //a=ice-pwd:x9cml/YzichV2+XlhiMu8g
      name: 'icePwd',
      reg: /^ice-pwd:(\S*)/,
      format: "ice-pwd:%s"
    },
    { //a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
      name: 'fingerprint',
      reg: /^fingerprint:(\S*) (\S*)/,
      names: ['type', 'hash'],
      format: "fingerprint:%s %s"
    },
    {
      //a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
      //a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0
      //a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0
      push:'candidates',
      reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: generation (\d*))?/,
      names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'generation'],
      format: function (o) {
        var str = "candidate:%s %d %s %d %s %d typ %s";
        // NB: candidate has two optional chunks, so %void middle one if it's missing
        str += (o.raddr != null) ? " raddr %s rport %d" : "%v%v";
        if (o.generation != null) {
          str += " generation %d";
        }
        return str;
      }
    },
    { //a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
      name: 'remoteCandidates',
      reg: /^remote-candidates:(.*)/,
      format: "remote-candidates:%s"
    },
    { //a=ice-options:google-ice
      name: 'iceOptions',
      reg: /^ice-options:(\S*)/,
      format: "ice-options:%s"
    },
    { //a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
      push: "ssrcs",
      reg: /^ssrc:(\d*) ([\w_]*):(.*)/,
      names: ['id', 'attribute', 'value'],
      format: "ssrc:%d %s:%s"
    },
    { //a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
      name: "msidSemantic",
      reg: /^msid-semantic: (\w*) (\S*)/,
      names: ['semantic', 'token'],
      format: "msid-semantic: %s %s" // space after ":" is not accidental
    },
    { //a=group:BUNDLE audio video
      push: 'groups',
      reg: /^group:(\w*) (.*)/,
      names: ['type', 'mids'],
      format: "group:%s %s"
    },
    { //a=rtcp-mux
      name: 'rtcpMux',
      reg: /^(rtcp-mux)/
    },
    { // any a= that we don't understand is kepts verbatim on media.invalid
      push: 'invalid',
      names: ["value"]
    }
  ]
};

// set sensible defaults to avoid polluting the grammar with boring details
Object.keys(grammar).forEach(function (key) {
  var objs = grammar[key];
  objs.forEach(function (obj) {
    if (!obj.reg) {
      obj.reg = /(.*)/;
    }
    if (!obj.format) {
      obj.format = "%s";
    }
  });
}); 

},{}],192:[function(require,module,exports){
var parser = require('./parser');
var writer = require('./writer');

exports.write = writer;
exports.parse = parser.parse;
exports.parseFmtpConfig = parser.parseFmtpConfig;
exports.parsePayloads = parser.parsePayloads;
exports.parseRemoteCandidates = parser.parseRemoteCandidates;

},{"./parser":193,"./writer":194}],193:[function(require,module,exports){
var toIntIfInt = function (v) {
  return String(Number(v)) === v ? Number(v) : v;
};

var attachProperties = function (match, location, names, rawName) {
  if (rawName && !names) {
    location[rawName] = toIntIfInt(match[1]);
  }
  else {
    for (var i = 0; i < names.length; i += 1) {
      if (match[i+1] != null) {
        location[names[i]] = toIntIfInt(match[i+1]);
      }
    }
  }
};

var parseReg = function (obj, location, content) {
  var needsBlank = obj.name && obj.names;
  if (obj.push && !location[obj.push]) {
    location[obj.push] = [];
  }
  else if (needsBlank && !location[obj.name]) {
    location[obj.name] = {};
  }
  var keyLocation = obj.push ?
    {} :  // blank object that will be pushed
    needsBlank ? location[obj.name] : location; // otherwise, named location or root

  attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);

  if (obj.push) {
    location[obj.push].push(keyLocation);
  }
};

var grammar = require('./grammar');
var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);

exports.parse = function (sdp) {
  var session = {}
    , media = []
    , location = session; // points at where properties go under (one of the above)

  // parse lines we understand
  sdp.split('\r\n').filter(validLine).forEach(function (l) {
    var type = l[0];
    var content = l.slice(2);
    if (type === 'm') {
      media.push({rtp: [], fmtp: []});
      location = media[media.length-1]; // point at latest media line
    }

    for (var j = 0; j < (grammar[type] || []).length; j += 1) {
      var obj = grammar[type][j];
      if (obj.reg.test(content)) {
        return parseReg(obj, location, content);
      }
    }
  });

  session.media = media; // link it up
  return session;
};

var fmtpReducer = function (acc, expr) {
  var s = expr.split('=');
  if (s.length === 2) {
    acc[s[0]] = toIntIfInt(s[1]);
  }
  return acc;
};

exports.parseFmtpConfig = function (str) {
  return str.split(';').reduce(fmtpReducer, {});
};

exports.parsePayloads = function (str) {
  return str.split(' ').map(Number);
};

exports.parseRemoteCandidates = function (str) {
  var candidates = [];
  var parts = str.split(' ').map(toIntIfInt);
  for (var i = 0; i < parts.length; i += 3) {
    candidates.push({
      component: parts[i],
      ip: parts[i + 1],
      port: parts[i + 2]
    });
  }
  return candidates;
};

},{"./grammar":191}],194:[function(require,module,exports){
var grammar = require('./grammar');

// customized util.format - discards excess arguments and can void middle ones
var formatRegExp = /%[sdv%]/g;
var format = function (formatStr) {
  var i = 1;
  var args = arguments;
  var len = args.length;
  return formatStr.replace(formatRegExp, function (x) {
    if (i >= len) {
      return x; // missing argument
    }
    var arg = args[i];
    i += 1;
    switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
    }
  });
  // NB: we discard excess arguments - they are typically undefined from makeLine
};

var makeLine = function (type, obj, location) {
  var str = obj.format instanceof Function ?
    (obj.format(obj.push ? location : location[obj.name])) :
    obj.format;

  var args = [type + '=' + str];
  if (obj.names) {
    for (var i = 0; i < obj.names.length; i += 1) {
      var n = obj.names[i];
      if (obj.name) {
        args.push(location[obj.name][n]);
      }
      else { // for mLine and push attributes
        args.push(location[obj.names[i]]);
      }
    }
  }
  else {
    args.push(location[obj.name]);
  }
  return format.apply(null, args);
};

// RFC specified order
// TODO: extend this with all the rest
var defaultOuterOrder = [
  'v', 'o', 's', 'i',
  'u', 'e', 'p', 'c',
  'b', 't', 'r', 'z', 'a'
];
var defaultInnerOrder = ['i', 'c', 'b', 'a'];


module.exports = function (session, opts) {
  opts = opts || {};
  // ensure certain properties exist
  if (session.version == null) {
    session.version = 0; // "v=0" must be there (only defined version atm)
  }
  if (session.name == null) {
    session.name = " "; // "s= " must be there if no meaningful name set
  }
  session.media.forEach(function (mLine) {
    if (mLine.payloads == null) {
      mLine.payloads = "";
    }
  });

  var outerOrder = opts.outerOrder || defaultOuterOrder;
  var innerOrder = opts.innerOrder || defaultInnerOrder;
  var sdp = [];

  // loop through outerOrder for matching properties on session
  outerOrder.forEach(function (type) {
    grammar[type].forEach(function (obj) {
      if (obj.name in session) {
        sdp.push(makeLine(type, obj, session));
      }
      else if (obj.push in session) {
        session[obj.push].forEach(function (el) {
          sdp.push(makeLine(type, obj, el));
        });
      }
    });
  });

  // then for each media line, follow the innerOrder
  session.media.forEach(function (mLine) {
    sdp.push(makeLine('m', grammar.m[0], mLine));

    innerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in mLine) {
          sdp.push(makeLine(type, obj, mLine));
        }
        else if (obj.push in mLine) {
          mLine[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  });

  return sdp.join('\r\n') + '\r\n';
};

},{"./grammar":191}],195:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],196:[function(require,module,exports){
module.exports={
  "name": "exsip",
  "title": "ExSIP",
  "description": "BroadSoft Javascript SIP library",
  "version": "2.0.0",
  "homepage": "http://www.broadsoft.com",
  "author": "BroadSoft, Inc.",
  "contributors": [
    {
      "url": ""
    }
  ],
  "main": "src/ExSIP.js",
  "repository": {
    "type": "git",
    "url": ""
  },
  "keywords": [
    "sip",
    "websocket",
    "webrtc",
    "library"
  ],
  "dependencies": {
    "sdp-transform": "0.6.1",
    "ws": "0.4.32"
  },
  "devDependencies": {
    "nodeunit": "0.9.0",
    "grunt": "0.4.5",
    "grunt-contrib-jshint": "0.10.0",
    "grunt-contrib-concat": "0.5.0",
    "grunt-contrib-nodeunit": "0.4.1",
    "grunt-contrib-uglify": "0.6.0",
    "grunt-contrib-watch": "0.6.1",
    "grunt-contrib-symlink": "0.3.0",
    "grunt-browserify": "3.0.1",
    "grunt-jsdoc": "0.5.7",
    "grunt-notify": ">=0.2.6",
    "grunt-bumpx": "0.1.5",
    "pegjs": "0.7.0"
  },
  "engines": {
    "node": ">=0.8"
  },
  "license": "MIT",
  "scripts": {
    "test": "grunt travis --verbose"
  }
}

},{}],197:[function(require,module,exports){
var pkg = require('../package.json');

var C = {
  USER_AGENT: 'BroadSoft WebRTC Client - ' +  pkg.version,

  // SIP scheme
  SIP:  'sip',
  SIPS: 'sips',

  // End and Failure causes
  causes: {
    // Generic error causes
    CONNECTION_ERROR:         'Connection Error',
    REQUEST_TIMEOUT:          'Request Timeout',
    SIP_FAILURE_CODE:         'SIP Failure Code',
    INTERNAL_ERROR:           'Internal Error',

    // SIP error causes
    BUSY:                     'Busy',
    REJECTED:                 'Rejected',
    REDIRECTED:               'Redirected',
    UNAVAILABLE:              'Unavailable',
    NOT_FOUND:                'Not Found',
    ADDRESS_INCOMPLETE:       'Address Incomplete',
    INCOMPATIBLE_SDP:         'Incompatible SDP',
    MISSING_SDP:              'Missing SDP',
    AUTHENTICATION_ERROR:     'Authentication Error',
    DIALOG_ERROR:             'Dialog Error',

    // Session error causes
    BYE:                      'Terminated',
    WEBRTC_NOT_SUPPORTED:     'WebRTC Not Supported',
    WEBRTC_ERROR:             'WebRTC Error',
    CANCELED:                 'Canceled',
    NO_ANSWER:                'No Answer',
    EXPIRES:                  'Expires',
    NO_ACK:                   'No ACK',
    USER_DENIED_MEDIA_ACCESS: 'User Denied Media Access',
    BAD_MEDIA_DESCRIPTION:    'Bad Media Description',
    RTP_TIMEOUT:              'RTP Timeout',
    NOT_ACCEPTABLE_ERROR:     'Not Acceptable'
  },

  SIP_ERROR_CAUSES: {
    REDIRECTED: [300,301,302,305,380],
    BUSY: [486,600],
    REJECTED: [403,603],
    NOT_FOUND: [404,604],
    UNAVAILABLE: [480,410,408,430],
    ADDRESS_INCOMPLETE: [484],
    INCOMPATIBLE_SDP: [488],
    AUTHENTICATION_ERROR:[401,407],
    NOT_ACCEPTABLE_ERROR:[606]
  },

  // SIP Methods
  ACK:        'ACK',
  BYE:        'BYE',
  CANCEL:     'CANCEL',
  INFO:       'INFO',
  INVITE:     'INVITE',
  REFER:      'REFER',
  MESSAGE:    'MESSAGE',
  NOTIFY:     'NOTIFY',
  OPTIONS:    'OPTIONS',
  REGISTER:   'REGISTER',
  UPDATE:     'UPDATE',
  SUBSCRIBE:  'SUBSCRIBE',

  // MODES
  SENDONLY:  'sendonly',
  RECVONLY:  'recvonly',
  SENDRECV:  'sendrecv',
  INACTIVE:  'inactive',

  /* SIP Response Reasons
   * DOC: http://www.iana.org/assignments/sip-parameters
   * Copied from https://github.com/versatica/OverSIP/blob/master/lib/oversip/sip/constants.rb#L7
   */
  REASON_PHRASE: {
    100: 'Trying',
    180: 'Ringing',
    181: 'Call Is Being Forwarded',
    182: 'Queued',
    183: 'Session Progress',
    199: 'Early Dialog Terminated',  // draft-ietf-sipcore-199
    200: 'OK',
    202: 'Accepted',  // RFC 3265
    204: 'No Notification',  //RFC 5839
    300: 'Multiple Choices',
    301: 'Moved Permanently',
    302: 'Moved Temporarily',
    305: 'Use Proxy',
    380: 'Alternative Service',
    400: 'Bad Request',
    401: 'Unauthorized',
    402: 'Payment Required',
    403: 'Forbidden',
    404: 'Not Found',
    405: 'Method Not Allowed',
    406: 'Not Acceptable',
    407: 'Proxy Authentication Required',
    408: 'Request Timeout',
    410: 'Gone',
    412: 'Conditional Request Failed',  // RFC 3903
    413: 'Request Entity Too Large',
    414: 'Request-URI Too Long',
    415: 'Unsupported Media Type',
    416: 'Unsupported URI Scheme',
    417: 'Unknown Resource-Priority',  // RFC 4412
    420: 'Bad Extension',
    421: 'Extension Required',
    422: 'Session Interval Too Small',  // RFC 4028
    423: 'Interval Too Brief',
    428: 'Use Identity Header',  // RFC 4474
    429: 'Provide Referrer Identity',  // RFC 3892
    430: 'Flow Failed',  // RFC 5626
    433: 'Anonymity Disallowed',  // RFC 5079
    436: 'Bad Identity-Info',  // RFC 4474
    437: 'Unsupported Certificate',  // RFC 4744
    438: 'Invalid Identity Header',  // RFC 4744
    439: 'First Hop Lacks Outbound Support',  // RFC 5626
    440: 'Max-Breadth Exceeded',  // RFC 5393
    469: 'Bad Info Package',  // draft-ietf-sipcore-info-events
    470: 'Consent Needed',  // RFC 5360
    478: 'Unresolvable Destination',  // Custom code copied from Kamailio.
    480: 'Temporarily Unavailable',
    481: 'Call/Transaction Does Not Exist',
    482: 'Loop Detected',
    483: 'Too Many Hops',
    484: 'Address Incomplete',
    485: 'Ambiguous',
    486: 'Busy Here',
    487: 'Request Terminated',
    488: 'Not Acceptable Here',
    489: 'Bad Event',  // RFC 3265
    491: 'Request Pending',
    493: 'Undecipherable',
    494: 'Security Agreement Required',  // RFC 3329
    500: 'ExSIP Internal Error',
    501: 'Not Implemented',
    502: 'Bad Gateway',
    503: 'Service Unavailable',
    504: 'Server Time-out',
    505: 'Version Not Supported',
    513: 'Message Too Large',
    580: 'Precondition Failure',  // RFC 3312
    600: 'Busy Everywhere',
    603: 'Decline',
    604: 'Does Not Exist Anywhere',
    606: 'Not Acceptable'
  },

  ALLOWED_METHODS: 'INVITE,ACK,CANCEL,BYE,UPDATE,MESSAGE,OPTIONS',
  ACCEPTED_BODY_TYPES: 'application/sdp, application/dtmf-relay',
  MAX_FORWARDS: 69
};


module.exports = C;

},{"../package.json":196}],198:[function(require,module,exports){
module.exports = Dialog;


var C = {
  // Dialog states
  STATUS_EARLY:       1,
  STATUS_CONFIRMED:   2
};

/**
 * Expose C object.
 */
Dialog.C = C;


/**
 * Dependencies.
 */
var SIPMessage = require('./SIPMessage');
var ExSIP_C = require('./Constants');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var Dialog_RequestSender = require('./Dialog/RequestSender');


// RFC 3261 12.1
function Dialog(owner, message, type, state) {
  var contact;

  this.uac_pending_reply = false;
  this.uas_pending_reply = false;
  this.is_acknowledged = false;
  this.type = type;

  if(!message.hasHeader('contact')) {
    return {
      error: 'unable to create a Dialog without Contact header field'
    };
  }

  if(message instanceof SIPMessage.IncomingResponse) {
    state = (message.status_code < 200) ? C.STATUS_EARLY : C.STATUS_CONFIRMED;
  } else {
    // Create confirmed dialog if state is not defined
    state = state || C.STATUS_CONFIRMED;
  }

  contact = message.parseHeader('contact');

  // RFC 3261 12.1.1
  if(type === 'UAS') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.to_tag,
      remote_tag: message.from_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.remote_seqnum = message.cseq;
    this.local_uri = message.parseHeader('to').uri;
    this.remote_uri = message.parseHeader('from').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route');
  }
  // RFC 3261 12.1.2
  else if(type === 'UAC') {
    this.id = {
      call_id: message.call_id,
      local_tag: message.from_tag,
      remote_tag: message.to_tag,
      toString: function() {
        return this.call_id + this.local_tag + this.remote_tag;
      }
    };
    this.state = state;
    this.local_seqnum = message.cseq;
    this.local_uri = message.parseHeader('from').uri;
    this.remote_uri = message.parseHeader('to').uri;
    this.remote_target = contact.uri;
    this.route_set = message.getHeaders('record-route').reverse();
  }

  this.logger = owner.ua.getLogger('ExSIP.dialog', this.id.toString());
  this.owner = owner;
  owner.ua.dialogs[this.id.toString()] = this;
  this.logger.debug('new ' + type + ' dialog created with status ' + (this.state === C.STATUS_EARLY ? 'EARLY': 'CONFIRMED'));
}


Dialog.prototype = {
  isUAS: function() {
    return this.type === 'UAS';
  },

  isUAC: function() {
    return this.type === 'UAC';
  },

  update: function(message, type) {
    this.state = C.STATUS_CONFIRMED;

    this.logger.debug('dialog '+ this.id.toString() +'  changed to CONFIRMED state');

    if(type === 'UAC') {
      // RFC 3261 13.2.2.4
      this.route_set = message.getHeaders('record-route').reverse();
    }
  },

  terminate: function() {
    this.logger.debug('dialog ' + this.id.toString() + ' deleted');
    delete this.owner.ua.dialogs[this.id.toString()];
  },

  // RFC 3261 12.2.1.1
  createRequest: function(method, extraHeaders, body) {
    var cseq, request;
    extraHeaders = extraHeaders && extraHeaders.slice() || [];

    if(!this.local_seqnum) { this.local_seqnum = Math.floor(Math.random() * 10000); }

    cseq = (method === ExSIP_C.CANCEL || method === ExSIP_C.ACK) ? this.local_seqnum : this.local_seqnum += 1;

    request = new SIPMessage.OutgoingRequest(
      method,
      this.remote_target,
      this.owner.ua, {
        'cseq': cseq,
        'call_id': this.id.call_id,
        'from_uri': this.local_uri,
        'from_tag': this.id.local_tag,
        'to_uri': this.remote_uri,
        'to_tag': this.id.remote_tag,
        'route_set': this.route_set
      }, extraHeaders, body);

  this.logger.debug('createRequest : dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    request.dialog = this;

    return request;
  },

  // RFC 3261 12.2.2
  checkInDialogRequest: function(request) {
    var self = this;

    // RFC3261 14.2 Modifying an Existing Session -UAS BEHAVIOR-
    if (request.method === ExSIP_C.INVITE || (request.method === ExSIP_C.UPDATE && request.body)) {
      if (this.uac_pending_reply === true) {
        request.reply(491);
      } else if (this.uas_pending_reply === true || (this.type === 'UAS' && !this.is_acknowledged)) {
        var retryAfter = (Math.random() * 10 | 0) + 1;
        request.reply(500, null, ['Retry-After:'+ retryAfter]);
        return false;
      } else {
        this.uas_pending_reply = true;
        request.server_transaction.on('stateChanged', function stateChanged(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
              e.sender.state === Transactions.C.STATUS_COMPLETED ||
              e.sender.state === Transactions.C.STATUS_TERMINATED) {

            request.server_transaction.removeListener('stateChanged', stateChanged);
            self.uas_pending_reply = false;

            if (self.uac_pending_reply === false) {
              self.owner.onReadyToReinvite();
            }
          }
        });
      }

      // RFC3261 12.2.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_ACCEPTED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.NOTIFY) {
      // RFC6665 3.2 Replace the dialog`s remote target URI if the request is accepted
      if(request.hasHeader('contact')) {
        request.server_transaction.on('stateChanged', function(e){
          if (e.sender.state === Transactions.C.STATUS_COMPLETED) {
            self.remote_target = request.parseHeader('contact').uri;
          }
        });
      }
    }
    else if (request.method === ExSIP_C.ACK) {
      this.is_acknowledged = true;
    }

    if(!this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    } else if(request.cseq < this.remote_seqnum) {
        //Do not try to reply to an ACK request.
        if (request.method !== ExSIP_C.ACK) {
          request.reply(500);
        }
        return false;
    } else if(request.cseq > this.remote_seqnum) {
      this.remote_seqnum = request.cseq;
    }

    return true;
  },

  createRequestSender: function(applicant, method, options) {
    options = options || {};

    var
      extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
      body = options.body || null,
      request = this.createRequest(method, extraHeaders, body),
      request_sender = new Dialog_RequestSender(this, applicant, request);
  this.logger.debug('dialog.request_sender.request.extraHeaders : '+Utils.toString(request.extraHeaders));

    return request_sender;  
  },

  sendRequest: function(applicant, method, options) {
      var request_sender = this.createRequestSender(applicant, method, options);
      request_sender.send();
  },

  receiveRequest: function(request) {
    //Check in-dialog request
    if(!this.checkInDialogRequest(request)) {
      return;
    }

    this.owner.receiveRequest(request);
  }
};

},{"./Constants":197,"./Dialog/RequestSender":199,"./SIPMessage":216,"./Transactions":218,"./Utils":222}],199:[function(require,module,exports){
module.exports = DialogRequestSender;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var Transactions = require('../Transactions');
var RTCSession = require('../RTCSession');
var RequestSender = require('../RequestSender');


function DialogRequestSender(dialog, applicant, request) {

  this.dialog = dialog;
  this.applicant = applicant;
  this.request = request;

  this.logger = dialog.owner.ua.getLogger('ExSIP.dialog.requestsender', dialog.id);

  // RFC3261 14.1 Modifying an Existing Session. UAC Behavior.
  this.reattempt = false;
  this.reattemptTimer = null;
}


DialogRequestSender.prototype = {
  send: function(callbacks) {
    var
      self = this,
      request_sender = new RequestSender(this, this.dialog.owner.ua);

    request_sender.send(callbacks);

    // RFC3261 14.2 Modifying an Existing Session -UAC BEHAVIOR-
    if (this.request.method === ExSIP_C.INVITE && request_sender.clientTransaction.state !== Transactions.C.STATUS_TERMINATED) {
      this.dialog.uac_pending_reply = true;
      request_sender.clientTransaction.on('stateChanged', function stateChanged(e) {
        if (e.sender.state === Transactions.C.STATUS_ACCEPTED ||
          e.sender.state === Transactions.C.STATUS_COMPLETED ||
          e.sender.state === Transactions.C.STATUS_TERMINATED) {

          request_sender.clientTransaction.removeListener('stateChanged', stateChanged);
          self.dialog.uac_pending_reply = false;

          if (self.dialog.uas_pending_reply === false) {
            self.dialog.owner.onReadyToReinvite();
          }
        }
      });
    }
  },

  onRequestTimeout: function() {
    this.logger.log('********* onRequestTimeout : ', this.applicant);
    this.applicant.onRequestTimeout();
  },

  onTransportError: function() {
    this.applicant.onTransportError();
  },

  receiveResponse: function(response) {
    var self = this;

    this.logger.debug('receiveResponse : ' + response);

    // RFC3261 12.2.1.2 408 or 481 is received for a request within a dialog.
    if (response.status_code === 408 || response.status_code === 481) {
      this.applicant.onDialogError(response);
    } else if (response.method === ExSIP_C.INVITE && response.status_code === 491) {
      if (this.reattempt) {
        this.applicant.receiveResponse(response);
      } else {
        this.request.cseq.value = this.dialog.local_seqnum += 1;
        this.reattemptTimer = setTimeout(
          function() {
            if (self.applicant.owner.status !== RTCSession.C.STATUS_TERMINATED) {
              self.reattempt = true;
              self.request_sender.send();
            }
          },
          this.getReattemptTimeout()
        );
      }
    } else {
      this.applicant.receiveResponse(response);
    }
  }
};
},{"../Constants":197,"../RTCSession":210,"../RequestSender":215,"../Transactions":218}],200:[function(require,module,exports){
module.exports = DigestAuthentication;


function DigestAuthentication(ua) {
  this.logger = ua.getLogger('ExSIP.digestauthentication');
  this.username = ua.configuration.authorization_user;
  this.password = ua.configuration.password;
  this.cnonce = null;
  this.nc = 0;
  this.ncHex = '00000000';
  this.response = null;
}


/**
 * Dependencies.
 */
var Utils = require('./Utils');


/**
* Performs Digest authentication given a SIP request and the challenge
* received in a response to that request.
* Returns true if credentials were successfully generated, false otherwise.
<<<<<<< HEAD
* 
* @param {ExSIP.OutgoingRequest} request
* @param {Object} challenge
=======
>>>>>>> ExSIP050
*/
DigestAuthentication.prototype.authenticate = function(request, challenge) {
  // Inspect and validate the challenge.

  this.algorithm = challenge.algorithm;
  this.realm = challenge.realm;
  this.nonce = challenge.nonce;
  this.opaque = challenge.opaque;
  this.stale = challenge.stale;

  if (this.algorithm) {
    if (this.algorithm !== 'MD5') {
      this.logger.warn('challenge with Digest algorithm different than "MD5", authentication aborted');
      return false;
    }
  } else {
    this.algorithm = 'MD5';
  }

  if (! this.realm) {
    this.logger.warn('challenge without Digest realm, authentication aborted');
    return false;
  }

  if (! this.nonce) {
    this.logger.warn('challenge without Digest nonce, authentication aborted');
    return false;
  }

  // 'qop' can contain a list of values (Array). Let's choose just one.
  if (challenge.qop) {
    if (challenge.qop.indexOf('auth') > -1) {
      this.qop = 'auth';
    } else if (challenge.qop.indexOf('auth-int') > -1) {
      this.qop = 'auth-int';
    } else {
      // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.
      this.logger.warn('challenge without Digest qop different than "auth" or "auth-int", authentication aborted');
      return false;
    }
  } else {
    this.qop = null;
  }

  // Fill other attributes.

  this.method = request.method;
  this.uri = request.ruri;
  this.cnonce = Utils.createRandomToken(12);
  this.nc += 1;
  this.updateNcHex();

  // nc-value = 8LHEX. Max value = 'FFFFFFFF'.
  if (this.nc === 4294967296) {
    this.nc = 1;
    this.ncHex = '00000001';
  }

  // Calculate the Digest "response" value.
  this.calculateResponse();

  return true;
};


/**
* Generate Digest 'response' value.
*/
DigestAuthentication.prototype.calculateResponse = function() {
  var ha1, ha2;

  // HA1 = MD5(A1) = MD5(username:realm:password)
  ha1 = Utils.calculateMD5(this.username + ":" + this.realm + ":" + this.password);

  if (this.qop === 'auth') {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth:" + ha2);

  } else if (this.qop === 'auth-int') {
    // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri + ":" + Utils.calculateMD5(this.body ? this.body : ""));
    // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + this.ncHex + ":" + this.cnonce + ":auth-int:" + ha2);

  } else if (this.qop === null) {
    // HA2 = MD5(A2) = MD5(method:digestURI)
    ha2 = Utils.calculateMD5(this.method + ":" + this.uri);
    // response = MD5(HA1:nonce:HA2)
    this.response = Utils.calculateMD5(ha1 + ":" + this.nonce + ":" + ha2);
  }
};


/**
* Return the Proxy-Authorization or WWW-Authorization header value.
*/
DigestAuthentication.prototype.toString = function() {
  var auth_params = [];

  if (! this.response) {
    throw new Error('response field does not exist, cannot generate Authorization header');
  }

  auth_params.push('algorithm=' + this.algorithm);
  auth_params.push('username="' + this.username + '"');
  auth_params.push('realm="' + this.realm + '"');
  auth_params.push('nonce="' + this.nonce + '"');
  auth_params.push('uri="' + this.uri + '"');
  auth_params.push('response="' + this.response + '"');
  if (this.opaque) {
    auth_params.push('opaque="' + this.opaque + '"');
  }
  if (this.qop) {
    auth_params.push('qop=' + this.qop);
    auth_params.push('cnonce="' + this.cnonce + '"');
    auth_params.push('nc=' + this.ncHex);
  }

  return 'Digest ' + auth_params.join(', ');
};


/**
* Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.
*/
DigestAuthentication.prototype.updateNcHex = function() {
  var hex = Number(this.nc).toString(16);
  this.ncHex = '00000000'.substr(0, 8-hex.length) + hex;
};
},{"./Utils":222}],201:[function(require,module,exports){
module.exports = EventEmitter;


function EventEmitter() {}


/**
 * Dependencies.
 */
var LoggerFactory = require('./LoggerFactory');


function Event(type, sender, data) {
  this.type = type;
  this.sender= sender;
  this.data = data;
}


var
  logger = new LoggerFactory().getLogger('ExSIP.eventemitter'),
  C = {
    MAX_LISTENERS: 50
  };


EventEmitter.prototype = {
  /**
   * Initialize events dictionaries.
   * -param {Array} events
   */
  initEvents: function(events) {
    var idx, length;

    if (!this.logger) {
      this.logger = logger;
    }

    this.maxListeners = C.MAX_LISTENERS;

    this.events = {};
    this.oneTimeListeners = {};

    length = events.length;
    for (idx = 0; idx < length; idx++) {
      this.events[events[idx]] = [];
      this.oneTimeListeners[events[idx]] = [];
    }
  },

  /**
   * Check whether an event exists or not.
   */
  checkEvent: function(event) {
    return !!this.events[event];
  },

  /**
   * Add a listener to the end of the listeners array for the specified event.
   */
  addListener: function(event, listener) {
    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to add a listener to a nonexistent event ' + event);
      return;
    }

    if (this.events[event].length >= this.maxListeners) {
      this.logger.warn('max listeners exceeded for event ' + event);
    }

    this.events[event].push(listener);
  },

  on: function(event, listener) {
    this.addListener(event, listener);
  },

  /**
   * Add a one time listener for the specified event.
   * The listener is invoked only the next time the event is fired, then it is removed.
   */
  once: function(event, listener) {
    this.on(event, listener);
    this.oneTimeListeners[event].push(listener);
  },

  /**
   * Remove a listener from the listener array for the specified event.
   * Note that the order of the array elements will change after removing the listener
   */
  removeListener: function(event, listener) {
    var events, length,
      idx = 0;

    if (listener === undefined) {
      return;
    } else if (typeof listener !== 'function') {
      this.logger.error('listener must be a function');
      return;
    } else if (!this.checkEvent(event)) {
      this.logger.error('unable to remove a listener from a nonexistent event'+ event);
      return;
    }

    events = this.events[event];
    length = events.length;

    while (idx < length) {
      if (events[idx] === listener) {
        events.splice(idx,1);
      } else {
        idx ++;
      }
    }
  },

  /**
   * Remove all listeners from the listener array for the specified event.
   */
  removeAllListener: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('unable to remove listeners from a nonexistent event'+ event);
      return;
    }

    this.events[event] = [];
    this.oneTimeListeners[event] = [];
  },

  /**
   * By default EventEmitter will print a warning
   * if more than C.MAX_LISTENERS listeners are added for a particular event.
   * This function allows that limit to be modified.
   */
  setMaxListeners: function(listeners) {
    if (typeof listeners !== 'number' || listeners < 0) {
      this.logger.error('listeners must be a positive number');
      return;
    }

    this.maxListeners = listeners;
  },

  /**
   * Get the listeners for a specific event.
   */
  listeners: function(event) {
    if (!this.checkEvent(event)) {
      this.logger.error('no event '+ event);
      return;
    }

    return this.events[event];
  },

  /**
   * Execute each of the listeners in order with the supplied arguments.
   */
  emit: function(event, sender, data) {
    var listeners, length, e, idx,
      self = this;

    if (!this.checkEvent(event)) {
      this.logger.error('unable to emit a nonexistent event'+ event);
      return;
    }

    this.logger.debug('emitting event '+ event);

    listeners = this.events[event];
    length = listeners.length;

    e = new Event(event, sender, data);

    listeners.map(function(listener) {
      return function() {
        listener.call(null, e);
      };
    }).forEach(function(callback) {
      try {
        callback();
      } catch(err) {
        self.logger.error(err.stack);
      }
    });

    // Remove one time listeners
    for (idx in this.oneTimeListeners[event]) {
      this.removeListener(event, this.oneTimeListeners[event][idx]);
    }

    this.oneTimeListeners[event] = [];
  }
};
},{"./LoggerFactory":206}],202:[function(require,module,exports){
var ExSIP = {
  C: require('./Constants'),
  Exceptions: require('./Exceptions'),
  Utils: require('./Utils'),
  UA: require('./UA'),
  URI: require('./URI'),
  NameAddrHeader: require('./NameAddrHeader'),
  Grammar: require('./Grammar'),
  WebRTC: require('./WebRTC'),
  RTCSession: require('./RTCSession')
};

module.exports = ExSIP;


var pkg = require('../package.json');


Object.defineProperties(ExSIP, {
  name: {
    get: function(){ return pkg.title; }
  },

  /**
   * Retrieve the version of ExSIP.
   * @memberof ExSIP
   * @method
   * @returns {String} Version in the form "X.Y.Z"
   * @example
   * // prints "1.0.0"
   * console.log(ExSIP.version)
   */
  version: {
    get: function(){ return pkg.version; }
  }
});

},{"../package.json":196,"./Constants":197,"./Exceptions":203,"./Grammar":204,"./NameAddrHeader":208,"./RTCSession":210,"./UA":220,"./URI":221,"./Utils":222,"./WebRTC":223}],203:[function(require,module,exports){
/**
 * @namespace Exceptions
 * @memberOf ExSIP
 */
var Exceptions = {
  /**
   * Exception thrown when a valid parameter is given to the ExSIP.UA constructor.
   * @class ConfigurationError
   * @memberOf ExSIP.Exceptions
   */
  ConfigurationError: (function(){
    var exception = function(parameter, value) {
      console.trace('----------------------ConfigurationError : '+parameter+', '+value);
      this.code = 1;
      this.name = 'CONFIGURATION_ERROR';
      this.parameter = parameter;
      this.value = value;
      this.message = (!this.value)? 'Missing parameter: '+ this.parameter : 'Invalid value '+ JSON.stringify(this.value) +' for parameter "'+ this.parameter +'"';
    };
    exception.prototype = new Error();
    return exception;
  }()),

  InvalidStateError: (function(){
    var exception = function(status) {
      console.trace('----------------------InvalidStateError : '+status);
      this.code = 2;
      this.name = 'INVALID_STATE_ERROR';
      this.status = status;
      this.message = 'Invalid status: '+ status;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotSupportedError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotSupportedError : '+message);
      this.code = 3;
      this.name = 'NOT_SUPPORTED_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }()),

  NotReadyError: (function(){
    var exception = function(message) {
      console.trace('----------------------NotReadyError : '+message);
      this.code = 4;
      this.name = 'NOT_READY_ERROR';
      this.message = message;
    };
    exception.prototype = new Error();
    return exception;
  }())
};

module.exports = Exceptions;
},{}],204:[function(require,module,exports){
module.exports = (function(){
  /*
   * Generated by PEG.js 0.7.0.
   *
   * http://pegjs.majda.cz/
   */
  
  function quote(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a
     * string literal except for the closing quote character, backslash,
     * carriage return, line separator, paragraph separator, and line feed.
     * Any character may appear in the form of an escape sequence.
     *
     * For portability, we also escape escape all control and non-ASCII
     * characters. Note that "\0" and "\v" escape sequences are not used
     * because JSHint does not like the first and IE the second.
     */
     return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, escape)
      + '"';
  }
  
  var result = {
    /*
     * Parses the input with a generated parser. If the parsing is successfull,
     * returns a value explicitly or implicitly specified by the grammar from
     * which the parser was generated (see |PEG.buildParser|). If the parsing is
     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.
     */
    parse: function(input, startRule) {
      var parseFunctions = {
        "CRLF": parse_CRLF,
        "DIGIT": parse_DIGIT,
        "ALPHA": parse_ALPHA,
        "HEXDIG": parse_HEXDIG,
        "WSP": parse_WSP,
        "OCTET": parse_OCTET,
        "DQUOTE": parse_DQUOTE,
        "SP": parse_SP,
        "HTAB": parse_HTAB,
        "alphanum": parse_alphanum,
        "reserved": parse_reserved,
        "unreserved": parse_unreserved,
        "mark": parse_mark,
        "escaped": parse_escaped,
        "LWS": parse_LWS,
        "SWS": parse_SWS,
        "HCOLON": parse_HCOLON,
        "TEXT_UTF8_TRIM": parse_TEXT_UTF8_TRIM,
        "TEXT_UTF8char": parse_TEXT_UTF8char,
        "UTF8_NONASCII": parse_UTF8_NONASCII,
        "UTF8_CONT": parse_UTF8_CONT,
        "LHEX": parse_LHEX,
        "token": parse_token,
        "token_nodot": parse_token_nodot,
        "separators": parse_separators,
        "word": parse_word,
        "STAR": parse_STAR,
        "SLASH": parse_SLASH,
        "EQUAL": parse_EQUAL,
        "LPAREN": parse_LPAREN,
        "RPAREN": parse_RPAREN,
        "RAQUOT": parse_RAQUOT,
        "LAQUOT": parse_LAQUOT,
        "COMMA": parse_COMMA,
        "SEMI": parse_SEMI,
        "COLON": parse_COLON,
        "LDQUOT": parse_LDQUOT,
        "RDQUOT": parse_RDQUOT,
        "comment": parse_comment,
        "ctext": parse_ctext,
        "quoted_string": parse_quoted_string,
        "quoted_string_clean": parse_quoted_string_clean,
        "qdtext": parse_qdtext,
        "quoted_pair": parse_quoted_pair,
        "SIP_URI_noparams": parse_SIP_URI_noparams,
        "SIP_URI": parse_SIP_URI,
        "uri_scheme": parse_uri_scheme,
        "userinfo": parse_userinfo,
        "user": parse_user,
        "user_unreserved": parse_user_unreserved,
        "password": parse_password,
        "hostport": parse_hostport,
        "host": parse_host,
        "hostname": parse_hostname,
        "domainlabel": parse_domainlabel,
        "toplabel": parse_toplabel,
        "IPv6reference": parse_IPv6reference,
        "IPv6address": parse_IPv6address,
        "h16": parse_h16,
        "ls32": parse_ls32,
        "IPv4address": parse_IPv4address,
        "dec_octet": parse_dec_octet,
        "port": parse_port,
        "uri_parameters": parse_uri_parameters,
        "uri_parameter": parse_uri_parameter,
        "transport_param": parse_transport_param,
        "user_param": parse_user_param,
        "method_param": parse_method_param,
        "ttl_param": parse_ttl_param,
        "maddr_param": parse_maddr_param,
        "lr_param": parse_lr_param,
        "other_param": parse_other_param,
        "pname": parse_pname,
        "pvalue": parse_pvalue,
        "paramchar": parse_paramchar,
        "param_unreserved": parse_param_unreserved,
        "headers": parse_headers,
        "header": parse_header,
        "hname": parse_hname,
        "hvalue": parse_hvalue,
        "hnv_unreserved": parse_hnv_unreserved,
        "Request_Response": parse_Request_Response,
        "Request_Line": parse_Request_Line,
        "Request_URI": parse_Request_URI,
        "absoluteURI": parse_absoluteURI,
        "hier_part": parse_hier_part,
        "net_path": parse_net_path,
        "abs_path": parse_abs_path,
        "opaque_part": parse_opaque_part,
        "uric": parse_uric,
        "uric_no_slash": parse_uric_no_slash,
        "path_segments": parse_path_segments,
        "segment": parse_segment,
        "param": parse_param,
        "pchar": parse_pchar,
        "scheme": parse_scheme,
        "authority": parse_authority,
        "srvr": parse_srvr,
        "reg_name": parse_reg_name,
        "query": parse_query,
        "SIP_Version": parse_SIP_Version,
        "INVITEm": parse_INVITEm,
        "ACKm": parse_ACKm,
        "OPTIONSm": parse_OPTIONSm,
        "BYEm": parse_BYEm,
        "CANCELm": parse_CANCELm,
        "REGISTERm": parse_REGISTERm,
        "SUBSCRIBEm": parse_SUBSCRIBEm,
        "NOTIFYm": parse_NOTIFYm,
        "Method": parse_Method,
        "Status_Line": parse_Status_Line,
        "Status_Code": parse_Status_Code,
        "extension_code": parse_extension_code,
        "Reason_Phrase": parse_Reason_Phrase,
        "Allow_Events": parse_Allow_Events,
        "Call_ID": parse_Call_ID,
        "Contact": parse_Contact,
        "contact_param": parse_contact_param,
        "name_addr": parse_name_addr,
        "display_name": parse_display_name,
        "contact_params": parse_contact_params,
        "c_p_q": parse_c_p_q,
        "c_p_expires": parse_c_p_expires,
        "delta_seconds": parse_delta_seconds,
        "qvalue": parse_qvalue,
        "generic_param": parse_generic_param,
        "gen_value": parse_gen_value,
        "Content_Disposition": parse_Content_Disposition,
        "disp_type": parse_disp_type,
        "disp_param": parse_disp_param,
        "handling_param": parse_handling_param,
        "Content_Encoding": parse_Content_Encoding,
        "Content_Length": parse_Content_Length,
        "Content_Type": parse_Content_Type,
        "media_type": parse_media_type,
        "m_type": parse_m_type,
        "discrete_type": parse_discrete_type,
        "composite_type": parse_composite_type,
        "extension_token": parse_extension_token,
        "x_token": parse_x_token,
        "m_subtype": parse_m_subtype,
        "m_parameter": parse_m_parameter,
        "m_value": parse_m_value,
        "CSeq": parse_CSeq,
        "CSeq_value": parse_CSeq_value,
        "Expires": parse_Expires,
        "Event": parse_Event,
        "event_type": parse_event_type,
        "From": parse_From,
        "from_param": parse_from_param,
        "tag_param": parse_tag_param,
        "Max_Forwards": parse_Max_Forwards,
        "Min_Expires": parse_Min_Expires,
        "Name_Addr_Header": parse_Name_Addr_Header,
        "Proxy_Authenticate": parse_Proxy_Authenticate,
        "challenge": parse_challenge,
        "other_challenge": parse_other_challenge,
        "auth_param": parse_auth_param,
        "digest_cln": parse_digest_cln,
        "realm": parse_realm,
        "realm_value": parse_realm_value,
        "domain": parse_domain,
        "URI": parse_URI,
        "nonce": parse_nonce,
        "nonce_value": parse_nonce_value,
        "opaque": parse_opaque,
        "stale": parse_stale,
        "algorithm": parse_algorithm,
        "qop_options": parse_qop_options,
        "qop_value": parse_qop_value,
        "Proxy_Require": parse_Proxy_Require,
        "Record_Route": parse_Record_Route,
        "rec_route": parse_rec_route,
        "Require": parse_Require,
        "Route": parse_Route,
        "route_param": parse_route_param,
        "Subscription_State": parse_Subscription_State,
        "substate_value": parse_substate_value,
        "subexp_params": parse_subexp_params,
        "event_reason_value": parse_event_reason_value,
        "Subject": parse_Subject,
        "Supported": parse_Supported,
        "To": parse_To,
        "to_param": parse_to_param,
        "Via": parse_Via,
        "via_parm": parse_via_parm,
        "via_params": parse_via_params,
        "via_ttl": parse_via_ttl,
        "via_maddr": parse_via_maddr,
        "via_received": parse_via_received,
        "via_branch": parse_via_branch,
        "response_port": parse_response_port,
        "sent_protocol": parse_sent_protocol,
        "protocol_name": parse_protocol_name,
        "transport": parse_transport,
        "sent_by": parse_sent_by,
        "via_host": parse_via_host,
        "via_port": parse_via_port,
        "ttl": parse_ttl,
        "WWW_Authenticate": parse_WWW_Authenticate,
        "extension_header": parse_extension_header,
        "header_value": parse_header_value,
        "message_body": parse_message_body,
        "stun_URI": parse_stun_URI,
        "stun_scheme": parse_stun_scheme,
        "stun_host_port": parse_stun_host_port,
        "stun_host": parse_stun_host,
        "reg_name": parse_reg_name,
        "stun_unreserved": parse_stun_unreserved,
        "sub_delims": parse_sub_delims,
        "turn_URI": parse_turn_URI,
        "turn_scheme": parse_turn_scheme,
        "turn_transport": parse_turn_transport,
        "uuid_URI": parse_uuid_URI,
        "uuid": parse_uuid,
        "hex4": parse_hex4,
        "hex8": parse_hex8,
        "hex12": parse_hex12
      };
      
      if (startRule !== undefined) {
        if (parseFunctions[startRule] === undefined) {
          throw new Error("Invalid rule name: " + quote(startRule) + ".");
        }
      } else {
        startRule = "CRLF";
      }
      
      var pos = 0;
      var reportFailures = 0;
      var rightmostFailuresPos = 0;
      var rightmostFailuresExpected = [];
      
      function padLeft(input, padding, length) {
        var result = input;
        
        var padLength = length - input.length;
        for (var i = 0; i < padLength; i++) {
          result = padding + result;
        }
        
        return result;
      }
      
      function escape(ch) {
        var charCode = ch.charCodeAt(0);
        var escapeChar;
        var length;
        
        if (charCode <= 0xFF) {
          escapeChar = 'x';
          length = 2;
        } else {
          escapeChar = 'u';
          length = 4;
        }
        
        return '\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);
      }
      
      function matchFailed(failure) {
        if (pos < rightmostFailuresPos) {
          return;
        }
        
        if (pos > rightmostFailuresPos) {
          rightmostFailuresPos = pos;
          rightmostFailuresExpected = [];
        }
        
        rightmostFailuresExpected.push(failure);
      }
      
      function parse_CRLF() {
        var result0;
        
        if (input.substr(pos, 2) === "\r\n") {
          result0 = "\r\n";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\r\\n\"");
          }
        }
        return result0;
      }
      
      function parse_DIGIT() {
        var result0;
        
        if (/^[0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9]");
          }
        }
        return result0;
      }
      
      function parse_ALPHA() {
        var result0;
        
        if (/^[a-zA-Z]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z]");
          }
        }
        return result0;
      }
      
      function parse_HEXDIG() {
        var result0;
        
        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[0-9a-fA-F]");
          }
        }
        return result0;
      }
      
      function parse_WSP() {
        var result0;
        
        result0 = parse_SP();
        if (result0 === null) {
          result0 = parse_HTAB();
        }
        return result0;
      }
      
      function parse_OCTET() {
        var result0;
        
        if (/^[\0-\xFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\0-\\xFF]");
          }
        }
        return result0;
      }
      
      function parse_DQUOTE() {
        var result0;
        
        if (/^["]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\"]");
          }
        }
        return result0;
      }
      
      function parse_SP() {
        var result0;
        
        if (input.charCodeAt(pos) === 32) {
          result0 = " ";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\" \"");
          }
        }
        return result0;
      }
      
      function parse_HTAB() {
        var result0;
        
        if (input.charCodeAt(pos) === 9) {
          result0 = "\t";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\t\"");
          }
        }
        return result0;
      }
      
      function parse_alphanum() {
        var result0;
        
        if (/^[a-zA-Z0-9]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9]");
          }
        }
        return result0;
      }
      
      function parse_reserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 59) {
          result0 = ";";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 47) {
            result0 = "/";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 63) {
              result0 = "?";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"?\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 38) {
                    result0 = "&";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"&\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 61) {
                      result0 = "=";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"=\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 36) {
                          result0 = "$";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"$\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 44) {
                            result0 = ",";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\",\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_unreserved() {
        var result0;
        
        result0 = parse_alphanum();
        if (result0 === null) {
          result0 = parse_mark();
        }
        return result0;
      }
      
      function parse_mark() {
        var result0;
        
        if (input.charCodeAt(pos) === 45) {
          result0 = "-";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"-\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 95) {
            result0 = "_";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"_\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 46) {
              result0 = ".";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 33) {
                result0 = "!";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 126) {
                  result0 = "~";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"~\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result0 = "*";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 39) {
                      result0 = "'";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"'\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 40) {
                        result0 = "(";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"(\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 41) {
                          result0 = ")";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\")\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_escaped() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 37) {
          result0 = "%";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"%\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, escaped) {return escaped.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LWS() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        pos2 = pos;
        result0 = [];
        result1 = parse_WSP();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_WSP();
        }
        if (result0 !== null) {
          result1 = parse_CRLF();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos2;
          }
        } else {
          result0 = null;
          pos = pos2;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result2 = parse_WSP();
          if (result2 !== null) {
            result1 = [];
            while (result2 !== null) {
              result1.push(result2);
              result2 = parse_WSP();
            }
          } else {
            result1 = null;
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return " "; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SWS() {
        var result0;
        
        result0 = parse_LWS();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_HCOLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_SP();
        if (result1 === null) {
          result1 = parse_HTAB();
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_SP();
          if (result1 === null) {
            result1 = parse_HTAB();
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ':'; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8_TRIM() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result1 = parse_TEXT_UTF8char();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_TEXT_UTF8char();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = [];
          result3 = parse_LWS();
          while (result3 !== null) {
            result2.push(result3);
            result3 = parse_LWS();
          }
          if (result2 !== null) {
            result3 = parse_TEXT_UTF8char();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = [];
            result3 = parse_LWS();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_LWS();
            }
            if (result2 !== null) {
              result3 = parse_TEXT_UTF8char();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_TEXT_UTF8char() {
        var result0;
        
        if (/^[!-~]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-~]");
          }
        }
        if (result0 === null) {
          result0 = parse_UTF8_NONASCII();
        }
        return result0;
      }
      
      function parse_UTF8_NONASCII() {
        var result0;
        
        if (/^[\x80-\uFFFF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\uFFFF]");
          }
        }
        return result0;
      }
      
      function parse_UTF8_CONT() {
        var result0;
        
        if (/^[\x80-\xBF]/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[\\x80-\\xBF]");
          }
        }
        return result0;
      }
      
      function parse_LHEX() {
        var result0;
        
        result0 = parse_DIGIT();
        if (result0 === null) {
          if (/^[a-f]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[a-f]");
            }
          }
        }
        return result0;
      }
      
      function parse_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_token_nodot() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 33) {
              result1 = "!";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"!\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 37) {
                result1 = "%";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"%\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 42) {
                  result1 = "*";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"*\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 95) {
                    result1 = "_";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"_\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result1 = "+";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 96) {
                        result1 = "`";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"`\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 39) {
                          result1 = "'";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"'\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 126) {
                            result1 = "~";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"~\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 33) {
                  result1 = "!";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"!\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 37) {
                    result1 = "%";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"%\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result1 = "*";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 95) {
                        result1 = "_";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"_\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result1 = "+";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 96) {
                            result1 = "`";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"`\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 39) {
                              result1 = "'";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"'\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 126) {
                                result1 = "~";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"~\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_separators() {
        var result0;
        
        if (input.charCodeAt(pos) === 40) {
          result0 = "(";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"(\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 41) {
            result0 = ")";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 60) {
              result0 = "<";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"<\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 62) {
                result0 = ">";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\">\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 64) {
                  result0 = "@";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"@\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result0 = ",";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result0 = ";";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result0 = ":";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 92) {
                          result0 = "\\";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"\\\\\"");
                          }
                        }
                        if (result0 === null) {
                          result0 = parse_DQUOTE();
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 47) {
                              result0 = "/";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"/\"");
                              }
                            }
                            if (result0 === null) {
                              if (input.charCodeAt(pos) === 91) {
                                result0 = "[";
                                pos++;
                              } else {
                                result0 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"[\"");
                                }
                              }
                              if (result0 === null) {
                                if (input.charCodeAt(pos) === 93) {
                                  result0 = "]";
                                  pos++;
                                } else {
                                  result0 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"]\"");
                                  }
                                }
                                if (result0 === null) {
                                  if (input.charCodeAt(pos) === 63) {
                                    result0 = "?";
                                    pos++;
                                  } else {
                                    result0 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"?\"");
                                    }
                                  }
                                  if (result0 === null) {
                                    if (input.charCodeAt(pos) === 61) {
                                      result0 = "=";
                                      pos++;
                                    } else {
                                      result0 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\"=\"");
                                      }
                                    }
                                    if (result0 === null) {
                                      if (input.charCodeAt(pos) === 123) {
                                        result0 = "{";
                                        pos++;
                                      } else {
                                        result0 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"{\"");
                                        }
                                      }
                                      if (result0 === null) {
                                        if (input.charCodeAt(pos) === 125) {
                                          result0 = "}";
                                          pos++;
                                        } else {
                                          result0 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"}\"");
                                          }
                                        }
                                        if (result0 === null) {
                                          result0 = parse_SP();
                                          if (result0 === null) {
                                            result0 = parse_HTAB();
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_word() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_alphanum();
        if (result1 === null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 === null) {
            if (input.charCodeAt(pos) === 46) {
              result1 = ".";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 33) {
                result1 = "!";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"!\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 37) {
                  result1 = "%";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"%\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 42) {
                    result1 = "*";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"*\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 95) {
                      result1 = "_";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"_\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result1 = "+";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 96) {
                          result1 = "`";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"`\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 39) {
                            result1 = "'";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"'\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 126) {
                              result1 = "~";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"~\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 40) {
                                result1 = "(";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"(\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 41) {
                                  result1 = ")";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\")\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 60) {
                                    result1 = "<";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"<\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 62) {
                                      result1 = ">";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\">\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 92) {
                                          result1 = "\\";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\"\\\\\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          result1 = parse_DQUOTE();
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 47) {
                                              result1 = "/";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"/\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              if (input.charCodeAt(pos) === 91) {
                                                result1 = "[";
                                                pos++;
                                              } else {
                                                result1 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"[\"");
                                                }
                                              }
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 93) {
                                                  result1 = "]";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"]\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 63) {
                                                    result1 = "?";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"?\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 123) {
                                                      result1 = "{";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"{\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 125) {
                                                        result1 = "}";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"}\"");
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_alphanum();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 45) {
                result1 = "-";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 46) {
                  result1 = ".";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\".\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 33) {
                    result1 = "!";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"!\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 37) {
                      result1 = "%";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"%\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 42) {
                        result1 = "*";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"*\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 95) {
                          result1 = "_";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"_\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 96) {
                              result1 = "`";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"`\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 39) {
                                result1 = "'";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"'\"");
                                }
                              }
                              if (result1 === null) {
                                if (input.charCodeAt(pos) === 126) {
                                  result1 = "~";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\"~\"");
                                  }
                                }
                                if (result1 === null) {
                                  if (input.charCodeAt(pos) === 40) {
                                    result1 = "(";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"(\"");
                                    }
                                  }
                                  if (result1 === null) {
                                    if (input.charCodeAt(pos) === 41) {
                                      result1 = ")";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\")\"");
                                      }
                                    }
                                    if (result1 === null) {
                                      if (input.charCodeAt(pos) === 60) {
                                        result1 = "<";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"<\"");
                                        }
                                      }
                                      if (result1 === null) {
                                        if (input.charCodeAt(pos) === 62) {
                                          result1 = ">";
                                          pos++;
                                        } else {
                                          result1 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\">\"");
                                          }
                                        }
                                        if (result1 === null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result1 = ":";
                                            pos++;
                                          } else {
                                            result1 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result1 === null) {
                                            if (input.charCodeAt(pos) === 92) {
                                              result1 = "\\";
                                              pos++;
                                            } else {
                                              result1 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\"\\\\\"");
                                              }
                                            }
                                            if (result1 === null) {
                                              result1 = parse_DQUOTE();
                                              if (result1 === null) {
                                                if (input.charCodeAt(pos) === 47) {
                                                  result1 = "/";
                                                  pos++;
                                                } else {
                                                  result1 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\"/\"");
                                                  }
                                                }
                                                if (result1 === null) {
                                                  if (input.charCodeAt(pos) === 91) {
                                                    result1 = "[";
                                                    pos++;
                                                  } else {
                                                    result1 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"[\"");
                                                    }
                                                  }
                                                  if (result1 === null) {
                                                    if (input.charCodeAt(pos) === 93) {
                                                      result1 = "]";
                                                      pos++;
                                                    } else {
                                                      result1 = null;
                                                      if (reportFailures === 0) {
                                                        matchFailed("\"]\"");
                                                      }
                                                    }
                                                    if (result1 === null) {
                                                      if (input.charCodeAt(pos) === 63) {
                                                        result1 = "?";
                                                        pos++;
                                                      } else {
                                                        result1 = null;
                                                        if (reportFailures === 0) {
                                                          matchFailed("\"?\"");
                                                        }
                                                      }
                                                      if (result1 === null) {
                                                        if (input.charCodeAt(pos) === 123) {
                                                          result1 = "{";
                                                          pos++;
                                                        } else {
                                                          result1 = null;
                                                          if (reportFailures === 0) {
                                                            matchFailed("\"{\"");
                                                          }
                                                        }
                                                        if (result1 === null) {
                                                          if (input.charCodeAt(pos) === 125) {
                                                            result1 = "}";
                                                            pos++;
                                                          } else {
                                                            result1 = null;
                                                            if (reportFailures === 0) {
                                                              matchFailed("\"}\"");
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_STAR() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 42) {
            result1 = "*";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"*\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "*"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SLASH() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "/"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_EQUAL() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "="; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 40) {
            result1 = "(";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"(\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "("; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RPAREN() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 41) {
            result1 = ")";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\")\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ")"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 62) {
          result0 = ">";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\">\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ">"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LAQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 60) {
            result1 = "<";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"<\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "<"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COMMA() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 44) {
            result1 = ",";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\",\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ","; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SEMI() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ";"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_COLON() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_SWS();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return ":"; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_LDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_RDQUOT() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DQUOTE();
        if (result0 !== null) {
          result1 = parse_SWS();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {return "\""; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_comment() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_LPAREN();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ctext();
          if (result2 === null) {
            result2 = parse_quoted_pair();
            if (result2 === null) {
              result2 = parse_comment();
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ctext();
            if (result2 === null) {
              result2 = parse_quoted_pair();
              if (result2 === null) {
                result2 = parse_comment();
              }
            }
          }
          if (result1 !== null) {
            result2 = parse_RPAREN();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ctext() {
        var result0;
        
        if (/^[!-']/.test(input.charAt(pos))) {
          result0 = input.charAt(pos);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("[!-']");
          }
        }
        if (result0 === null) {
          if (/^[*-[]/.test(input.charAt(pos))) {
            result0 = input.charAt(pos);
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("[*-[]");
            }
          }
          if (result0 === null) {
            if (/^[\]-~]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[\\]-~]");
              }
            }
            if (result0 === null) {
              result0 = parse_UTF8_NONASCII();
              if (result0 === null) {
                result0 = parse_LWS();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_string() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_quoted_string_clean() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SWS();
        if (result0 !== null) {
          result1 = parse_DQUOTE();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_qdtext();
            if (result3 === null) {
              result3 = parse_quoted_pair();
            }
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_qdtext();
              if (result3 === null) {
                result3 = parse_quoted_pair();
              }
            }
            if (result2 !== null) {
              result3 = parse_DQUOTE();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return input.substring(pos-1, offset+1); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qdtext() {
        var result0;
        
        result0 = parse_LWS();
        if (result0 === null) {
          if (input.charCodeAt(pos) === 33) {
            result0 = "!";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"!\"");
            }
          }
          if (result0 === null) {
            if (/^[#-[]/.test(input.charAt(pos))) {
              result0 = input.charAt(pos);
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("[#-[]");
              }
            }
            if (result0 === null) {
              if (/^[\]-~]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\]-~]");
                }
              }
              if (result0 === null) {
                result0 = parse_UTF8_NONASCII();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_quoted_pair() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 92) {
          result0 = "\\";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"\\\\\"");
          }
        }
        if (result0 !== null) {
          if (/^[\0-\t]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[\\0-\\t]");
            }
          }
          if (result1 === null) {
            if (/^[\x0B-\f]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[\\x0B-\\f]");
              }
            }
            if (result1 === null) {
              if (/^[\x0E-]/.test(input.charAt(pos))) {
                result1 = input.charAt(pos);
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("[\\x0E-]");
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI_noparams() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_SIP_URI() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_uri_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_userinfo();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_hostport();
              if (result3 !== null) {
                result4 = parse_uri_parameters();
                if (result4 !== null) {
                  result5 = parse_headers();
                  result5 = result5 !== null ? result5 : "";
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            var header;
                            try {
                                data.uri = new URI(data.scheme, data.user, data.host, data.port, data.uri_params, data.uri_headers);
                                delete data.scheme;
                                delete data.user;
                                delete data.host;
                                delete data.host_type;
                                delete data.port;
                                delete data.uri_params;
        
                                if (startRule === 'SIP_URI') { data = data.uri;}
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_scheme() {
        var result0;
        var pos0;
        
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"sip\"");
          }
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.substr(pos, 4).toLowerCase() === "sips") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"sips\"");
            }
          }
          if (result0 !== null) {
            result0 = (function(offset) {
                              data.scheme = uri_scheme.toLowerCase(); })(pos0);
          }
          if (result0 === null) {
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_userinfo() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_user();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_password();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 64) {
              result2 = "@";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"@\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.user = decodeURIComponent(input.substring(pos-1, offset));})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_user_unreserved();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_user_unreserved();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_user_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 38) {
          result0 = "&";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"&\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 61) {
            result0 = "=";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 43) {
              result0 = "+";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"+\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 36) {
                result0 = "$";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"$\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 44) {
                  result0 = ",";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 59) {
                    result0 = ";";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\";\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 63) {
                      result0 = "?";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"?\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 47) {
                        result0 = "/";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"/\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_password() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 38) {
              result1 = "&";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 61) {
                result1 = "=";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"=\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result1 = "+";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 36) {
                    result1 = "$";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"$\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 44) {
                      result1 = ",";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\",\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              if (input.charCodeAt(pos) === 38) {
                result1 = "&";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 61) {
                  result1 = "=";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"=\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result1 = "+";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result1 = "$";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 44) {
                        result1 = ",";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\",\"");
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.password = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host = input.substring(pos, offset).toLowerCase();
                            return data.host; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hostname() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        pos2 = pos;
        result1 = parse_domainlabel();
        if (result1 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos2;
          }
        } else {
          result1 = null;
          pos = pos2;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos2 = pos;
          result1 = parse_domainlabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
        }
        if (result0 !== null) {
          result1 = parse_toplabel();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'domain';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domainlabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_toplabel() {
        var result0, result1;
        
        if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
          result1 = input.charAt(pos);
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("[a-zA-Z0-9_\\-]");
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            if (/^[a-zA-Z0-9_\-]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[a-zA-Z0-9_\\-]");
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_IPv6reference() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_IPv6address();
          if (result1 !== null) {
            if (input.charCodeAt(pos) === 93) {
              result2 = "]";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"]\"");
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv6';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_IPv6address() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result3 = ":";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_h16();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result5 = ":";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_h16();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result7 = ":";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_h16();
                        if (result8 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result9 = ":";
                            pos++;
                          } else {
                            result9 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result9 !== null) {
                            result10 = parse_h16();
                            if (result10 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result11 = ":";
                                pos++;
                              } else {
                                result11 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result11 !== null) {
                                result12 = parse_ls32();
                                if (result12 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11, result12];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          pos1 = pos;
          if (input.substr(pos, 2) === "::") {
            result0 = "::";
            pos += 2;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"::\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_h16();
            if (result1 !== null) {
              if (input.charCodeAt(pos) === 58) {
                result2 = ":";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result2 !== null) {
                result3 = parse_h16();
                if (result3 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result4 = ":";
                    pos++;
                  } else {
                    result4 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result4 !== null) {
                    result5 = parse_h16();
                    if (result5 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result6 = ":";
                        pos++;
                      } else {
                        result6 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result6 !== null) {
                        result7 = parse_h16();
                        if (result7 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result8 = ":";
                            pos++;
                          } else {
                            result8 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result8 !== null) {
                            result9 = parse_h16();
                            if (result9 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result10 = ":";
                                pos++;
                              } else {
                                result10 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result10 !== null) {
                                result11 = parse_ls32();
                                if (result11 !== null) {
                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10, result11];
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 === null) {
            pos1 = pos;
            if (input.substr(pos, 2) === "::") {
              result0 = "::";
              pos += 2;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"::\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_h16();
              if (result1 !== null) {
                if (input.charCodeAt(pos) === 58) {
                  result2 = ":";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result2 !== null) {
                  result3 = parse_h16();
                  if (result3 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result4 = ":";
                      pos++;
                    } else {
                      result4 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result4 !== null) {
                      result5 = parse_h16();
                      if (result5 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result6 = ":";
                          pos++;
                        } else {
                          result6 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result6 !== null) {
                          result7 = parse_h16();
                          if (result7 !== null) {
                            if (input.charCodeAt(pos) === 58) {
                              result8 = ":";
                              pos++;
                            } else {
                              result8 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result8 !== null) {
                              result9 = parse_ls32();
                              if (result9 !== null) {
                                result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 === null) {
              pos1 = pos;
              if (input.substr(pos, 2) === "::") {
                result0 = "::";
                pos += 2;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"::\"");
                }
              }
              if (result0 !== null) {
                result1 = parse_h16();
                if (result1 !== null) {
                  if (input.charCodeAt(pos) === 58) {
                    result2 = ":";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result2 !== null) {
                    result3 = parse_h16();
                    if (result3 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result4 = ":";
                        pos++;
                      } else {
                        result4 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result4 !== null) {
                        result5 = parse_h16();
                        if (result5 !== null) {
                          if (input.charCodeAt(pos) === 58) {
                            result6 = ":";
                            pos++;
                          } else {
                            result6 = null;
                            if (reportFailures === 0) {
                              matchFailed("\":\"");
                            }
                          }
                          if (result6 !== null) {
                            result7 = parse_ls32();
                            if (result7 !== null) {
                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
              if (result0 === null) {
                pos1 = pos;
                if (input.substr(pos, 2) === "::") {
                  result0 = "::";
                  pos += 2;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"::\"");
                  }
                }
                if (result0 !== null) {
                  result1 = parse_h16();
                  if (result1 !== null) {
                    if (input.charCodeAt(pos) === 58) {
                      result2 = ":";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\":\"");
                      }
                    }
                    if (result2 !== null) {
                      result3 = parse_h16();
                      if (result3 !== null) {
                        if (input.charCodeAt(pos) === 58) {
                          result4 = ":";
                          pos++;
                        } else {
                          result4 = null;
                          if (reportFailures === 0) {
                            matchFailed("\":\"");
                          }
                        }
                        if (result4 !== null) {
                          result5 = parse_ls32();
                          if (result5 !== null) {
                            result0 = [result0, result1, result2, result3, result4, result5];
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
                if (result0 === null) {
                  pos1 = pos;
                  if (input.substr(pos, 2) === "::") {
                    result0 = "::";
                    pos += 2;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"::\"");
                    }
                  }
                  if (result0 !== null) {
                    result1 = parse_h16();
                    if (result1 !== null) {
                      if (input.charCodeAt(pos) === 58) {
                        result2 = ":";
                        pos++;
                      } else {
                        result2 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result2 !== null) {
                        result3 = parse_ls32();
                        if (result3 !== null) {
                          result0 = [result0, result1, result2, result3];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                  if (result0 === null) {
                    pos1 = pos;
                    if (input.substr(pos, 2) === "::") {
                      result0 = "::";
                      pos += 2;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"::\"");
                      }
                    }
                    if (result0 !== null) {
                      result1 = parse_ls32();
                      if (result1 !== null) {
                        result0 = [result0, result1];
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                    if (result0 === null) {
                      pos1 = pos;
                      if (input.substr(pos, 2) === "::") {
                        result0 = "::";
                        pos += 2;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"::\"");
                        }
                      }
                      if (result0 !== null) {
                        result1 = parse_h16();
                        if (result1 !== null) {
                          result0 = [result0, result1];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                      if (result0 === null) {
                        pos1 = pos;
                        result0 = parse_h16();
                        if (result0 !== null) {
                          if (input.substr(pos, 2) === "::") {
                            result1 = "::";
                            pos += 2;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"::\"");
                            }
                          }
                          if (result1 !== null) {
                            result2 = parse_h16();
                            if (result2 !== null) {
                              if (input.charCodeAt(pos) === 58) {
                                result3 = ":";
                                pos++;
                              } else {
                                result3 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result3 !== null) {
                                result4 = parse_h16();
                                if (result4 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result5 = ":";
                                    pos++;
                                  } else {
                                    result5 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result5 !== null) {
                                    result6 = parse_h16();
                                    if (result6 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result7 = ":";
                                        pos++;
                                      } else {
                                        result7 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result7 !== null) {
                                        result8 = parse_h16();
                                        if (result8 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result9 = ":";
                                            pos++;
                                          } else {
                                            result9 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result9 !== null) {
                                            result10 = parse_ls32();
                                            if (result10 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                        if (result0 === null) {
                          pos1 = pos;
                          result0 = parse_h16();
                          if (result0 !== null) {
                            pos2 = pos;
                            if (input.charCodeAt(pos) === 58) {
                              result1 = ":";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\":\"");
                              }
                            }
                            if (result1 !== null) {
                              result2 = parse_h16();
                              if (result2 !== null) {
                                result1 = [result1, result2];
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                            } else {
                              result1 = null;
                              pos = pos2;
                            }
                            result1 = result1 !== null ? result1 : "";
                            if (result1 !== null) {
                              if (input.substr(pos, 2) === "::") {
                                result2 = "::";
                                pos += 2;
                              } else {
                                result2 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"::\"");
                                }
                              }
                              if (result2 !== null) {
                                result3 = parse_h16();
                                if (result3 !== null) {
                                  if (input.charCodeAt(pos) === 58) {
                                    result4 = ":";
                                    pos++;
                                  } else {
                                    result4 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result4 !== null) {
                                    result5 = parse_h16();
                                    if (result5 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result6 = ":";
                                        pos++;
                                      } else {
                                        result6 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result6 !== null) {
                                        result7 = parse_h16();
                                        if (result7 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result8 = ":";
                                            pos++;
                                          } else {
                                            result8 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result8 !== null) {
                                            result9 = parse_ls32();
                                            if (result9 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                          } else {
                            result0 = null;
                            pos = pos1;
                          }
                          if (result0 === null) {
                            pos1 = pos;
                            result0 = parse_h16();
                            if (result0 !== null) {
                              pos2 = pos;
                              if (input.charCodeAt(pos) === 58) {
                                result1 = ":";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\":\"");
                                }
                              }
                              if (result1 !== null) {
                                result2 = parse_h16();
                                if (result2 !== null) {
                                  result1 = [result1, result2];
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                              } else {
                                result1 = null;
                                pos = pos2;
                              }
                              result1 = result1 !== null ? result1 : "";
                              if (result1 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result2 = ":";
                                  pos++;
                                } else {
                                  result2 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result2 !== null) {
                                  result3 = parse_h16();
                                  if (result3 !== null) {
                                    result2 = [result2, result3];
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result2 = null;
                                  pos = pos2;
                                }
                                result2 = result2 !== null ? result2 : "";
                                if (result2 !== null) {
                                  if (input.substr(pos, 2) === "::") {
                                    result3 = "::";
                                    pos += 2;
                                  } else {
                                    result3 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\"::\"");
                                    }
                                  }
                                  if (result3 !== null) {
                                    result4 = parse_h16();
                                    if (result4 !== null) {
                                      if (input.charCodeAt(pos) === 58) {
                                        result5 = ":";
                                        pos++;
                                      } else {
                                        result5 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result5 !== null) {
                                        result6 = parse_h16();
                                        if (result6 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result7 = ":";
                                            pos++;
                                          } else {
                                            result7 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result7 !== null) {
                                            result8 = parse_ls32();
                                            if (result8 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                            } else {
                              result0 = null;
                              pos = pos1;
                            }
                            if (result0 === null) {
                              pos1 = pos;
                              result0 = parse_h16();
                              if (result0 !== null) {
                                pos2 = pos;
                                if (input.charCodeAt(pos) === 58) {
                                  result1 = ":";
                                  pos++;
                                } else {
                                  result1 = null;
                                  if (reportFailures === 0) {
                                    matchFailed("\":\"");
                                  }
                                }
                                if (result1 !== null) {
                                  result2 = parse_h16();
                                  if (result2 !== null) {
                                    result1 = [result1, result2];
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                } else {
                                  result1 = null;
                                  pos = pos2;
                                }
                                result1 = result1 !== null ? result1 : "";
                                if (result1 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result2 = ":";
                                    pos++;
                                  } else {
                                    result2 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result2 !== null) {
                                    result3 = parse_h16();
                                    if (result3 !== null) {
                                      result2 = [result2, result3];
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result2 = null;
                                    pos = pos2;
                                  }
                                  result2 = result2 !== null ? result2 : "";
                                  if (result2 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result3 = ":";
                                      pos++;
                                    } else {
                                      result3 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result3 !== null) {
                                      result4 = parse_h16();
                                      if (result4 !== null) {
                                        result3 = [result3, result4];
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result3 = null;
                                      pos = pos2;
                                    }
                                    result3 = result3 !== null ? result3 : "";
                                    if (result3 !== null) {
                                      if (input.substr(pos, 2) === "::") {
                                        result4 = "::";
                                        pos += 2;
                                      } else {
                                        result4 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\"::\"");
                                        }
                                      }
                                      if (result4 !== null) {
                                        result5 = parse_h16();
                                        if (result5 !== null) {
                                          if (input.charCodeAt(pos) === 58) {
                                            result6 = ":";
                                            pos++;
                                          } else {
                                            result6 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result6 !== null) {
                                            result7 = parse_ls32();
                                            if (result7 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                              } else {
                                result0 = null;
                                pos = pos1;
                              }
                              if (result0 === null) {
                                pos1 = pos;
                                result0 = parse_h16();
                                if (result0 !== null) {
                                  pos2 = pos;
                                  if (input.charCodeAt(pos) === 58) {
                                    result1 = ":";
                                    pos++;
                                  } else {
                                    result1 = null;
                                    if (reportFailures === 0) {
                                      matchFailed("\":\"");
                                    }
                                  }
                                  if (result1 !== null) {
                                    result2 = parse_h16();
                                    if (result2 !== null) {
                                      result1 = [result1, result2];
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                  } else {
                                    result1 = null;
                                    pos = pos2;
                                  }
                                  result1 = result1 !== null ? result1 : "";
                                  if (result1 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result2 = ":";
                                      pos++;
                                    } else {
                                      result2 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result2 !== null) {
                                      result3 = parse_h16();
                                      if (result3 !== null) {
                                        result2 = [result2, result3];
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result2 = null;
                                      pos = pos2;
                                    }
                                    result2 = result2 !== null ? result2 : "";
                                    if (result2 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result3 = ":";
                                        pos++;
                                      } else {
                                        result3 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result3 !== null) {
                                        result4 = parse_h16();
                                        if (result4 !== null) {
                                          result3 = [result3, result4];
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result3 = null;
                                        pos = pos2;
                                      }
                                      result3 = result3 !== null ? result3 : "";
                                      if (result3 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result4 = ":";
                                          pos++;
                                        } else {
                                          result4 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result4 !== null) {
                                          result5 = parse_h16();
                                          if (result5 !== null) {
                                            result4 = [result4, result5];
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result4 = null;
                                          pos = pos2;
                                        }
                                        result4 = result4 !== null ? result4 : "";
                                        if (result4 !== null) {
                                          if (input.substr(pos, 2) === "::") {
                                            result5 = "::";
                                            pos += 2;
                                          } else {
                                            result5 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\"::\"");
                                            }
                                          }
                                          if (result5 !== null) {
                                            result6 = parse_ls32();
                                            if (result6 !== null) {
                                              result0 = [result0, result1, result2, result3, result4, result5, result6];
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                } else {
                                  result0 = null;
                                  pos = pos1;
                                }
                                if (result0 === null) {
                                  pos1 = pos;
                                  result0 = parse_h16();
                                  if (result0 !== null) {
                                    pos2 = pos;
                                    if (input.charCodeAt(pos) === 58) {
                                      result1 = ":";
                                      pos++;
                                    } else {
                                      result1 = null;
                                      if (reportFailures === 0) {
                                        matchFailed("\":\"");
                                      }
                                    }
                                    if (result1 !== null) {
                                      result2 = parse_h16();
                                      if (result2 !== null) {
                                        result1 = [result1, result2];
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                    } else {
                                      result1 = null;
                                      pos = pos2;
                                    }
                                    result1 = result1 !== null ? result1 : "";
                                    if (result1 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result2 = ":";
                                        pos++;
                                      } else {
                                        result2 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result2 !== null) {
                                        result3 = parse_h16();
                                        if (result3 !== null) {
                                          result2 = [result2, result3];
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result2 = null;
                                        pos = pos2;
                                      }
                                      result2 = result2 !== null ? result2 : "";
                                      if (result2 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result3 = ":";
                                          pos++;
                                        } else {
                                          result3 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result3 !== null) {
                                          result4 = parse_h16();
                                          if (result4 !== null) {
                                            result3 = [result3, result4];
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result3 = null;
                                          pos = pos2;
                                        }
                                        result3 = result3 !== null ? result3 : "";
                                        if (result3 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result4 = ":";
                                            pos++;
                                          } else {
                                            result4 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result4 !== null) {
                                            result5 = parse_h16();
                                            if (result5 !== null) {
                                              result4 = [result4, result5];
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result4 = null;
                                            pos = pos2;
                                          }
                                          result4 = result4 !== null ? result4 : "";
                                          if (result4 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result5 = ":";
                                              pos++;
                                            } else {
                                              result5 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result5 !== null) {
                                              result6 = parse_h16();
                                              if (result6 !== null) {
                                                result5 = [result5, result6];
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result5 = null;
                                              pos = pos2;
                                            }
                                            result5 = result5 !== null ? result5 : "";
                                            if (result5 !== null) {
                                              if (input.substr(pos, 2) === "::") {
                                                result6 = "::";
                                                pos += 2;
                                              } else {
                                                result6 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\"::\"");
                                                }
                                              }
                                              if (result6 !== null) {
                                                result7 = parse_h16();
                                                if (result7 !== null) {
                                                  result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  } else {
                                    result0 = null;
                                    pos = pos1;
                                  }
                                  if (result0 === null) {
                                    pos1 = pos;
                                    result0 = parse_h16();
                                    if (result0 !== null) {
                                      pos2 = pos;
                                      if (input.charCodeAt(pos) === 58) {
                                        result1 = ":";
                                        pos++;
                                      } else {
                                        result1 = null;
                                        if (reportFailures === 0) {
                                          matchFailed("\":\"");
                                        }
                                      }
                                      if (result1 !== null) {
                                        result2 = parse_h16();
                                        if (result2 !== null) {
                                          result1 = [result1, result2];
                                        } else {
                                          result1 = null;
                                          pos = pos2;
                                        }
                                      } else {
                                        result1 = null;
                                        pos = pos2;
                                      }
                                      result1 = result1 !== null ? result1 : "";
                                      if (result1 !== null) {
                                        pos2 = pos;
                                        if (input.charCodeAt(pos) === 58) {
                                          result2 = ":";
                                          pos++;
                                        } else {
                                          result2 = null;
                                          if (reportFailures === 0) {
                                            matchFailed("\":\"");
                                          }
                                        }
                                        if (result2 !== null) {
                                          result3 = parse_h16();
                                          if (result3 !== null) {
                                            result2 = [result2, result3];
                                          } else {
                                            result2 = null;
                                            pos = pos2;
                                          }
                                        } else {
                                          result2 = null;
                                          pos = pos2;
                                        }
                                        result2 = result2 !== null ? result2 : "";
                                        if (result2 !== null) {
                                          pos2 = pos;
                                          if (input.charCodeAt(pos) === 58) {
                                            result3 = ":";
                                            pos++;
                                          } else {
                                            result3 = null;
                                            if (reportFailures === 0) {
                                              matchFailed("\":\"");
                                            }
                                          }
                                          if (result3 !== null) {
                                            result4 = parse_h16();
                                            if (result4 !== null) {
                                              result3 = [result3, result4];
                                            } else {
                                              result3 = null;
                                              pos = pos2;
                                            }
                                          } else {
                                            result3 = null;
                                            pos = pos2;
                                          }
                                          result3 = result3 !== null ? result3 : "";
                                          if (result3 !== null) {
                                            pos2 = pos;
                                            if (input.charCodeAt(pos) === 58) {
                                              result4 = ":";
                                              pos++;
                                            } else {
                                              result4 = null;
                                              if (reportFailures === 0) {
                                                matchFailed("\":\"");
                                              }
                                            }
                                            if (result4 !== null) {
                                              result5 = parse_h16();
                                              if (result5 !== null) {
                                                result4 = [result4, result5];
                                              } else {
                                                result4 = null;
                                                pos = pos2;
                                              }
                                            } else {
                                              result4 = null;
                                              pos = pos2;
                                            }
                                            result4 = result4 !== null ? result4 : "";
                                            if (result4 !== null) {
                                              pos2 = pos;
                                              if (input.charCodeAt(pos) === 58) {
                                                result5 = ":";
                                                pos++;
                                              } else {
                                                result5 = null;
                                                if (reportFailures === 0) {
                                                  matchFailed("\":\"");
                                                }
                                              }
                                              if (result5 !== null) {
                                                result6 = parse_h16();
                                                if (result6 !== null) {
                                                  result5 = [result5, result6];
                                                } else {
                                                  result5 = null;
                                                  pos = pos2;
                                                }
                                              } else {
                                                result5 = null;
                                                pos = pos2;
                                              }
                                              result5 = result5 !== null ? result5 : "";
                                              if (result5 !== null) {
                                                pos2 = pos;
                                                if (input.charCodeAt(pos) === 58) {
                                                  result6 = ":";
                                                  pos++;
                                                } else {
                                                  result6 = null;
                                                  if (reportFailures === 0) {
                                                    matchFailed("\":\"");
                                                  }
                                                }
                                                if (result6 !== null) {
                                                  result7 = parse_h16();
                                                  if (result7 !== null) {
                                                    result6 = [result6, result7];
                                                  } else {
                                                    result6 = null;
                                                    pos = pos2;
                                                  }
                                                } else {
                                                  result6 = null;
                                                  pos = pos2;
                                                }
                                                result6 = result6 !== null ? result6 : "";
                                                if (result6 !== null) {
                                                  if (input.substr(pos, 2) === "::") {
                                                    result7 = "::";
                                                    pos += 2;
                                                  } else {
                                                    result7 = null;
                                                    if (reportFailures === 0) {
                                                      matchFailed("\"::\"");
                                                    }
                                                  }
                                                  if (result7 !== null) {
                                                    result0 = [result0, result1, result2, result3, result4, result5, result6, result7];
                                                  } else {
                                                    result0 = null;
                                                    pos = pos1;
                                                  }
                                                } else {
                                                  result0 = null;
                                                  pos = pos1;
                                                }
                                              } else {
                                                result0 = null;
                                                pos = pos1;
                                              }
                                            } else {
                                              result0 = null;
                                              pos = pos1;
                                            }
                                          } else {
                                            result0 = null;
                                            pos = pos1;
                                          }
                                        } else {
                                          result0 = null;
                                          pos = pos1;
                                        }
                                      } else {
                                        result0 = null;
                                        pos = pos1;
                                      }
                                    } else {
                                      result0 = null;
                                      pos = pos1;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.host_type = 'IPv6';
                          return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_h16() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ls32() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_h16();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_h16();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_IPv4address();
        }
        return result0;
      }
      
      function parse_IPv4address() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_dec_octet();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_dec_octet();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_dec_octet();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 46) {
                    result5 = ".";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_dec_octet();
                    if (result6 !== null) {
                      result0 = [result0, result1, result2, result3, result4, result5, result6];
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.host_type = 'IPv4';
                            return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_dec_octet() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "25") {
          result0 = "25";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"25\"");
          }
        }
        if (result0 !== null) {
          if (/^[0-5]/.test(input.charAt(pos))) {
            result1 = input.charAt(pos);
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("[0-5]");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          if (input.charCodeAt(pos) === 50) {
            result0 = "2";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"2\"");
            }
          }
          if (result0 !== null) {
            if (/^[0-4]/.test(input.charAt(pos))) {
              result1 = input.charAt(pos);
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("[0-4]");
              }
            }
            if (result1 !== null) {
              result2 = parse_DIGIT();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            if (input.charCodeAt(pos) === 49) {
              result0 = "1";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"1\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_DIGIT();
              if (result1 !== null) {
                result2 = parse_DIGIT();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
            if (result0 === null) {
              pos0 = pos;
              if (/^[1-9]/.test(input.charAt(pos))) {
                result0 = input.charAt(pos);
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("[1-9]");
                }
              }
              if (result0 !== null) {
                result1 = parse_DIGIT();
                if (result1 !== null) {
                  result0 = [result0, result1];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
              if (result0 === null) {
                result0 = parse_DIGIT();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, port) {
                            port = parseInt(port.join(''));
                            data.port = port;
                            return port; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uri_parameters() {
        var result0, result1, result2;
        var pos0;
        
        result0 = [];
        pos0 = pos;
        if (input.charCodeAt(pos) === 59) {
          result1 = ";";
          pos++;
        } else {
          result1 = null;
          if (reportFailures === 0) {
            matchFailed("\";\"");
          }
        }
        if (result1 !== null) {
          result2 = parse_uri_parameter();
          if (result2 !== null) {
            result1 = [result1, result2];
          } else {
            result1 = null;
            pos = pos0;
          }
        } else {
          result1 = null;
          pos = pos0;
        }
        while (result1 !== null) {
          result0.push(result1);
          pos0 = pos;
          if (input.charCodeAt(pos) === 59) {
            result1 = ";";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_uri_parameter();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos0;
            }
          } else {
            result1 = null;
            pos = pos0;
          }
        }
        return result0;
      }
      
      function parse_uri_parameter() {
        var result0;
        
        result0 = parse_transport_param();
        if (result0 === null) {
          result0 = parse_user_param();
          if (result0 === null) {
            result0 = parse_method_param();
            if (result0 === null) {
              result0 = parse_ttl_param();
              if (result0 === null) {
                result0 = parse_maddr_param();
                if (result0 === null) {
                  result0 = parse_lr_param();
                  if (result0 === null) {
                    result0 = parse_other_param();
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_transport_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 10).toLowerCase() === "transport=") {
          result0 = input.substr(pos, 10);
          pos += 10;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"transport=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result1 = input.substr(pos, 4);
                pos += 4;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\"sctp\"");
                }
              }
              if (result1 === null) {
                if (input.substr(pos, 3).toLowerCase() === "tls") {
                  result1 = input.substr(pos, 3);
                  pos += 3;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"tls\"");
                  }
                }
                if (result1 === null) {
                  result1 = parse_token();
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, transport) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['transport'] = transport.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_user_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "user=") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"user=\"");
          }
        }
        if (result0 !== null) {
          if (input.substr(pos, 5).toLowerCase() === "phone") {
            result1 = input.substr(pos, 5);
            pos += 5;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"phone\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 2).toLowerCase() === "ip") {
              result1 = input.substr(pos, 2);
              pos += 2;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"ip\"");
              }
            }
            if (result1 === null) {
              result1 = parse_token();
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, user) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['user'] = user.toLowerCase(); })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_method_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "method=") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"method=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_Method();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, method) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['method'] = method; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 4).toLowerCase() === "ttl=") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_ttl();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              if(!data.params) data.params={};
                              data.params['ttl'] = ttl; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_maddr_param() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "maddr=") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr=\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_host();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, maddr) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['maddr'] = maddr; })(pos0, result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_lr_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 2).toLowerCase() === "lr") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"lr\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(!data.uri_params) data.uri_params={};
                              data.uri_params['lr'] = undefined; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_other_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_pname();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_pvalue();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                              if(!data.uri_params) data.uri_params = {};
                              if (typeof value === 'undefined'){
                                value = undefined;
                              }
                              else {
                                value = value[1];
                              }
                              data.uri_params[param.toLowerCase()] = value && value.toLowerCase();})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pname() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pname) {return pname.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_pvalue() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_paramchar();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_paramchar();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, pvalue) {return pvalue.join(''); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_paramchar() {
        var result0;
        
        result0 = parse_param_unreserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_param_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 58) {
                result0 = ":";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\":\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_headers() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 63) {
          result0 = "?";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"?\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_header();
          if (result1 !== null) {
            result2 = [];
            pos1 = pos;
            if (input.charCodeAt(pos) === 38) {
              result3 = "&";
              pos++;
            } else {
              result3 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result3 !== null) {
              result4 = parse_header();
              if (result4 !== null) {
                result3 = [result3, result4];
              } else {
                result3 = null;
                pos = pos1;
              }
            } else {
              result3 = null;
              pos = pos1;
            }
            while (result3 !== null) {
              result2.push(result3);
              pos1 = pos;
              if (input.charCodeAt(pos) === 38) {
                result3 = "&";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"&\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_header();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hname();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 61) {
            result1 = "=";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"=\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, hname, hvalue) {
                              hname = hname.join('').toLowerCase();
                              hvalue = hvalue.join('');
                              if(!data.uri_headers) data.uri_headers = {};
                              if (!data.uri_headers[hname]) {
                                data.uri_headers[hname] = [hvalue];
                              } else {
                                data.uri_headers[hname].push(hvalue);
                              }})(pos0, result0[0], result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hname() {
        var result0, result1;
        
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_hnv_unreserved();
            if (result1 === null) {
              result1 = parse_unreserved();
              if (result1 === null) {
                result1 = parse_escaped();
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_hvalue() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_hnv_unreserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_hnv_unreserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
            }
          }
        }
        return result0;
      }
      
      function parse_hnv_unreserved() {
        var result0;
        
        if (input.charCodeAt(pos) === 91) {
          result0 = "[";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"[\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 93) {
            result0 = "]";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"]\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 47) {
              result0 = "/";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 43) {
                    result0 = "+";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"+\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 36) {
                      result0 = "$";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"$\"");
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Request_Response() {
        var result0;
        
        result0 = parse_Status_Line();
        if (result0 === null) {
          result0 = parse_Request_Line();
        }
        return result0;
      }
      
      function parse_Request_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_Method();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Request_URI();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_SIP_Version();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Request_URI() {
        var result0;
        
        result0 = parse_SIP_URI();
        if (result0 === null) {
          result0 = parse_absoluteURI();
        }
        return result0;
      }
      
      function parse_absoluteURI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hier_part();
            if (result2 === null) {
              result2 = parse_opaque_part();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hier_part() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_net_path();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 63) {
            result1 = "?";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"?\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_query();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_net_path() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2) === "//") {
          result0 = "//";
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"//\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_authority();
          if (result1 !== null) {
            result2 = parse_abs_path();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_abs_path() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.charCodeAt(pos) === 47) {
          result0 = "/";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"/\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_path_segments();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque_part() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_uric_no_slash();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_uric();
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_uric();
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uric() {
        var result0;
        
        result0 = parse_reserved();
        if (result0 === null) {
          result0 = parse_unreserved();
          if (result0 === null) {
            result0 = parse_escaped();
          }
        }
        return result0;
      }
      
      function parse_uric_no_slash() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 59) {
              result0 = ";";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 63) {
                result0 = "?";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 58) {
                  result0 = ":";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\":\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 64) {
                    result0 = "@";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"@\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 38) {
                      result0 = "&";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"&\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 61) {
                        result0 = "=";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"=\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 43) {
                          result0 = "+";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"+\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 36) {
                            result0 = "$";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"$\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 44) {
                              result0 = ",";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\",\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_path_segments() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_segment();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 47) {
            result2 = "/";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_segment();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 47) {
              result2 = "/";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"/\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_segment();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_segment() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 59) {
            result2 = ";";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\";\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 59) {
              result2 = ";";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\";\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_param() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_pchar();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_pchar();
        }
        return result0;
      }
      
      function parse_pchar() {
        var result0;
        
        result0 = parse_unreserved();
        if (result0 === null) {
          result0 = parse_escaped();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 58) {
              result0 = ":";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\":\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 64) {
                result0 = "@";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"@\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 38) {
                  result0 = "&";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"&\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 61) {
                    result0 = "=";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"=\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 43) {
                      result0 = "+";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"+\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 36) {
                        result0 = "$";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"$\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_scheme() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_ALPHA();
        if (result0 !== null) {
          result1 = [];
          result2 = parse_ALPHA();
          if (result2 === null) {
            result2 = parse_DIGIT();
            if (result2 === null) {
              if (input.charCodeAt(pos) === 43) {
                result2 = "+";
                pos++;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"+\"");
                }
              }
              if (result2 === null) {
                if (input.charCodeAt(pos) === 45) {
                  result2 = "-";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"-\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 46) {
                    result2 = ".";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\".\"");
                    }
                  }
                }
              }
            }
          }
          while (result2 !== null) {
            result1.push(result2);
            result2 = parse_ALPHA();
            if (result2 === null) {
              result2 = parse_DIGIT();
              if (result2 === null) {
                if (input.charCodeAt(pos) === 43) {
                  result2 = "+";
                  pos++;
                } else {
                  result2 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"+\"");
                  }
                }
                if (result2 === null) {
                  if (input.charCodeAt(pos) === 45) {
                    result2 = "-";
                    pos++;
                  } else {
                    result2 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result2 === null) {
                    if (input.charCodeAt(pos) === 46) {
                      result2 = ".";
                      pos++;
                    } else {
                      result2 = null;
                      if (reportFailures === 0) {
                        matchFailed("\".\"");
                      }
                    }
                  }
                }
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.scheme= input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_authority() {
        var result0;
        
        result0 = parse_srvr();
        if (result0 === null) {
          result0 = parse_reg_name();
        }
        return result0;
      }
      
      function parse_srvr() {
        var result0, result1;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_userinfo();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_hostport();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        
        result1 = parse_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            if (input.charCodeAt(pos) === 36) {
              result1 = "$";
              pos++;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"$\"");
              }
            }
            if (result1 === null) {
              if (input.charCodeAt(pos) === 44) {
                result1 = ",";
                pos++;
              } else {
                result1 = null;
                if (reportFailures === 0) {
                  matchFailed("\",\"");
                }
              }
              if (result1 === null) {
                if (input.charCodeAt(pos) === 59) {
                  result1 = ";";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\";\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 58) {
                    result1 = ":";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\":\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 64) {
                      result1 = "@";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"@\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 38) {
                        result1 = "&";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"&\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 61) {
                          result1 = "=";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"=\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 43) {
                            result1 = "+";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"+\"");
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                if (input.charCodeAt(pos) === 36) {
                  result1 = "$";
                  pos++;
                } else {
                  result1 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"$\"");
                  }
                }
                if (result1 === null) {
                  if (input.charCodeAt(pos) === 44) {
                    result1 = ",";
                    pos++;
                  } else {
                    result1 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result1 === null) {
                    if (input.charCodeAt(pos) === 59) {
                      result1 = ";";
                      pos++;
                    } else {
                      result1 = null;
                      if (reportFailures === 0) {
                        matchFailed("\";\"");
                      }
                    }
                    if (result1 === null) {
                      if (input.charCodeAt(pos) === 58) {
                        result1 = ":";
                        pos++;
                      } else {
                        result1 = null;
                        if (reportFailures === 0) {
                          matchFailed("\":\"");
                        }
                      }
                      if (result1 === null) {
                        if (input.charCodeAt(pos) === 64) {
                          result1 = "@";
                          pos++;
                        } else {
                          result1 = null;
                          if (reportFailures === 0) {
                            matchFailed("\"@\"");
                          }
                        }
                        if (result1 === null) {
                          if (input.charCodeAt(pos) === 38) {
                            result1 = "&";
                            pos++;
                          } else {
                            result1 = null;
                            if (reportFailures === 0) {
                              matchFailed("\"&\"");
                            }
                          }
                          if (result1 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result1 = "=";
                              pos++;
                            } else {
                              result1 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                            if (result1 === null) {
                              if (input.charCodeAt(pos) === 43) {
                                result1 = "+";
                                pos++;
                              } else {
                                result1 = null;
                                if (reportFailures === 0) {
                                  matchFailed("\"+\"");
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        } else {
          result0 = null;
        }
        return result0;
      }
      
      function parse_query() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_uric();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_uric();
        }
        return result0;
      }
      
      function parse_SIP_Version() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 47) {
            result1 = "/";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"/\"");
            }
          }
          if (result1 !== null) {
            result3 = parse_DIGIT();
            if (result3 !== null) {
              result2 = [];
              while (result3 !== null) {
                result2.push(result3);
                result3 = parse_DIGIT();
              }
            } else {
              result2 = null;
            }
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 46) {
                result3 = ".";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result3 !== null) {
                result5 = parse_DIGIT();
                if (result5 !== null) {
                  result4 = [];
                  while (result5 !== null) {
                    result4.push(result5);
                    result5 = parse_DIGIT();
                  }
                } else {
                  result4 = null;
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.sip_version = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_INVITEm() {
        var result0;
        
        if (input.substr(pos, 6) === "INVITE") {
          result0 = "INVITE";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"INVITE\"");
          }
        }
        return result0;
      }
      
      function parse_ACKm() {
        var result0;
        
        if (input.substr(pos, 3) === "ACK") {
          result0 = "ACK";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ACK\"");
          }
        }
        return result0;
      }
      
      function parse_OPTIONSm() {
        var result0;
        
        if (input.substr(pos, 7) === "OPTIONS") {
          result0 = "OPTIONS";
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"OPTIONS\"");
          }
        }
        return result0;
      }
      
      function parse_BYEm() {
        var result0;
        
        if (input.substr(pos, 3) === "BYE") {
          result0 = "BYE";
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"BYE\"");
          }
        }
        return result0;
      }
      
      function parse_CANCELm() {
        var result0;
        
        if (input.substr(pos, 6) === "CANCEL") {
          result0 = "CANCEL";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"CANCEL\"");
          }
        }
        return result0;
      }
      
      function parse_REGISTERm() {
        var result0;
        
        if (input.substr(pos, 8) === "REGISTER") {
          result0 = "REGISTER";
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"REGISTER\"");
          }
        }
        return result0;
      }
      
      function parse_SUBSCRIBEm() {
        var result0;
        
        if (input.substr(pos, 9) === "SUBSCRIBE") {
          result0 = "SUBSCRIBE";
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SUBSCRIBE\"");
          }
        }
        return result0;
      }
      
      function parse_NOTIFYm() {
        var result0;
        
        if (input.substr(pos, 6) === "NOTIFY") {
          result0 = "NOTIFY";
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"NOTIFY\"");
          }
        }
        return result0;
      }
      
      function parse_Method() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_INVITEm();
        if (result0 === null) {
          result0 = parse_ACKm();
          if (result0 === null) {
            result0 = parse_OPTIONSm();
            if (result0 === null) {
              result0 = parse_BYEm();
              if (result0 === null) {
                result0 = parse_CANCELm();
                if (result0 === null) {
                  result0 = parse_REGISTERm();
                  if (result0 === null) {
                    result0 = parse_SUBSCRIBEm();
                    if (result0 === null) {
                      result0 = parse_NOTIFYm();
                      if (result0 === null) {
                        result0 = parse_token();
                      }
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                            data.method = input.substring(pos, offset);
                            return data.method; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Line() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_SIP_Version();
        if (result0 !== null) {
          result1 = parse_SP();
          if (result1 !== null) {
            result2 = parse_Status_Code();
            if (result2 !== null) {
              result3 = parse_SP();
              if (result3 !== null) {
                result4 = parse_Reason_Phrase();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Status_Code() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_extension_code();
        if (result0 !== null) {
          result0 = (function(offset, status_code) {
                          data.status_code = parseInt(status_code.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_extension_code() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          if (result1 !== null) {
            result2 = parse_DIGIT();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Reason_Phrase() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_reserved();
        if (result1 === null) {
          result1 = parse_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_UTF8_NONASCII();
              if (result1 === null) {
                result1 = parse_UTF8_CONT();
                if (result1 === null) {
                  result1 = parse_SP();
                  if (result1 === null) {
                    result1 = parse_HTAB();
                  }
                }
              }
            }
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_reserved();
          if (result1 === null) {
            result1 = parse_unreserved();
            if (result1 === null) {
              result1 = parse_escaped();
              if (result1 === null) {
                result1 = parse_UTF8_NONASCII();
                if (result1 === null) {
                  result1 = parse_UTF8_CONT();
                  if (result1 === null) {
                    result1 = parse_SP();
                    if (result1 === null) {
                      result1 = parse_HTAB();
                    }
                  }
                }
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          data.reason_phrase = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Allow_Events() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_event_type();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_event_type();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Call_ID() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_word();
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 64) {
            result1 = "@";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"@\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_word();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Contact() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        result0 = parse_STAR();
        if (result0 === null) {
          pos1 = pos;
          result0 = parse_contact_param();
          if (result0 !== null) {
            result1 = [];
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_contact_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
            while (result2 !== null) {
              result1.push(result2);
              pos2 = pos;
              result2 = parse_COMMA();
              if (result2 !== null) {
                result3 = parse_contact_param();
                if (result3 !== null) {
                  result2 = [result2, result3];
                } else {
                  result2 = null;
                  pos = pos2;
                }
              } else {
                result2 = null;
                pos = pos2;
              }
            }
            if (result1 !== null) {
              result0 = [result0, result1];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var idx, length;
                                length = data.multi_header.length;
                                for (idx = 0; idx < length; idx++) {
                                  if (data.multi_header[idx].parsed === null) {
                                    data = null;
                                    break;
                                  }
                                }
                                if (data !== null) {
                                  data = data.multi_header;
                                } else {
                                  data = -1;
                                }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_param() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_contact_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_contact_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                var header;
                                if(!data.multi_header) data.multi_header = [];
                                try {
                                  header = new NameAddrHeader(data.uri, data.display_name, data.params);
                                  delete data.uri;
                                  delete data.display_name;
                                  delete data.params;
                                } catch(e) {
                                  header = null;
                                }
                                data.multi_header.push( { 'possition': pos,
                                                          'offset': offset,
                                                          'parsed': header
                                                        });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_name_addr() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_display_name();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_display_name() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_LWS();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_LWS();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        if (result0 !== null) {
          result0 = (function(offset, display_name) {
                                display_name = input.substring(pos, offset).trim();
                                if (display_name[0] === '\"') {
                                  display_name = display_name.substring(1, display_name.length-1);
                                }
                                data.display_name = display_name; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_contact_params() {
        var result0;
        
        result0 = parse_c_p_q();
        if (result0 === null) {
          result0 = parse_c_p_expires();
          if (result0 === null) {
            result0 = parse_generic_param();
          }
        }
        return result0;
      }
      
      function parse_c_p_q() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 1).toLowerCase() === "q") {
          result0 = input.substr(pos, 1);
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"q\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_qvalue();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, q) {
                                if(!data.params) data.params = {};
                                data.params['q'] = q; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_c_p_expires() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 7).toLowerCase() === "expires") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"expires\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_delta_seconds();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, expires) {
                                if(!data.params) data.params = {};
                                data.params['expires'] = expires; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_delta_seconds() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, delta_seconds) {
                                return parseInt(delta_seconds.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qvalue() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.charCodeAt(pos) === 48) {
          result0 = "0";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"0\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          if (input.charCodeAt(pos) === 46) {
            result1 = ".";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result1 = [result1, result2, result3, result4];
                } else {
                  result1 = null;
                  pos = pos2;
                }
              } else {
                result1 = null;
                pos = pos2;
              }
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                return parseFloat(input.substring(pos, offset)); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_generic_param() {
        var result0, result1, result2;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_gen_value();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, param, value) {
                                if(!data.params) data.params = {};
                                if (typeof value === 'undefined'){
                                  value = undefined;
                                }
                                else {
                                  value = value[1];
                                }
                                data.params[param.toLowerCase()] = value;})(pos0, result0[0], result0[1]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_gen_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_host();
          if (result0 === null) {
            result0 = parse_quoted_string();
          }
        }
        return result0;
      }
      
      function parse_Content_Disposition() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_disp_type();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_disp_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_disp_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_disp_type() {
        var result0;
        
        if (input.substr(pos, 6).toLowerCase() === "render") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"render\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "session") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"session\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 4).toLowerCase() === "icon") {
              result0 = input.substr(pos, 4);
              pos += 4;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"icon\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "alert") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"alert\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        return result0;
      }
      
      function parse_disp_param() {
        var result0;
        
        result0 = parse_handling_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_handling_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "handling") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"handling\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 8).toLowerCase() === "optional") {
              result2 = input.substr(pos, 8);
              pos += 8;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"optional\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "required") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"required\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Encoding() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Length() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, length) {
                                data = parseInt(length.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Content_Type() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_media_type();
        if (result0 !== null) {
          result0 = (function(offset) {
                                data = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_media_type() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_m_type();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_m_subtype();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_m_parameter();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_m_parameter();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_type() {
        var result0;
        
        result0 = parse_discrete_type();
        if (result0 === null) {
          result0 = parse_composite_type();
        }
        return result0;
      }
      
      function parse_discrete_type() {
        var result0;
        
        if (input.substr(pos, 4).toLowerCase() === "text") {
          result0 = input.substr(pos, 4);
          pos += 4;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"text\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 5).toLowerCase() === "image") {
            result0 = input.substr(pos, 5);
            pos += 5;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"image\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 5).toLowerCase() === "audio") {
              result0 = input.substr(pos, 5);
              pos += 5;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"audio\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 5).toLowerCase() === "video") {
                result0 = input.substr(pos, 5);
                pos += 5;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"video\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 11).toLowerCase() === "application") {
                  result0 = input.substr(pos, 11);
                  pos += 11;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"application\"");
                  }
                }
                if (result0 === null) {
                  result0 = parse_extension_token();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_composite_type() {
        var result0;
        
        if (input.substr(pos, 7).toLowerCase() === "message") {
          result0 = input.substr(pos, 7);
          pos += 7;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"message\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "multipart") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"multipart\"");
            }
          }
          if (result0 === null) {
            result0 = parse_extension_token();
          }
        }
        return result0;
      }
      
      function parse_extension_token() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_x_token();
        }
        return result0;
      }
      
      function parse_x_token() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 2).toLowerCase() === "x-") {
          result0 = input.substr(pos, 2);
          pos += 2;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"x-\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_token();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_subtype() {
        var result0;
        
        result0 = parse_extension_token();
        if (result0 === null) {
          result0 = parse_token();
        }
        return result0;
      }
      
      function parse_m_parameter() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_m_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_m_value() {
        var result0;
        
        result0 = parse_token();
        if (result0 === null) {
          result0 = parse_quoted_string();
        }
        return result0;
      }
      
      function parse_CSeq() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_CSeq_value();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_Method();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_CSeq_value() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, cseq_value) {
                          data.value=parseInt(cseq_value.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, expires) {data = expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Event() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_event_type();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, event_type) {
                               data.event = event_type.join('').toLowerCase(); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_event_type() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token_nodot();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          if (input.charCodeAt(pos) === 46) {
            result2 = ".";
            pos++;
          } else {
            result2 = null;
            if (reportFailures === 0) {
              matchFailed("\".\"");
            }
          }
          if (result2 !== null) {
            result3 = parse_token_nodot();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            if (input.charCodeAt(pos) === 46) {
              result2 = ".";
              pos++;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\".\"");
              }
            }
            if (result2 !== null) {
              result3 = parse_token_nodot();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_From() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_from_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_from_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                        var tag = data.tag;
                        try {
                          data = new NameAddrHeader(data.uri, data.display_name, data.params);
                          if (tag) {data.setParam('tag',tag)}
                        } catch(e) {
                          data = -1;
                        }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_from_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_tag_param() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "tag") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"tag\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, tag) {data.tag = tag; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Max_Forwards() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result1 = parse_DIGIT();
        if (result1 !== null) {
          result0 = [];
          while (result1 !== null) {
            result0.push(result1);
            result1 = parse_DIGIT();
          }
        } else {
          result0 = null;
        }
        if (result0 !== null) {
          result0 = (function(offset, forwards) {
                          data = parseInt(forwards.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Min_Expires() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_delta_seconds();
        if (result0 !== null) {
          result0 = (function(offset, min_expires) {data = min_expires; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Name_Addr_Header() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = [];
        result1 = parse_display_name();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_display_name();
        }
        if (result0 !== null) {
          result1 = parse_LAQUOT();
          if (result1 !== null) {
            result2 = parse_SIP_URI();
            if (result2 !== null) {
              result3 = parse_RAQUOT();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                result5 = parse_SEMI();
                if (result5 !== null) {
                  result6 = parse_generic_param();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  result5 = parse_SEMI();
                  if (result5 !== null) {
                    result6 = parse_generic_param();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              try {
                                data = new NameAddrHeader(data.uri, data.display_name, data.params);
                              } catch(e) {
                                data = -1;
                              }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "digest") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"Digest\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_digest_cln();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_digest_cln();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_digest_cln();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        if (result0 === null) {
          result0 = parse_other_challenge();
        }
        return result0;
      }
      
      function parse_other_challenge() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_auth_param();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_COMMA();
              if (result4 !== null) {
                result5 = parse_auth_param();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_COMMA();
                if (result4 !== null) {
                  result5 = parse_auth_param();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_auth_param() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 === null) {
              result2 = parse_quoted_string();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_digest_cln() {
        var result0;
        
        result0 = parse_realm();
        if (result0 === null) {
          result0 = parse_domain();
          if (result0 === null) {
            result0 = parse_nonce();
            if (result0 === null) {
              result0 = parse_opaque();
              if (result0 === null) {
                result0 = parse_stale();
                if (result0 === null) {
                  result0 = parse_algorithm();
                  if (result0 === null) {
                    result0 = parse_qop_options();
                    if (result0 === null) {
                      result0 = parse_auth_param();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_realm() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "realm") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"realm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_realm_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_realm_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, realm) { data.realm = realm; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_domain() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "domain") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"domain\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              result3 = parse_URI();
              if (result3 !== null) {
                result4 = [];
                pos1 = pos;
                result6 = parse_SP();
                if (result6 !== null) {
                  result5 = [];
                  while (result6 !== null) {
                    result5.push(result6);
                    result6 = parse_SP();
                  }
                } else {
                  result5 = null;
                }
                if (result5 !== null) {
                  result6 = parse_URI();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                } else {
                  result5 = null;
                  pos = pos1;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos1 = pos;
                  result6 = parse_SP();
                  if (result6 !== null) {
                    result5 = [];
                    while (result6 !== null) {
                      result5.push(result6);
                      result6 = parse_SP();
                    }
                  } else {
                    result5 = null;
                  }
                  if (result5 !== null) {
                    result6 = parse_URI();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos1;
                    }
                  } else {
                    result5 = null;
                    pos = pos1;
                  }
                }
                if (result4 !== null) {
                  result5 = parse_RDQUOT();
                  if (result5 !== null) {
                    result0 = [result0, result1, result2, result3, result4, result5];
                  } else {
                    result0 = null;
                    pos = pos0;
                  }
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_URI() {
        var result0;
        
        result0 = parse_absoluteURI();
        if (result0 === null) {
          result0 = parse_abs_path();
        }
        return result0;
      }
      
      function parse_nonce() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "nonce") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"nonce\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_nonce_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_nonce_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_quoted_string_clean();
        if (result0 !== null) {
          result0 = (function(offset, nonce) { data.nonce=nonce; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_opaque() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "opaque") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"opaque\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_quoted_string_clean();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, opaque) { data.opaque=opaque; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stale() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stale") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stale\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            pos1 = pos;
            if (input.substr(pos, 4).toLowerCase() === "true") {
              result2 = input.substr(pos, 4);
              pos += 4;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"true\"");
              }
            }
            if (result2 !== null) {
              result2 = (function(offset) { data.stale=true; })(pos1);
            }
            if (result2 === null) {
              pos = pos1;
            }
            if (result2 === null) {
              pos1 = pos;
              if (input.substr(pos, 5).toLowerCase() === "false") {
                result2 = input.substr(pos, 5);
                pos += 5;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"false\"");
                }
              }
              if (result2 !== null) {
                result2 = (function(offset) { data.stale=false; })(pos1);
              }
              if (result2 === null) {
                pos = pos1;
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_algorithm() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 9).toLowerCase() === "algorithm") {
          result0 = input.substr(pos, 9);
          pos += 9;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"algorithm\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            if (input.substr(pos, 3).toLowerCase() === "md5") {
              result2 = input.substr(pos, 3);
              pos += 3;
            } else {
              result2 = null;
              if (reportFailures === 0) {
                matchFailed("\"MD5\"");
              }
            }
            if (result2 === null) {
              if (input.substr(pos, 8).toLowerCase() === "md5-sess") {
                result2 = input.substr(pos, 8);
                pos += 8;
              } else {
                result2 = null;
                if (reportFailures === 0) {
                  matchFailed("\"MD5-sess\"");
                }
              }
              if (result2 === null) {
                result2 = parse_token();
              }
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, algorithm) {
                              data.algorithm=algorithm.toUpperCase(); })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_options() {
        var result0, result1, result2, result3, result4, result5, result6;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "qop") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"qop\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_LDQUOT();
            if (result2 !== null) {
              pos1 = pos;
              result3 = parse_qop_value();
              if (result3 !== null) {
                result4 = [];
                pos2 = pos;
                if (input.charCodeAt(pos) === 44) {
                  result5 = ",";
                  pos++;
                } else {
                  result5 = null;
                  if (reportFailures === 0) {
                    matchFailed("\",\"");
                  }
                }
                if (result5 !== null) {
                  result6 = parse_qop_value();
                  if (result6 !== null) {
                    result5 = [result5, result6];
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                } else {
                  result5 = null;
                  pos = pos2;
                }
                while (result5 !== null) {
                  result4.push(result5);
                  pos2 = pos;
                  if (input.charCodeAt(pos) === 44) {
                    result5 = ",";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\",\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_qop_value();
                    if (result6 !== null) {
                      result5 = [result5, result6];
                    } else {
                      result5 = null;
                      pos = pos2;
                    }
                  } else {
                    result5 = null;
                    pos = pos2;
                  }
                }
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              if (result3 !== null) {
                result4 = parse_RDQUOT();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_qop_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 8).toLowerCase() === "auth-int") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"auth-int\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "auth") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"auth\"");
            }
          }
          if (result0 === null) {
            result0 = parse_token();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, qop_value) {
                                data.qop || (data.qop=[]);
                                data.qop.push(qop_value.toLowerCase()); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Proxy_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Record_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_rec_route();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_rec_route();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_rec_route();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var idx, length;
                          length = data.multi_header.length;
                          for (idx = 0; idx < length; idx++) {
                            if (data.multi_header[idx].parsed === null) {
                              data = null;
                              break;
                            }
                          }
                          if (data !== null) {
                            data = data.multi_header;
                          } else {
                            data = -1;
                          }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_rec_route() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                          var header;
                          if(!data.multi_header) data.multi_header = [];
                          try {
                            header = new NameAddrHeader(data.uri, data.display_name, data.params);
                            delete data.uri;
                            delete data.display_name;
                            delete data.params;
                          } catch(e) {
                            header = null;
                          }
                          data.multi_header.push( { 'possition': pos,
                                                    'offset': offset,
                                                    'parsed': header
                                                  });})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Require() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Route() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_route_param();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_route_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_route_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_route_param() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_name_addr();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_generic_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_generic_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_Subscription_State() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_substate_value();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_subexp_params();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_subexp_params();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_substate_value() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 6).toLowerCase() === "active") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"active\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 7).toLowerCase() === "pending") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"pending\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 10).toLowerCase() === "terminated") {
              result0 = input.substr(pos, 10);
              pos += 10;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"terminated\"");
              }
            }
            if (result0 === null) {
              result0 = parse_token();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                                data.state = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_subexp_params() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "reason") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"reason\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_event_reason_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, reason) {
                                if (typeof reason !== 'undefined') data.reason = reason; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        if (result0 === null) {
          pos0 = pos;
          pos1 = pos;
          if (input.substr(pos, 7).toLowerCase() === "expires") {
            result0 = input.substr(pos, 7);
            pos += 7;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"expires\"");
            }
          }
          if (result0 !== null) {
            result1 = parse_EQUAL();
            if (result1 !== null) {
              result2 = parse_delta_seconds();
              if (result2 !== null) {
                result0 = [result0, result1, result2];
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
          if (result0 !== null) {
            result0 = (function(offset, expires) {
                                  if (typeof expires !== 'undefined') data.expires = expires; })(pos0, result0[2]);
          }
          if (result0 === null) {
            pos = pos0;
          }
          if (result0 === null) {
            pos0 = pos;
            pos1 = pos;
            if (input.substr(pos, 11).toLowerCase() === "retry_after") {
              result0 = input.substr(pos, 11);
              pos += 11;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"retry_after\"");
              }
            }
            if (result0 !== null) {
              result1 = parse_EQUAL();
              if (result1 !== null) {
                result2 = parse_delta_seconds();
                if (result2 !== null) {
                  result0 = [result0, result1, result2];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
            if (result0 !== null) {
              result0 = (function(offset, retry_after) {
                                    if (typeof retry_after !== 'undefined') data.retry_after = retry_after; })(pos0, result0[2]);
            }
            if (result0 === null) {
              pos = pos0;
            }
            if (result0 === null) {
              result0 = parse_generic_param();
            }
          }
        }
        return result0;
      }
      
      function parse_event_reason_value() {
        var result0;
        
        if (input.substr(pos, 11).toLowerCase() === "deactivated") {
          result0 = input.substr(pos, 11);
          pos += 11;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"deactivated\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 9).toLowerCase() === "probation") {
            result0 = input.substr(pos, 9);
            pos += 9;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"probation\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 8).toLowerCase() === "rejected") {
              result0 = input.substr(pos, 8);
              pos += 8;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"rejected\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 7).toLowerCase() === "timeout") {
                result0 = input.substr(pos, 7);
                pos += 7;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"timeout\"");
                }
              }
              if (result0 === null) {
                if (input.substr(pos, 6).toLowerCase() === "giveup") {
                  result0 = input.substr(pos, 6);
                  pos += 6;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"giveup\"");
                  }
                }
                if (result0 === null) {
                  if (input.substr(pos, 10).toLowerCase() === "noresource") {
                    result0 = input.substr(pos, 10);
                    pos += 10;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"noresource\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.substr(pos, 9).toLowerCase() === "invariant") {
                      result0 = input.substr(pos, 9);
                      pos += 9;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"invariant\"");
                      }
                    }
                    if (result0 === null) {
                      result0 = parse_token();
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_Subject() {
        var result0;
        
        result0 = parse_TEXT_UTF8_TRIM();
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_Supported() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_token();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_token();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        result0 = result0 !== null ? result0 : "";
        return result0;
      }
      
      function parse_To() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_SIP_URI_noparams();
        if (result0 === null) {
          result0 = parse_name_addr();
        }
        if (result0 !== null) {
          result1 = [];
          pos2 = pos;
          result2 = parse_SEMI();
          if (result2 !== null) {
            result3 = parse_to_param();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos2;
            }
          } else {
            result2 = null;
            pos = pos2;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos2 = pos;
            result2 = parse_SEMI();
            if (result2 !== null) {
              result3 = parse_to_param();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos2;
              }
            } else {
              result2 = null;
              pos = pos2;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                      var tag = data.tag;
                      try {
                        data = new NameAddrHeader(data.uri, data.display_name, data.params);
                        if (tag) {data.setParam('tag',tag)}
                      } catch(e) {
                        data = -1;
                      }})(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_to_param() {
        var result0;
        
        result0 = parse_tag_param();
        if (result0 === null) {
          result0 = parse_generic_param();
        }
        return result0;
      }
      
      function parse_Via() {
        var result0, result1, result2, result3;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_parm();
        if (result0 !== null) {
          result1 = [];
          pos1 = pos;
          result2 = parse_COMMA();
          if (result2 !== null) {
            result3 = parse_via_parm();
            if (result3 !== null) {
              result2 = [result2, result3];
            } else {
              result2 = null;
              pos = pos1;
            }
          } else {
            result2 = null;
            pos = pos1;
          }
          while (result2 !== null) {
            result1.push(result2);
            pos1 = pos;
            result2 = parse_COMMA();
            if (result2 !== null) {
              result3 = parse_via_parm();
              if (result3 !== null) {
                result2 = [result2, result3];
              } else {
                result2 = null;
                pos = pos1;
              }
            } else {
              result2 = null;
              pos = pos1;
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_parm() {
        var result0, result1, result2, result3, result4, result5;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_sent_protocol();
        if (result0 !== null) {
          result1 = parse_LWS();
          if (result1 !== null) {
            result2 = parse_sent_by();
            if (result2 !== null) {
              result3 = [];
              pos1 = pos;
              result4 = parse_SEMI();
              if (result4 !== null) {
                result5 = parse_via_params();
                if (result5 !== null) {
                  result4 = [result4, result5];
                } else {
                  result4 = null;
                  pos = pos1;
                }
              } else {
                result4 = null;
                pos = pos1;
              }
              while (result4 !== null) {
                result3.push(result4);
                pos1 = pos;
                result4 = parse_SEMI();
                if (result4 !== null) {
                  result5 = parse_via_params();
                  if (result5 !== null) {
                    result4 = [result4, result5];
                  } else {
                    result4 = null;
                    pos = pos1;
                  }
                } else {
                  result4 = null;
                  pos = pos1;
                }
              }
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_params() {
        var result0;
        
        result0 = parse_via_ttl();
        if (result0 === null) {
          result0 = parse_via_maddr();
          if (result0 === null) {
            result0 = parse_via_received();
            if (result0 === null) {
              result0 = parse_via_branch();
              if (result0 === null) {
                result0 = parse_response_port();
                if (result0 === null) {
                  result0 = parse_generic_param();
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_via_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 3).toLowerCase() === "ttl") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"ttl\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_ttl();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_ttl_value) {
                              data.ttl = via_ttl_value; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_maddr() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "maddr") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"maddr\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_host();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_maddr) {
                              data.maddr = via_maddr; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_received() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 8).toLowerCase() === "received") {
          result0 = input.substr(pos, 8);
          pos += 8;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"received\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_IPv4address();
            if (result2 === null) {
              result2 = parse_IPv6address();
            }
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_received) {
                              data.received = via_received; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_branch() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 6).toLowerCase() === "branch") {
          result0 = input.substr(pos, 6);
          pos += 6;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"branch\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_branch) {
                              data.branch = via_branch; })(pos0, result0[2]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_response_port() {
        var result0, result1, result2, result3;
        var pos0, pos1, pos2;
        
        pos0 = pos;
        pos1 = pos;
        if (input.substr(pos, 5).toLowerCase() === "rport") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"rport\"");
          }
        }
        if (result0 !== null) {
          pos2 = pos;
          result1 = parse_EQUAL();
          if (result1 !== null) {
            result2 = [];
            result3 = parse_DIGIT();
            while (result3 !== null) {
              result2.push(result3);
              result3 = parse_DIGIT();
            }
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos2;
            }
          } else {
            result1 = null;
            pos = pos2;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              if(typeof response_port !== 'undefined')
                                data.rport = response_port.join(''); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_protocol() {
        var result0, result1, result2, result3, result4;
        var pos0;
        
        pos0 = pos;
        result0 = parse_protocol_name();
        if (result0 !== null) {
          result1 = parse_SLASH();
          if (result1 !== null) {
            result2 = parse_token();
            if (result2 !== null) {
              result3 = parse_SLASH();
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos0;
                }
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_protocol_name() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "sip") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"SIP\"");
          }
        }
        if (result0 === null) {
          result0 = parse_token();
        }
        if (result0 !== null) {
          result0 = (function(offset, via_protocol) {
                              data.protocol = via_protocol; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_transport() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 3).toLowerCase() === "udp") {
          result0 = input.substr(pos, 3);
          pos += 3;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"UDP\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 3).toLowerCase() === "tcp") {
            result0 = input.substr(pos, 3);
            pos += 3;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"TCP\"");
            }
          }
          if (result0 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tls") {
              result0 = input.substr(pos, 3);
              pos += 3;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"TLS\"");
              }
            }
            if (result0 === null) {
              if (input.substr(pos, 4).toLowerCase() === "sctp") {
                result0 = input.substr(pos, 4);
                pos += 4;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"SCTP\"");
                }
              }
              if (result0 === null) {
                result0 = parse_token();
              }
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, via_transport) {
                              data.transport = via_transport; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_sent_by() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_via_host();
        if (result0 !== null) {
          pos1 = pos;
          result1 = parse_COLON();
          if (result1 !== null) {
            result2 = parse_via_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_hostname();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.host = input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_via_port() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        result0 = result0 !== null ? result0 : "";
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result3 = parse_DIGIT();
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result4 = parse_DIGIT();
                result4 = result4 !== null ? result4 : "";
                if (result4 !== null) {
                  result0 = [result0, result1, result2, result3, result4];
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, via_sent_by_port) {
                              data.port = parseInt(via_sent_by_port.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_ttl() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_DIGIT();
        if (result0 !== null) {
          result1 = parse_DIGIT();
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result2 = parse_DIGIT();
            result2 = result2 !== null ? result2 : "";
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, ttl) {
                              return parseInt(ttl.join('')); })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_WWW_Authenticate() {
        var result0;
        
        result0 = parse_challenge();
        return result0;
      }
      
      function parse_extension_header() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_token();
        if (result0 !== null) {
          result1 = parse_HCOLON();
          if (result1 !== null) {
            result2 = parse_header_value();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_header_value() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_TEXT_UTF8char();
        if (result1 === null) {
          result1 = parse_UTF8_CONT();
          if (result1 === null) {
            result1 = parse_LWS();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_TEXT_UTF8char();
          if (result1 === null) {
            result1 = parse_UTF8_CONT();
            if (result1 === null) {
              result1 = parse_LWS();
            }
          }
        }
        return result0;
      }
      
      function parse_message_body() {
        var result0, result1;
        
        result0 = [];
        result1 = parse_OCTET();
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_OCTET();
        }
        return result0;
      }
      
      function parse_stun_URI() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_stun_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "stuns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"stuns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "stun") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"stun\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host_port() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_stun_host();
        if (result0 !== null) {
          pos1 = pos;
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_port();
            if (result2 !== null) {
              result1 = [result1, result2];
            } else {
              result1 = null;
              pos = pos1;
            }
          } else {
            result1 = null;
            pos = pos1;
          }
          result1 = result1 !== null ? result1 : "";
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_host() {
        var result0;
        var pos0;
        
        pos0 = pos;
        result0 = parse_IPv4address();
        if (result0 === null) {
          result0 = parse_IPv6reference();
          if (result0 === null) {
            result0 = parse_reg_name();
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, host) {
                              data.host = host; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_reg_name() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = [];
        result1 = parse_stun_unreserved();
        if (result1 === null) {
          result1 = parse_escaped();
          if (result1 === null) {
            result1 = parse_sub_delims();
          }
        }
        while (result1 !== null) {
          result0.push(result1);
          result1 = parse_stun_unreserved();
          if (result1 === null) {
            result1 = parse_escaped();
            if (result1 === null) {
              result1 = parse_sub_delims();
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              return input.substring(pos, offset); })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_stun_unreserved() {
        var result0;
        
        result0 = parse_ALPHA();
        if (result0 === null) {
          result0 = parse_DIGIT();
          if (result0 === null) {
            if (input.charCodeAt(pos) === 45) {
              result0 = "-";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"-\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 46) {
                result0 = ".";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\".\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 95) {
                  result0 = "_";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"_\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 126) {
                    result0 = "~";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"~\"");
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_sub_delims() {
        var result0;
        
        if (input.charCodeAt(pos) === 33) {
          result0 = "!";
          pos++;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"!\"");
          }
        }
        if (result0 === null) {
          if (input.charCodeAt(pos) === 36) {
            result0 = "$";
            pos++;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"$\"");
            }
          }
          if (result0 === null) {
            if (input.charCodeAt(pos) === 38) {
              result0 = "&";
              pos++;
            } else {
              result0 = null;
              if (reportFailures === 0) {
                matchFailed("\"&\"");
              }
            }
            if (result0 === null) {
              if (input.charCodeAt(pos) === 39) {
                result0 = "'";
                pos++;
              } else {
                result0 = null;
                if (reportFailures === 0) {
                  matchFailed("\"'\"");
                }
              }
              if (result0 === null) {
                if (input.charCodeAt(pos) === 40) {
                  result0 = "(";
                  pos++;
                } else {
                  result0 = null;
                  if (reportFailures === 0) {
                    matchFailed("\"(\"");
                  }
                }
                if (result0 === null) {
                  if (input.charCodeAt(pos) === 41) {
                    result0 = ")";
                    pos++;
                  } else {
                    result0 = null;
                    if (reportFailures === 0) {
                      matchFailed("\")\"");
                    }
                  }
                  if (result0 === null) {
                    if (input.charCodeAt(pos) === 42) {
                      result0 = "*";
                      pos++;
                    } else {
                      result0 = null;
                      if (reportFailures === 0) {
                        matchFailed("\"*\"");
                      }
                    }
                    if (result0 === null) {
                      if (input.charCodeAt(pos) === 43) {
                        result0 = "+";
                        pos++;
                      } else {
                        result0 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"+\"");
                        }
                      }
                      if (result0 === null) {
                        if (input.charCodeAt(pos) === 44) {
                          result0 = ",";
                          pos++;
                        } else {
                          result0 = null;
                          if (reportFailures === 0) {
                            matchFailed("\",\"");
                          }
                        }
                        if (result0 === null) {
                          if (input.charCodeAt(pos) === 59) {
                            result0 = ";";
                            pos++;
                          } else {
                            result0 = null;
                            if (reportFailures === 0) {
                              matchFailed("\";\"");
                            }
                          }
                          if (result0 === null) {
                            if (input.charCodeAt(pos) === 61) {
                              result0 = "=";
                              pos++;
                            } else {
                              result0 = null;
                              if (reportFailures === 0) {
                                matchFailed("\"=\"");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        return result0;
      }
      
      function parse_turn_URI() {
        var result0, result1, result2, result3, result4;
        var pos0, pos1;
        
        pos0 = pos;
        result0 = parse_turn_scheme();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 58) {
            result1 = ":";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\":\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_stun_host_port();
            if (result2 !== null) {
              pos1 = pos;
              if (input.substr(pos, 11) === "?transport=") {
                result3 = "?transport=";
                pos += 11;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"?transport=\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_transport();
                if (result4 !== null) {
                  result3 = [result3, result4];
                } else {
                  result3 = null;
                  pos = pos1;
                }
              } else {
                result3 = null;
                pos = pos1;
              }
              result3 = result3 !== null ? result3 : "";
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_scheme() {
        var result0;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5).toLowerCase() === "turns") {
          result0 = input.substr(pos, 5);
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"turns\"");
          }
        }
        if (result0 === null) {
          if (input.substr(pos, 4).toLowerCase() === "turn") {
            result0 = input.substr(pos, 4);
            pos += 4;
          } else {
            result0 = null;
            if (reportFailures === 0) {
              matchFailed("\"turn\"");
            }
          }
        }
        if (result0 !== null) {
          result0 = (function(offset, scheme) {
                              data.scheme = scheme; })(pos0, result0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_turn_transport() {
        var result0, result1, result2;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_transport();
        if (result0 !== null) {
          if (input.substr(pos, 3).toLowerCase() === "udp") {
            result1 = input.substr(pos, 3);
            pos += 3;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"udp\"");
            }
          }
          if (result1 === null) {
            if (input.substr(pos, 3).toLowerCase() === "tcp") {
              result1 = input.substr(pos, 3);
              pos += 3;
            } else {
              result1 = null;
              if (reportFailures === 0) {
                matchFailed("\"tcp\"");
              }
            }
            if (result1 === null) {
              result1 = [];
              result2 = parse_unreserved();
              while (result2 !== null) {
                result1.push(result2);
                result2 = parse_unreserved();
              }
            }
          }
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset) {
                              data.transport = transport; })(pos0);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid_URI() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        if (input.substr(pos, 5) === "uuid:") {
          result0 = "uuid:";
          pos += 5;
        } else {
          result0 = null;
          if (reportFailures === 0) {
            matchFailed("\"uuid:\"");
          }
        }
        if (result0 !== null) {
          result1 = parse_uuid();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_uuid() {
        var result0, result1, result2, result3, result4, result5, result6, result7, result8;
        var pos0, pos1;
        
        pos0 = pos;
        pos1 = pos;
        result0 = parse_hex8();
        if (result0 !== null) {
          if (input.charCodeAt(pos) === 45) {
            result1 = "-";
            pos++;
          } else {
            result1 = null;
            if (reportFailures === 0) {
              matchFailed("\"-\"");
            }
          }
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              if (input.charCodeAt(pos) === 45) {
                result3 = "-";
                pos++;
              } else {
                result3 = null;
                if (reportFailures === 0) {
                  matchFailed("\"-\"");
                }
              }
              if (result3 !== null) {
                result4 = parse_hex4();
                if (result4 !== null) {
                  if (input.charCodeAt(pos) === 45) {
                    result5 = "-";
                    pos++;
                  } else {
                    result5 = null;
                    if (reportFailures === 0) {
                      matchFailed("\"-\"");
                    }
                  }
                  if (result5 !== null) {
                    result6 = parse_hex4();
                    if (result6 !== null) {
                      if (input.charCodeAt(pos) === 45) {
                        result7 = "-";
                        pos++;
                      } else {
                        result7 = null;
                        if (reportFailures === 0) {
                          matchFailed("\"-\"");
                        }
                      }
                      if (result7 !== null) {
                        result8 = parse_hex12();
                        if (result8 !== null) {
                          result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8];
                        } else {
                          result0 = null;
                          pos = pos1;
                        }
                      } else {
                        result0 = null;
                        pos = pos1;
                      }
                    } else {
                      result0 = null;
                      pos = pos1;
                    }
                  } else {
                    result0 = null;
                    pos = pos1;
                  }
                } else {
                  result0 = null;
                  pos = pos1;
                }
              } else {
                result0 = null;
                pos = pos1;
              }
            } else {
              result0 = null;
              pos = pos1;
            }
          } else {
            result0 = null;
            pos = pos1;
          }
        } else {
          result0 = null;
          pos = pos1;
        }
        if (result0 !== null) {
          result0 = (function(offset, uuid) {
                          data = input.substring(pos+5, offset); })(pos0, result0[0]);
        }
        if (result0 === null) {
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex4() {
        var result0, result1, result2, result3;
        var pos0;
        
        pos0 = pos;
        result0 = parse_HEXDIG();
        if (result0 !== null) {
          result1 = parse_HEXDIG();
          if (result1 !== null) {
            result2 = parse_HEXDIG();
            if (result2 !== null) {
              result3 = parse_HEXDIG();
              if (result3 !== null) {
                result0 = [result0, result1, result2, result3];
              } else {
                result0 = null;
                pos = pos0;
              }
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex8() {
        var result0, result1;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result0 = [result0, result1];
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      function parse_hex12() {
        var result0, result1, result2;
        var pos0;
        
        pos0 = pos;
        result0 = parse_hex4();
        if (result0 !== null) {
          result1 = parse_hex4();
          if (result1 !== null) {
            result2 = parse_hex4();
            if (result2 !== null) {
              result0 = [result0, result1, result2];
            } else {
              result0 = null;
              pos = pos0;
            }
          } else {
            result0 = null;
            pos = pos0;
          }
        } else {
          result0 = null;
          pos = pos0;
        }
        return result0;
      }
      
      
      function cleanupExpected(expected) {
        expected.sort();
        
        var lastExpected = null;
        var cleanExpected = [];
        for (var i = 0; i < expected.length; i++) {
          if (expected[i] !== lastExpected) {
            cleanExpected.push(expected[i]);
            lastExpected = expected[i];
          }
        }
        return cleanExpected;
      }
      
      function computeErrorPosition() {
        /*
         * The first idea was to use |String.split| to break the input up to the
         * error position along newlines and derive the line and column from
         * there. However IE's |split| implementation is so broken that it was
         * enough to prevent it.
         */
        
        var line = 1;
        var column = 1;
        var seenCR = false;
        
        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {
          var ch = input.charAt(i);
          if (ch === "\n") {
            if (!seenCR) { line++; }
            column = 1;
            seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            line++;
            column = 1;
            seenCR = true;
          } else {
            column++;
            seenCR = false;
          }
        }
        
        return { line: line, column: column };
      }
      
      
        var URI = require('./URI');
        var NameAddrHeader = require('./NameAddrHeader');
      
        var data = {};
      
      
      var result = parseFunctions[startRule]();
      
      /*
       * The parser is now in one of the following three states:
       *
       * 1. The parser successfully parsed the whole input.
       *
       *    - |result !== null|
       *    - |pos === input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 2. The parser successfully parsed only a part of the input.
       *
       *    - |result !== null|
       *    - |pos < input.length|
       *    - |rightmostFailuresExpected| may or may not contain something
       *
       * 3. The parser did not successfully parse any part of the input.
       *
       *   - |result === null|
       *   - |pos === 0|
       *   - |rightmostFailuresExpected| contains at least one failure
       *
       * All code following this comment (including called functions) must
       * handle these states.
       */
      if (result === null || pos !== input.length) {
        var offset = Math.max(pos, rightmostFailuresPos);
        var found = offset < input.length ? input.charAt(offset) : null;
        var errorPosition = computeErrorPosition();
        
        new this.SyntaxError(
          cleanupExpected(rightmostFailuresExpected),
          found,
          offset,
          errorPosition.line,
          errorPosition.column
        );
        return -1;
      }
      
      return data;
    },
    
    /* Returns the parser source code. */
    toSource: function() { return this._source; }
  };
  
  /* Thrown when a parser encounters a syntax error. */
  
  result.SyntaxError = function(expected, found, offset, line, column) {
    function buildMessage(expected, found) {
      var expectedHumanized, foundHumanized;
      
      switch (expected.length) {
        case 0:
          expectedHumanized = "end of input";
          break;
        case 1:
          expectedHumanized = expected[0];
          break;
        default:
          expectedHumanized = expected.slice(0, expected.length - 1).join(", ")
            + " or "
            + expected[expected.length - 1];
      }
      
      foundHumanized = found ? quote(found) : "end of input";
      
      return "Expected " + expectedHumanized + " but " + foundHumanized + " found.";
    }
    
    this.name = "SyntaxError";
    this.expected = expected;
    this.found = found;
    this.message = buildMessage(expected, found);
    this.offset = offset;
    this.line = line;
    this.column = column;
  };
  
  result.SyntaxError.prototype = Error.prototype;
  
  return result;
})();

},{"./NameAddrHeader":208,"./URI":221}],205:[function(require,module,exports){
module.exports = Logger;

function DateFmt(fstr) {
  this.formatString = fstr;

  var mthNames = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
  var dayNames = ["Sun","Mon","Tue","Wed","Thu","Fri","Sat"];
  var zeroPad = function(number) {
    return ("0"+number).substr(-2,2);
  };

  var dateMarkers = {
    d:['getDate',function(v) { return zeroPad(v);}],
    m:['getMonth',function(v) { return zeroPad(v+1);}],
    n:['getMonth',function(v) { return mthNames[v]; }],
    w:['getDay',function(v) { return dayNames[v]; }],
    y:['getFullYear'],
    H:['getHours',function(v) { return zeroPad(v);}],
    M:['getMinutes',function(v) { return zeroPad(v);}],
    S:['getSeconds',function(v) { return zeroPad(v);}],
    i:['toISOString']
  };

  this.format = function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if ( dateMarker[1] !== null ) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  };

}


function Logger(logger, category, label) {
  this.logger = logger;
  this.category = category;
  this.label = label;
  this.fmt = new DateFmt("%m%d/%H%M%S");
}

Logger.prototype.debug = function(content) {
  this.logger.debug(this.category, this.label, content);
};

Logger.prototype.log = function(content) {
  this.logger.log(this.category, this.label, content);
};

Logger.prototype.warn = function(content) {
  this.logger.warn(this.category, this.label, content);
};

Logger.prototype.error = function(content) {
  this.logger.error(this.category, this.label, content);
};

Logger.prototype.formatMsg = function(msg) {
  return this.getTime()+' : '+msg;
};
Logger.prototype.getTime = function() {
  return this.getTimeFor(new Date());
};
Logger.prototype.getTimeFor = function(date) {
  return this.fmt.format(date);
};
},{}],206:[function(require,module,exports){
module.exports = LoggerFactory;


/**
 * Dependencies.
 */
var Logger = require('./Logger');


function LoggerFactory() {
  var logger,
    levels = { 'error': 0, 'warn': 1, 'log': 2, 'debug': 3 },
    level = 1,
    builtinEnabled = true,
    connector = null;

    this.loggers = {};

    logger = this.getLogger('ExSIP.loggerfactory');


  Object.defineProperties(this, {
    builtinEnabled: {
      get: function(){ return builtinEnabled; },
      set: function(value){
        if (typeof value === 'boolean') {
          builtinEnabled = value;
        } else {
          logger.error('invalid "builtinEnabled" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    level: {
      get: function() {return level; },
      set: function(value) {
        if (value >= 0 && value <=3) {
          level = value;
        } else if (value > 3) {
          level = 3;
        } else if (levels.hasOwnProperty(value)) {
          level = levels[value];
        } else {
          logger.error('invalid "level" parameter value: '+ JSON.stringify(value));
        }
      }
    },

    connector: {
      get: function() {return connector; },
      set: function(value){
        if(value === null || value === "" || value === undefined) {
          connector = null;
        } else if (typeof value === 'function') {
          connector = value;
        } else {
          logger.error('invalid "connector" parameter value: '+ JSON.stringify(value));
        }
      }
    }
  });
}


LoggerFactory.prototype.print = function(target, category, label, content) {
  var prefix = [];

  prefix.push(new Date());

  prefix.push(category);

  if (label) {
    prefix.push(label);
  }

  prefix.push('');

  if (typeof content === 'string') {
    target.call(console, prefix.join(' | ') + content);
  } else {
    target.call(console, content);
  }
};

LoggerFactory.prototype.debug = function(category, label, content) {
  if (this.level === 3) {
    if (this.builtinEnabled) {
      this.print(console.info, category, label, content);
    }

    if (this.connector) {
      this.connector('debug', category, label, content);
    }
  }
};

LoggerFactory.prototype.log = function(category, label, content) {
  if (this.level >= 2) {
    if (this.builtinEnabled) {
      this.print(console.log, category, label, content);
    }

    if (this.connector) {
      this.connector('log', category, label, content);
    }
  }
};

LoggerFactory.prototype.warn = function(category, label, content) {
  if (this.level >= 1) {
    if (this.builtinEnabled) {
      this.print(console.warn, category, label, content);
    }

    if (this.connector) {
      this.connector('warn', category, label, content);
    }
  }
};

LoggerFactory.prototype.error = function(category, label, content) {
  if (this.builtinEnabled) {
    this.print(console.error,category, label, content);
  }

  if (this.connector) {
    this.connector('error', category, label, content);
  }
};

LoggerFactory.prototype.getLogger = function(category, label) {
  var logger;

  if (label && this.level === 1) {
    return new Logger(this, category, label);
  } else if (this.loggers[category]) {
    return this.loggers[category];
  } else {
    logger = new Logger(this, category);
    this.loggers[category] = logger;
    return logger;
  }
};

},{"./Logger":205}],207:[function(require,module,exports){
module.exports = Message;

function Message(ua) {
  this.ua = ua;
  this.logger = ua.getLogger('ExSIP.message');

  // Custom message empty object for high level use
  this.data = {};
}


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');
var RequestSender = require('./RequestSender');
var Transactions = require('./Transactions');
var Exceptions = require('./Exceptions');


Message.prototype = new EventEmitter();


Message.prototype.isDebug = function() {
  return this.ua.isDebug();
};

Message.prototype.send = function(target, body, options) {
  var request_sender, event, contentType, eventHandlers, extraHeaders,
    events = [
      'succeeded',
      'failed'
    ],
    originalTarget = target;

  if (target === undefined || body === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: '+ originalTarget);
  }

  this.initEvents(events);

  // Get call options
  options = options || {};
  extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [];
  eventHandlers = options.eventHandlers || {};
  contentType = options.contentType || 'text/plain';

  this.content_type = contentType;

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.closed = false;
  this.ua.applicants[this] = this;

  extraHeaders.push('Content-Type: '+ contentType);

  this.request = new SIPMessage.OutgoingRequest(ExSIP_C.MESSAGE, target, this.ua, null, extraHeaders);

  if(body) {
    this.request.body = body;
    this.content = body;
  } else {
    this.content = null;
  }

  request_sender = new RequestSender(this, this.ua);

  this.newMessage('local', this.request);

  request_sender.send();
};

Message.prototype.receiveResponse = function(response) {
  var cause;

  if(this.closed) {
    return;
  }
  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      delete this.ua.applicants[this];
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      delete this.ua.applicants[this];
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};


Message.prototype.onRequestTimeout = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.REQUEST_TIMEOUT
  });
};

Message.prototype.onTransportError = function() {
  if(this.closed) {
    return;
  }
  this.emit('failed', this, {
    originator: 'system',
    cause: ExSIP_C.causes.CONNECTION_ERROR
  });
};

Message.prototype.close = function() {
  this.closed = true;
  delete this.ua.applicants[this];
};

Message.prototype.init_incoming = function(request) {
  var transaction;

  this.request = request;
  this.content_type = request.getHeader('Content-Type');

  if (request.body) {
    this.content = request.body;
  } else {
    this.content = null;
  }

  this.newMessage('remote', request);

  transaction = this.ua.transactions.nist[request.via_branch];

  if (transaction && (transaction.state === Transactions.C.STATUS_TRYING || transaction.state === Transactions.C.STATUS_PROCEEDING)) {
    request.reply(200);
  }
};

/**
 * Accept the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.accept = function(options) {
  options = options || {};

  var
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"accept" not supported for outgoing Message');
  }

  this.request.reply(200, null, extraHeaders, body);
};

/**
 * Reject the incoming Message
 * Only valid for incoming Messages
 */
Message.prototype.reject = function(options) {
  options = options || {};

  var
    status_code = options.status_code || 480,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"reject" not supported for outgoing Message');
  }

  if (status_code < 300 || status_code >= 700) {
    throw new TypeError('Invalid status_code: '+ status_code);
  }

  this.request.reply(status_code, reason_phrase, extraHeaders, body);
};

/**
 * Internal Callbacks
 */

Message.prototype.newMessage = function(originator, request) {
  var message = this,
    event_name = 'newMessage';

  if (originator === 'remote') {
    message.direction = 'incoming';
    message.local_identity = request.to;
    message.remote_identity = request.from;
  } else if (originator === 'local'){
    message.direction = 'outgoing';
    message.local_identity = request.from;
    message.remote_identity = request.to;
  }

  message.ua.emit(event_name, message.ua, {
    originator: originator,
    message: message,
    request: request
  });
};
},{"./Constants":197,"./EventEmitter":201,"./Exceptions":203,"./RequestSender":215,"./SIPMessage":216,"./Transactions":218,"./Utils":222}],208:[function(require,module,exports){
module.exports = NameAddrHeader;


/**
 * Dependencies.
 */
var URI = require('./URI');
var Grammar = require('./Grammar');


function NameAddrHeader(uri, display_name, parameters) {
  var param;

  // Checks
  if(!uri || !(uri instanceof URI)) {
    throw new TypeError('missing or invalid "uri" parameter');
  }

  // Initialize parameters
  this.uri = uri;
  this.parameters = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  Object.defineProperties(this, {
    display_name: {
      get: function() { return display_name; },
      set: function(value) {
        display_name = (value === 0) ? '0' : value;
      }
    }
  });
}

NameAddrHeader.prototype = {
  setParam: function(key, value) {
    if (key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  clone: function() {
    return new NameAddrHeader(
      this.uri.clone(),
      this.display_name,
      JSON.parse(JSON.stringify(this.parameters)));
  },

  toString: function() {
    var body, parameter;

    body  = (this.display_name || this.display_name === 0) ? '"' + this.display_name + '" ' : '';
    body += '<' + this.uri.toString() + '>';

    for (parameter in this.parameters) {
      body += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        body += '='+ this.parameters[parameter];
      }
    }

    return body;
  }
};


/**
  * Parse the given string and returns a NameAddrHeader instance or undefined if
  * it is an invalid NameAddrHeader.
  */
NameAddrHeader.parse = function(name_addr_header) {
  name_addr_header = Grammar.parse(name_addr_header,'Name_Addr_Header');

  if (name_addr_header !== -1) {
    return name_addr_header;
  } else {
    return undefined;
  }
};
},{"./Grammar":204,"./URI":221}],209:[function(require,module,exports){
var Parser = {};

module.exports = Parser;


/**
 * Dependencies.
 */
var sdp_transform = require('sdp-transform');
var Grammar = require('./Grammar');
var SIPMessage = require('./SIPMessage');


/**
 * Extract and parse every header of a SIP message.
 */
function getHeader(data, headerStart) {
  var
    // 'start' position of the header.
    start = headerStart,
    // 'end' position of the header.
    end = 0,
    // 'partial end' position of the header.
    partialEnd = 0;

  //End of message.
  if (data.substring(start, start + 2).match(/(^\r\n)/)) {
    return -2;
  }

  while(end === 0) {
    // Partial End of Header.
    partialEnd = data.indexOf('\r\n', start);

    // 'indexOf' returns -1 if the value to be found never occurs.
    if (partialEnd === -1) {
      return partialEnd;
    }

    if(!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\r\n)/) && data.charAt(partialEnd + 2).match(/(^\s+)/)) {
      // Not the end of the message. Continue from the next position.
      start = partialEnd + 2;
    } else {
      end = partialEnd;
    }
  }

  return end;
}

function parseHeader(message, data, headerStart, headerEnd) {
  var header, idx, length, parsed,
    hcolonIndex = data.indexOf(':', headerStart),
    headerName = data.substring(headerStart, hcolonIndex).trim(),
    headerValue = data.substring(hcolonIndex + 1, headerEnd).trim();

  // If header-field is well-known, parse it.
  switch(headerName.toLowerCase()) {
    case 'via':
    case 'v':
      message.addHeader('via', headerValue);
      if(message.getHeaders('via').length === 1) {
        parsed = message.parseHeader('Via');
        if(parsed) {
          message.via = parsed;
          message.via_branch = parsed.branch;
        }
      } else {
        parsed = 0;
      }
      break;
    case 'from':
    case 'f':
      message.setHeader('from', headerValue);
      parsed = message.parseHeader('from');
      if(parsed) {
        message.from = parsed;
        message.from_tag = parsed.getParam('tag');
      }
      break;
    case 'to':
    case 't':
      message.setHeader('to', headerValue);
      parsed = message.parseHeader('to');
      if(parsed) {
        message.to = parsed;
        message.to_tag = parsed.getParam('tag');
      }
      break;
    case 'record-route':
      parsed = Grammar.parse(headerValue, 'Record_Route');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('record-route', headerValue.substring(header.possition, header.offset));
        message.headers['Record-Route'][message.getHeaders('record-route').length - 1].parsed = header.parsed;
      }
      break;
    case 'call-id':
    case 'i':
      message.setHeader('call-id', headerValue);
      parsed = message.parseHeader('call-id');
      if(parsed) {
        message.call_id = headerValue;
      }
      break;
    case 'contact':
    case 'm':
      parsed = Grammar.parse(headerValue, 'Contact');

      if (parsed === -1) {
        parsed = undefined;
      }

      length = parsed.length;
      for (idx = 0; idx < length; idx++) {
        header = parsed[idx];
        message.addHeader('contact', headerValue.substring(header.possition, header.offset));
        message.headers.Contact[message.getHeaders('contact').length - 1].parsed = header.parsed;
      }
      break;
    case 'content-length':
    case 'l':
      message.setHeader('content-length', headerValue);
      parsed = message.parseHeader('content-length');
      break;
    case 'content-type':
    case 'c':
      message.setHeader('content-type', headerValue);
      parsed = message.parseHeader('content-type');
      break;
    case 'cseq':
      message.setHeader('cseq', headerValue);
      parsed = message.parseHeader('cseq');
      if(parsed) {
        message.cseq = parsed.value;
      }
      if(message instanceof SIPMessage.IncomingResponse) {
        message.method = parsed.method;
      }
      break;
    case 'max-forwards':
      message.setHeader('max-forwards', headerValue);
      parsed = message.parseHeader('max-forwards');
      break;
    case 'www-authenticate':
      message.setHeader('www-authenticate', headerValue);
      parsed = message.parseHeader('www-authenticate');
      break;
    case 'proxy-authenticate':
      message.setHeader('proxy-authenticate', headerValue);
      parsed = message.parseHeader('proxy-authenticate');
      break;
    default:
      // Do not parse this header.
      message.setHeader(headerName, headerValue);
      parsed = 0;
  }

  if (parsed === undefined) {
    return {
      error: 'error parsing header "'+ headerName +'"'
    };
  } else {
    return true;
  }
}


/**
 * Parse SIP Message
 */
Parser.parseMessage = function(data, ua) {
  var message, firstLine, contentLength, bodyStart, parsed,
    headerStart = 0,
    headerEnd = data.indexOf('\r\n'),
    logger = ua.getLogger('ExSIP.parser');

  if(headerEnd === -1) {
    logger.warn('no CRLF found, not a SIP message, discarded');
    return;
  }

  // Parse first line. Check if it is a Request or a Reply.
  firstLine = data.substring(0, headerEnd);
  parsed = Grammar.parse(firstLine, 'Request_Response');

  if(parsed === -1) {
    logger.warn('error parsing first line of SIP message: "' + firstLine + '"');
    return;
  } else if(!parsed.status_code) {
    message = new SIPMessage.IncomingRequest(ua);
    message.method = parsed.method;
    message.ruri = parsed.uri;
  } else {
    message = new SIPMessage.IncomingResponse(ua);
    message.status_code = parsed.status_code;
    message.reason_phrase = parsed.reason_phrase;
  }

  message.data = data;
  headerStart = headerEnd + 2;

  /* Loop over every line in data. Detect the end of each header and parse
  * it or simply add to the headers collection.
  */
  while(true) {
    headerEnd = getHeader(data, headerStart);

    // The SIP message has normally finished.
    if(headerEnd === -2) {
      bodyStart = headerStart + 2;
      break;
    }
    // data.indexOf returned -1 due to a malformed message.
    else if(headerEnd === -1) {
      parsed.error('malformed message');
      return;
    }

    parsed = parseHeader(message, data, headerStart, headerEnd);

    if(parsed !== true) {
      logger.error(parsed.error);
      return;
    }

    headerStart = headerEnd + 2;
  }

  /* RFC3261 18.3.
   * If there are additional bytes in the transport packet
   * beyond the end of the body, they MUST be discarded.
   */
  if(message.hasHeader('content-length')) {
    contentLength = message.getHeader('content-length');
    message.body = data.substr(bodyStart, contentLength);
  } else {
    message.body = data.substring(bodyStart);
  }

  return message;
};

/**
 * sdp-transform features.
 */
Parser.parseSDP = sdp_transform.parse;
Parser.writeSDP = sdp_transform.write;
Parser.parseFmtpConfig = sdp_transform.parseFmtpConfig;
Parser.parsePayloads = sdp_transform.parsePayloads;
Parser.parseRemoteCandidates = sdp_transform.parseRemoteCandidates;
},{"./Grammar":204,"./SIPMessage":216,"sdp-transform":192}],210:[function(require,module,exports){
module.exports = RTCSession;


var C = {
  // RTCSession states
  STATUS_NULL: 0,
  STATUS_INVITE_SENT: 1,
  STATUS_1XX_RECEIVED: 2,
  STATUS_INVITE_RECEIVED: 3,
  STATUS_WAITING_FOR_ANSWER: 4,
  STATUS_ANSWERED: 5,
  STATUS_WAITING_FOR_ACK: 6,
  STATUS_CANCELED: 7,
  STATUS_TERMINATED: 8,
  STATUS_CONFIRMED: 9,
  STATUS_REFER_SENT: 10,
  STATUS_BYE_SENT: 11
};

/**
 * Expose C object.
 */
RTCSession.C = C;

/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Exceptions = require('./Exceptions');
var Parser = require('./Parser');
var Utils = require('./Utils');
var Timers = require('./Timers');
var UA = require('./UA');
var WebRTC = require('./WebRTC');
var SIPMessage = require('./SIPMessage');
var Dialog = require('./Dialog');
var RequestSender = require('./RequestSender');
var RTCSession_RTCMediaHandler = require('./RTCSession/RTCMediaHandler');
var RTCSession_DTMF = require('./RTCSession/DTMF');


function RTCSession(ua) {
  var events = [
    'connecting',
    'progress',
    'failed',
    'accepted',
    'confirmed',
    'ended',
    'newDTMF',
    'hold',
    'held',
    'resumed',
    'unhold',
    'muted',
    'unmuted',
    'started',
    'onReInvite'
  ];

  this.ua = ua;
  this.setStatus(C.STATUS_NULL);
  this.dialog = null;
  this.earlyDialogs = {};
  this.rtcMediaHandler = null;
  this.receiveResponse = this.receiveInviteResponse;

  // RTCSession confirmation flag
  this.is_confirmed = false;

  // is late SDP being negotiated
  this.late_sdp = false;

  // Session Timers
  this.timers = {
    ackTimer: null,
    expiresTimer: null,
    invite2xxTimer: null,
    userNoAnswerTimer: null
  };

  // Custom session empty object for high level use
  this.data = {};
  this.dtmf = new RTCSession_DTMF(this);

  /**
   * User API
   */

  // Mute/Hold state
  this.isOnHold = false;
  this.audioMuted = false;
  this.videoMuted = false;
  this.local_hold = false;
  this.remote_hold = false;
  this.start_time = null;

  this.pending_actions = {
    actions: [],

    length: function() {
      return this.actions.length;
    },

    isPending: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          return true;
        }
      }
      return false;
    },

    shift: function() {
      return this.actions.shift();
    },

    push: function(name) {
      this.actions.push({
        name: name
      });
    },

    pop: function(name) {
      var
        idx = 0,
        length = this.actions.length;

      for (idx; idx < length; idx++) {
        if (this.actions[idx].name === name) {
          this.actions.splice(idx, 1);
        }
      }
    }
  };

  // Custom session empty object for high level use
  this.data = {};

  this.initEvents(events);
}

RTCSession.prototype = new EventEmitter();

/**
 * Terminate the call.
 */
RTCSession.prototype.terminate = function(options) {
  options = options || {};

  var cancel_reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    body = options.body;

  // Check Session Status
  if (this.status === C.STATUS_TERMINATED) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.logger.log('terminate with status : ' + this.status);

  switch (this.status) {
    // - UAC -
    case C.STATUS_NULL:
    case C.STATUS_INVITE_SENT:
    case C.STATUS_1XX_RECEIVED:
      this.logger.debug('canceling RTCSession');

      if (status_code && (status_code < 200 || status_code >= 700)) {
        throw new TypeError('Invalid status_code: ' + status_code);
      } else if (status_code) {
        reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
        cancel_reason = 'SIP ;cause=' + status_code + ' ;text="' + reason_phrase + '"';
      }

      // Check Session Status
      if (this.status === C.STATUS_NULL) {
        this.isCanceled = true;
        this.cancelReason = cancel_reason;
      } else if (this.status === C.STATUS_INVITE_SENT) {
        if (this.received_100) {
          this.logger.debug('canceling after received 100 response');
          if (typeof(this.request.cancel) === 'undefined') {
            this.sendBye(options);
            this.ended('local', null, ExSIP_C.causes.BYE);
          } else {
            this.isCanceled = true;
            this.logger.log('terminate on 100 - setting isCanceled = true', this.ua);
            this.request.cancel(cancel_reason);
          }
        } else {
          this.isCanceled = true;
          this.cancelReason = cancel_reason;
        }
      } else if (this.status === C.STATUS_1XX_RECEIVED) {
        this.isCanceled = true;
        this.logger.log('terminate on 1xx - setting isCanceled = true');
        this.request.cancel(cancel_reason);
      }

      this.setStatus(C.STATUS_CANCELED);

      this.failed('local', null, ExSIP_C.causes.CANCELED);
      break;

      // - UAS -
    case C.STATUS_WAITING_FOR_ANSWER:
      this.logger.log('rejecting RTCSession with 486 Busy Here', this.ua);
      this.request.reply(486);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;
    case C.STATUS_ANSWERED:
      this.logger.debug('rejecting RTCSession');

      status_code = status_code || 480;

      if (status_code < 300 || status_code >= 700) {
        throw new TypeError('Invalid status_code: ' + status_code);
      }

      this.request.reply(status_code, reason_phrase, extraHeaders, body);
      this.failed('local', null, ExSIP_C.causes.REJECTED);
      break;

    case C.STATUS_WAITING_FOR_ACK:
    case C.STATUS_REFER_SENT:
    case C.STATUS_CONFIRMED:
      this.logger.debug('terminating RTCSession');

      // Send Bye
      this.sendBye(options);
      return;
      // reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';

      // if (status_code && (status_code < 200 || status_code >= 700)) {
      //   throw new TypeError('Invalid status_code: '+ status_code);
      // } else if (status_code) {
      //   extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
      // }

      // /* RFC 3261 section 15 (Terminating a session):
      //   *
      //   * "...the callee's UA MUST NOT send a BYE on a confirmed dialog
      //   * until it has received an ACK for its 2xx response or until the server
      //   * transaction times out."
      //   */
      // if (this.status === C.STATUS_WAITING_FOR_ACK &&
      //     this.direction === 'incoming' &&
      //     this.request.server_transaction.state !== Transactions.C.STATUS_TERMINATED) {

      //   // Save the dialog for later restoration
      //   dialog = this.dialog;

      //   // Send the BYE as soon as the ACK is received...
      //   this.receiveRequest = function(request) {
      //     if(request.method === ExSIP_C.ACK) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // this.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   };

      //   // .., or when the INVITE transaction times out
      //   this.request.server_transaction.on('stateChanged', function(e){
      //     if (e.sender.state === Transactions.C.STATUS_TERMINATED) {
      //       self.sendBye({
      //         extraHeaders: extraHeaders,
      //         body: body
      //       });
      //       // self.sendRequest(ExSIP_C.BYE, {
      //       //   extraHeaders: extraHeaders,
      //       //   body: body
      //       // });
      //       dialog.terminate();
      //     }
      //   });

      //   this.ended('local', null, cause);

      //   // Restore the dialog into 'this' in order to be able to send the in-dialog BYE :-)
      //   this.dialog = dialog;

      //   // Restore the dialog into 'ua' so the ACK can reach 'this' session
      //   this.ua.dialogs[dialog.id.toString()] = dialog;

      // } else {
      //   self.sendBye({
      //     extraHeaders: extraHeaders,
      //     body: body
      //   });
      //   return;
      //   // this.sendRequest(ExSIP_C.BYE, {
      //   //   extraHeaders: extraHeaders,
      //   //   body: body
      //   // });

      //   // this.ended('local', null, cause);
      // }
  }

  this.close();
};

/**
 * Answer the call.
 */
RTCSession.prototype.answer = function(options) {
  options = options || {};

  var idx, length, sdp, remoteDescription,
    hasAudio = false,
    hasVideo = false,
    self = this,
    request = this.request,
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    mediaConstraints = options.mediaConstraints || {},
    mediaStream = options.mediaStream || null,

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer succeeded
    sdpCreationSucceeded = function(body) {
      var
      // run for reply success callback
        replySucceeded = function() {
          self.setStatus(C.STATUS_WAITING_FOR_ACK);

          self.setInvite2xxTimer(request, body);
          self.setACKTimer();
          self.accepted('local');
        },

        // run for reply failure callback
        replyFailed = function() {
          self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
        };

      request.reply(200, null, extraHeaders,
        body,
        replySucceeded,
        replyFailed
      );
    },

    // rtcMediaHandler.createAnswer or rtcMediaHandler.createOffer failed
    sdpCreationFailed = function() {
      if (self.status === C.STATUS_TERMINATED) {
        return;
      }

      self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

  this.data = options.data || {};

  // Check Session Direction and Status
  if (this.direction !== 'incoming') {
    throw new Exceptions.NotSupportedError('"answer" not supported for outgoing RTCSession');
  } else if (this.status !== C.STATUS_WAITING_FOR_ANSWER) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  this.setStatus(C.STATUS_ANSWERED);

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS')) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  clearTimeout(this.timers.userNoAnswerTimer);

  extraHeaders.unshift('Contact: ' + self.contact);

  // Determine incoming media from remote session description
  remoteDescription = this.rtcMediaHandler.peerConnection.remoteDescription || {};
  sdp = Parser.parseSDP(remoteDescription.sdp || '');

  // Make sure sdp is an array, not the case if there is only one media
  if (!(sdp.media instanceof Array)) {
    sdp.media = [sdp.media || []];
  }

  // Go through all medias in SDP to find offered capabilities to answer with
  idx = sdp.media.length;
  while (idx--) {
    if (sdp.media[idx].type === 'audio' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasAudio = true;
    }
    if (sdp.media[idx].type === 'video' &&
      (sdp.media[idx].direction === 'sendrecv' ||
        sdp.media[idx].direction === 'recvonly')) {
      hasVideo = true;
    }
  }

  // Remove audio from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.audio === false) {
    length = mediaStream.getAudioTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getAudioTracks()[idx]);
    }
  }

  // Remove video from mediaStream if suggested by mediaConstraints
  if (mediaStream && mediaConstraints.video === false) {
    length = mediaStream.getVideoTracks().length;
    for (idx = 0; idx < length; idx++) {
      mediaStream.removeTrack(mediaStream.getVideoTracks()[idx]);
    }
  }

  // Set audio constraints based on incoming stream if not supplied
  if (mediaConstraints.audio === undefined) {
    mediaConstraints.audio = hasAudio;
  }

  // Set video constraints based on incoming stream if not supplied
  if (mediaConstraints.video === undefined) {
    mediaConstraints.video = hasVideo;
  }

  this.getUserMedia(mediaConstraints, sdpCreationSucceeded, sdpCreationFailed, {
    isAnswer: true,
    remoteSdp: request.body
  });
};

/**
 * Send a DTMF
 */
RTCSession.prototype.sendDTMF = function(tones, options) {
  var duration, interToneGap;

  options = options || {};
  duration = options.duration || null;
  interToneGap = options.interToneGap || null;

  if (tones === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check Session Status
  if (this.status !== C.STATUS_CONFIRMED && this.status !== C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Convert to string
  if (typeof tones === 'number') {
    tones = tones.toString();
  }

  // Check tones
  if (!tones || typeof tones !== 'string' || !tones.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tones: ' + tones);
  }

  // Check duration
  if (duration && !Utils.isDecimal(duration)) {
    throw new TypeError('Invalid tone duration: ' + duration);
  } else if (!duration) {
    duration = RTCSession_DTMF.C.DEFAULT_DURATION;
  } else if (duration < RTCSession_DTMF.C.MIN_DURATION) {
    this.logger.warn('"duration" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MIN_DURATION;
  } else if (duration > RTCSession_DTMF.C.MAX_DURATION) {
    this.logger.warn('"duration" value is greater than the maximum allowed, setting it to ' + RTCSession_DTMF.C.MAX_DURATION + ' milliseconds');
    duration = RTCSession_DTMF.C.MAX_DURATION;
  } else {
    duration = Math.abs(duration);
  }
  options.duration = duration;

  // Check interToneGap
  if (interToneGap && !Utils.isDecimal(interToneGap)) {
    throw new TypeError('Invalid interToneGap: ' + interToneGap);
  } else if (!interToneGap) {
    interToneGap = RTCSession_DTMF.C.DEFAULT_INTER_TONE_GAP;
  } else if (interToneGap < RTCSession_DTMF.C.MIN_INTER_TONE_GAP) {
    this.logger.warn('"interToneGap" value is lower than the minimum allowed, setting it to ' + RTCSession_DTMF.C.MIN_INTER_TONE_GAP + ' milliseconds');
    interToneGap = RTCSession_DTMF.C.MIN_INTER_TONE_GAP;
  } else {
    interToneGap = Math.abs(interToneGap);
  }

  this.dtmf.send(tones, options);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.rejectReInvite = function(options) {
  options = options || {};

  this.logger.log('rejecting re-INVITE');

  this.request.reply(488);
};

/**
 * Accepts the reInvite.
 * @param {Object} [options]
 */
RTCSession.prototype.acceptReInvite = function(options) {
  options = options || {};

  var self = this,
    extraHeaders = options.extraHeaders || [];

  this.logger.log('accepting re-INVITE');

  var replySucceeded = function() {
    var timeout = Timers.T1;

    self.setStatus(C.STATUS_WAITING_FOR_ACK);

    /**
     * RFC3261 13.3.1.4
     * Response retransmissions cannot be accomplished by transaction layer
     *  since it is destroyed when receiving the first 2xx answer
     */
    self.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
        if (self.status !== C.STATUS_WAITING_FOR_ACK) {
          return;
        }

        self.request.reply(200, null, extraHeaders, self.rtcMediaHandler.peerConnection.localDescription.sdp);

        if (timeout < Timers.T2) {
          timeout = timeout * 2;
          if (timeout > Timers.T2) {
            timeout = Timers.T2;
          }
        }
        self.timers.invite2xxTimer = setTimeout(
          invite2xxRetransmission, timeout
        );
      },
      timeout
    );

    /**
     * RFC3261 14.2
     * If a UAS generates a 2xx response and never receives an ACK,
     *  it SHOULD generate a BYE to terminate the dialog.
     */
    self.timers.ackTimer = setTimeout(function() {
        if (self.status === C.STATUS_WAITING_FOR_ACK) {
          self.logger.log('no ACK received');
          //                window.clearTimeout(self.timers.invite2xxTimer);
          //                self.sendBye();
          //                self.ended('remote', null, ExSIP.C.causes.NO_ACK);
        }
      },
      Timers.TIMER_H
    );

    self.started('local', undefined, true);
  };

  var replyFailed = function() {
    self.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
  };

  //    var previousRemoteDescription = self.rtcMediaHandler.peerConnection.remoteDescription;
  var connectSuccess = function() {
    self.logger.debug('onMessage success');
    self.request.reply(200, null, extraHeaders,
      self.rtcMediaHandler.peerConnection.localDescription.getSdp({
        additionalSdp: self.rtcMediaHandler.peerConnection.remoteUnsupportedMedia
      }),
      replySucceeded,
      replyFailed
    );
  };

  var connectFailed = function(e) {
    self.logger.warn('invalid SDP');
    self.logger.warn(e);
    self.request.reply(488);
  };

  this.initialRemoteSdp = this.initialRemoteSdp || self.rtcMediaHandler.peerConnection.remoteDescription.sdp;
  var sdp = this.request.body;
  if (sdp.length === 0) {
    this.logger.debug('empty sdp');
  }
  this.reconnectRtcMediaHandler(connectSuccess, connectFailed, {
    isAnswer: true,
    remoteSdp: sdp,
    isReconnect: true
  });
};

RTCSession.prototype.reconnectRtcMediaHandler = function(connectSuccess, connectFailed, options) {
  var self = this;
  options = options || {};
  var localMedia = options.localMedia || this.rtcMediaHandler.localMedia;
  options.createOfferConstraints = options.createOfferConstraints || this.rtcMediaHandler.createOfferConstraints;
  this.rtcMediaHandler.close(!!options.localMedia);

  this.initRtcMediaHandler(options);
  this.rtcMediaHandler.localMedia = localMedia;
  this.rtcMediaHandler.createOfferConstraints = options.createOfferConstraints;
  this.connectRtcMediaHandler(localMedia, function() {
    self.started('local', undefined, true);
    connectSuccess();
  }, connectFailed, options);
};

// /**
//  * Send a generic in-dialog Request
//  */
// RTCSession.prototype.sendRequest = function(method, options, callbacks) {
//   var request = new RTCSession_Request(this, callbacks);

//   if(options.status) {
//     this.status = options.status;
//   }
//   request.body = options.sdp;

//   request.send(method, options);
// };

/**
 * Check if RTCSession is ready for a re-INVITE
 */
RTCSession.prototype.isReadyToReinvite = function() {
  // rtcMediaHandler is not ready
  if (!this.rtcMediaHandler.isReady()) {
    return;
  }

  // Another INVITE transaction is in progress
  if (this.dialog.uac_pending_reply === true || this.dialog.uas_pending_reply === true) {
    return false;
  } else {
    return true;
  }
};


/**
 * Mute
 */
RTCSession.prototype.mute = function(options) {
  options = options || {
    audio: true,
    video: false
  };

  var
    audioMuted = false,
    videoMuted = false;

  if (this.audioMuted === false && options.audio) {
    audioMuted = true;
    this.audioMuted = true;
    this.toogleMuteAudio(true);
  }

  if (this.videoMuted === false && options.video) {
    videoMuted = true;
    this.videoMuted = true;
    this.toogleMuteVideo(true);
  }

  if (audioMuted === true || videoMuted === true) {
    this.onmute({
      audio: audioMuted,
      video: videoMuted
    });
  }
};

/**
 * Unmute
 */
RTCSession.prototype.unmute = function(options) {
  options = options || {
    audio: true,
    video: true
  };

  var
    audioUnMuted = false,
    videoUnMuted = false;

  if (this.audioMuted === true && options.audio) {
    audioUnMuted = true;
    this.audioMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteAudio(false);
    }
  }

  if (this.videoMuted === true && options.video) {
    videoUnMuted = true;
    this.videoMuted = false;

    if (this.local_hold === false) {
      this.toogleMuteVideo(false);
    }
  }

  if (audioUnMuted === true || videoUnMuted === true) {
    this.onunmute({
      audio: audioUnMuted,
      video: videoUnMuted
    });
  }
};

/**
 * isMuted
 */
RTCSession.prototype.isMuted = function() {
  return {
    audio: this.audioMuted,
    video: this.videoMuted
  };
};

/**
 * Hold
 */
// RTCSession.prototype.hold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   this.toogleMuteAudio(true);
//   this.toogleMuteVideo(true);

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'unhold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'hold' action, add this one to the queue
//      * Else, if there is already a 'hold' action, skip
//      */
//     if (this.pending_actions.isPending('unhold')) {
//       this.pending_actions.pop('unhold');
//       return;
//     } else if (!this.pending_actions.isPending('hold')) {
//       this.pending_actions.push('hold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === true) {
//       return;
//     }
//   }

//   this.onhold('local');

//   this.sendReinvite({
//     mangle: function(body) {
//       var idx, length;

//       body = Parser.parseSDP(body);

//       length = body.media.length;
//       for (idx = 0; idx < length; idx++) {
//         if (body.media[idx].direction === undefined) {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendrecv') {
//           body.media[idx].direction = 'sendonly';
//         } else if (body.media[idx].direction === 'sendonly') {
//           body.media[idx].direction = 'inactive';
//         }
//       }

//       return Parser.writeSDP(body);
//     }
//   });
// };

// /**
//  * Unhold
//  */
// RTCSession.prototype.unhold = function() {

//   if (this.status !== C.STATUS_WAITING_FOR_ACK && this.status !== C.STATUS_CONFIRMED) {
//     throw new Exceptions.InvalidStateError(this.status);
//   }

//   if (!this.audioMuted) {
//     this.toogleMuteAudio(false);
//   }

//   if (!this.videoMuted) {
//     this.toogleMuteVideo(false);
//   }

//   if (!this.isReadyToReinvite()) {
//     /* If there is a pending 'hold' action, cancel it and don't queue this one
//      * Else, if there isn't any 'unhold' action, add this one to the queue
//      * Else, if there is already an 'unhold' action, skip
//      */
//     if (this.pending_actions.isPending('hold')) {
//       this.pending_actions.pop('hold');
//       return;
//     } else if (!this.pending_actions.isPending('unhold')) {
//       this.pending_actions.push('unhold');
//       return;
//     } else {
//       return;
//     }
//   } else {
//     if (this.local_hold === false) {
//       return;
//     }
//   }

//   this.onunhold('local');

//   this.sendReinvite();
// };


/**
 * Session Timers
 */


/**
 * RFC3261 13.3.1.4
 * Response retransmissions cannot be accomplished by transaction layer
 *  since it is destroyed when receiving the first 2xx answer
 */
RTCSession.prototype.setInvite2xxTimer = function(request, body) {
  var
    self = this,
    timeout = Timers.T1;

  this.timers.invite2xxTimer = setTimeout(function invite2xxRetransmission() {
    if (self.status !== C.STATUS_WAITING_FOR_ACK) {
      return;
    }

    request.reply(200, null, ['Contact: ' + self.contact], body);

    if (timeout < Timers.T2) {
      timeout = timeout * 2;
      if (timeout > Timers.T2) {
        timeout = Timers.T2;
      }
    }
    self.timers.invite2xxTimer = setTimeout(
      invite2xxRetransmission, timeout
    );
  }, timeout);
};


/**
 * RFC3261 14.2
 * If a UAS generates a 2xx response and never receives an ACK,
 *  it SHOULD generate a BYE to terminate the dialog.
 */
RTCSession.prototype.setACKTimer = function() {
  var self = this;

  this.timers.ackTimer = setTimeout(function() {
    if (self.status === C.STATUS_WAITING_FOR_ACK) {
      self.logger.debug('no ACK received, terminating the call');
      clearTimeout(self.timers.invite2xxTimer);
      self.sendBye();
      // self.sendRequest(ExSIP_C.BYE);
      self.ended('remote', null, ExSIP_C.causes.NO_ACK);
    }
  }, Timers.TIMER_H);
};


/**
 * RTCPeerconnection handlers
 */
// Modified to support Firefox 22
RTCSession.prototype.getLocalStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.localStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.localStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getLocalStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.getRemoteStreams = function() {
  try {
    if (this.rtcMediaHandler.peerConnection.remoteStreams) {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.remoteStreams || [];
    } else {
      return this.rtcMediaHandler &&
        this.rtcMediaHandler.peerConnection &&
        this.rtcMediaHandler.peerConnection.getRemoteStreams() || [];
    }
  } catch (ex) {
    return [];
  }
};

RTCSession.prototype.initRtcMediaHandler = function(options) {
  options = options || {};
  var constraints = options.RTCConstraints || this.ua.rtcConstraints() || {
    "optional": [{
      'DtlsSrtpKeyAgreement': 'true'
    }]
  };
  this.rtcMediaHandler = new RTCSession_RTCMediaHandler(this, {
    constraints: constraints,
    stun_servers: options.stun_servers,
    turn_servers: options.turn_servers
  });
};
/**
 * Session Management
 */

RTCSession.prototype.init_incoming = function(request) {
  var expires,
    self = this,
    contentType = request.getHeader('Content-Type'),

    waitForAnswer = function() {
      self.setStatus(C.STATUS_WAITING_FOR_ANSWER);

      // Set userNoAnswerTimer
      self.timers.userNoAnswerTimer = setTimeout(function() {
        request.reply(408);
        self.failed('local', null, ExSIP_C.causes.NO_ANSWER);
      }, self.ua.configuration.no_answer_timeout);

      /* Set expiresTimer
       * RFC3261 13.3.1
       */
      if (expires) {
        self.timers.expiresTimer = setTimeout(function() {
          if (self.status === C.STATUS_WAITING_FOR_ANSWER) {
            request.reply(487);
            self.failed('system', null, ExSIP_C.causes.EXPIRES);
          }
        }, expires);
      }

      // Fire 'newRTCSession' event.
      self.newRTCSession('remote', request);

      // Reply 180.
      request.reply(180, null, ['Contact: ' + self.contact]);

      // Fire 'progress' event.
      // TODO: Document that 'response' field in 'progress' event is null for
      // incoming calls.
      self.progress('local', null);
    };

  // Check body and content type
  if (request.body && (contentType !== 'application/sdp')) {
    request.reply(415);
    return;
  }

  // Session parameter initialization
  this.setStatus(C.STATUS_INVITE_RECEIVED);
  this.from_tag = request.from_tag;
  this.id = request.call_id + this.from_tag;
  this.request = request;
  this.contact = this.ua.contact.toString();

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  //Get the Expires header value if exists
  if (request.hasHeader('expires')) {
    expires = request.getHeader('expires') * 1000;
  }

  /* Set the to_tag before
   * replying a response code that will create a dialog.
   */
  request.to_tag = Utils.newTag();

  // An error on dialog creation will fire 'failed' event
  if (!this.createDialog(request, 'UAS', true)) {
    request.reply(500, 'Missing Contact header field');
    return;
  }

  //Initialize Media Session
  this.initRtcMediaHandler();

  if (request.body) {
    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid. Fire UA newRTCSession
       */
      waitForAnswer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.warn('invalid SDP');
        self.logger.warn(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    waitForAnswer();
  }
};

RTCSession.prototype.connect = function(target, options) {
  var self = this;
  options = options || {};

  this.data = options.data || {};

  this.initRtcMediaHandler(options);

  this.connectLocalMedia(target, options, function() {
    self.sendInviteRequest(target, options);
  }, function() {

  });
};

RTCSession.prototype.close = function() {
  var idx;

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  this.logger.debug('closing INVITE session ' + this.id);

  // 1st Step. Terminate media.
  if (this.rtcMediaHandler) {
    this.rtcMediaHandler.close();
  }

  // 2nd Step. Terminate signaling.

  // Clear session timers
  for (idx in this.timers) {
    clearTimeout(this.timers[idx]);
  }

  // Terminate dialogs

  // Terminate confirmed dialog
  if (this.dialog) {
    this.dialog.terminate();
    delete this.dialog;
  }

  // Terminate early dialogs
  for (idx in this.earlyDialogs) {
    this.earlyDialogs[idx].terminate();
    delete this.earlyDialogs[idx];
  }

  this.setStatus(C.STATUS_TERMINATED);

  delete this.ua.sessions[this.id];
};

/**
 * Dialog Management
 * @private
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.id) {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
      // Dialog not created due to an error.
      else {
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.id) {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
    // Dialog not created due to an error
    else {
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    }
  }
};

RTCSession.prototype.connectRtcMediaHandler = function(stream, creationSucceeded, creationFailed, options) {
  this.rtcMediaHandler.connect(stream, creationSucceeded, creationFailed, options);
  this.dtmf.enableDtmfSender(stream, this.rtcMediaHandler.peerConnection);
};

RTCSession.prototype.sendData = function(data) {
  this.rtcMediaHandler.sendData(data);
};

/**
 * Get User Media
 * @private
 */
RTCSession.prototype.getUserMedia = function(constraints, creationSucceeded, creationFailed, options) {
  var self = this;

  var userMediaSucceeded = function(stream) {
    self.ua.localMedia = stream;
    self.connectRtcMediaHandler(stream, creationSucceeded, creationFailed, options);
    //      self.reconnectRtcMediaHandler(creationSucceeded, creationFailed, {localMedia: stream});
  };

  var userMediaFailed = function() {
    if (self.status === C.STATUS_TERMINATED) {
      return;
    }
    self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  };


  if (this.ua.reuseLocalMedia() && this.ua.localMedia) {
    this.rtcMediaHandler.localMedia = this.ua.localMedia;
    userMediaSucceeded(this.ua.localMedia);
  } else {
    this.rtcMediaHandler.getUserMedia(
      userMediaSucceeded,
      userMediaFailed,
      constraints
    );
  }
};

RTCSession.prototype.sendInviteRequest = function(target, options, inviteSuccessCallback, inviteFailureCallback) {
  options = options || {};
  options.status = C.STATUS_INVITE_SENT;
  options.sdp = this.rtcMediaHandler.peerConnection.localDescription.sdp;
  options.target = target;
  this.sendRequest(ExSIP_C.INVITE, options, {
    success: inviteSuccessCallback,
    failure: inviteFailureCallback
  });
};
/**
 * Initial Request Sender
 * @private
 */
RTCSession.prototype.createOutgoingRequestSender = function(target, method, options) {
  options = options || {};

  var event, requestParams, iceServers,
    originalTarget = target,
    eventHandlers = options.eventHandlers || {},
    extraHeaders = options.extraHeaders && options.extraHeaders.slice() || [],
    stun_servers = options.stun_servers || null,
    turn_servers = options.turn_servers || null;


  if (stun_servers) {
    iceServers = UA.configuration_check.optional.stun_servers(stun_servers);
    if (!iceServers) {
      throw new TypeError('Invalid stun_servers: ' + stun_servers);
    } else {
      stun_servers = iceServers;
    }
  }

  if (turn_servers) {
    iceServers = UA.configuration_check.optional.turn_servers(turn_servers);
    if (!iceServers) {
      throw new TypeError('Invalid turn_servers: ' + turn_servers);
    } else {
      turn_servers = iceServers;
    }
  }

  if (target === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Check WebRTC support
  if (!WebRTC.isSupported) {
    throw new Exceptions.NotSupportedError('WebRTC not supported');
  }

  // Check target validity
  target = this.ua.normalizeTarget(target);
  if (!target) {
    throw new TypeError('Invalid target: ' + originalTarget);
  }

  // Check Session Status
  if (this.status !== C.STATUS_NULL) {
    throw new Exceptions.InvalidStateError(this.status);
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  // Session parameter initialization
  this.from_tag = Utils.newTag();

  // Set anonymous property
  this.anonymous = options.anonymous || false;

  // OutgoingSession specific parameters
  this.isCanceled = false;

  requestParams = {
    from_tag: this.from_tag
  };

  this.contact = this.ua.contact.toString({
    anonymous: this.anonymous,
    outbound: true
  });

  if (this.anonymous) {
    requestParams.from_display_name = 'Anonymous';
    requestParams.from_uri = 'sip:anonymous@anonymous.invalid';

    extraHeaders.push('P-Preferred-Identity: ' + this.ua.configuration.uri.toString());
    extraHeaders.push('Privacy: id');
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Allow: '+ Utils.getAllowedMethods(this.ua));

  this.request = new SIPMessage.OutgoingRequest(method, target, this.ua, requestParams, extraHeaders);

  this.id = this.request.call_id + this.from_tag;

  this.logger = this.ua.getLogger('rtcsession', this.id);

  //Save the session into the ua sessions collection.
  this.ua.sessions[this.id] = this;

  this.newRTCSession('local', this.request);

  return new RequestSender(this, this.ua);

};

RTCSession.prototype.sendReferRequest = function(sessionToTransfer, options) {
  this.sessionToTransfer = sessionToTransfer;
  options = options || {};
  options.status = C.STATUS_REFER_SENT;
  options.target = sessionToTransfer.dialog.remote_target;
  this.sendRequest(ExSIP_C.REFER, options);
};

RTCSession.prototype.sendNotifyRequest = function(options, successCallback, failureCallback) {
  options = options || {};
  var extraHeaders = ['Content-Type: message/sipfrag',
    'Subscription-State: ' + (options.subscriptionState || "active;expires=60"),
    'Event: refer'
  ];
  options = Utils.merge_options({
    extraHeaders: extraHeaders
  }, options);
  this.sendRequest(ExSIP_C.NOTIFY, options, {
    success: successCallback,
    failure: failureCallback
  });
};

RTCSession.prototype.isStarted = function() {
  return this.start_time !== null;
};

RTCSession.prototype.isHeld = function() {
  return this.isOnHold;
};

RTCSession.prototype.held = function() {
  this.isOnHold = true;
  this.emit('held', this);
};

RTCSession.prototype.resumed = function() {
  this.isOnHold = false;
  this.emit('resumed', this);
};

RTCSession.prototype.hold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({audioMode: ExSIP_C.INACTIVE, audioPort: "0", videoMode: ExSIP_C.INACTIVE, videoPort: "0"}, function(){
      self.held();
      if(inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.unhold = function(inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.changeSession({audioMode: ExSIP_C.SENDRECV, videoMode: ExSIP_C.SENDRECV}, function(){
      self.resumed();
      if(inviteSuccessCallback) {
        inviteSuccessCallback();
      }
    },
    inviteFailureCallback);
};

RTCSession.prototype.changeSession = function(sdpOptions, inviteSuccessCallback, inviteFailureCallback) {
  var self = this;
  this.logger.debug('changeSession : '+JSON.stringify(sdpOptions));
  this.reconnectRtcMediaHandler(function() {
    self.logger.debug('changeSession : reconnectRtcMediaHandler : success');
    self.receiveResponse = self.receiveReinviteResponse;
    self.reinviteSucceeded = inviteSuccessCallback;
    self.reinviteFailed = inviteFailureCallback;
    self.sendInviteRequest(undefined, undefined);
  }, function() {
    self.logger.error("Could not change local mode");
  }, sdpOptions);
};

/**
 * Reception of Response for Initial INVITE
 */
RTCSession.prototype.receiveInviteResponse = function(response) {
  var cause, dialog,
    session = this;

  // Handle 2XX retransmissions and responses from forked requests
  if (this.dialog && (response.status_code >= 200 && response.status_code <= 299)) {

    /*
     * If it is a retransmission from the endpoint that established
     * the dialog, send an ACK
     */
    if (this.dialog.id.call_id === response.call_id &&
      this.dialog.id.local_tag === response.from_tag &&
      this.dialog.id.remote_tag === response.to_tag) {
      this.sendRequest(ExSIP_C.ACK);
      return;
    }

    // If not, send an ACK  and terminate
    else {
      dialog = new Dialog(this, response, 'UAC');

      if (dialog.error !== undefined) {
        this.logger.error(dialog.error);
        return;
      }

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.ACK);

      dialog.sendRequest({
        owner: {
          status: C.STATUS_TERMINATED
        },
        onRequestTimeout: function() {},
        onTransportError: function() {},
        onDialogError: function() {},
        receiveResponse: function() {}
      }, ExSIP_C.BYE);
      return;
    }

  }

  // Proceed to cancellation if the user requested.
  if (this.isCanceled) {
    // Remove the flag. We are done.
    this.isCanceled = false;

    if (response.status_code >= 100 && response.status_code < 200) {
      this.request.cancel(this.cancelReason);
    } else if (response.status_code >= 200 && response.status_code < 299) {
      this.acceptAndTerminate(response);
    }
    return;
  }

  if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
    return;
  }

  switch (true) {
    case /^100$/.test(response.status_code):
      this.received_100 = true;
      break;
    case /^1[0-9]{2}$/.test(response.status_code):
      this.received_100 = true;
      if (this.status !== C.STATUS_INVITE_SENT && this.status !== C.STATUS_1XX_RECEIVED) {
        break;
      }

      // Do nothing with 1xx responses without To tag.
      if (!response.to_tag) {
        this.logger.warn('1xx response received without to tag');
        break;
      }

      // Create Early Dialog if 1XX comes with contact
      if (response.hasHeader('contact')) {
        // An error on dialog creation will fire 'failed' event
        if (!this.createDialog(response, 'UAC', true)) {
          break;
        }
      }

      this.setStatus(C.STATUS_1XX_RECEIVED);
      this.progress('remote', response);

      if (!response.body) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'pranswer',
        response.body,
        /*
         * OnSuccess.
         * SDP Answer fits with Offer.
         */
        function() {},
        /*
         * OnFailure.
         * SDP Answer does not fit with Offer.
         */
        function(e) {
          session.logger.warn(e);
          session.earlyDialogs[response.call_id + response.from_tag + response.to_tag].terminate();
        }
      );
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      this.setStatus(C.STATUS_CONFIRMED);

      if (!response.body) {
        this.acceptAndTerminate(response, 400, ExSIP_C.causes.MISSING_SDP);
        this.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        break;
      }

      // An error on dialog creation will fire 'failed' event
      if (!this.createDialog(response, 'UAC')) {
        break;
      }

      this.rtcMediaHandler.onMessage(
        'answer',
        response.body,
        /*
         * onSuccess
         * SDP Answer fits with Offer. Media will start
         */
        function() {
          session.accepted('remote', response);
          session.sendRequest(ExSIP_C.ACK);
          session.confirmed('local', null);
        },
        /*
         * onFailure
         * SDP Answer does not fit the Offer. Accept the call and Terminate.
         */
        function(e) {
          session.logger.warn(e);
          session.acceptAndTerminate(response, 488, 'Not Acceptable Here');
          session.failed('remote', response, ExSIP_C.causes.BAD_MEDIA_DESCRIPTION);
        }
      );
      break;
    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.failed('remote', response, cause);
  }
};

/**
 * Dialog Management
 */
RTCSession.prototype.createDialog = function(message, type, early) {
  var dialog, early_dialog,
    local_tag = (type === 'UAS') ? message.to_tag : message.from_tag,
    remote_tag = (type === 'UAS') ? message.from_tag : message.to_tag,
    id = message.call_id + local_tag + remote_tag;

  early_dialog = this.earlyDialogs[id];

  // Early Dialog
  if (early) {
    if (early_dialog) {
      return true;
    } else {
      early_dialog = new Dialog(this, message, type, Dialog.C.STATUS_EARLY);

      // Dialog has been successfully created.
      if (early_dialog.error) {
        this.logger.error(dialog.error);
        this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
        return false;
      } else {
        this.earlyDialogs[id] = early_dialog;
        return true;
      }
    }
  }

  // Confirmed Dialog
  else {
    // In case the dialog is in _early_ state, update it
    if (early_dialog) {
      early_dialog.update(message, type);
      this.dialog = early_dialog;
      delete this.earlyDialogs[id];
      return true;
    }

    // Otherwise, create a _confirmed_ dialog
    dialog = new Dialog(this, message, type);

    if (dialog.error) {
      this.logger.error(dialog.error);
      this.failed('remote', message, ExSIP_C.causes.INTERNAL_ERROR);
      return false;
    } else {
      this.to_tag = message.to_tag;
      this.dialog = dialog;
      return true;
    }
  }
};

/**
 * In dialog INVITE Reception
 */

RTCSession.prototype.receiveReinvite = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = false,

    createSdp = function(onSuccess, onFailure) {
      if (self.late_sdp) {
        self.rtcMediaHandler.createOffer(onSuccess, onFailure);
      } else {
        self.rtcMediaHandler.createAnswer(onSuccess, onFailure);
      }
    },

    answer = function() {
      createSdp(
        // onSuccess
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              self.setStatus(C.STATUS_WAITING_FOR_ACK);
              self.setInvite2xxTimer(request, body);
              self.setACKTimer();

              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        // onFailure
        function() {
          request.reply(500);
        }
      );
    };


  if (request.body) {
    if (contentType !== 'application/sdp') {
      this.logger.warn('invalid Content-Type');
      request.reply(415);
      return;
    }

    sdp = Parser.parseSDP(request.body);

    for (idx = 0; idx < sdp.media.length; idx++) {
      direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

      if (direction === 'sendonly' || direction === 'inactive') {
        hold = true;
      }
    }

    this.rtcMediaHandler.onMessage(
      'offer',
      request.body,
      /*
       * onSuccess
       * SDP Offer is valid
       */
      answer,
      /*
       * onFailure
       * Bad media description
       */
      function(e) {
        self.logger.error(e);
        request.reply(488);
      }
    );
  } else {
    this.late_sdp = true;
    answer();
  }
};

/**
 * In dialog UPDATE Reception
 */

RTCSession.prototype.receiveUpdate = function(request) {
  var
    sdp, idx, direction,
    self = this,
    contentType = request.getHeader('Content-Type'),
    hold = true;

  if (!request.body) {
    request.reply(200);
    return;
  }

  if (contentType !== 'application/sdp') {
    this.logger.warn('invalid Content-Type');
    request.reply(415);
    return;
  }

  sdp = Parser.parseSDP(request.body);

  for (idx = 0; idx < sdp.media.length; idx++) {
    direction = sdp.direction || sdp.media[idx].direction || 'sendrecv';

    if (direction !== 'sendonly' && direction !== 'inactive') {
      hold = false;
    }
  }

  this.rtcMediaHandler.onMessage(
    'offer',
    request.body,
    /*
     * onSuccess
     * SDP Offer is valid
     */
    function() {
      self.rtcMediaHandler.createAnswer(
        function(body) {
          request.reply(200, null, ['Contact: ' + self.contact], body,
            function() {
              if (self.remote_hold === true && hold === false) {
                self.onunhold('remote');
              } else if (self.remote_hold === false && hold === true) {
                self.onhold('remote');
              }
            }
          );
        },
        function() {
          request.reply(500);
        }
      );
    },
    /*
     * onFailure
     * Bad media description
     */
    function(e) {
      self.logger.error(e);
      request.reply(488);
    }
  );
};

/**
 * In dialog Request Reception
 */
RTCSession.prototype.receiveRequest = function(request) {
  var contentType,
    self = this;

  if (request.method === ExSIP_C.CANCEL) {
    /* RFC3261 15 States that a UAS may have accepted an invitation while a CANCEL
     * was in progress and that the UAC MAY continue with the session established by
     * any 2xx response, or MAY terminate with BYE. ExSIP does continue with the
     * established session. So the CANCEL is processed only if the session is not yet
     * established.
     */

    /*
     * Terminate the whole session in case the user didn't accept (or yet send the answer)
     * nor reject the request opening the session.
     */
    if (this.status === C.STATUS_WAITING_FOR_ANSWER || this.status === C.STATUS_ANSWERED) {
      this.setStatus(C.STATUS_CANCELED);
      this.request.reply(487);
      this.failed('remote', request, ExSIP_C.causes.CANCELED);
    }
  } else {
    // Requests arriving here are in-dialog requests.
    switch (request.method) {
      case ExSIP_C.ACK:
        if (this.status === C.STATUS_WAITING_FOR_ACK) {
          clearTimeout(this.timers.ackTimer);
          clearTimeout(this.timers.invite2xxTimer);
          this.setStatus(C.STATUS_CONFIRMED);
          if(request.body.length > 0) {
            this.logger.log('set remoteDescription for late offer ACK');
            this.rtcMediaHandler.onMessage(self.rtcMediaHandler.getSetRemoteLocationType(), request.body, function(){
              self.logger.log('late offer remoteDescription success');
              self.started('local', undefined, true);
            }, function(){
              self.logger.log('late offer remoteDescription failure');
            });
          }
        }
        break;
      case ExSIP_C.BYE:
        if (this.status === C.STATUS_CONFIRMED) {
          request.reply(200);
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else if (this.status === C.STATUS_INVITE_RECEIVED) {
          request.reply(200);
          this.request.reply(487, 'BYE Received');
          this.ended('remote', request, ExSIP_C.causes.BYE);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INVITE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('re-INVITE received');
          this.request = request;
          // accept empty reinvites
          if (!request.body || request.body.length === 0) {
            this.acceptReInvite();
            return;
          }

          var description = new WebRTC.RTCSessionDescription({
            type: "offer",
            sdp: request.body
          });
          var oldDescription = this.rtcMediaHandler.peerConnection.remoteDescription;
          var audioAdd = description.hasActiveAudio() && (!oldDescription || !oldDescription.hasActiveAudio());
          var videoAdd = description.hasActiveVideo() && (!oldDescription || !oldDescription.hasActiveVideo());
          if (audioAdd || videoAdd) {
            this.ua.emit("onReInvite", this.ua, {
              session: this,
              request: request,
              audioAdd: audioAdd,
              videoAdd: videoAdd
            });
          } else {
            this.acceptReInvite();
          }
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.INFO:
        if (this.status === C.STATUS_CONFIRMED || this.status === C.STATUS_WAITING_FOR_ACK || this.status === C.STATUS_INVITE_RECEIVED || this.status === C.STATUS_ANSWERED) {
          contentType = request.getHeader('content-type');
          if (contentType && (contentType.match(/^application\/dtmf-relay/i))) {
            new RTCSession_DTMF(this).init_incoming(request);
          } else if (contentType && (contentType.match(/^application\/media_control\+xml/i))) {
            request.reply(200);
            this.started('local', undefined, true);
          } else {
            request.reply(415);
          }
        } else {
          this.logger.debug('Wrong Status : ' + this.status);
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.UPDATE:
        if (this.status === C.STATUS_CONFIRMED) {
          this.logger.debug('UPDATE received');
          this.receiveUpdate(request);
        } else {
          request.reply(403, 'Wrong Status');
        }
        break;
      case ExSIP_C.REFER:
        if(this.status === C.STATUS_CONFIRMED) {
          this.ua.processRefer(this, request);
        }
        break;
      case ExSIP_C.NOTIFY:
        if(this.status === C.STATUS_REFER_SENT) {
          request.reply(200);
          this.logger.log('received NOTIFY with body : ' + request.body);
          var status = parseInt(request.body.match(/SIP\/2.0\s(.*)\s/)[1], 10);
          this.logger.log('NOTIFY status : ' + status);

          if(!this.sessionToTransfer) {
            this.logger.warn('no transferred session for REFER session : ' + this.id);
            return;
          }

          if(status >= 200 && status <= 299) {
            this.logger.log('terminate transferred session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.terminate();
          } else if(status >= 400 && status <= 699) {
            this.logger.warn('resuming session : ' + this.sessionToTransfer.id);
            this.sessionToTransfer.unhold(function(){
              self.logger.log('resumed session : ' + self.sessionToTransfer.id);
            });
          }
        }
        break;
      default:
        request.reply(501);
    }
  }
};


RTCSession.prototype.setStatus = function(status) {
  if(this.logger) {
    this.logger.debug('setStatus : '+Object.keys(C)[status]);    
  } else {
    console.log('setStatus : '+Object.keys(C)[status]);
  }
  this.status = status;
};

RTCSession.prototype.supports = function(name) {
  var supported = this.request.getHeader("Supported");
  return supported !== undefined && supported.indexOf(name) !== -1;
};

/**
 * @private
 */
RTCSession.prototype.sendACK = function() {
  this.sendRequest(ExSIP_C.ACK);
};

/**
 * @private
 */
RTCSession.prototype.sendBye = function(options) {
  var self = this;
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];

  var reason,
    status_code = options.status_code,
    reason_phrase = options.reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '',
    body = options.body;

  if (status_code && (status_code < 200 || status_code >= 700)) {
    throw new TypeError('Invalid status_code: ' + status_code);
  } else if (status_code) {
    reason = 'SIP ;cause=' + status_code + '; text="' + reason_phrase + '"';
    options.extraHeaders.push('Reason: ' + reason);
  }

  options.sdp = body;
  options.status = C.STATUS_BYE_SENT;
  var callbacks = {
    success: function() {
      self.sendACK();
      self.ended('local', null, ExSIP_C.causes.BYE);
    }
  };
  this.logger.log('sendBye : ' + callbacks);
  this.sendRequest(ExSIP_C.BYE, options, callbacks);
};


/**
 * @private
 */
RTCSession.prototype.sendRequest = function(method, options, requestCallbacks) {
  var request_sender;
  options = options || {};
  if (this.dialog) {
    this.logger.debug('sendRequest : dialog : ' + method);
    request_sender = this.dialog.createRequestSender(this, method, options);
  } else {
    this.logger.debug('sendRequest : createOutgoingRequestSender : ' + method + ', ' + JSON.stringify(options));
    request_sender = this.createOutgoingRequestSender(options.target, method, options);
  }

  if (!request_sender) {
    return;
  }

  if (options.status) {
    this.setStatus(options.status);
  }
  request_sender.request.body = options.sdp;

  var hasSdp = request_sender.request.body && request_sender.request.body.length > 0;
  if (!Utils.containsHeader(request_sender.request.extraHeaders, "Content-Type") && hasSdp) {
    request_sender.request.extraHeaders.push('Content-Type: application/sdp');
  }
  this.logger.debug('request_sender.request.extraHeaders : ' + Utils.toString(request_sender.request.extraHeaders));

  request_sender.send(requestCallbacks);
};

/**
 * Session 1009s
 */

/**
 * Callback to be called from UA instance when TransportError occurs
 * @private
 */
RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Initial Request Sender
 */
RTCSession.prototype.connectLocalMedia = function(target, options, success, failure) {
  var
    self = this;

  // // User media succeeded
  // userMediaSucceeded = function(stream) {
  //   self.rtcMediaHandler.addStream(
  //     stream,
  //     streamAdditionSucceeded,
  //     streamAdditionFailed
  //   );
  // },

  // // User media failed
  // userMediaFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('local', null, ExSIP_C.causes.USER_DENIED_MEDIA_ACCESS);
  // },

  // // rtcMediaHandler.addStream successfully added
  // streamAdditionSucceeded = function() {
  //   self.connecting(self.request);

  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.rtcMediaHandler.createOffer(
  //     offerCreationSucceeded,
  //     offerCreationFailed,
  //     RTCOfferConstraints
  //   );
  // },

  // // rtcMediaHandler.addStream failed
  // streamAdditionFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // },

  // // rtcMediaHandler.createOffer succeeded
  // offerCreationSucceeded = function(offer) {
  //   if (self.isCanceled || self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.request.body = offer;
  //   self.status = C.STATUS_INVITE_SENT;
  //   request_sender.send();
  // },

  // // rtcMediaHandler.createOffer failed
  // offerCreationFailed = function() {
  //   if (self.status === C.STATUS_TERMINATED) {
  //     return;
  //   }

  //   self.failed('system', null, ExSIP_C.causes.WEBRTC_ERROR);
  // };

  this.receiveResponse = this.receiveInviteResponse;
  var mediaConstraints = options.mediaConstraints || {
    audio: true,
    video: true
  };

  this.getUserMedia(mediaConstraints, function() {
    self.logger.log('getUserMedia succeeded');
    success();
  }, function() {
    self.logger.log('getUserMedia failed');
    self.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    failure();
  }, options);

  // if (mediaStream) {
  //   userMediaSucceeded(mediaStream);
  // } else {
  //   this.getUserMedia(
  //     mediaConstraints,
  //     userMediaSucceeded,
  //     userMediaFailed
  //   );
  // }
};

/**
 * Send Re-INVITE
 */
RTCSession.prototype.sendReinvite = function(options) {
  options = options || {};

  var
    self = this,
    extraHeaders = options.extraHeaders || [],
    eventHandlers = options.eventHandlers || {},
    mangle = options.mangle || null;

  if (eventHandlers.succeeded) {
    this.reinviteSucceeded = eventHandlers.succeeded;
  } else {
    this.reinviteSucceeded = function() {};
  }
  if (eventHandlers.failed) {
    this.reinviteFailed = eventHandlers.failed;
  } else {
    this.reinviteFailed = function() {};
  }

  extraHeaders.push('Contact: ' + this.contact);
  extraHeaders.push('Content-Type: application/sdp');

  this.receiveResponse = this.receiveReinviteResponse;

  this.rtcMediaHandler.createOffer(
    function(body) {
      if (mangle) {
        body = mangle(body);
      }

      self.dialog.sendRequest(self, ExSIP_C.INVITE, {
        extraHeaders: extraHeaders,
        body: body
      });
    },
    function() {
      if (self.isReadyToReinvite()) {
        self.onReadyToReinvite();
      }
      self.reinviteFailed();
    }
  );
};


/**
 * Reception of Response for in-dialog INVITE
 */
RTCSession.prototype.receiveReinviteResponse = function(response) {
  var
    self = this,
    contentType = response.getHeader('Content-Type');

  if (this.status === C.STATUS_TERMINATED) {
    return;
  }

  switch (true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      break;
    case /^2[0-9]{2}$/.test(response.status_code):
      this.setStatus(C.STATUS_CONFIRMED);
      this.sendRequest(ExSIP_C.ACK);

      if (!response.body) {
        this.reinviteFailed();
        break;
      } else if (contentType !== 'application/sdp') {
        this.reinviteFailed();
        break;
      }

      this.rtcMediaHandler.onMessage(
        'answer',
        response.body,
        /*
         * onSuccess
         * SDP Answer fits with Offer.
         */
        function() {
          if(self.reinviteSucceeded) {
            self.reinviteSucceeded();
          }
        },
        /*
         * onFailure
         * SDP Answer does not fit the Offer.
         */
        function() {
          if(self.reinviteFailed) {
            self.reinviteFailed();            
          }
        }
      );
      break;
    default:
      if(this.reinviteFailed) {
        this.reinviteFailed();        
      }
  }
};



RTCSession.prototype.acceptAndTerminate = function(response, status_code, reason_phrase) {
  var extraHeaders = [];

  if (status_code) {
    reason_phrase = reason_phrase || ExSIP_C.REASON_PHRASE[status_code] || '';
    extraHeaders.push('Reason: SIP ;cause=' + status_code + '; text="' + reason_phrase + '"');
  }

  // An error on dialog creation will fire 'failed' event
  if (this.dialog || this.createDialog(response, 'UAC')) {
    this.sendRequest(ExSIP_C.ACK);
    this.sendBye();
    // this.sendRequest(ExSIP_C.BYE, {
    //   extraHeaders: extraHeaders
    // });
  }

  // Update session status.
  this.setStatus(C.STATUS_TERMINATED);
};


RTCSession.prototype.toogleMuteAudio = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getAudioTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

RTCSession.prototype.toogleMuteVideo = function(mute) {
  var streamIdx, trackIdx, tracks,
    localStreams = this.getLocalStreams();

  for (streamIdx in localStreams) {
    tracks = localStreams[streamIdx].getVideoTracks();
    for (trackIdx in tracks) {
      tracks[trackIdx].enabled = !mute;
    }
  }
};

/**
 * Session Callbacks
 */

RTCSession.prototype.onTransportError = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    } else {
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

/**
 * Callback to be called from UA instance when RequestTimeout occurs
 * @private
 */
RTCSession.prototype.onRequestTimeout = function() {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('system', null, ExSIP_C.causes.REQUEST_TIMEOUT);
    } else {
      this.ua.reconnect();
      this.failed('system', null, ExSIP_C.causes.CONNECTION_ERROR);
    }
  }
};

RTCSession.prototype.onDialogError = function(response) {
  if (this.status !== C.STATUS_TERMINATED) {
    if (this.status === C.STATUS_CONFIRMED) {
      this.ended('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    } else {
      this.failed('remote', response, ExSIP_C.causes.DIALOG_ERROR);
    }
  }
};

/**
 * Internal Callbacks
 */

RTCSession.prototype.newRTCSession = function(originator, request) {
  var session = this,
    event_name = 'newRTCSession';

  if (originator === 'remote') {
    session.direction = 'incoming';
    session.local_identity = request.to;
    session.remote_identity = request.from;
  } else if (originator === 'local') {
    session.direction = 'outgoing';
    session.local_identity = request.from;
    session.remote_identity = request.to;
  }

  session.ua.emit(event_name, session.ua, {
    originator: originator,
    session: session,
    request: request
  });
};

RTCSession.prototype.connecting = function(request) {
  var session = this,
    event_name = 'connecting';

  session.emit(event_name, session, {
    request: request
  });
};

RTCSession.prototype.progress = function(originator, response) {
  var session = this,
    event_name = 'progress';

  session.emit(event_name, session, {
    originator: originator,
    response: response || null
  });
};

RTCSession.prototype.accepted = function(originator, message) {
  var session = this,
    event_name = 'accepted';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.started = function(originator, message) {
  var session = this,
    event_name = 'started';

  session.start_time = new Date();

  session.emit(event_name, session, {
    originator: originator,
    response: message || null
  });
};

RTCSession.prototype.confirmed = function(originator, ack) {
  var session = this,
    event_name = 'confirmed';

  this.is_confirmed = true;

  session.emit(event_name, session, {
    originator: originator,
    ack: ack || null
  });
};

RTCSession.prototype.ended = function(originator, message, cause) {
  var session = this,
    event_name = 'ended';

  session.end_time = new Date();

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.failed = function(originator, message, cause) {
  var session = this,
    event_name = 'failed';

  session.close();
  session.emit(event_name, session, {
    originator: originator,
    message: message || null,
    cause: cause
  });
};

RTCSession.prototype.onhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = true;
  } else {
    this.remote_hold = true;
  }

  this.emit('hold', this, {
    originator: originator
  });
};

RTCSession.prototype.onunhold = function(originator) {
  if (originator === 'local') {
    this.local_hold = false;
  } else {
    this.remote_hold = false;
  }

  this.emit('unhold', this, {
    originator: originator
  });
};

RTCSession.prototype.onmute = function(options) {
  this.emit('muted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onunmute = function(options) {
  this.emit('unmuted', this, {
    audio: options.audio,
    video: options.video
  });
};

RTCSession.prototype.onReadyToReinvite = function() {
  var action = (this.pending_actions.length() > 0) ? this.pending_actions.shift() : null;

  if (!action) {
    return;
  }

  if (action.name === 'hold') {
    this.hold();
  } else if (action.name === 'unhold') {
    this.unhold();
  }
};
},{"./Constants":197,"./Dialog":198,"./EventEmitter":201,"./Exceptions":203,"./Parser":209,"./RTCSession/DTMF":211,"./RTCSession/RTCMediaHandler":213,"./RequestSender":215,"./SIPMessage":216,"./Timers":217,"./UA":220,"./Utils":222,"./WebRTC":223}],211:[function(require,module,exports){
module.exports = DTMF;


var C = {
  MIN_DURATION:            70,
  MAX_DURATION:            6000,
  DEFAULT_DURATION:        100,
  MIN_INTER_TONE_GAP:      50,
  DEFAULT_INTER_TONE_GAP:  500
};

/**
 * Expose C object.
 */
DTMF.C = C;


/**
 * Dependencies.
 */
var EventEmitter = require('../EventEmitter');
var Exceptions = require('../Exceptions');
var RTCSession = require('../RTCSession');
var Utils = require('../Utils');


function DTMF(session) {
  var events = [
  'succeeded',
  'failed'
  ];

  this.sendTimeoutId = null;
  this.queuedDTMFs = [];
  this.session = session;
  this.direction = null;
  this.tone = null;
  this.duration = null;
  this.interToneGap = null;
  this.dtmfSender = null;

  this.logger = this.session.ua.getLogger('rtcsession.dtmf', session.id);

  this.initEvents(events);
}

DTMF.prototype = new EventEmitter();

DTMF.prototype.send = function(tone, options) {
  var event, eventHandlers, extraHeaders;

  if (tone === undefined) {
    throw new TypeError('Not enough arguments');
  }

  this.direction = 'outgoing';

  // Check RTCSession Status
  if (this.session.status !== RTCSession.C.STATUS_CONFIRMED && this.session.status !== RTCSession.C.STATUS_WAITING_FOR_ACK) {
    throw new Exceptions.InvalidStateError(this.session.status);
  }

  // Get DTMF options
  options = options || {};
  extraHeaders = options.extraHeaders ? options.extraHeaders.slice() : [];
  eventHandlers = options.eventHandlers || {};

  // Check tone type
  if (typeof tone === 'string' ) {
    tone = tone.toUpperCase();
  } else if (typeof tone === 'number') {
    tone = tone.toString();
  } else {
    throw new TypeError('Invalid tone: '+ tone);
  }

  // Check tone value
  if (!tone.match(/^[0-9A-D#*,]+$/i)) {
    throw new TypeError('Invalid tone: '+ tone);
  } else {
    this.tone = tone;
  }

  // Set event handlers
  for (event in eventHandlers) {
    this.on(event, eventHandlers[event]);
  }

  this.queueTone(this.tone, options.duration, options.interToneGap);
};

DTMF.prototype.processQueuedDTMFs = function() {
  var self = this;
  if(this.queuedDTMFs.length === 0) {
    return;
  }
  if(!this.dtmfSender.canInsertDTMF) {
    this.logger.log("DTMF Sender cannot insert DTMF - trying again after timeout", this.session.ua);
    this.sendTimeoutId = setTimeout(function(){
      self.processQueuedDTMFs();
    }, 1000);
    return;
  }
  var tones = "";
  var durationSum = 0;
  var interToneGapSum = 0;
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    tones += dtmf.tone;
    durationSum += dtmf.duration;
    interToneGapSum += dtmf.interToneGap;
  }
  var duration = durationSum / this.queuedDTMFs.length;
  var interToneGap = interToneGapSum / this.queuedDTMFs.length;

  this.logger.log("sending DTMF with tones "+tones+", duration "+duration+", gap "+interToneGap);
  this.dtmfSender.insertDTMF(tones, duration, interToneGap);
};

DTMF.prototype.queueTone = function(tone, duration, interToneGap) {
  this.logger.log("Queue tone : "+tone);
  clearTimeout(this.sendTimeoutId);
  this.queuedDTMFs.push({tone: tone, duration: duration, interToneGap: interToneGap});
  var self = this;
  this.sendTimeoutId = setTimeout(function(){
    self.processQueuedDTMFs();
  }, 2 * duration);
};

DTMF.prototype.onDTMFSent = function(tone) {
  if (!tone) {
    return;
  }

  this.logger.log("Sent Dtmf tone: " + tone.tone);
  for(var i=0; i < this.queuedDTMFs.length; i++) {
    var dtmf = this.queuedDTMFs[i];
    if(tone.tone === dtmf.tone) {
      this.queuedDTMFs.splice(i, 1);
      this.logger.log("removing from queued tones - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    } else if(dtmf.tone.indexOf(tone.tone) !== -1) {
      dtmf.tone = dtmf.tone.replace(tone.tone, '');
      this.queuedDTMFs[i] = dtmf;
      this.logger.log("removing from queued tones as contained - remaining queue: \t" + Utils.toString(this.queuedDTMFs));
      break;
    }
  }
  this.session.emit('newDTMF', this.session, {
    originator: 'local',
    dtmf: this,
    tone: tone.tone
  });
};

DTMF.prototype.enableDtmfSender = function(localstream, peerConnection) {
  var self = this;
  this.logger.debug('enableDtmfSender : '+localstream);
  if (localstream !== null) {
    var local_audio_track = localstream.getAudioTracks()[0];
    this.dtmfSender = peerConnection.createDTMFSender(local_audio_track);
    this.logger.log("Created DTMF Sender with canInsertDTMF : "+this.dtmfSender.canInsertDTMF);

    this.dtmfSender.ontonechange = function(tone) {
      self.onDTMFSent(tone);
    };

    this.processQueuedDTMFs();
  }
  else {
    this.logger.error("No Local Stream to create DTMF Sender");
  }
};

/**
* @private
*/
DTMF.prototype.receiveResponse = function(response) {
  var cause;

  switch(true) {
    case /^1[0-9]{2}$/.test(response.status_code):
      // Ignore provisional responses.
      break;

    case /^2[0-9]{2}$/.test(response.status_code):
      this.emit('succeeded', this, {
        originator: 'remote',
        response: response
      });
      break;

    default:
      cause = Utils.sipErrorCause(response.status_code);
      this.emit('failed', this, {
        originator: 'remote',
        response: response,
        cause: cause
      });
      break;
  }
};

/**
 * @private
 */
DTMF.prototype.onRequestTimeout = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.REQUEST_TIMEOUT
  });
};

/**
 * @private
 */
DTMF.prototype.onTransportError = function() {
  this.emit('failed', this, {
    originator: 'system',
    cause: C.causes.CONNECTION_ERROR
  });
};

/**
 * @private
 */
DTMF.prototype.init_incoming = function(request) {
  var body,
    reg_tone = /^(Signal\s*?=\s*?)([0-9A-D#*]{1})(\s)?.*/,
    reg_duration = /^(Duration\s?=\s?)([0-9]{1,4})(\s)?.*/;

  this.direction = 'incoming';
  this.request = request;

  request.reply(200);

  if (request.body) {
    body = request.body.split('\r\n');
    if (body.length === 2) {
      if (reg_tone.test(body[0])) {
        this.tone = body[0].replace(reg_tone,"$2");
      }
      if (reg_duration.test(body[1])) {
        this.duration = parseInt(body[1].replace(reg_duration,"$2"), 10);
      }
    }
  }

  if (!this.tone || !this.duration) {
    this.logger.warn('invalid INFO DTMF received, discarded');
  } else {
    this.session.emit('newDTMF', this.session, {
      originator: 'remote',
      dtmf: this,
      request: request
    });
  }
};
},{"../EventEmitter":201,"../Exceptions":203,"../RTCSession":210,"../Utils":222}],212:[function(require,module,exports){
module.exports = DataChannel;

var EventEmitter = require('../EventEmitter');
/**
 * Dependencies.
 */
function DataChannel(session, peerConnection) {

  this.session = session;
  this.peerConnection = peerConnection;
  this.sendChannel = null;
  this.receiveChannel = null;
  this.chunkLength = 60000;
  this.dataReceived = [];

  this.logger = session.ua.getLogger('ExSIP.rtcsession.datachannel', session.id);

  this.initSendChannel();
}

DataChannel.prototype = new EventEmitter();

DataChannel.prototype.isDebug = function() {
  return this.session.ua.isDebug();
};

DataChannel.prototype.close = function() {
  if(this.sendChannel) {
    this.sendChannel.close();
  }
  if(this.receiveChannel) {
    this.receiveChannel.close();
  }
};

DataChannel.prototype.send = function(data) {
  this.sendInChunks(data);
  this.logger.log('Sent Data: ' + data, this.session.ua);
  this.session.emit('dataSent', this, { data: data });
};

DataChannel.prototype.sendInChunks = function(data) {
  var text = null, last = false, self = this;
  if (data.length > this.chunkLength) {
    text = data.slice(0, this.chunkLength); // getting chunk using predefined chunk length
  } else {
    text = data;
    last = true;
  }

  this.sendChannel.send(text + (last ? "\n" : "")); // use JSON.stringify for chrome!

  if (!last) {
    var remainingDataURL = data.slice(text.length);
    window.setTimeout(function () {
      self.sendInChunks(remainingDataURL); // continue transmitting
    }, 50);
  }
};

DataChannel.prototype.initSendChannel = function() {
  var self = this;
  try {
    // Data Channel api supported from Chrome M25.
    // You might need to start chrome with  --enable-data-channels flag.
    this.sendChannel = this.peerConnection.createDataChannel("sendDataChannel", null);
    this.logger.log('Created send data channel', this.session.ua);

    var onSendChannelStateChange = function() {
      var readyState = self.sendChannel.readyState;
      this.logger.log('Send channel state is: ' + readyState, self.session.ua);
    };

    this.sendChannel.onopen = onSendChannelStateChange;
    this.sendChannel.onclose = onSendChannelStateChange;

    var receiveChannelCallback = function(event) {
      this.logger.log('Receive Channel Callback', self.session.ua);
      self.receiveChannel = event.channel;

      var onReceiveChannelStateChange = function() {
        var readyState = self.receiveChannel.readyState;
        this.logger.log('Receive channel state is: ' + readyState, self.session.ua);
      };

      var onReceiveMessageCallback = function(event) {
        this.logger.log('Received Message : '+event.data, self.session.ua);

        if(event.data.indexOf('\n') !== -1) {
          self.dataReceived.push(event.data.replace('\n', ''));
          var data = self.dataReceived.join('');
          self.dataReceived = [];
          self.session.emit('dataReceived', self, { data: data });
        } else {
          self.dataReceived.push(event.data);
        }
      };

      self.receiveChannel.onmessage = onReceiveMessageCallback;
      self.receiveChannel.onopen = onReceiveChannelStateChange;
      self.receiveChannel.onclose = onReceiveChannelStateChange;
    };

    this.peerConnection.ondatachannel = receiveChannelCallback;
  } catch (e) {
    this.emit('failed', this, {
      cause: 'Failed to create data channel'
    });
    self.logger.error('Create Data channel failed with exception: ' + e.message);
  }
};
},{"../EventEmitter":201}],213:[function(require,module,exports){
module.exports = RTCMediaHandler;

/**
 * Dependencies.
 */
var ExSIP_C = require('../Constants');
var WebRTC = require('../WebRTC');
var Utils = require('../Utils');
var DataChannel = require('./DataChannel');


/* RTCMediaHandler
 * -class PeerConnection helper Class.
 * -param {RTCSession} session
 * -param {Object} [contraints]
 */
function RTCMediaHandler(session, constraints) {
  constraints = constraints || {};
  this.logger = session.ua.getLogger('ExSIP.rtcsession.rtcmediahandler', session.id);

  this.logger.log('constraints : '+Utils.toString(constraints), session.ua);
  this.session = session;
  this.localMedia = null;
  this.peerConnection = null;
  this.createOfferConstraints = null;
  this.dataChannel = null;
  this.ready = true;

  this.init(constraints);
}


RTCMediaHandler.prototype = {
  isReady: function() {
    return this.ready;
  },

  copy: function(rtcMediaHandler) {
    var self = this;

    var streamAdditionSucceeded = function() {
    };
    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
    };

    var description = new WebRTC.RTCSessionDescription({type: this.getSetLocalDescriptionType(), sdp: rtcMediaHandler.peerConnection.localDescription.sdp});
    this.setLocalDescription(description);

    this.addStream(rtcMediaHandler.localMedia, streamAdditionSucceeded, streamAdditionFailed);
  },

  connect: function(stream, connectSucceeded, connectFailed, options) {
    var self = this;
    options = options || {};
    this.logger.log('connect with isAnswer : '+options.isAnswer+" and remoteSdp : "+options.remoteSdp, self.session.ua);

    var setLocalDescription = function(callback) {
      self.setLocalDescription(options.localDescription, callback || connectSucceeded, connectFailed);
    };

    var setRemoteDescription = function(successCallback) {
      self.onMessage(
        self.getSetRemoteLocationType(),
        options.remoteSdp,
        successCallback || connectSucceeded, function(e){
          self.logger.error("setRemoteDescription failed");
          self.logger.error(Utils.toString(e));
          connectFailed();
        }
      );
    };

    var createAnswer = function(){
      self.createAnswer(connectSucceeded, connectFailed, options.mediaConstraints);
    };

    var createOffer = function(){
      self.createOffer(function(sdp){
        if(options.remoteSdp && options.remoteSdp !== "") {
          setRemoteDescription(connectSucceeded);
        } else {
          connectSucceeded(sdp);
        }
      }, connectFailed, options.createOfferConstraints, options);
    };

    var streamAdditionSucceeded = function() {
      var hasRemoteSdp = options.remoteSdp && options.remoteSdp.length > 0;
      var isRemote = options.isAnswer && hasRemoteSdp;
      self.logger.log("isRemote : "+isRemote+", isAnswer : "+options.isAnswer+", hasRemoteSdp :"+hasRemoteSdp, self.session.ua);
      if(isRemote) {
        if(options.localDescription) {
          setRemoteDescription(setLocalDescription);
        } else {
          setRemoteDescription(createAnswer);
        }
      } else {
        if(options.remoteSdp) {
          setLocalDescription(setRemoteDescription);
        } else {
          createOffer();
        }
      }
    };

    var streamAdditionFailed = function() {
      if (self.session.status === ExSIP_C.STATUS_TERMINATED) {
        return;
      }

      self.session.failed('local', null, ExSIP_C.causes.WEBRTC_ERROR);
      connectFailed();
    };

    this.addStream(
      stream,
      streamAdditionSucceeded,
      streamAdditionFailed
    );
  },

  createOffer: function(onSuccess, onFailure, constraints, options) {
    var self = this;
    options = options || {};

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed')) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    this.createOfferConstraints = constraints;
    this.logger.log("createOffer with createOfferConstraints : "+Utils.toString(this.createOfferConstraints), this.session.ua);
    this.peerConnection.createOffer(
      function(sessionDescription){
        if(options.videoMode) {
          sessionDescription.setVideoMode(options.videoMode);
        }
        if(options.videoPort) {
          sessionDescription.setVideoPort(options.videoPort);
        }
        if(options.audioMode) {
          sessionDescription.setAudioMode(options.audioMode);
        }
        if(options.audioPort) {
          sessionDescription.setAudioPort(options.audioPort);
        }
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create offer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  getRemoteDescriptionSdp: function() {
    return this.peerConnection.remoteDescription ? this.peerConnection.remoteDescription.sdp : undefined;
  },

  createAnswer: function(onSuccess, onFailure, constraints) {
    var self = this;

    function onSetLocalDescriptionSuccess() {
      if (self.peerConnection.iceGatheringState === 'complete' && (self.peerConnection.iceConnectionState === 'connected' || self.peerConnection.iceConnectionState === 'completed')) {
        self.ready = true;
        onSuccess(self.peerConnection.localDescription.sdp);
      } else {
        self.onIceCompleted = function() {
          self.onIceCompleted = undefined;
          self.ready = true;
          onSuccess(self.peerConnection.localDescription.sdp);
        };
      }
    }

    this.ready = false;

    constraints = constraints ||  this.createOfferConstraints;
    this.logger.log("createAnswer with constraints : "+constraints, this.session.ua);
    this.peerConnection.createAnswer(
      function(sessionDescription){
        self.setLocalDescription(
          sessionDescription,
          onSetLocalDescriptionSuccess,
          function(e) {
            self.ready = true;
            onFailure(e);
          }
        );
      },
      function(e) {
        self.ready = true;
        self.logger.error('unable to create answer');
        self.logger.error(e);
        onFailure(e);
      },
      constraints
    );
  },

  setLocalDescription: function(sessionDescription, onSuccess, onFailure) {
    var self = this;

    this.peerConnection.setLocalDescription(
      sessionDescription,
      onSuccess,
      function(e) {
        self.logger.error('unable to set local description');
        self.logger.error(e);
        onFailure(e);
      }
    );
  },

  addStream: function(stream, onSuccess, onFailure, constraints) {
    try {
      this.logger.log("add stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.addStream(stream, constraints);
    } catch(e) {
      this.logger.error('error adding stream');
      this.logger.error(e);
      onFailure();
      return;
    }

    onSuccess();
  },

  clearStreams: function() {
    if(!this.localMedia) {
      return;
    }
    if(this.removeStream(this.localMedia)) {
      this.localMedia = null;
    }
    return;
  },

  removeStream: function(stream) {
    try {
      this.logger.log("remove stream : "+Utils.toString(stream), this.session.ua);
      this.peerConnection.removeStream(stream);
    } catch(e) {
      this.logger.error('error removing stream');
      this.logger.error(e);
      return false;
    }

    return true;
  },

  getSetLocalDescriptionType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-local-offer') {
      return "offer";
    } else if(state === 'have-remote-offer' || state === 'have-local-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  getSetRemoteLocationType: function(){
    var state = this.peerConnection.signalingState;
    if(state === 'stable' || state === 'have-remote-offer') {
      return "offer";
    } else if(state === 'have-local-offer' || state === 'have-remote-pr-answer'){
      return "answer";
    } else {
      this.logger.error("state "+state +" not implemented - returning offer");
      return "offer";
    }
  },

  sendData: function(data) {
    if(this.dataChannel) {
      this.dataChannel.send(data);
    } else {
      this.logger.error('datachannel is not enabled - see UA.configuration.enable_datachannel');
    }
  },

  /**
  * peerConnection creation.
  */
  init: function(options) {
    options = options || {};

    var idx, length, server,
      self = this,
      servers = [],
      constraints = options.constraints || {},
      stun_servers = options.stun_servers  || null,
      turn_servers = options.turn_servers || null,
      config = this.session.ua.configuration;

    if (!stun_servers) {
      stun_servers = config.stun_servers;
    }

    if (!turn_servers) {
      turn_servers = config.turn_servers;
    }

    /* Change 'url' to 'urls' whenever this issue is solved:
     * https://code.google.com/p/webrtc/issues/detail?id=2096
     */

    if (stun_servers.length > 0) {
      servers.push({'url': stun_servers});
    }

    length = turn_servers.length;
    for (idx = 0; idx < length; idx++) {
      server = turn_servers[idx];
      servers.push({
        'url': server.urls,
        'username': server.username,
        'credential': server.credential
      });
    }

    this.peerConnection = new WebRTC.RTCPeerConnection({'iceServers': servers}, constraints);

    this.peerConnection.onaddstream = function(e) {
      self.logger.debug('stream added: '+ e.stream.id);
    };

    this.peerConnection.onremovestream = function(e) {
      self.logger.debug('stream removed: '+ e.stream.id);
    };

    this.peerConnection.onicecandidate = function(e) {
      if (e.candidate && self.session.ua.rtcMediaHandlerOptions.enableICE) {
        self.logger.debug('ICE candidate received: '+ e.candidate.candidate);
      } else if (self.onIceCompleted !== undefined) {
        self.logger.log('onIceCompleted with ready : '+ self.ready+" and candidate : "+Utils.toString(e.candidate), self.session.ua);
        if(!self.ready && e.candidate) {
          self.onIceCompleted();
        }      
      }
    };

    this.peerConnection.oniceconnectionstatechange = function() {
      self.logger.debug('ICE connection state changed to "'+ this.iceConnectionState +'"');

      if (this.iceConnectionState === 'failed') {
        self.session.terminate({
            cause: ExSIP_C.causes.RTP_TIMEOUT,
            status_code: 200,
            reason_phrase: ExSIP_C.causes.RTP_TIMEOUT
          });
      }
    };


    this.peerConnection.onstatechange = function() {
      self.logger.debug('PeerConnection state changed to "'+ this.readyState +'"');
    };

    if(self.session.ua.configuration.enable_datachannel) {
      this.dataChannel = new DataChannel(this.session, this.peerConnection);
    }
  },

  close: function(stopLocalMedia) {
    this.logger.debug('closing PeerConnection');
    if(this.peerConnection) {
      if(this.peerConnection.signalingState !== 'closed') {
        this.logger.log('closing PeerConnection', this.session.ua);
        this.peerConnection.close();
      }

      if(stopLocalMedia) {
        if(this.localMedia) {
          this.logger.log('stopping local media '+Utils.toString(this.localMedia), this.session.ua);
          this.localMedia.stop();
        }
      }
    }
  },

  /**
  * -param {Object} mediaConstraints
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  getUserMedia: function(onSuccess, onFailure, constraints) {
    var self = this;

    this.logger.debug('requesting access to local media');

    WebRTC.getUserMedia(constraints,
      function(stream) {
        self.logger.debug('got local media stream');
        self.localMedia = stream;
        onSuccess(stream);
      },
      function(e) {
        self.logger.error('unable to get user media');
        self.logger.error(e);
        onFailure();
      }
    );
  },

  /**
  * Message reception.
  * -param {String} type
  * -param {String} sdp
  * -param {Function} onSuccess
  * -param {Function} onFailure
  */
  onMessage: function(type, body, onSuccess, onFailure) {
    var self = this;
    var description = new WebRTC.RTCSessionDescription({type: type, sdp:body});
    if(this.session.ua.rtcMediaHandlerOptions.videoBandwidth) {
      description.setVideoBandwidth(this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
      this.logger.log("Modifying SDP with videoBandwidth : "+this.session.ua.rtcMediaHandlerOptions.videoBandwidth);
    }

    if(this.peerConnection) {
      if(!description.sdp) {
        this.logger.log('empty sdp on setRemoteDescription - calling success');
        onSuccess();
        return;
      }

      var unsupportedMedia = description.removeUnsupportedMedia();
      if(unsupportedMedia) {
        this.logger.log('removed unsupported media : '+unsupportedMedia);
        this.peerConnection.remoteUnsupportedMedia = unsupportedMedia;
      }

      this.logger.log('peerConnection.setRemoteDescription : description : '+Utils.toString(description));
      this.logger.log('peerConnection.setRemoteDescription for type '+description.type+' : '+description.sdp);
      this.peerConnection.setRemoteDescription(
        description,
        onSuccess,
        function(e){
          self.logger.log("----------setRemoteDescription with error : "+JSON.stringify(e));
          onFailure(e);
        }
      );
    }
  }
};
},{"../Constants":197,"../Utils":222,"../WebRTC":223,"./DataChannel":212}],214:[function(require,module,exports){
module.exports = Registrator;


/**
 * Dependecies
 */
var Utils = require('./Utils');
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var RequestSender = require('./RequestSender');

function Registrator(ua, transport) {
  var reg_id=1; //Force reg_id to 1.

  this.logger = ua.getLogger('ExSIP.registrator');

  this.ua = ua;
  this.transport = transport;

  this.registrar = ua.configuration.registrar_server;
  this.expires = ua.configuration.register_expires;

  // Call-ID and CSeq values RFC3261 10.2
  this.call_id = Utils.createRandomToken(22);
  this.cseq = 0;

  // this.to_uri
  this.to_uri = ua.configuration.uri;

  this.registrationTimer = null;

  // Set status
  this.registered = false;

  // Contact header
  this.contact = this.ua.contact.toString();

  // sip.ice media feature tag (RFC 5768)
  this.contact += ';+sip.ice';

  // Custom headers for REGISTER and un-REGISTER.
  this.extraHeaders = [];

  // Custom Contact header params for REGISTER and un-REGISTER.
  this.extraContactParams = "";

  if(reg_id) {
    this.contact += ';reg-id='+ reg_id;
    this.contact += ';+sip.instance="<urn:uuid:'+ this.ua.configuration.instance_id+'>"';
  }
}


Registrator.prototype = {
  setExtraHeaders: function(extraHeaders) {
    if (! extraHeaders instanceof Array) {
      extraHeaders = [];
    }

    this.extraHeaders = extraHeaders.slice();
  },

  setExtraContactParams: function(extraContactParams) {
    if (! extraContactParams instanceof Object) {
      extraContactParams = {};
    }

    // Reset it.
    this.extraContactParams = "";

    for(var param_key in extraContactParams) {
      var param_value = extraContactParams[param_key];
      this.extraContactParams += (";" + param_key);
      if (param_value) {
        this.extraContactParams += ("=" + param_value);
      }
    }
  },

  register: function() {
    var request_sender, cause, extraHeaders,
      self = this;

    extraHeaders = this.extraHeaders.slice();
    extraHeaders.push('Contact: ' + this.contact + ';expires=' + this.expires + this.extraContactParams);
    extraHeaders.push('Expires: '+ this.expires);

    this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
        'to_uri': this.to_uri,
        'call_id': this.call_id,
        'cseq': (this.cseq += 1)
      }, extraHeaders);

    request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var contact, expires,
        contacts = response.getHeaders('contact').length;

      // Discard responses to older REGISTER/un-REGISTER requests.
      if(response.cseq !== this.cseq) {
        return;
      }

      // Clear registration timer
      if (this.registrationTimer !== null) {
        clearTimeout(this.registrationTimer);
        this.registrationTimer = null;
      }

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          if(response.hasHeader('expires')) {
            expires = response.getHeader('expires');
          }

          // Search the Contact pointing to us and update the expires value accordingly.
          if (!contacts) {
            this.logger.warn('no Contact header in response to REGISTER, response ignored');
            break;
          }

          while(contacts--) {
            contact = response.parseHeader('contact', contacts);
            if(contact.uri.user === this.ua.contact.uri.user) {
              expires = contact.getParam('expires');
              break;
            } else {
              contact = null;
            }
          }

          if (!contact) {
            this.logger.warn('no Contact header pointing to us, response ignored');
            break;
          }

          if(!expires) {
            expires = this.expires;
          }

          // Re-Register before the expiration interval has elapsed.
          // For that, decrease the expires value. ie: 3 seconds
          this.registrationTimer = setTimeout(function() {
            self.registrationTimer = null;
            self.register();
          }, (expires * 1000) - 3000);

          //Save gruu values
          if (contact.hasParam('temp-gruu')) {
            this.ua.contact.temp_gruu = contact.getParam('temp-gruu').replace(/"/g,'');
          }
          if (contact.hasParam('pub-gruu')) {
            this.ua.contact.pub_gruu = contact.getParam('pub-gruu').replace(/"/g,'');
          }

          if (! this.registered) {
            this.registered = true;
            this.ua.emit('registered', this.ua, {
              response: response
            });
          }
          break;
        // Interval too brief RFC3261 10.2.8
        case /^423$/.test(response.status_code):
          if(response.hasHeader('min-expires')) {
            // Increase our registration interval to the suggested minimum
            this.expires = response.getHeader('min-expires');
            // Attempt the registration again immediately
            this.register();
          } else { //This response MUST contain a Min-Expires header field
            this.logger.warn('423 response received for REGISTER without Min-Expires');
            this.registrationFailure(response, ExSIP_C.causes.SIP_FAILURE_CODE);
          }
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.registrationFailure(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.registrationFailure(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.registrationFailure(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  unregister: function(options) {
    var extraHeaders;

    if(!this.registered) {
      this.logger.debug('already unregistered');
      return;
    }

    options = options || {};

    this.registered = false;

    // Clear the registration timer.
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    extraHeaders = this.extraHeaders.slice();

    if(options.all) {
      extraHeaders.push('Contact: *' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    } else {
      extraHeaders.push('Contact: '+ this.contact + ';expires=0' + this.extraContactParams);
      extraHeaders.push('Expires: 0');

      this.request = new SIPMessage.OutgoingRequest(ExSIP_C.REGISTER, this.registrar, this.ua, {
          'to_uri': this.to_uri,
          'call_id': this.call_id,
          'cseq': (this.cseq += 1)
        }, extraHeaders);
    }

    var request_sender = new RequestSender(this, this.ua);

    this.receiveResponse = function(response) {
      var cause;

      switch(true) {
        case /^1[0-9]{2}$/.test(response.status_code):
          // Ignore provisional responses.
          break;
        case /^2[0-9]{2}$/.test(response.status_code):
          this.unregistered(response);
          break;
        default:
          cause = Utils.sipErrorCause(response.status_code);
          this.unregistered(response, cause);
      }
    };

    this.onRequestTimeout = function() {
      this.unregistered(null, ExSIP_C.causes.REQUEST_TIMEOUT);
    };

    this.onTransportError = function() {
      this.unregistered(null, ExSIP_C.causes.CONNECTION_ERROR);
    };

    request_sender.send();
  },

  registrationFailure: function(response, cause) {
    this.ua.emit('registrationFailed', this.ua, {
      response: response || null,
      cause: cause
    });

    if (this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua, {
        response: response || null,
        cause: cause
      });
    }
  },

  unregistered: function(response, cause) {
    this.registered = false;
    this.ua.emit('unregistered', this.ua, {
      response: response || null,
      cause: cause || null
    });
  },

  onTransportConnected: function() {
    this.register();
  },

  onTransportClosed: function() {
    if (this.registrationTimer !== null) {
      clearTimeout(this.registrationTimer);
      this.registrationTimer = null;
    }

    if(this.registered) {
      this.registered = false;
      this.ua.emit('unregistered', this.ua);
    }
  },

  close: function() {
    if (this.registered) {
      this.unregister();
    }
  }
};
},{"./Constants":197,"./RequestSender":215,"./SIPMessage":216,"./Utils":222}],215:[function(require,module,exports){
module.exports = RequestSender;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var UA = require('./UA');
var DigestAuthentication = require('./DigestAuthentication');
var Transactions = require('./Transactions');

function RequestSender(applicant, ua) {
  this.logger = ua.getLogger('ExSIP.requestsender');
  this.ua = ua;
  this.applicant = applicant;
  this.method = applicant.request.method;
  this.request = applicant.request;
  this.credentials = null;
  this.challenged = false;
  this.staled = false;

  // If ua is in closing process or even closed just allow sending Bye and ACK
  if (ua.status === UA.C.STATUS_USER_CLOSED && (this.method !== ExSIP_C.BYE || this.method !== ExSIP_C.ACK)) {
    this.onTransportError();
  }
}


/**
 * Create the client transaction and send the message.
 */
RequestSender.prototype = {
  send: function(callbacks) {
    this.callbacks = callbacks || {};
    this.logger.log('callbacks : ' + this.callbacks);

    switch (this.method) {
      case "INVITE":
        this.clientTransaction = new Transactions.InviteClientTransaction(this, this.request, this.ua.transport);
        break;
      case "ACK":
        this.clientTransaction = new Transactions.AckClientTransaction(this, this.request, this.ua.transport);
        break;
      default:
        this.clientTransaction = new Transactions.NonInviteClientTransaction(this, this.request, this.ua.transport);
    }
    this.clientTransaction.send();
  },

  /**
   * Callback fired when receiving a request timeout error from the client transaction.
   * To be re-defined by the applicant.
   */
  onRequestTimeout: function() {
    this.logger.log('******************** onRequestTimeout : '+this.applicant);
    this.applicant.onRequestTimeout();
  },

  /**
   * Callback fired when receiving a transport error from the client transaction.
   * To be re-defined by the applicant.
   */
  onTransportError: function() {
    this.applicant.onTransportError();
  },

  /**
   * Called from client transaction when receiving a correct response to the request.
   * Authenticate request if needed or pass the response back to the applicant.
   */
  receiveResponse: function(response) {
    var cseq, challenge, authorization_header_name,
      status_code = response.status_code;
    this.logger.log('receiveResponse: callbacks : ' + this.callbacks);


    /*
     * Authentication
     * Authenticate once. _challenged_ flag used to avoid infinite authentications.
     */
    if ((status_code === 401 || status_code === 407)) {

      // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.
      if (response.status_code === 401) {
        challenge = response.parseHeader('www-authenticate');
        authorization_header_name = 'authorization';
      } else {
        challenge = response.parseHeader('proxy-authenticate');
        authorization_header_name = 'proxy-authorization';
      }

      // Verify it seems a valid challenge.
      if (!challenge) {
        this.logger.warn(response.status_code + ' with wrong or missing challenge, cannot authenticate');
        this.applicant.receiveResponse(response);
        return;
      }

      if (!this.challenged || (!this.staled && challenge.stale === true)) {
        if (!this.credentials) {
          this.credentials = new DigestAuthentication(this.ua);
        }

        // Verify that the challenge is really valid.
        if (!this.credentials.authenticate(this.request, challenge)) {
          this.applicant.receiveResponse(response);
          return;
        }
        this.challenged = true;

        if (challenge.stale) {
          this.staled = true;
        }

        if (response.method === ExSIP_C.REGISTER) {
          cseq = this.applicant.cseq += 1;
        } else if (this.request.dialog) {
          cseq = this.request.dialog.local_seqnum += 1;
        } else {
          cseq = this.request.cseq + 1;
          this.request.cseq = cseq;
        }
        this.request.setHeader('cseq', cseq + ' ' + this.method);

        this.request.setHeader(authorization_header_name, this.credentials.toString());
        this.send();
      } else {
        this.applicant.receiveResponse(response);
      }
    } else {
      this.applicant.receiveResponse(response);
    }

    switch (true) {
      case /^1[0-9]{2}$/.test(response.status_code):
        break;
      case /^2[0-9]{2}$/.test(response.status_code):
        if (this.callbacks.success) {
          this.callbacks.success();
        }
        break;
      default:
        if (this.callbacks.failure) {
          this.callbacks.failure(response);
        }
        break;
    }

  }
};
},{"./Constants":197,"./DigestAuthentication":200,"./Transactions":218,"./UA":220}],216:[function(require,module,exports){
module.exports = {
  OutgoingRequest: OutgoingRequest,
  IncomingRequest: IncomingRequest,
  IncomingResponse: IncomingResponse
};


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var NameAddrHeader = require('./NameAddrHeader');
var Grammar = require('./Grammar');


/**
 * -param {String} method request method
 * -param {String} ruri request uri
 * -param {UA} ua
 * -param {Object} params parameters that will have priority over ua.configuration parameters:
 * <br>
 *  - cseq, call_id, from_tag, from_uri, from_display_name, to_uri, to_tag, route_set
 * -param {Object} [headers] extra headers
 * -param {String} [body]
 */
function OutgoingRequest(method, ruri, ua, params, extraHeaders, body) {
  var
    to,
    from,
    call_id,
    cseq;

  params = params || {};

  this.logger = ua.getLogger('ExSIP.sipmessage');

  this.logger.debug('OutgoingRequest.extraHeaders : '+method+', '+ruri+', '+extraHeaders);
  // Mandatory parameters check
  if(!method || !ruri || !ua) {
    return null;
  }

  this.ua = ua;
  this.headers = {};
  this.method = method;
  this.ruri = ruri;
  this.body = body;
  this.extraHeaders = extraHeaders && extraHeaders.slice() || [];
this.logger.debug('OutgoingRequest.extraHeaders 2 : '+this.extraHeaders);
  // Fill the Common SIP Request Headers

  // Route
  if (params.route_set) {
    this.setHeader('route', params.route_set);
  } else if (ua.configuration.use_preloaded_route){
    this.setHeader('route', ua.transport.server.sip_uri);
  }

  // Via
  // Empty Via header. Will be filled by the client transaction.
  this.setHeader('via', '');

  // Max-Forwards
  this.setHeader('max-forwards', ExSIP_C.MAX_FORWARDS);

  // To
  to = (params.to_display_name || params.to_display_name === 0) ? '"' + params.to_display_name + '" ' : '';
  var toUri = (params.to_uri || ruri);
  to += '<' + (ua.configuration.enable_ims && toUri.isPhoneNumber() && toUri.toString().indexOf(';user=phone') === -1 ? toUri +";user=phone" : toUri) + '>';
  to += params.to_tag ? ';tag=' + params.to_tag : '';
  this.to = new NameAddrHeader.parse(to);
  this.setHeader('to', to);


  // From
  var fromName;
  if (params.from_display_name || params.from_display_name === 0) {
    fromName = '"' + params.from_display_name + '" ';
  } else if (ua.configuration.display_name) {
    fromName = '"' + ua.configuration.display_name + '" ';
  } else {
    fromName = '';
  }
  var fromUri = (params.from_uri || ua.configuration.uri);
  fromName += '<' + (ua.configuration.enable_ims && fromUri.isPhoneNumber() && fromUri.toString().indexOf(';user=phone') === -1 ? fromUri +";user=phone" : fromUri) + '>';
  var fromTag = ';tag=' + (params.from_tag || Utils.newTag());
  from = fromName + fromTag;
  this.from = new NameAddrHeader.parse(from);
  this.setHeader('from', from);

  // Call-ID
  call_id = params.call_id || (ua.configuration.exsip_id + Utils.createRandomToken(15));
  this.call_id = call_id;
  this.setHeader('call-id', call_id);

  // CSeq
  cseq = params.cseq || Math.floor(Math.random() * 10000);
  this.cseq = cseq;
  this.setHeader('cseq', cseq + ' ' + method);

  // P-Asserted-Identity
  if(ua.configuration.enable_ims) {
    this.setHeader('P-Asserted-Identity', fromName);
  } else if(ua.configuration.p_asserted_identity) {
    this.setHeader('P-Asserted-Identity', ua.configuration.p_asserted_identity);
  }
}

OutgoingRequest.prototype = {
  /**
   * Replace the the given header by the given value.
   * -param {String} name header name
   * -param {String | Array} value header value
   */
  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  /**
   * Get the value of the given header name at the given position.
   * -param {String} name header name
   * -returns {String|undefined} Returns the specified header, null if header doesn't exist.
   */
  getHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length,
      header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0];
      }
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          return header.substring(header.indexOf(':')+1).trim();
        }
      }
    }

    return;
  },

  /**
   * Get the header/s of the given name.
   * -param {String} name header name
   * -returns {Array} Array with all the headers of the specified name.
   */
  getHeaders: function(name) {
    var idx, length, regexp,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if (header) {
      length = header.length;
      for (idx = 0; idx < length; idx++) {
        result.push(header[idx]);
      }
      return result;
    } else {
      length = this.extraHeaders.length;
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        header = this.extraHeaders[idx];
        if (regexp.test(header)) {
          result.push(header.substring(header.indexOf(':')+1).trim());
        }
      }
      return result;
    }
  },

  /**
   * Verify the existence of the given header.
   * -param {String} name header name
   * -returns {boolean} true if header with given name exists, false otherwise
   */
  hasHeader: function(name) {
    var regexp, idx,
      length = this.extraHeaders.length;

    if (this.headers[Utils.headerize(name)]) {
      return true;
    } else {
      regexp = new RegExp('^\\s*'+ name +'\\s*:','i');
      for (idx=0; idx<length; idx++) {
        if (regexp.test(this.extraHeaders[idx])) {
          return true;
        }
      }
    }

    return false;
  },

  toString: function() {
    var msg = '', header, length, idx,
      supported = [];

    msg += this.method + ' ' + (this.ua.configuration.enable_ims && this.ruri.isPhoneNumber() ? this.ruri + ";user=phone" : this.ruri) + ' SIP/2.0\r\n';

    for (header in this.headers) {
      length = this.headers[header].length;
      for (idx = 0; idx < length; idx++) {
        msg += header + ': ' + this.headers[header][idx] + '\r\n';
      }
    }

    length = this.extraHeaders.length;
    for (idx = 0; idx < length; idx++) {
      msg += this.extraHeaders[idx].trim() +'\r\n';
    }

    // Supported
    switch (this.method) {
      case ExSIP_C.REGISTER:
        supported.push('path', 'gruu');
        break;
      case ExSIP_C.INVITE:
        if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
          supported.push('gruu');
        }
        break;
    }

    supported.push('outbound');

    // Allow
    if(!this.hasHeader('Allow')) {
      msg += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';      
    }

    if(!this.hasHeader('Supported')) {
      msg += 'Supported: ' +  supported +'\r\n';
    }
    
    msg += 'User-Agent: ' + ExSIP_C.USER_AGENT +'\r\n';

    if(this.body) {
      length = Utils.str_utf8_length(this.body);
      msg += 'Content-Length: ' + length + '\r\n\r\n';
      msg += this.body;
    } else {
      msg += 'Content-Length: 0\r\n\r\n';
    }

    return msg;
  }
};


function IncomingMessage(){
  this.data = null;
  this.headers = null;
  this.method =  null;
  this.via = null;
  this.via_branch = null;
  this.call_id = null;
  this.cseq = null;
  this.from = null;
  this.from_tag = null;
  this.to = null;
  this.to_tag = null;
  this.body = null;
}

IncomingMessage.prototype = {
  /**
  * Insert a header of the given name and value into the last position of the
  * header array.
  */
  addHeader: function(name, value) {
    var header = { raw: value };

    name = Utils.headerize(name);

    if(this.headers[name]) {
      this.headers[name].push(header);
    } else {
      this.headers[name] = [header];
    }
  },

  getHeader: function(name) {
    var header = this.headers[Utils.headerize(name)];

    if(header) {
      if(header[0]) {
        return header[0].raw;
      }
    } else {
      return;
    }
  },

  /**
   * Get the header/s of the given name.
   */
  getHeaders: function(name) {
    var idx, length,
      header = this.headers[Utils.headerize(name)],
      result = [];

    if(!header) {
      return [];
    }

    length = header.length;
    for (idx = 0; idx < length; idx++) {
      result.push(header[idx].raw);
    }

    return result;
  },

  /**
   * Verify the existence of the given header.
   */
  hasHeader: function(name) {
    return(this.headers[Utils.headerize(name)]) ? true : false;
  },

  /**
  * Parse the given header on the given index.
  * -param {String} name header name
  * -param {Number} [idx=0] header index
  * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
  */
  parseHeader: function(name, idx) {
    var header, value, parsed;

    name = Utils.headerize(name);

    idx = idx || 0;

    if(!this.headers[name]) {
      this.logger.log('header "' + name + '" not present');
      return;
    } else if(idx >= this.headers[name].length) {
      this.logger.log('not so many "' + name + '" headers present');
      return;
    }

    header = this.headers[name][idx];
    value = header.raw;

    if(header.parsed) {
      return header.parsed;
    }

    //substitute '-' by '_' for grammar rule matching.
    parsed = Grammar.parse(value, name.replace(/-/g, '_'));

    if(parsed === -1) {
      this.headers[name].splice(idx, 1); //delete from headers
      this.logger.warn('error parsing "' + name + '" header field with value "' + value + '"');
      return;
    } else {
      header.parsed = parsed;
      return parsed;
    }
  },

  /**
   * Message Header attribute selector. Alias of parseHeader.
   * -param {String} name header name
   * -param {Number} [idx=0] header index
   * -returns {Object|undefined} Parsed header object, undefined if the header is not present or in case of a parsing error.
   *
   * -example
   * message.s('via',3).port
   */
  s: function(name, idx) {
    return this.parseHeader(name, idx);
  },

  /**
  * Replace the value of the given header by the value.
  * -param {String} name header name
  * -param {String} value header value
  */
  setHeader: function(name, value) {
    var header = { raw: value };
    this.headers[Utils.headerize(name)] = [header];
  }
};

function IncomingRequest(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.ua = ua;
  this.headers = {};
  this.ruri = null;
  this.transport = null;
  this.server_transaction = null;
}

IncomingRequest.prototype = new IncomingMessage();

/**
* Stateful reply.
* -param {Number} code status code
* -param {String} reason reason phrase
* -param {Object} headers extra headers
* -param {String} body body
* -param {Function} [onSuccess] onSuccess callback
* -param {Function} [onFailure] onFailure callback
*/
IncomingRequest.prototype.reply = function(code, reason, extraHeaders, body, onSuccess, onFailure) {
  var rr, vias, length, idx, response,
    supported = [],
    to = this.getHeader('To'),
    r = 0,
    v = 0;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';
  extraHeaders = extraHeaders && extraHeaders.slice() || [];

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  if(this.method === ExSIP_C.INVITE && code > 100 && code <= 200) {
    rr = this.getHeaders('record-route');
    length = rr.length;

    for(r; r < length; r++) {
      response += 'Record-Route: ' + rr[r] + '\r\n';
    }
  }

  vias = this.getHeaders('via');
  length = vias.length;

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';

  length = extraHeaders.length;
  for (idx = 0; idx < length; idx++) {
    response += extraHeaders[idx].trim() +'\r\n';
  }

  // Supported
  switch (this.method) {
    case ExSIP_C.INVITE:
      if (this.ua.contact.pub_gruu || this.ua.contact.temp_gruu) {
        supported.push('gruu');
      }
      break;
  }

  supported.push('outbound');

  // Allow and Accept
  if (this.method === ExSIP_C.OPTIONS) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  } else if (code === 405) {
    response += 'Allow: '+ ExSIP_C.ALLOWED_METHODS +'\r\n';
  } else if (code === 415 ) {
    response += 'Accept: '+ ExSIP_C.ACCEPTED_BODY_TYPES +'\r\n';
  }

  response += 'Supported: ' +  supported +'\r\n';

  if(body) {
    length = Utils.str_utf8_length(body);
    if(!this.hasHeader('Content-Type')) {
      response += 'Content-Type: application/sdp\r\n';      
    }
    response += 'Content-Length: ' + length + '\r\n\r\n';
    response += body;
  } else {
    response += 'Content-Length: ' + 0 + '\r\n\r\n';
  }

  this.server_transaction.receiveResponse(code, response, onSuccess, onFailure);
};

/**
* Stateless reply.
* -param {Number} code status code
* -param {String} reason reason phrase
*/
IncomingRequest.prototype.reply_sl = function(code, reason) {
  var to, response,
    v = 0,
    vias = this.getHeaders('via'),
    length = vias.length;

  code = code || null;
  reason = reason || null;

  // Validate code and reason values
  if (!code || (code < 100 || code > 699)) {
    throw new TypeError('Invalid status_code: '+ code);
  } else if (reason && typeof reason !== 'string' && !(reason instanceof String)) {
    throw new TypeError('Invalid reason_phrase: '+ reason);
  }

  reason = reason || ExSIP_C.REASON_PHRASE[code] || '';

  response = 'SIP/2.0 ' + code + ' ' + reason + '\r\n';

  for(v; v < length; v++) {
    response += 'Via: ' + vias[v] + '\r\n';
  }

  to = this.getHeader('To');

  if(!this.to_tag && code > 100) {
    to += ';tag=' + Utils.newTag();
  } else if(this.to_tag && !this.s('to').hasParam('tag')) {
    to += ';tag=' + this.to_tag;
  }

  response += 'To: ' + to + '\r\n';
  response += 'From: ' + this.getHeader('From') + '\r\n';
  response += 'Call-ID: ' + this.call_id + '\r\n';
  response += 'CSeq: ' + this.cseq + ' ' + this.method + '\r\n';
  response += 'Content-Length: ' + 0 + '\r\n\r\n';

  this.transport.send(response);
};

function IncomingResponse(ua) {
  this.logger = ua.getLogger('ExSIP.sipmessage');
  this.headers = {};
  this.status_code = null;
  this.reason_phrase = null;
}

IncomingResponse.prototype = new IncomingMessage();

},{"./Constants":197,"./Grammar":204,"./NameAddrHeader":208,"./Utils":222}],217:[function(require,module,exports){
var T1 = 500,
  T2 = 4000,
  T4 = 5000;


var Timers = {
  T1: T1,
  T2: T2,
  T4: T4,
  TIMER_B: 64 * T1,
  TIMER_D: 0  * T1,
  TIMER_F: 64 * T1,
  TIMER_H: 64 * T1,
  TIMER_I: 0  * T1,
  TIMER_J: 0  * T1,
  TIMER_K: 0  * T4,
  TIMER_L: 64 * T1,
  TIMER_M: 64 * T1,
  PROVISIONAL_RESPONSE_INTERVAL: 60000  // See RFC 3261 Section 13.3.1.1
};

module.exports = Timers;

},{}],218:[function(require,module,exports){
module.exports = {
  C: null,
  NonInviteClientTransaction: NonInviteClientTransaction,
  InviteClientTransaction: InviteClientTransaction,
  AckClientTransaction: AckClientTransaction,
  NonInviteServerTransaction: NonInviteServerTransaction,
  InviteServerTransaction: InviteServerTransaction,
  checkTransaction: checkTransaction
};


var C = {
  // Transaction states
  STATUS_TRYING:     1,
  STATUS_PROCEEDING: 2,
  STATUS_CALLING:    3,
  STATUS_ACCEPTED:   4,
  STATUS_COMPLETED:  5,
  STATUS_TERMINATED: 6,
  STATUS_CONFIRMED:  7,

  // Transaction types
  NON_INVITE_CLIENT: 'nict',
  NON_INVITE_SERVER: 'nist',
  INVITE_CLIENT: 'ict',
  INVITE_SERVER: 'ist'
};

/**
 * Expose C object.
 */
module.exports.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var EventEmitter = require('./EventEmitter');
var Timers = require('./Timers');


function NonInviteClientTransaction(request_sender, request, transport) {
  var via,
    via_transport,
    events = ['stateChanged'];

  this.type = C.NON_INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  this.initEvents(events);
}


NonInviteClientTransaction.prototype = new EventEmitter();

NonInviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteClientTransaction.prototype.send = function() {
  var tr = this;

  this.stateChanged(C.STATUS_TRYING);
  this.F = setTimeout(function() {tr.timer_F();}, Timers.TIMER_F);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

NonInviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting non-INVITE client transaction ' + this.id);
  clearTimeout(this.F);
  clearTimeout(this.K);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onTransportError();
};

NonInviteClientTransaction.prototype.timer_F = function() {
  this.logger.debug('Timer F expired for non-INVITE client transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
  this.request_sender.onRequestTimeout();
};

NonInviteClientTransaction.prototype.timer_K = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

NonInviteClientTransaction.prototype.receiveResponse = function(response) {
  var
    tr = this,
    status_code = response.status_code;
  if(status_code < 200) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
    }
  } else {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        clearTimeout(this.F);

        if(status_code === 408) {
          this.request_sender.onRequestTimeout();
        } else {
          this.request_sender.receiveResponse(response);
        }

        this.K = setTimeout(function() {tr.timer_K();}, Timers.TIMER_K);
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteClientTransaction(request_sender, request, transport) {
  var via,
    tr = this,
    via_transport,
    events = ['stateChanged'];

  this.type = C.INVITE_CLIENT;
  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.ict', this.id);

  this.logger.log('******************** request_sender : ' + request_sender);
  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);

  this.request_sender.ua.newTransaction(this);

  // TODO: Adding here the cancel() method is a hack that must be fixed.
  // Add the cancel property to the request.
  //Will be called from the request instance, not the transaction itself.
  this.request.cancel = function(reason) {
    tr.cancel_request(tr, reason);
  };

  this.initEvents(events);
}

InviteClientTransaction.prototype = new EventEmitter();

InviteClientTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteClientTransaction.prototype.send = function() {
  var tr = this;
  this.stateChanged(C.STATUS_CALLING);
  this.B = setTimeout(function() {
    tr.timer_B();
  }, Timers.TIMER_B);

  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

InviteClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, deleting INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  clearTimeout(this.D);
  clearTimeout(this.M);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);

  if (this.state !== C.STATUS_ACCEPTED) {
    this.request_sender.onTransportError();
  }
};

// RFC 6026 7.2
InviteClientTransaction.prototype.timer_M = function() {
  this.logger.debug('Timer M expired for INVITE client transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    clearTimeout(this.B);
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
  }
};

// RFC 3261 17.1.1
InviteClientTransaction.prototype.timer_B = function() {
  this.logger.debug('Timer B expired for INVITE client transaction ' + this.id);
  if(this.state === C.STATUS_CALLING) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.request_sender.ua.destroyTransaction(this);
    this.logger.debug('InviteClientTransaction.timer_B : ' + this.request_sender);
    this.request_sender.onRequestTimeout();
  }
};

InviteClientTransaction.prototype.timer_D = function() {
  this.logger.debug('Timer D expired for INVITE client transaction ' + this.id);
  clearTimeout(this.B);
  this.stateChanged(C.STATUS_TERMINATED);
  this.request_sender.ua.destroyTransaction(this);
};

InviteClientTransaction.prototype.sendACK = function(response) {
  var tr = this;

  this.ack = 'ACK ' + this.request.ruri + ' SIP/2.0\r\n';
  this.ack += 'Via: ' + this.request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.ack += 'Route: ' + this.request.headers.Route.toString() + '\r\n';
  }

  this.ack += 'To: ' + response.getHeader('to') + '\r\n';
  this.ack += 'From: ' + this.request.headers.From.toString() + '\r\n';
  this.ack += 'Call-ID: ' + this.request.headers['Call-ID'].toString() + '\r\n';
  this.ack += 'CSeq: ' + this.request.headers.CSeq.toString().split(' ')[0];
  this.ack += ' ACK\r\n';
  this.ack += 'Content-Length: 0\r\n\r\n';

  this.D = setTimeout(function() {tr.timer_D();}, Timers.TIMER_D);

  this.transport.send(this.ack);
};

InviteClientTransaction.prototype.cancel_request = function(tr, reason) {
  var request = tr.request;

  this.cancel = ExSIP_C.CANCEL + ' ' + request.ruri + ' SIP/2.0\r\n';
  this.cancel += 'Via: ' + request.headers.Via.toString() + '\r\n';

  if(this.request.headers.Route) {
    this.cancel += 'Route: ' + request.headers.Route.toString() + '\r\n';
  }

  this.cancel += 'To: ' + request.headers.To.toString() + '\r\n';
  this.cancel += 'From: ' + request.headers.From.toString() + '\r\n';
  this.cancel += 'Call-ID: ' + request.headers['Call-ID'].toString() + '\r\n';
  this.cancel += 'CSeq: ' + request.headers.CSeq.toString().split(' ')[0] +
  ' CANCEL\r\n';

  if(reason) {
    this.cancel += 'Reason: ' + reason + '\r\n';
  }

  this.cancel += 'Content-Length: 0\r\n\r\n';

  // Send only if a provisional response (>100) has been received.
  if(this.state === C.STATUS_PROCEEDING) {
    this.transport.send(this.cancel);
  }
};

InviteClientTransaction.prototype.receiveResponse = function(response) {
  var
  tr = this,
  status_code = response.status_code;

  if(status_code >= 100 && status_code <= 199) {
    this.logger.debug('received 1xx : '+this.state);
    switch(this.state) {
      case C.STATUS_CALLING:
        this.stateChanged(C.STATUS_PROCEEDING);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_PROCEEDING:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_CALLING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.M = setTimeout(function() {
          tr.timer_M();
        }, Timers.TIMER_M);
        this.request_sender.receiveResponse(response);
        break;
      case C.STATUS_ACCEPTED:
        this.request_sender.receiveResponse(response);
        break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
      switch(this.state) {
        case C.STATUS_CALLING:
        case C.STATUS_PROCEEDING:
          this.state = C.STATUS_COMPLETED;
          this.sendACK(response);
          if(status_code === 503) {
            var options = {code: 503, reason: 'Service Unavailable', retryCallback: function(transport){
              transport.ua.once("connected", function(e){
                if(transport === e.data.transport) {
                  tr.send();
                }
              });
            }};
            this.request_sender.ua.onTransportError(this.request_sender.ua.transport, options);
          } else {
            this.request_sender.receiveResponse(response);
          }
          break;
        case C.STATUS_COMPLETED:
          this.sendACK(response);
          break;
      }
    }
};


function AckClientTransaction(request_sender, request, transport) {
  var via,
    via_transport;

  this.transport = transport;
  this.id = 'z9hG4bK' + Math.floor(Math.random() * 10000000);
  this.request_sender = request_sender;
  this.request = request;

  this.logger = request_sender.ua.getLogger('ExSIP.transaction.nict', this.id);

  if (request_sender.ua.configuration.hack_via_tcp) {
    via_transport = 'TCP';
  }
  else if (request_sender.ua.configuration.hack_via_ws) {
    via_transport = 'WS';
  }
  else {
    via_transport = transport.server.scheme;
  }

  via = 'SIP/2.0/' + via_transport;
  via += ' ' + request_sender.ua.configuration.via_host + ';branch=' + this.id;

  this.request.setHeader('via', via);
}

AckClientTransaction.prototype = new EventEmitter();

AckClientTransaction.prototype.send = function() {
  if(!this.transport.send(this.request)) {
    this.onTransportError();
  }
};

AckClientTransaction.prototype.onTransportError = function() {
  this.logger.debug('transport error occurred, for an ACK client transaction ' + this.id);
  this.request_sender.onTransportError();
};


function NonInviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.NON_INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.nist', this.id);

  this.state = C.STATUS_TRYING;

  ua.newTransaction(this);

  this.initEvents(events);
}

NonInviteServerTransaction.prototype = new EventEmitter();

NonInviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

NonInviteServerTransaction.prototype.timer_J = function() {
  this.logger.debug('Timer J expired for non-INVITE server transaction ' + this.id);
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

NonInviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting non-INVITE server transaction ' + this.id);

    clearTimeout(this.J);
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

NonInviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code === 100) {
    /* RFC 4320 4.1
     * 'A SIP element MUST NOT
     * send any provisional response with a
     * Status-Code other than 100 to a non-INVITE request.'
     */
    switch(this.state) {
      case C.STATUS_TRYING:
        this.stateChanged(C.STATUS_PROCEEDING);
        if(!this.transport.send(response))  {
          this.onTransportError();
        }
        break;
      case C.STATUS_PROCEEDING:
        this.last_response = response;
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
    }
  } else if(status_code >= 200 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_TRYING:
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_COMPLETED);
        this.last_response = response;
        if(Timers.TIMER_J === 0) {
            tr.timer_J();
        } else {
          this.J = setTimeout(function() {
            tr.timer_J();
          }, Timers.TIMER_J);
        }
        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else if (onSuccess) {
          onSuccess();
        }
        break;
      case C.STATUS_COMPLETED:
        break;
    }
  }
};


function InviteServerTransaction(request, ua) {
  var events = ['stateChanged'];

  this.type = C.INVITE_SERVER;
  this.id = request.via_branch;
  this.request = request;
  this.transport = request.transport;
  this.ua = ua;
  this.last_response = '';
  request.server_transaction = this;

  this.logger = ua.getLogger('ExSIP.transaction.ist', this.id);

  this.state = C.STATUS_PROCEEDING;

  ua.newTransaction(this);

  this.resendProvisionalTimer = null;

  request.reply(100);

  this.initEvents(events);
}

InviteServerTransaction.prototype = new EventEmitter();

InviteServerTransaction.prototype.stateChanged = function(state) {
  this.state = state;
  this.emit('stateChanged', this);
};

InviteServerTransaction.prototype.timer_H = function() {
  this.logger.debug('Timer H expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_COMPLETED) {
    this.logger.log('transactions', 'ACK for INVITE server transaction was never received, call will be terminated');
  }

  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

InviteServerTransaction.prototype.timer_I = function() {
  this.stateChanged(C.STATUS_TERMINATED);
  this.ua.destroyTransaction(this);
};

// RFC 6026 7.1
InviteServerTransaction.prototype.timer_L = function() {
  this.logger.debug('Timer L expired for INVITE server transaction ' + this.id);

  if(this.state === C.STATUS_ACCEPTED) {
    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.onTransportError = function() {
  if (!this.transportError) {
    this.transportError = true;

    this.logger.debug('transport error occurred, deleting INVITE server transaction ' + this.id);

    if (this.resendProvisionalTimer !== null) {
      clearInterval(this.resendProvisionalTimer);
      this.resendProvisionalTimer = null;
    }

    clearTimeout(this.L);
    clearTimeout(this.H);
    clearTimeout(this.I);

    this.stateChanged(C.STATUS_TERMINATED);
    this.ua.destroyTransaction(this);
  }
};

InviteServerTransaction.prototype.resend_provisional = function() {
  if(!this.transport.send(this.last_response)) {
    this.onTransportError();
  }
};

// INVITE Server Transaction RFC 3261 17.2.1
InviteServerTransaction.prototype.receiveResponse = function(status_code, response, onSuccess, onFailure) {
  var tr = this;

  if(status_code >= 100 && status_code <= 199) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if(!this.transport.send(response)) {
          this.onTransportError();
        }
        this.last_response = response;
        break;
    }
  }

  if(status_code > 100 && status_code <= 199 && this.state === C.STATUS_PROCEEDING) {
    // Trigger the resendProvisionalTimer only for the first non 100 provisional response.
    if(this.resendProvisionalTimer === null) {
      this.resendProvisionalTimer = setInterval(function() {
        tr.resend_provisional();}, Timers.PROVISIONAL_RESPONSE_INTERVAL);
    }
  } else if(status_code >= 200 && status_code <= 299) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        this.stateChanged(C.STATUS_ACCEPTED);
        this.last_response = response;
        this.L = setTimeout(function() {
          tr.timer_L();
        }, Timers.TIMER_L);

        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }
        /* falls through */
        case C.STATUS_ACCEPTED:
          // Note that this point will be reached for proceeding tr.state also.
          if(!this.transport.send(response)) {
            this.onTransportError();
            if (onFailure) {
              onFailure();
            }
          } else if (onSuccess) {
            onSuccess();
          }
          break;
    }
  } else if(status_code >= 300 && status_code <= 699) {
    switch(this.state) {
      case C.STATUS_PROCEEDING:
        if (this.resendProvisionalTimer !== null) {
          clearInterval(this.resendProvisionalTimer);
          this.resendProvisionalTimer = null;
        }

        if(!this.transport.send(response)) {
          this.onTransportError();
          if (onFailure) {
            onFailure();
          }
        } else {
          this.stateChanged(C.STATUS_COMPLETED);
          this.H = setTimeout(function() {
            tr.timer_H();
          }, Timers.TIMER_H);
          if (onSuccess) {
            onSuccess();
          }
        }
        break;
    }
  }
};

/**
 * INVITE:
 *  _true_ if retransmission
 *  _false_ new request
 *
 * ACK:
 *  _true_  ACK to non2xx response
 *  _false_ ACK must be passed to TU (accepted state)
 *          ACK to 2xx response
 *
 * CANCEL:
 *  _true_  no matching invite transaction
 *  _false_ matching invite transaction and no final response sent
 *
 * OTHER:
 *  _true_  retransmission
 *  _false_ new request
 */
function checkTransaction(ua, request) {
  var tr;

  switch(request.method) {
    case ExSIP_C.INVITE:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_PROCEEDING:
            tr.transport.send(tr.last_response);
            break;

            // RFC 6026 7.1 Invite retransmission
            //received while in C.STATUS_ACCEPTED state. Absorb it.
          case C.STATUS_ACCEPTED:
            break;
        }
        console.log("checkTransaction failed for INVITE request and server transaction in state : "+tr.state);
        return true;
      }
      break;
    case ExSIP_C.ACK:
      tr = ua.transactions.ist[request.via_branch];

      // RFC 6026 7.1
      if(tr) {
        if(tr.state === C.STATUS_ACCEPTED) {
          return false;
        } else if(tr.state === C.STATUS_COMPLETED) {
          tr.state = C.STATUS_CONFIRMED;
          tr.I = setTimeout(function() {tr.timer_I();}, Timers.TIMER_I);
          return true;
        }
      }
      // ACK to 2XX Response.
      else {
        return false;
      }
      break;
    case ExSIP_C.CANCEL:
      tr = ua.transactions.ist[request.via_branch];
      if(tr) {
        request.reply_sl(200);
        if(tr.state === C.STATUS_PROCEEDING) {
          return false;
        } else {
          console.log("checkTransaction failed for CANCEL request and server transaction in state : "+tr.state);
          return true;
        }
      } else {
        request.reply_sl(481);
        console.log("checkTransaction failed for CANCEL request and no server transaction");
        return true;
      }
      break;
    default:

      // Non-INVITE Server Transaction RFC 3261 17.2.2
      console.log('***************** nist : ', Object.keys(ua.transactions.nist));
      tr = ua.transactions.nist[request.via_branch];
      if(tr) {
        switch(tr.state) {
          case C.STATUS_TRYING:
            break;
          case C.STATUS_PROCEEDING:
          case C.STATUS_COMPLETED:
            tr.transport.send(tr.last_response);
            break;
        }
        console.log("checkTransaction failed for non invite server transaction in state : "+tr.state);
        return true;
      }
      break;
  }
}

},{"./Constants":197,"./EventEmitter":201,"./Timers":217}],219:[function(require,module,exports){
(function (global){
module.exports = Transport;


var C = {
  // Transport status codes
  STATUS_READY:        0,
  STATUS_DISCONNECTED: 1,
  STATUS_ERROR:        2
};


/**
 * Expose C object.
 */
Transport.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Parser = require('./Parser');
var UA = require('./UA');
var SIPMessage = require('./SIPMessage');
var sanityCheck = require('./sanityCheck');
// Conditional module loading.
var WebSocket;  // jshint ignore:line
var isNode = false;
if (global.WebSocket) {
  WebSocket = global.WebSocket;  // jshint ignore:line
}
else {
  WebSocket = require('ws');  // jshint ignore:line
  isNode = true;
}


function Transport(ua, server) {
  this.logger = ua.getLogger('ExSIP.transport');
  this.ua = ua;
  this.ws = null;
  this.server = server;
  this.reconnection_attempts = 0;
  this.closed = false;
  this.connected = false;
  this.reconnectTimer = null;
  this.lastTransportError = {};

  if (isNode) {
    this.ws_options = this.ua.configuration.node_ws_options;
    this.ws_options.protocol = 'sip';
    this.ws_options.headers = {
      'User-Agent': ExSIP_C.USER_AGENT
    };
  }
}

Transport.prototype = {
  /**
   * Send a message.
   */
  send: function(msg) {
    var message = msg.toString();

    if(this.ws && this.readyState() === WebSocket.OPEN) {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('sending WebSocket message:\n\n' + message + '\n');
      }
      this.ws.send(message);
      return true;
    } else {
      this.logger.warn('unable to send message, WebSocket is not open');
      return false;
    }
  },

  readyState: function() {
    return this.ws.readyState;
  },

  /**
  * Disconnect socket.
  */
  disconnect: function() {
    if(this.ws) {
      // Clear reconnectTimer
      clearTimeout(this.reconnectTimer);
      // TODO: should make this.reconnectTimer = null here?

      this.closed = true;
      this.logger.debug('closing WebSocket ' + this.server.ws_uri);
      this.ws.close();
    }

    // TODO: Why this??
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
      this.ua.emit('disconnected', this.ua, {
        transport: this,
        code: this.lastTransportError.code,
        reason: this.lastTransportError.reason
      });
    }
  },

  /**
  * Connect socket.
  */
  connect: function() {
    var transport = this;

    if(this.ws && (this.readyState() === WebSocket.OPEN || this.readyState() === WebSocket.CONNECTING)) {
      this.logger.log('WebSocket ' + this.server.ws_uri + ' is already connected');
      return false;
    }

    if(this.ws) {
      this.ws.close();
    }

    this.logger.log('connecting to WebSocket ' + this.server.ws_uri);
    this.ua.onTransportConnecting(this,
      (this.reconnection_attempts === 0)?1:this.reconnection_attempts);

    try {
      if (! isNode) {
        this.ws = new WebSocket(this.server.ws_uri, 'sip');
        this.ws.binaryType = 'arraybuffer';
      }
      else {
        this.ws = new WebSocket(this.server.ws_uri, this.ws_options);
      }
      this.ua.usedServers.push(this.server);

      this.ws.onopen = function() {
        transport.onOpen();
      };

      this.ws.onclose = function(e) {
        transport.onClose(e);
      };

      this.ws.onmessage = function(e) {
        transport.onMessage(e);
      };

      this.ws.onerror = function(e) {
        transport.onError(e);
      };
    } catch(e) {
      this.logger.warn('error connecting to WebSocket ' + this.server.ws_uri + ': ' + e);
      this.lastTransportError.code = null;
      this.lastTransportError.reason = e.message;
      this.ua.onTransportError(this);
    }
  },

  // Transport Event Handlers

  onOpen: function() {
    this.connected = true;

    this.logger.debug('WebSocket ' + this.server.ws_uri + ' connected');
    // Clear reconnectTimer since we are not disconnected
    if (this.reconnectTimer !== null) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }
    // Reset reconnection_attempts
    this.reconnection_attempts = 0;
    // Disable closed
    this.closed = false;
    // Trigger onTransportConnected callback
    this.ua.onTransportConnected(this);
  },

  onClose: function(e) {
    var connected_before = this.connected;

    this.connected = false;
    this.lastTransportError.code = e.code;
    this.lastTransportError.reason = e.reason;
    this.logger.debug('WebSocket disconnected (code: ' + e.code + (e.reason? '| reason: ' + e.reason : '') +')');

    if(e.wasClean === false) {
      this.logger.warn('WebSocket abrupt disconnection');
    }
    // Transport was connected
    if(connected_before === true) {
      this.ua.onTransportClosed(this);
      // Check whether the user requested to close.
      if(!this.closed) {
        this.reConnect();
      } else {
        this.ua.emit('disconnected', this.ua, {
          transport: this,
          code: this.lastTransportError.code,
          reason: this.lastTransportError.reason
        });
      }
    } else {
      // This is the first connection attempt
      // May be a network error (or may be UA.stop() was called)
      this.ua.onTransportError(this);
    }
  },

  onMessage: function(e) {
    var message, transaction,
      data = e.data;

    // CRLF Keep Alive response from server. Ignore it.
    if(data === '\r\n') {
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket message with CRLF Keep Alive response');
      }
      return;
    }

    // WebSocket binary message.
    else if (typeof data !== 'string') {
      try {
        data = String.fromCharCode.apply(null, new Uint8Array(data));
      } catch(evt) {
        this.logger.warn('received WebSocket binary message failed to be converted into string, message discarded');
        return;
      }

      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket binary message:\n\n' + data + '\n');
      }
    }

    // WebSocket text message.
    else {
      this.logger.log('onMessage : '+this.ua.configuration.trace_sip);
      if (this.ua.configuration.trace_sip === true) {
        this.logger.debug('received WebSocket text message:\n\n' + data + '\n');
      }
    }

    message = Parser.parseMessage(data, this.ua);

    if (! message) {
      return;
    }

    if(this.ua.status === UA.C.STATUS_USER_CLOSED && message instanceof SIPMessage.IncomingRequest) {
      return;
    }

    // Do some sanity check
    if(! sanityCheck(message, this.ua, this)) {
      return;
    }

    if(message instanceof SIPMessage.IncomingRequest) {
      message.transport = this;
      this.ua.receiveRequest(message);
    } else if(message instanceof SIPMessage.IncomingResponse) {
      /* Unike stated in 18.1.2, if a response does not match
      * any transaction, it is discarded here and no passed to the core
      * in order to be discarded there.
      */
      switch(message.method) {
        case ExSIP_C.INVITE:
          transaction = this.ua.transactions.ict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
        case ExSIP_C.ACK:
          // Just in case ;-)
          break;
        default:
          transaction = this.ua.transactions.nict[message.via_branch];
          if(transaction) {
            transaction.receiveResponse(message);
          }
          break;
      }
    }
  },

  onError: function(e) {
    this.logger.warn('WebSocket connection error: ' + e);
  },

  /**
  * Reconnection attempt logic.
  */
  reConnect: function() {
    var transport = this;

    this.reconnection_attempts += 1;

    if(this.reconnection_attempts > this.ua.configuration.ws_server_max_reconnection) {
      this.logger.warn('maximum reconnection attempts for WebSocket ' + this.server.ws_uri);
      this.ua.onTransportError(this);
    } else {
      this.logger.log('trying to reconnect to WebSocket ' + this.server.ws_uri + ' (reconnection attempt ' + this.reconnection_attempts + ')'+ ' (reconnection timeout '+this.ua.configuration.ws_server_reconnection_timeout+')');

      if(this.ua.configuration.ws_server_reconnection_timeout === 0) {
        transport.connect();
      } else {
        this.reconnectTimer = setTimeout(function() {
          transport.connect();
          transport.reconnectTimer = null;
        }, this.ua.configuration.ws_server_reconnection_timeout * 1000);
      }
    }
  }
};
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Constants":197,"./Parser":209,"./SIPMessage":216,"./UA":220,"./sanityCheck":224,"ws":195}],220:[function(require,module,exports){
module.exports = UA;


var C = {
  // UA status codes
  STATUS_INIT: 0,
  STATUS_READY: 1,
  STATUS_USER_CLOSED: 2,
  STATUS_NOT_READY: 3,

  // UA error codes
  CONFIGURATION_ERROR: 1,
  NETWORK_ERROR: 2
};

/**
 * Expose C object.
 */
UA.C = C;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var LoggerFactory = require('./LoggerFactory');
var EventEmitter = require('./EventEmitter');
var Registrator = require('./Registrator');
var RTCSession = require('./RTCSession');
var Message = require('./Message');
var Transport = require('./Transport');
var Transactions = require('./Transactions');
var Transactions = require('./Transactions');
var Utils = require('./Utils');
var WebRTC = require('./WebRTC');
var Exceptions = require('./Exceptions');
var URI = require('./URI');
var Grammar = require('./Grammar');
var Utils = require('./Utils');



/**
 * The User-Agent class.
 * @class UA
 * @param {Object} configuration Configuration parameters.
 * @throws {Exceptions.ConfigurationError} If a configuration parameter is invalid.
 * @throws {TypeError} If no configuration is given.
 */
function UA(configuration) {
  var events = [
    'connecting',
    'connected',
    'disconnected',
    'newTransaction',
    'transactionDestroyed',
    'registered',
    'unregistered',
    'registrationFailed',
    'newRTCSession',
    'newMessage',
    'onReInvite'
  ];

  this.log = new LoggerFactory();
  this.logger = this.getLogger('ua');
  this.usedServers = [];
  this.rtcMediaHandlerOptions = {};

  this.cache = {
    credentials: {}
  };

  this.configuration = {};
  this.dynConfiguration = {};
  this.dialogs = {};

  //User actions outside any session/dialog (MESSAGE)
  this.applicants = {};

  this.sessions = {};
  this.transport = null;
  this.contact = null;
  this.status = C.STATUS_INIT;
  this.error = null;
  this.transactions = {
    nist: {},
    nict: {},
    ist: {},
    ict: {}
  };

  // Custom UA empty object for high level use
  this.data = {};

  this.transportRecoverAttempts = 0;
  this.transportRecoveryTimer = null;

  Object.defineProperties(this, {
    transactionsCount: {
      get: function() {
        var type,
          transactions = ['nist', 'nict', 'ist', 'ict'],
          count = 0;

        for (type in transactions) {
          count += Object.keys(this.transactions[transactions[type]]).length;
        }

        return count;
      }
    },

    nictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nict).length;
      }
    },

    nistTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.nist).length;
      }
    },

    ictTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ict).length;
      }
    },

    istTransactionsCount: {
      get: function() {
        return Object.keys(this.transactions.ist).length;
      }
    }
  });

  /**
   * Load configuration
   */

  if (configuration === undefined) {
    throw new TypeError('Not enough arguments');
  }

  // Apply log configuration if present
  if (configuration.log) {
    if (configuration.log.hasOwnProperty('builtinEnabled')) {
      this.log.builtinEnabled = configuration.log.builtinEnabled;
    }

    if (configuration.log.hasOwnProperty('level')) {
      this.log.level = configuration.log.level;
    }

    if (configuration.log.hasOwnProperty('connector')) {
      this.log.connector = configuration.log.connector;
    }
  }

  try {
    this.loadConfig(configuration);
    this.initEvents(events);
  } catch (e) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.CONFIGURATION_ERROR;
    throw e;
  }

  // Initialize registrator
  this._registrator = new Registrator(this);
}


UA.prototype = new EventEmitter();

//=================
//  High Level API
//=================
UA.prototype.isDebug = function() {
  return this.configuration.trace_sip === true;
};

/**
 * Registration state.
 * @param {Boolean}
 */
UA.prototype.isRegistered = function() {
  if (this._registrator && this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 * @param {Boolean}
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

UA.prototype.transfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    this.logger.warn("invalid transfer target");
    return;
  }

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending refer to transferee");
    self.sendReferBasic(sessionToTransfer, transferTarget, options);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.attendedTransfer = function(transferTarget, sessionToTransfer, options) {
  var self = this;
  this.logger.log('attended transfer : ' + transferTarget + ' : options : ' + Utils.toString(options));
  transferTarget = Utils.normalizeTarget(transferTarget, this.configuration.hostport_params);
  if (!transferTarget) {
    this.logger.warn('invalid transfer target');
    sessionToTransfer.failed('local', null, ExSIP_C.causes.INVALID_TARGET);
    return;
  }


  var targetSession = self.newSession(options);
  targetSession.rtcMediaHandler.copy(sessionToTransfer.rtcMediaHandler);

  var holdTargetSuccess = function() {
    self.logger.log("transfer : hold target success - sending attended refer");
    self.sendReferAttended(sessionToTransfer, targetSession, transferTarget, options);
  };

  var holdTargetFailed = function() {
    self.logger.log("transfer : hold target failed");
  };

  var sendTargetInviteSuccess = function() {
    self.logger.log("transfer : send invite to target success - putting target on hold");
    targetSession.hold(holdTargetSuccess, holdTargetFailed);
  };

  var sendTargetInviteFailed = function(response) {
    self.logger.log("transfer : send invite to target failed - sending basic refer");
    if (response.status_code === 420) {
      self.sendReferBasic(sessionToTransfer, transferTarget, options);
    }
  };

  var holdFailed = function() {
    self.logger.log("transfer : hold failed");
  };

  var holdSuccess = function() {
    self.logger.log("transfer : hold success - sending invite to target");
    targetSession.sendInviteRequest(transferTarget, {
        extraHeaders: ["Require: replaces"]
      },
      sendTargetInviteSuccess, sendTargetInviteFailed);
  };

  self.logger.log("transfer : holding session to transfer");
  sessionToTransfer.hold(holdSuccess, holdFailed);
};

UA.prototype.sendReferAttended = function(sessionToTransfer, targetSession, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, targetSession, options);
  var referTo = "<" + (transferTarget).toString() +
    "?Replaces=" + targetSession.dialog.id.call_id +
    "%3Bto-tag%3D" + targetSession.dialog.id.remote_tag +
    "%3Bfrom-tag%3D" + targetSession.dialog.id.local_tag + ">";
  options.extraHeaders.push('Refer-To: ' + referTo);
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.processRefer = function(sessionToTransfer, referRequest) {
  var self = this;
  referRequest.reply(202);
  var notifySuccess = function() {
    self.logger.log("Notify successful");
  };
  var notifyFailure = function() {
    self.logger.log("Notify failed");
  };
  sessionToTransfer.sendNotifyRequest({
    sdp: "SIP/2.0 100 Trying"
  }, notifySuccess, notifyFailure);
};

UA.prototype.sendReferBasic = function(sessionToTransfer, transferTarget, options) {
  var referSession = this.getReferSession(sessionToTransfer, options);
  options = this.getReferOptions(sessionToTransfer, sessionToTransfer, options);
  options.extraHeaders.push('Refer-To: <' + transferTarget + '>');
  this.logger.debug('refer options : ' + JSON.stringify(options));
  referSession.sendReferRequest(sessionToTransfer, options);
};

UA.prototype.getReferOptions = function(sessionToTransfer, targetDialogSession, options) {
  options = options || {};
  options.extraHeaders = options.extraHeaders || [];
  if (sessionToTransfer.supports("tdialog")) {
    options.extraHeaders.push('Require: tdialog');
    var localTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.remote_tag : targetDialogSession.dialog.id.local_tag;
    var remoteTag = targetDialogSession.dialog.isUAS() ? targetDialogSession.dialog.id.local_tag : targetDialogSession.dialog.id.remote_tag;
    var targetDialog = targetDialogSession.dialog.id.call_id + ";local-tag=" + localTag + ";remote-tag=" + remoteTag;
    options.extraHeaders.push('Target-Dialog: ' + targetDialog);
  }
  return options;
};

UA.prototype.getReferSession = function(sessionToTransfer, options) {
  if (sessionToTransfer.supports("tdialog")) {
    return this.newSession(options);
  } else {
    this.logger.warn('tdialog not supported - sending refer in same session : ' + sessionToTransfer.id, this);
    return sessionToTransfer;
  }
};

UA.prototype.newSession = function(options) {
  var session = new RTCSession(this);
  session.initRtcMediaHandler(options);
  return session;
};

UA.prototype.getUserMedia = function(options, success, failure, force) {
  if (!force && this.localMedia) {
    return this.localMedia;
  }

  if (this.localMedia) {
    this.logger.log("stopping existing local media stream", this);
    this.localMedia.stop();
  }

  this.logger.log('options : ' + Utils.toString(options), this);
  var self = this;
  var constraints = options.mediaConstraints || {
    audio: true,
    video: true
  };
  WebRTC.getUserMedia(constraints,
    function(stream) {
      self.logger.log('got local media stream', self);
      self.localMedia = stream;
      success(stream);
    },
    function(e) {
      self.logger.error('unable to get user media');
      self.logger.error(e);
      failure(e);
    }
  );
};

/**
 * Gracefully close.
 *
 */
UA.prototype.stop = function() {
  var session, applicant,
    ua = this;

  this.logger.log('user requested closure...');

  // Remove dynamic settings.
  this.dynConfiguration = {};

  if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.warn('UA already closed');
    return;
  }

  // Clear transportRecoveryTimer
  clearTimeout(this.transportRecoveryTimer);

  // Close registrator
  if (this._registrator) {
    this.logger.debug('closing registrator');
    this._registrator.close();
  }

  // If there are session wait a bit so CANCEL/BYE can be sent and their responses received.
  var num_sessions = Object.keys(this.sessions).length;

  // Run  _terminate_ on every Session
  for (session in this.sessions) {
    this.logger.log('closing session ' + session, this);
    this.sessions[session].terminate();
  }

  // Run  _close_ on every applicant
  for (applicant in this.applicants) {
    this.applicants[applicant].close();
  }

  this.status = C.STATUS_USER_CLOSED;
  // If there are no pending non-INVITE client or server transactions and no
  // sessions, then disconnect now. Otherwise wait for 2 seconds.
  if (this.nistTransactionsCount === 0 && this.nictTransactionsCount === 0 && num_sessions === 0) {
    ua.transport.disconnect();
  } else {
    setTimeout(function() {
      ua.transport.disconnect();
    }, 2000);
  }
};

UA.prototype.reconnect = function() {
  this.logger.debug('************** reconnect');
  this.stop();
  this.status = C.STATUS_INIT;
  this.start();
};

/**
 * Connect to the WS server if status = STATUS_INIT.
 * Resume UA after being closed.
 */
UA.prototype.start = function() {
  var server;

  this.logger.debug('user requested startup... : ', this.status);

  if (this.status === C.STATUS_INIT) {
    server = this.getNextWsServer({
      force: true
    });
    this.transport = new Transport(this, server);
    this.transport.connect();
  } else if (this.status === C.STATUS_USER_CLOSED) {
    this.logger.log('resuming');
    this.status = C.STATUS_READY;
    this.transport.connect();
  } else if (this.status === C.STATUS_READY) {
    this.logger.log('UA is in READY status, not resuming');
  } else {
    this.logger.error('Connection is down. Auto-Recovery system is trying to connect');
  }

  // Set dynamic configuration.
  this.dynConfiguration.register = this.configuration.register;
};

/**
 * Register.
 */
UA.prototype.register = function() {
  this.dynConfiguration.register = true;
  this._registrator.register();
};

/**
 * Unregister.
 */
UA.prototype.unregister = function(options) {
  this.dynConfiguration.register = false;
  this._registrator.unregister(options);
};

/**
 * Get the Registrator instance.
 */
UA.prototype.registrator = function() {
  return this._registrator;
};

/**
 * Registration state.
 */
UA.prototype.isRegistered = function() {
  if (this._registrator.registered) {
    return true;
  } else {
    return false;
  }
};

/**
 * Connection state.
 */
UA.prototype.isConnected = function() {
  if (this.transport) {
    return this.transport.connected;
  } else {
    return false;
  }
};

/**
 * Make an outgoing call.
 *
 * -param {String} target
 * -param {Object} views
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.call = function(target, options) {
  var session;

  session = new RTCSession(this);
  session.connect(target, options);
  return session;
};

/**
 * Send a message.
 *
 * -param {String} target
 * -param {String} body
 * -param {Object} [options]
 *
 * -throws {TypeError}
 *
 */
UA.prototype.sendMessage = function(target, body, options) {
  var message;

  message = new Message(this);
  message.send(target, body, options);
};

/**
 * Normalice a string into a valid SIP request URI
 * -param {String} target
 * -returns {URI|undefined}
 */
UA.prototype.normalizeTarget = function(target) {
  return Utils.normalizeTarget(target, this.configuration.hostport_params);
};

UA.prototype.setRtcMediaHandlerOptions = function(rtcMediaHandlerOptions) {
  this.rtcMediaHandlerOptions = rtcMediaHandlerOptions;
};

UA.prototype.rtcConstraints = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.RTCConstraints : false;
};

UA.prototype.reuseLocalMedia = function() {
  return this.rtcMediaHandlerOptions ? this.rtcMediaHandlerOptions.reuseLocalMedia : false;
};

//===============================
//  Private (For internal use)
//===============================

UA.prototype.saveCredentials = function(credentials) {
  this.cache.credentials[credentials.realm] = this.cache.credentials[credentials.realm] || {};
  this.cache.credentials[credentials.realm][credentials.uri] = credentials;
};

UA.prototype.getCredentials = function(request) {
  var realm, credentials;

  realm = request.ruri.host;

  if (this.cache.credentials[realm] && this.cache.credentials[realm][request.ruri]) {
    credentials = this.cache.credentials[realm][request.ruri];
    credentials.method = request.method;
  }

  return credentials;
};

UA.prototype.getLogger = function(category, label) {
  return this.log.getLogger(category, label);
};


//==========================
// Event Handlers
//==========================

/**
 * Transport Close event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportClosed = function(transport) {
  // Run _onTransportError_ callback on every client transaction using _transport_
  var type, idx, length,
    client_transactions = ['nict', 'ict', 'nist', 'ist'];

  transport.server.status = Transport.C.STATUS_DISCONNECTED;
  this.logger.log('connection state set to ' + Transport.C.STATUS_DISCONNECTED, this);

  length = client_transactions.length;
  for (type = 0; type < length; type++) {
    for (idx in this.transactions[client_transactions[type]]) {
      this.transactions[client_transactions[type]][idx].onTransportError();
    }
  }

  // Close sessions if GRUU is not being used
  if (!this.contact.pub_gruu) {
    this.closeSessionsOnTransportError();
  }
};

/**
 * Unrecoverable transport event.
 * Connection reattempt logic has been done and didn't success.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportError = function(transport, options) {
  options = options || {};
  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.logger.log('transport ' + transport.server.ws_uri + ' failed | connection state set to ' + Transport.C.STATUS_ERROR, this);

  // Close sessions.
  //Mark this transport as 'down' and try the next one
  transport.server.status = Transport.C.STATUS_ERROR;

  this.closeSessionsOnTransportError();
  if (!this.error || this.error !== C.NETWORK_ERROR) {
    this.status = C.STATUS_NOT_READY;
    this.error = C.NETWORK_ERROR;
  }
  // Transport Recovery process
  this.recoverTransport(options);

  var data = Utils.merge_options({
    transport: transport,
    code: transport.lastTransportError.code,
    reason: transport.lastTransportError.reason
  }, options);
  this.emit('disconnected', this, data);
};

/**
 * Transport connection event.
 * @private
 * @event
 * @param {Transport} transport.
 */
UA.prototype.onTransportConnected = function(transport) {
  this.transport = transport;

  // Reset transport recovery counter
  this.transportRecoverAttempts = 0;

  transport.server.status = Transport.C.STATUS_READY;
  this.logger.log('connection state set to ' + Transport.C.STATUS_READY, this);

  if (this.status === C.STATUS_USER_CLOSED) {
    return;
  }

  this.status = C.STATUS_READY;
  this.error = null;
  this.emit('connected', this, {
    transport: transport
  });

  if (this.dynConfiguration.register) {
    if (this._registrator) {
      this._registrator.onTransportConnected();
    } else {
      this._registrator = new Registrator(this, transport);
      this.register();
    }
  } else if (!this._registrator) {
    this._registrator = new Registrator(this, transport);
  }
};

/**
 * Transport connecting event
 */
UA.prototype.onTransportConnecting = function(transport, attempts) {
  this.emit('connecting', this, {
    transport: transport,
    attempts: attempts
  });
};


/**
 * new Transaction
 */
UA.prototype.newTransaction = function(transaction) {
  this.transactions[transaction.type][transaction.id] = transaction;
  this.emit('newTransaction', this, {
    transaction: transaction
  });
};


/**
 * Transaction destroyed.
 */
UA.prototype.destroyTransaction = function(transaction) {
  delete this.transactions[transaction.type][transaction.id];
  this.emit('transactionDestroyed', this, {
    transaction: transaction
  });
};


//=========================
// receiveRequest
//=========================

/**
 * Request reception
 * @private
 * @param {IncomingRequest} request.
 */
UA.prototype.receiveRequest = function(request) {
  var dialog, session, message,
    method = request.method;

  // Check that Ruri points to us
  if (request.ruri.user !== this.configuration.uri.user && request.ruri.user !== this.contact.uri.user) {
    this.logger.warn('Request-URI (' + request.ruri.user + ') does not point to us (' + this.configuration.uri.user + ')', this);
    if (request.method !== ExSIP_C.ACK) {
      request.reply_sl(404);
    }
    return;
  }

  // Check request URI scheme
  if (request.ruri.scheme === ExSIP_C.SIPS) {
    request.reply_sl(416);
    return;
  }

  // Check transaction
  if (Transactions.checkTransaction(this, request)) {
    this.logger.warn('Check Transaction failed', this);
    return;
  }

  // Create the server transaction
  if (method === ExSIP_C.INVITE) {
    new Transactions.InviteServerTransaction(request, this);
  } else if (method !== ExSIP_C.ACK && method !== ExSIP_C.CANCEL) {
    new Transactions.NonInviteServerTransaction(request, this);
  }

  /* RFC3261 12.2.2
   * Requests that do not change in any way the state of a dialog may be
   * received within a dialog (for example, an OPTIONS request).
   * They are processed as if they had been received outside the dialog.
   */
  if (method === ExSIP_C.OPTIONS) {
    request.reply(200);
  } else if (method === ExSIP_C.MESSAGE) {
    if (!this.checkEvent('newMessage') || this.listeners('newMessage').length === 0) {
      request.reply(405);
      return;
    }
    message = new Message(this);
    message.init_incoming(request);
  } else if (method === ExSIP_C.INVITE) {
    if (!this.checkEvent('newRTCSession') || this.listeners('newRTCSession').length === 0) {
      request.reply(405);
      return;
    }
  }

  // Initial Request
  if (!request.to_tag) {
    switch (method) {
      case ExSIP_C.INVITE:
        if (WebRTC.isSupported) {
          this.logger.debug('INVITE received', this);
          session = new RTCSession(this);
          session.init_incoming(request);
        } else {
          this.logger.warn('INVITE received but WebRTC is not supported', this);
          request.reply(488);
        }
        break;
      case ExSIP_C.BYE:
        // Out of dialog BYE received
        request.reply(481);
        break;
      case ExSIP_C.CANCEL:
        session = this.findSession(request);
        if (session) {
          session.receiveRequest(request);
        } else {
          this.logger.warn('received CANCEL request for a non existent session', this);
        }
        break;
      case ExSIP_C.ACK:
        /* Absorb it.
         * ACK request without a corresponding Invite Transaction
         * and without To tag.
         */
        break;
      default:
        request.reply(405);
        break;
    }
  }
  // In-dialog request
  else {
    dialog = this.findDialog(request);

    if (dialog) {
      dialog.receiveRequest(request);
    } else if (method === ExSIP_C.NOTIFY) {
      session = this.findSession(request);
      if (session) {
        this.logger.log('received NOTIFY request for session : ' + session.id, this);
        session.receiveRequest(request);
      } else {
        this.logger.warn('received NOTIFY request for a non existent session', this);
        this.logger.log('request : ' + (request.call_id + "-" + request.from_tag + "-" + request.to_tag), this);
        this.logger.log('sessions : ' + Object.keys(this.sessions), this);
        request.reply(481, 'Subscription does not exist');
      }
    }
    /* RFC3261 12.2.2
     * Request with to tag, but no matching dialog found.
     * Exception: ACK for an Invite request for which a dialog has not
     * been created.
     */
    else {
      if (method !== ExSIP_C.ACK) {
        request.reply(481);
      }
    }
  }
};

//=================
// Utils
//=================

/**
 * Get the session to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest} request.
 * @returns {OutgoingSession|IncomingSession|null}
 */
UA.prototype.findSession = function(request) {
  var
    sessionIDa = request.call_id + request.from_tag,
    sessionA = this.sessions[sessionIDa],
    sessionIDb = request.call_id + request.to_tag,
    sessionB = this.sessions[sessionIDb];

  if (sessionA) {
    return sessionA;
  } else if (sessionB) {
    return sessionB;
  } else {
    return null;
  }
};

/**
 * Get the dialog to which the request belongs to, if any.
 * @private
 * @param {IncomingRequest}
 * @returns {Dialog|null}
 */
UA.prototype.findDialog = function(request) {
  var
    id = request.call_id + request.from_tag + request.to_tag,
    dialog = this.dialogs[id];

  if (dialog) {
    return dialog;
  } else {
    id = request.call_id + request.to_tag + request.from_tag;
    dialog = this.dialogs[id];
    if (dialog) {
      return dialog;
    } else {
      return null;
    }
  }
};

/**
 * Retrieve the next server to which connect.
 * @private
 * @returns {Object} ws_server
 */
UA.prototype.getNextWsServer = function(options) {
  options = options || {};

  // reset if all servers have been used
  if (options.force && this.usedServers.length >= this.configuration.ws_servers.length) {
    this.usedServers = [];
  }

  var candidates = [];
  var totalWeight = 0;
  // Add only server with status ready and not already used
  for (var i = 0; i < this.configuration.ws_servers.length; i++) {
    var server = this.configuration.ws_servers[i];
    if (server.status === Transport.C.STATUS_READY && this.usedServers.indexOf(server) === -1) {
      candidates.push(server);
      totalWeight += (server.weight || 1);
    }
  }

  var weightedServers = []; //new array to hold "weighted" servers
  for (var j = 0; j < candidates.length; j++) {
    var candidate = candidates[j];
    for (var k = 0; k < (candidate.weight || 1); k++) {
      weightedServers.push(candidate);
    }
  }

  var randomNumber = Math.floor(Math.random() * totalWeight);
  var index = Math.min(randomNumber, weightedServers.length - 1);
  return weightedServers[index];
};

/**
 * Close all sessions on transport error.
 */
UA.prototype.closeSessionsOnTransportError = function() {
  var idx;

  // Run _transportError_ for every Session
  for (idx in this.sessions) {
    this.sessions[idx].onTransportError();
  }
  // Call registrator _onTransportClosed_
  this._registrator.onTransportClosed();
};

UA.prototype.loadConfig = function(configuration) {
  // Settings and default values
  var parameter, value, checked_value, hostport_params, registrar_server,
    settings = {
      /* Host address
       * Value to be set in Via sent_by and host part of Contact FQDN
       */
      via_host: Utils.createRandomToken(12) + '.invalid',

      // Password
      password: null,

      // Registration parameters
      register_expires: 600,
      register: true,
      registrar_server: null,

      // Transport related parameters
      ws_server_max_reconnection: 3,
      ws_server_reconnection_timeout: 4,

      connection_recovery_min_interval: 2,
      connection_recovery_max_interval: 30,

      use_preloaded_route: false,

      // Session parameters
      no_answer_timeout: 60,
      stun_servers: ['stun:stun.l.google.com:19302'],
      turn_servers: [],

      // Logging parameters
      trace_sip: false,

      // Hacks
      hack_via_tcp: false,
      hack_via_ws: false,
      hack_ip_in_contact: false,
      enable_datachannel: false,
      enable_ims: false,
      p_asserted_identity: null,

      // Options for Node.
      node_ws_options: {}
    };

  // Pre-Configuration

  // Check Mandatory parameters
  for (parameter in UA.configuration_check.mandatory) {
    if (!configuration.hasOwnProperty(parameter)) {
      throw new Exceptions.ConfigurationError(parameter);
    } else {
      value = configuration[parameter];
      checked_value = UA.configuration_check.mandatory[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Check Optional parameters
  for (parameter in UA.configuration_check.optional) {
    if (configuration.hasOwnProperty(parameter)) {
      value = configuration[parameter];

      /* If the parameter value is null, empty string, undefined, empty array
       * or it's a number with NaN value, then apply its default value.
       */
      if (Utils.isEmpty(value)) {
        continue;
      }

      checked_value = UA.configuration_check.optional[parameter].call(this, value);
      if (checked_value !== undefined) {
        settings[parameter] = checked_value;
      } else {
        throw new Exceptions.ConfigurationError(parameter, value);
      }
    }
  }

  // Sanity Checks

  // Connection recovery intervals
  if (settings.connection_recovery_max_interval < settings.connection_recovery_min_interval) {
    throw new Exceptions.ConfigurationError('connection_recovery_max_interval', settings.connection_recovery_max_interval);
  }

  // Post Configuration Process

  // Allow passing 0 number as display_name.
  if (settings.display_name === 0) {
    settings.display_name = '0';
  }

  // Instance-id for GRUU
  if (!settings.instance_id) {
    settings.instance_id = Utils.newUUID();
  }

  // ExSIP_id instance parameter. Static random tag of length 5
  settings.exsip_id = Utils.createRandomToken(5);

  // String containing settings.uri without scheme and user.
  hostport_params = settings.uri.clone();
  hostport_params.user = null;
  settings.hostport_params = hostport_params.toString().replace(/^sip:/i, '');

  /* Check whether authorization_user is explicitly defined.
   * Take 'settings.uri.user' value if not.
   */
  if (!settings.authorization_user) {
    settings.authorization_user = settings.uri.user;
  }

  /* If no 'registrar_server' is set use the 'uri' value without user portion. */
  if (!settings.registrar_server) {
    registrar_server = settings.uri.clone();
    registrar_server.user = null;
    settings.registrar_server = registrar_server;
  }

  // User no_answer_timeout
  settings.no_answer_timeout = settings.no_answer_timeout * 1000;

  // Via Host
  if (settings.hack_ip_in_contact) {
    settings.via_host = Utils.getRandomTestNetIP();
  }

  // Set empty Stun Server Set if explicitly passed an empty Array
  value = configuration.stun_servers;
  if (value instanceof Array && value.length === 0) {
    settings.stun_servers = [];
  }

  this.contact = {
    pub_gruu: null,
    temp_gruu: null,
    uri: new URI('sip', Utils.createRandomToken(8), settings.via_host, null, {
      transport: 'ws'
    }),
    toString: function(options) {
      options = options || {};

      var
        anonymous = options.anonymous || null,
        outbound = options.outbound || null,
        contact = '<';

      if (anonymous) {
        contact += this.temp_gruu || 'sip:anonymous@anonymous.invalid;transport=ws';
      } else {
        contact += this.pub_gruu || this.uri.toString();
      }

      if (outbound && (anonymous ? !this.temp_gruu : !this.pub_gruu)) {
        contact += ';ob';
      }

      contact += '>';

      return contact;
    }
  };

  // Fill the value of the configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = settings[parameter];
  }

  Object.defineProperties(this.configuration, UA.configuration_skeleton);

  // Clean UA.configuration_skeleton
  for (parameter in settings) {
    UA.configuration_skeleton[parameter].value = '';
  }

  this.logger.debug('configuration parameters after validation:');
  for (parameter in settings) {
    switch (parameter) {
      case 'uri':
      case 'registrar_server':
        this.logger.debug('· ' + parameter + ': ' + settings[parameter]);
        break;
      case 'password':
        this.logger.debug('· ' + parameter + ': ' + 'NOT SHOWN');
        break;
      default:
        this.logger.debug('· ' + parameter + ': ' + JSON.stringify(settings[parameter]));
    }
  }

  return;
};

UA.prototype.retry = function(nextRetry, server, callback) {
  var self = this;
  var retryCallback = function() {
    var transport = new Transport(self, server);
    if (callback) {
      callback(transport);
    }
  };

  if (nextRetry === 0) {
    retryCallback();
  } else {
    setTimeout(retryCallback, nextRetry * 1000);
  }
};

UA.prototype.recoverTransport = function(options) {
  var idx, length, k, nextRetry, count, server;

  options = options || {};
  count = this.transportRecoverAttempts;

  length = this.configuration.ws_servers.length;
  for (idx = 0; idx < length; idx++) {
    this.configuration.ws_servers[idx].status = Transport.C.STATUS_READY;
  }

  server = this.getNextWsServer();
  if (options.code === 503 && !server) {
    delete options.retryAfter;
    this.logger.log('non-failover on 503 error - skipping recoverTransport', this);
    return;
  }

  var maxTransportRecoveryAttempts = this.configuration.max_transport_recovery_attempts;
  if (typeof(maxTransportRecoveryAttempts) !== "undefined" && count >= parseInt(maxTransportRecoveryAttempts, 10)) {
    delete options.retryAfter;
    this.logger.log('recover attempts ' + count + " exceed max transport recovery attempts " + maxTransportRecoveryAttempts + " - skipping recoverTransport");
    return;
  }

  if (server) {
    this.logger.log('failover - new connection attempt with ' + server.ws_uri);
    this.retry(0, server, options.retryCallback);
    return;
  }

  if (options.retryAfter) {
    nextRetry = options.retryAfter;
  } else {
    k = Math.floor((Math.random() * Math.pow(2, count)) + 1);
    nextRetry = k * this.configuration.connection_recovery_min_interval;

    if (nextRetry > this.configuration.connection_recovery_max_interval) {
      this.logger.log('time for next connection attempt exceeds connection_recovery_max_interval, resetting counter', this);
      nextRetry = this.configuration.connection_recovery_min_interval;
      count = 0;
    }
  }

  server = this.getNextWsServer({
    force: true
  });
  this.transportRecoverAttempts = count + 1;
  this.logger.log('resetting ws server list - next connection attempt in ' + nextRetry + ' seconds to ' + server.ws_uri + ' : ' + this.transportRecoverAttempts);
  this.retry(nextRetry, server, options.retryCallback);
};

/**
 * Configuration Object skeleton.
 */
/**
 * Configuration Object skeleton.
 */
UA.configuration_skeleton = (function() {
  var idx, parameter,
    skeleton = {},
    parameters = [
      // Internal parameters
      "exsip_id",
      "ws_server_max_reconnection",
      "ws_server_reconnection_timeout",
      "hostport_params",

      // Mandatory user configurable parameters
      "uri",
      "ws_servers",

      // Optional user configurable parameters
      "authorization_user",
      "connection_recovery_max_interval",
      "connection_recovery_min_interval",
      "max_transport_recovery_attempts",
      "display_name",
      "hack_via_tcp", // false
      "hack_via_ws", // false
      "hack_ip_in_contact", //false
      "instance_id",
      "no_answer_timeout", // 30 seconds
      "node_ws_options",
      "password",
      "register_expires", // 600 seconds
      "registrar_server",
      "stun_servers",
      "trace_sip",
      "turn_servers",
      "use_preloaded_route",
      "enable_datachannel",
      "enable_ims",
      "p_asserted_identity",

      // Post-configuration generated parameters
      "via_core_value",
      "via_host"
    ];

  for (idx in parameters) {
    parameter = parameters[idx];
    skeleton[parameter] = {
      value: '',
      writable: false,
      configurable: false
    };
  }

  skeleton.register = {
    value: '',
    writable: true,
    configurable: false
  };

  return skeleton;
}());

/**
 * Configuration checker.
 */
UA.configuration_check = {
  mandatory: {

    uri: function(uri) {
      var parsed;

      if (!/^sip:/i.test(uri)) {
        uri = ExSIP_C.SIP + ':' + uri;
      }
      parsed = URI.parse(uri);

      if (!parsed) {
        return;
      } else if (!parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    ws_servers: function(ws_servers) {
      var idx, length, url;

      /* Allow defining ws_servers parameter as:
       *  String: "host"
       *  Array of Strings: ["host1", "host2"]
       *  Array of Objects: [{ws_uri:"host1", weight:1}, {ws_uri:"host2", weight:0}]
       *  Array of Objects and Strings: [{ws_uri:"host1"}, "host2"]
       */
      if (typeof ws_servers === 'string') {
        ws_servers = [{
          ws_uri: ws_servers
        }];
      } else if (ws_servers instanceof Array) {
        length = ws_servers.length;
        for (idx = 0; idx < length; idx++) {
          if (typeof ws_servers[idx] === 'string') {
            ws_servers[idx] = {
              ws_uri: ws_servers[idx]
            };
          }
        }
      } else {
        return;
      }

      if (ws_servers.length === 0) {
        return false;
      }

      length = ws_servers.length;
      for (idx = 0; idx < length; idx++) {
        if (!ws_servers[idx].ws_uri) {
          this.logger.error('missing "ws_uri" attribute in ws_servers parameter');
          return;
        }
        if (ws_servers[idx].weight && !Number(ws_servers[idx].weight)) {
          this.logger.error('"weight" attribute in ws_servers parameter must be a Number');
          return;
        }

        url = Grammar.parse(ws_servers[idx].ws_uri, 'absoluteURI');

        if (url === -1) {
          this.logger.error('invalid "ws_uri" attribute in ws_servers parameter: ' + ws_servers[idx].ws_uri);
          return;
        } else if (url.scheme !== 'wss' && url.scheme !== 'ws') {
          this.logger.error('invalid URI scheme in ws_servers parameter: ' + url.scheme);
          return;
        } else {
          ws_servers[idx].sip_uri = '<sip:' + url.host + (url.port ? ':' + url.port : '') + ';transport=ws;lr>';

          if (!ws_servers[idx].weight) {
            ws_servers[idx].weight = 0;
          }

          ws_servers[idx].status = 0;
          ws_servers[idx].scheme = url.scheme.toUpperCase();
        }
      }
      return ws_servers;
    }
  },

  optional: {

    authorization_user: function(authorization_user) {
      if (Grammar.parse('"' + authorization_user + '"', 'quoted_string') === -1) {
        return;
      } else {
        return authorization_user;
      }
    },

    connection_recovery_max_interval: function(connection_recovery_max_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_max_interval)) {
        value = Number(connection_recovery_max_interval);
        if (value > 0) {
          return value;
        }
      }
    },

    connection_recovery_min_interval: function(connection_recovery_min_interval) {
      var value;
      if (Utils.isDecimal(connection_recovery_min_interval)) {
        value = Number(connection_recovery_min_interval);
        if (value >= 0) {
          return value;
        }
      }
    },

    display_name: function(display_name) {
      if (Grammar.parse('"' + display_name + '"', 'display_name') === -1) {
        return;
      } else {
        return display_name;
      }
    },

    hack_via_tcp: function(hack_via_tcp) {
      if (typeof hack_via_tcp === 'boolean') {
        return hack_via_tcp;
      }
    },

    hack_via_ws: function(hack_via_ws) {
      if (typeof hack_via_ws === 'boolean') {
        return hack_via_ws;
      }
    },

    hack_ip_in_contact: function(hack_ip_in_contact) {
      if (typeof hack_ip_in_contact === 'boolean') {
        return hack_ip_in_contact;
      }
    },

    enable_ims: function(enable_ims) {
      if (typeof enable_ims === 'boolean') {
        return enable_ims;
      }
    },

    ws_server_reconnection_timeout: function(ws_server_reconnection_timeout) {
      var value;
      if (Utils.isDecimal(ws_server_reconnection_timeout)) {
        value = Number(ws_server_reconnection_timeout);
        if (value >= 0) {
          return value;
        }
      }
    },

    max_transport_recovery_attempts: function(max_transport_recovery_attempts) {
      var value;
      if (Utils.isDecimal(max_transport_recovery_attempts)) {
        value = Number(max_transport_recovery_attempts);
        if (value >= 0) {
          return value;
        }
      }
    },

    p_asserted_identity: function(p_asserted_identity) {
      return String(p_asserted_identity);
    },

    enable_datachannel: function(enable_datachannel) {
      if (typeof enable_datachannel === 'boolean') {
        return enable_datachannel;
      }
    },

    instance_id: function(instance_id) {
      if ((/^uuid:/i.test(instance_id))) {
        instance_id = instance_id.substr(5);
      }

      if (Grammar.parse(instance_id, 'uuid') === -1) {
        return;
      } else {
        return instance_id;
      }
    },

    no_answer_timeout: function(no_answer_timeout) {
      var value;
      if (Utils.isDecimal(no_answer_timeout)) {
        value = Number(no_answer_timeout);
        if (value > 0) {
          return value;
        }
      }
    },

    node_ws_options: function(node_ws_options) {
      return (typeof node_ws_options === 'object') ? node_ws_options : {};
    },

    password: function(password) {
      return String(password);
    },

    register: function(register) {
      if (typeof register === 'boolean') {
        return register;
      }
    },

    register_expires: function(register_expires) {
      var value;
      if (Utils.isDecimal(register_expires)) {
        value = Number(register_expires);
        if (value > 0) {
          return value;
        }
      }
    },

    registrar_server: function(registrar_server) {
      var parsed;

      if (!/^sip:/i.test(registrar_server)) {
        registrar_server = ExSIP_C.SIP + ':' + registrar_server;
      }
      parsed = URI.parse(registrar_server);

      if (!parsed) {
        return;
      } else if (parsed.user) {
        return;
      } else {
        return parsed;
      }
    },

    stun_servers: function(stun_servers) {
      var idx, length, stun_server;

      if (typeof stun_servers === 'string') {
        stun_servers = [stun_servers];
      } else if (!(stun_servers instanceof Array)) {
        return;
      }

      length = stun_servers.length;
      for (idx = 0; idx < length; idx++) {
        stun_server = stun_servers[idx];
        if (!(/^stuns?:/.test(stun_server))) {
          stun_server = 'stun:' + stun_server;
        }

        if (Grammar.parse(stun_server, 'stun_URI') === -1) {
          return;
        } else {
          stun_servers[idx] = stun_server;
        }
      }
      return stun_servers;
    },

    trace_sip: function(trace_sip) {
      if (typeof trace_sip === 'boolean') {
        return trace_sip;
      }
    },

    turn_servers: function(turn_servers) {
      var idx, idx2, length, length2, turn_server, url;

      if (!turn_servers instanceof Array) {
        turn_servers = [turn_servers];
      }

      length = turn_servers.length;
      for (idx = 0; idx < length; idx++) {
        turn_server = turn_servers[idx];

        // Backward compatibility:
        //Allow defining the turn_server 'urls' with the 'server' property.
        if (turn_server.server) {
          turn_server.urls = [turn_server.server];
        }

        // Backward compatibility:
        //Allow defining the turn_server 'credential' with the 'password' property.
        if (turn_server.password) {
          turn_server.credential = [turn_server.password];
        }

        if (!turn_server.urls || !turn_server.username || !turn_server.credential) {
          return;
        }

        if (!(turn_server.urls instanceof Array)) {
          turn_server.urls = [turn_server.urls];
        }

        length2 = turn_server.urls.length;
        for (idx2 = 0; idx2 < length2; idx2++) {
          url = turn_server.urls[idx2];

          if (!(/^turns?:/.test(url))) {
            url = 'turn:' + url;
          }

          if (Grammar.parse(url, 'turn_URI') === -1) {
            return;
          }
        }
      }
      return turn_servers;
    },

    use_preloaded_route: function(use_preloaded_route) {
      if (typeof use_preloaded_route === 'boolean') {
        return use_preloaded_route;
      }
    }
  }
};
},{"./Constants":197,"./EventEmitter":201,"./Exceptions":203,"./Grammar":204,"./LoggerFactory":206,"./Message":207,"./RTCSession":210,"./Registrator":214,"./Transactions":218,"./Transport":219,"./URI":221,"./Utils":222,"./WebRTC":223}],221:[function(require,module,exports){
module.exports = URI;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var Utils = require('./Utils');
var Grammar = require('./Grammar');


/**
 * -param {String} [scheme]
 * -param {String} [user]
 * -param {String} host
 * -param {String} [port]
 * -param {Object} [parameters]
 * -param {Object} [headers]
 *
 */
function URI(scheme, user, host, port, parameters, headers) {
  var param, header;

  // Checks
  if(!host) {
    throw new TypeError('missing or invalid "host" parameter');
  }

  // Initialize parameters
  scheme = scheme || ExSIP_C.SIP;
  this.parameters = {};
  this.headers = {};

  for (param in parameters) {
    this.setParam(param, parameters[param]);
  }

  for (header in headers) {
    this.setHeader(header, headers[header]);
  }

  Object.defineProperties(this, {
    scheme: {
      get: function(){ return scheme; },
      set: function(value){
        scheme = value.toLowerCase();
      }
    },

    user: {
      get: function(){ return user; },
      set: function(value){
        user = value;
      }
    },

    host: {
      get: function(){ return host; },
      set: function(value){
        host = value.toLowerCase();
      }
    },

    port: {
      get: function(){ return port; },
      set: function(value){
        port = value === 0 ? value : (parseInt(value,10) || null);
      }
    }
  });
}


URI.prototype = {
  setParam: function(key, value) {
    if(key) {
      this.parameters[key.toLowerCase()] = (typeof value === 'undefined' || value === null) ? null : value.toString().toLowerCase();
    }
  },

  getParam: function(key) {
    if(key) {
      return this.parameters[key.toLowerCase()];
    }
  },

  hasParam: function(key) {
    if(key) {
      return (this.parameters.hasOwnProperty(key.toLowerCase()) && true) || false;
    }
  },

  deleteParam: function(parameter) {
    var value;
    parameter = parameter.toLowerCase();
    if (this.parameters.hasOwnProperty(parameter)) {
      value = this.parameters[parameter];
      delete this.parameters[parameter];
      return value;
    }
  },

  clearParams: function() {
    this.parameters = {};
  },

  setHeader: function(name, value) {
    this.headers[Utils.headerize(name)] = (value instanceof Array) ? value : [value];
  },

  getHeader: function(name) {
    if(name) {
      return this.headers[Utils.headerize(name)];
    }
  },

  hasHeader: function(name) {
    if(name) {
      return (this.headers.hasOwnProperty(Utils.headerize(name)) && true) || false;
    }
  },

  deleteHeader: function(header) {
    var value;
    header = Utils.headerize(header);
    if(this.headers.hasOwnProperty(header)) {
      value = this.headers[header];
      delete this.headers[header];
      return value;
    }
  },

  clearHeaders: function() {
    this.headers = {};
  },

  isPhoneNumber: function() {
    return this.user && this.user.match(/^\+?\d+$/) !== null;
  },

  clone: function() {
    return new URI(
      this.scheme,
      this.user,
      this.host,
      this.port,
      JSON.parse(JSON.stringify(this.parameters)),
      JSON.parse(JSON.stringify(this.headers)));
  },

  toString: function(){
    var header, parameter, idx, uri,
      headers = [];

    uri  = this.scheme + ':';
    if (this.user) {
      uri += Utils.escapeUser(this.user) + '@';
    }
    uri += this.host;
    if (this.port || this.port === 0) {
      uri += ':' + this.port;
    }

    for (parameter in this.parameters) {
      uri += ';' + parameter;

      if (this.parameters[parameter] !== null) {
        uri += '='+ this.parameters[parameter];
      }
    }

    for(header in this.headers) {
      for(idx in this.headers[header]) {
        headers.push(header + '=' + this.headers[header][idx]);
      }
    }

    if (headers.length > 0) {
      uri += '?' + headers.join('&');
    }

    return uri;
  },

  toAor: function(show_port){
      var aor;

      aor  = this.scheme + ':';
      if (this.user) {
        aor += Utils.escapeUser(this.user) + '@';
      }
      aor += this.host;
      if (show_port && (this.port || this.port === 0)) {
        aor += ':' + this.port;
      }

      return aor;
  }
};


/**
  * Parse the given string and returns a ExSIP.URI instance or undefined if
  * it is an invalid URI.
  */
URI.parse = function(uri) {
  uri = Grammar.parse(uri,'SIP_URI');

  if (uri !== -1) {
    return uri;
  } else {
    return undefined;
  }
};
},{"./Constants":197,"./Grammar":204,"./Utils":222}],222:[function(require,module,exports){
var Utils = {};

module.exports = Utils;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var URI = require('./URI');
var Grammar = require('./Grammar');

Utils.inArray = function(array, el) {
  for (var i = array.length; i--;) {
    if (array[i] === el) {
      return true;
    }
  }
  return false;
};

Utils.isEqArrays = function(arr1, arr2) {
  if (arr1 === null && arr2 !== null) {
    return false;
  }
  if (arr1 !== null && arr2 === null) {
    return false;
  }
  if (arr1 === null && arr2 === null) {
    return true;
  }
  if (arr1.length !== arr2.length) {
    return false;
  }
  for (var i = arr1.length; i--;) {
    if (!this.inArray(arr2, arr1[i])) {
      return false;
    }
  }
  return true;
};

/**
 * Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1
 * @param obj1
 * @param obj2
 * @returns obj3 a new object based on obj1 and obj2
 */
Utils.merge_options = function(obj1, obj2) {
  var obj3 = {};
  for (var attrname1 in obj1) {
    obj3[attrname1] = obj1[attrname1];
  }
  for (var attrname2 in obj2) {
    obj3[attrname2] = obj2[attrname2];
  }
  return obj3;
};

Utils.containsHeader = function(headers, name) {
  for (var i = 0; i < headers.length; i++) {
    if (headers[i].indexOf(name) !== -1) {
      return true;
    }
  }
  return false;
};

Utils.str_utf8_length = function(string) {
  return unescape(encodeURIComponent(string)).length;
};

Utils.toString = function(object) {
  var seen = [];

  return JSON.stringify(object, function(key, val) {
    if (typeof val === "object") {
      if (seen.indexOf(val) >= 0) {
        return;
      }
      seen.push(val);
    }
    return val;
  });
};

Utils.isFunction = function(fn) {
  if (fn !== undefined) {
    return (Object.prototype.toString.call(fn) === '[object Function]') ? true : false;
  } else {
    return false;
  }
};

Utils.isDecimal = function(num) {
  return !isNaN(num) && (parseFloat(num) === parseInt(num, 10));
};

Utils.getHeadersFromQuery = function(query) {
  var headers = [];
  var queryParts = query.split("&");
  for (var i = 0; i < queryParts.length; i++) {
    var parameters = queryParts[i].split("=");
    headers.push(parameters[0] + ": " + decodeURIComponent(parameters[1]));
  }
  return headers;
};

Utils.stripSip = function(address) {
  var match = address.match(/<sip\:(.*)\>/);
  return match ? match[1] : address;
};

Utils.isEmpty = function(value) {
  if (value === null || value === "" || value === undefined || (value instanceof Array && value.length === 0) || (typeof(value) === 'number' && isNaN(value))) {
    return true;
  }
};

Utils.getAllowedMethods = function(ua) {
  var event,
    allowed = ExSIP_C.ALLOWED_METHODS.toString();

  for (event in ExSIP_C.EVENT_METHODS) {
    if (ua.checkEvent(event) && ua.listeners(event).length > 0) {
      allowed += ',' + ExSIP_C.EVENT_METHODS[event];
    }
  }

  return allowed;
};

Utils.createRandomToken = function(size, base) {
  var i, r,
    token = '';

  base = base || 32;

  for (i = 0; i < size; i++) {
    r = Math.random() * base | 0;
    token += r.toString(base);
  }
  return token;
};

Utils.newTag = function() {
  return Utils.createRandomToken(10);
};

// http://stackoverflow.com/users/109538/broofa
Utils.newUUID = function() {
  var UUID = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0,
      v = c === 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });

  return UUID;
};

Utils.hostType = function(host) {
  if (!host) {
    return;
  } else {
    host = Grammar.parse(host, 'host');
    if (host !== -1) {
      return host.host_type;
    }
  }
};

/**
 * Normalize SIP URI.
 * NOTE: It does not allow a SIP URI without username.
 * Accepts 'sip', 'sips' and 'tel' URIs and convert them into 'sip'.
 * Detects the domain part (if given) and properly hex-escapes the user portion.
 * If the user portion has only 'tel' number symbols the user portion is clean of 'tel' visual separators.
 */
Utils.normalizeTarget = function(target, domain) {
  var uri, target_array, target_user, target_domain;

  // If no target is given then raise an error.
  if (!target) {
    return;
    // If a URI instance is given then return it.
  } else if (target instanceof URI) {
    return target;

    // If a string is given split it by '@':
    // - Last fragment is the desired domain.
    // - Otherwise append the given domain argument.
  } else if (typeof target === 'string') {
    target_array = target.split('@');

    switch (target_array.length) {
      case 1:
        if (!domain) {
          return;
        }
        target_user = target;
        target_domain = domain;
        break;
      case 2:
        target_user = target_array[0];
        target_domain = target_array[1];
        break;
      default:
        target_user = target_array.slice(0, target_array.length - 1).join('@');
        target_domain = target_array[target_array.length - 1];
    }

    // Remove the URI scheme (if present).
    target_user = target_user.replace(/^(sips?|tel):/i, '');

    // Remove 'tel' visual separators if the user portion just contains 'tel' number symbols.
    if (/^[\-\.\(\)]*\+?[0-9\-\.\(\)]+$/.test(target_user)) {
      target_user = target_user.replace(/[\-\.\(\)]/g, '');
    }

    // Build the complete SIP URI.
    target = ExSIP_C.SIP + ':' + Utils.escapeUser(target_user) + '@' + target_domain;

    // Finally parse the resulting URI.
    if ((uri = URI.parse(target))) {
      return uri;
    } else {
      return;
    }
  } else {
    return;
  }
};

/**
 * Hex-escape a SIP URI user.
 */
Utils.escapeUser = function(user) {
  // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F"), '/' (%2F).
  return encodeURIComponent(decodeURIComponent(user)).replace(/%3A/ig, ':').replace(/%2B/ig, '+').replace(/%3F/ig, '?').replace(/%2F/ig, '/');
};

Utils.headerize = function(string) {
  var exceptions = {
      'Call-Id': 'Call-ID',
      'Cseq': 'CSeq',
      'Www-Authenticate': 'WWW-Authenticate'
    },
    name = string.toLowerCase().replace(/_/g, '-').split('-'),
    hname = '',
    parts = name.length,
    part;

  for (part = 0; part < parts; part++) {
    if (part !== 0) {
      hname += '-';
    }
    hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);
  }
  if (exceptions[hname]) {
    hname = exceptions[hname];
  }
  return hname;
};

Utils.sipErrorCause = function(status_code) {
  var cause;

  for (cause in ExSIP_C.SIP_ERROR_CAUSES) {
    if (ExSIP_C.SIP_ERROR_CAUSES[cause].indexOf(status_code) !== -1) {
      return ExSIP_C.causes[cause];
    }
  }

  return ExSIP_C.causes.SIP_FAILURE_CODE;
};

/**
 * Generate a random Test-Net IP (http://tools.ietf.org/html/rfc5735)
 */
Utils.getRandomTestNetIP = function() {
  function getOctet(from, to) {
    return Math.floor(Math.random() * (to - from + 1) + from);
  }
  return '192.0.2.' + getOctet(1, 254);
};

// MD5 (Message-Digest Algorithm) http://www.webtoolkit.info
Utils.calculateMD5 = function(string) {
  function rotateLeft(lValue, iShiftBits) {
    return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
  }

  function addUnsigned(lX, lY) {
    var lX4, lY4, lX8, lY8, lResult;
    lX8 = (lX & 0x80000000);
    lY8 = (lY & 0x80000000);
    lX4 = (lX & 0x40000000);
    lY4 = (lY & 0x40000000);
    lResult = (lX & 0x3FFFFFFF) + (lY & 0x3FFFFFFF);
    if (lX4 & lY4) {
      return (lResult ^ 0x80000000 ^ lX8 ^ lY8);
    }
    if (lX4 | lY4) {
      if (lResult & 0x40000000) {
        return (lResult ^ 0xC0000000 ^ lX8 ^ lY8);
      } else {
        return (lResult ^ 0x40000000 ^ lX8 ^ lY8);
      }
    } else {
      return (lResult ^ lX8 ^ lY8);
    }
  }

  function doF(x, y, z) {
    return (x & y) | ((~x) & z);
  }

  function doG(x, y, z) {
    return (x & z) | (y & (~z));
  }

  function doH(x, y, z) {
    return (x ^ y ^ z);
  }

  function doI(x, y, z) {
    return (y ^ (x | (~z)));
  }

  function doFF(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doF(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doGG(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doG(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doHH(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doH(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function doII(a, b, c, d, x, s, ac) {
    a = addUnsigned(a, addUnsigned(addUnsigned(doI(b, c, d), x), ac));
    return addUnsigned(rotateLeft(a, s), b);
  }

  function convertToWordArray(string) {
    var lWordCount;
    var lMessageLength = string.length;
    var lNumberOfWords_temp1 = lMessageLength + 8;
    var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
    var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
    var lWordArray = new Array(lNumberOfWords - 1);
    var lBytePosition = 0;
    var lByteCount = 0;
    while (lByteCount < lMessageLength) {
      lWordCount = (lByteCount - (lByteCount % 4)) / 4;
      lBytePosition = (lByteCount % 4) * 8;
      lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) << lBytePosition));
      lByteCount++;
    }
    lWordCount = (lByteCount - (lByteCount % 4)) / 4;
    lBytePosition = (lByteCount % 4) * 8;
    lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 << lBytePosition);
    lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
    lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
    return lWordArray;
  }

  function wordToHex(lValue) {
    var wordToHexValue = "",
      wordToHexValue_temp = "",
      lByte, lCount;
    for (lCount = 0; lCount <= 3; lCount++) {
      lByte = (lValue >>> (lCount * 8)) & 255;
      wordToHexValue_temp = "0" + lByte.toString(16);
      wordToHexValue = wordToHexValue + wordToHexValue_temp.substr(wordToHexValue_temp.length - 2, 2);
    }
    return wordToHexValue;
  }

  function utf8Encode(string) {
    string = string.replace(/\r\n/g, "\n");
    var utftext = "";

    for (var n = 0; n < string.length; n++) {
      var c = string.charCodeAt(n);

      if (c < 128) {
        utftext += String.fromCharCode(c);
      } else if ((c > 127) && (c < 2048)) {
        utftext += String.fromCharCode((c >> 6) | 192);
        utftext += String.fromCharCode((c & 63) | 128);
      } else {
        utftext += String.fromCharCode((c >> 12) | 224);
        utftext += String.fromCharCode(((c >> 6) & 63) | 128);
        utftext += String.fromCharCode((c & 63) | 128);
      }
    }
    return utftext;
  }

  var x = [];
  var k, AA, BB, CC, DD, a, b, c, d;
  var S11 = 7,
    S12 = 12,
    S13 = 17,
    S14 = 22;
  var S21 = 5,
    S22 = 9,
    S23 = 14,
    S24 = 20;
  var S31 = 4,
    S32 = 11,
    S33 = 16,
    S34 = 23;
  var S41 = 6,
    S42 = 10,
    S43 = 15,
    S44 = 21;

  string = utf8Encode(string);

  x = convertToWordArray(string);

  a = 0x67452301;
  b = 0xEFCDAB89;
  c = 0x98BADCFE;
  d = 0x10325476;

  for (k = 0; k < x.length; k += 16) {
    AA = a;
    BB = b;
    CC = c;
    DD = d;
    a = doFF(a, b, c, d, x[k + 0], S11, 0xD76AA478);
    d = doFF(d, a, b, c, x[k + 1], S12, 0xE8C7B756);
    c = doFF(c, d, a, b, x[k + 2], S13, 0x242070DB);
    b = doFF(b, c, d, a, x[k + 3], S14, 0xC1BDCEEE);
    a = doFF(a, b, c, d, x[k + 4], S11, 0xF57C0FAF);
    d = doFF(d, a, b, c, x[k + 5], S12, 0x4787C62A);
    c = doFF(c, d, a, b, x[k + 6], S13, 0xA8304613);
    b = doFF(b, c, d, a, x[k + 7], S14, 0xFD469501);
    a = doFF(a, b, c, d, x[k + 8], S11, 0x698098D8);
    d = doFF(d, a, b, c, x[k + 9], S12, 0x8B44F7AF);
    c = doFF(c, d, a, b, x[k + 10], S13, 0xFFFF5BB1);
    b = doFF(b, c, d, a, x[k + 11], S14, 0x895CD7BE);
    a = doFF(a, b, c, d, x[k + 12], S11, 0x6B901122);
    d = doFF(d, a, b, c, x[k + 13], S12, 0xFD987193);
    c = doFF(c, d, a, b, x[k + 14], S13, 0xA679438E);
    b = doFF(b, c, d, a, x[k + 15], S14, 0x49B40821);
    a = doGG(a, b, c, d, x[k + 1], S21, 0xF61E2562);
    d = doGG(d, a, b, c, x[k + 6], S22, 0xC040B340);
    c = doGG(c, d, a, b, x[k + 11], S23, 0x265E5A51);
    b = doGG(b, c, d, a, x[k + 0], S24, 0xE9B6C7AA);
    a = doGG(a, b, c, d, x[k + 5], S21, 0xD62F105D);
    d = doGG(d, a, b, c, x[k + 10], S22, 0x2441453);
    c = doGG(c, d, a, b, x[k + 15], S23, 0xD8A1E681);
    b = doGG(b, c, d, a, x[k + 4], S24, 0xE7D3FBC8);
    a = doGG(a, b, c, d, x[k + 9], S21, 0x21E1CDE6);
    d = doGG(d, a, b, c, x[k + 14], S22, 0xC33707D6);
    c = doGG(c, d, a, b, x[k + 3], S23, 0xF4D50D87);
    b = doGG(b, c, d, a, x[k + 8], S24, 0x455A14ED);
    a = doGG(a, b, c, d, x[k + 13], S21, 0xA9E3E905);
    d = doGG(d, a, b, c, x[k + 2], S22, 0xFCEFA3F8);
    c = doGG(c, d, a, b, x[k + 7], S23, 0x676F02D9);
    b = doGG(b, c, d, a, x[k + 12], S24, 0x8D2A4C8A);
    a = doHH(a, b, c, d, x[k + 5], S31, 0xFFFA3942);
    d = doHH(d, a, b, c, x[k + 8], S32, 0x8771F681);
    c = doHH(c, d, a, b, x[k + 11], S33, 0x6D9D6122);
    b = doHH(b, c, d, a, x[k + 14], S34, 0xFDE5380C);
    a = doHH(a, b, c, d, x[k + 1], S31, 0xA4BEEA44);
    d = doHH(d, a, b, c, x[k + 4], S32, 0x4BDECFA9);
    c = doHH(c, d, a, b, x[k + 7], S33, 0xF6BB4B60);
    b = doHH(b, c, d, a, x[k + 10], S34, 0xBEBFBC70);
    a = doHH(a, b, c, d, x[k + 13], S31, 0x289B7EC6);
    d = doHH(d, a, b, c, x[k + 0], S32, 0xEAA127FA);
    c = doHH(c, d, a, b, x[k + 3], S33, 0xD4EF3085);
    b = doHH(b, c, d, a, x[k + 6], S34, 0x4881D05);
    a = doHH(a, b, c, d, x[k + 9], S31, 0xD9D4D039);
    d = doHH(d, a, b, c, x[k + 12], S32, 0xE6DB99E5);
    c = doHH(c, d, a, b, x[k + 15], S33, 0x1FA27CF8);
    b = doHH(b, c, d, a, x[k + 2], S34, 0xC4AC5665);
    a = doII(a, b, c, d, x[k + 0], S41, 0xF4292244);
    d = doII(d, a, b, c, x[k + 7], S42, 0x432AFF97);
    c = doII(c, d, a, b, x[k + 14], S43, 0xAB9423A7);
    b = doII(b, c, d, a, x[k + 5], S44, 0xFC93A039);
    a = doII(a, b, c, d, x[k + 12], S41, 0x655B59C3);
    d = doII(d, a, b, c, x[k + 3], S42, 0x8F0CCC92);
    c = doII(c, d, a, b, x[k + 10], S43, 0xFFEFF47D);
    b = doII(b, c, d, a, x[k + 1], S44, 0x85845DD1);
    a = doII(a, b, c, d, x[k + 8], S41, 0x6FA87E4F);
    d = doII(d, a, b, c, x[k + 15], S42, 0xFE2CE6E0);
    c = doII(c, d, a, b, x[k + 6], S43, 0xA3014314);
    b = doII(b, c, d, a, x[k + 13], S44, 0x4E0811A1);
    a = doII(a, b, c, d, x[k + 4], S41, 0xF7537E82);
    d = doII(d, a, b, c, x[k + 11], S42, 0xBD3AF235);
    c = doII(c, d, a, b, x[k + 2], S43, 0x2AD7D2BB);
    b = doII(b, c, d, a, x[k + 9], S44, 0xEB86D391);
    a = addUnsigned(a, AA);
    b = addUnsigned(b, BB);
    c = addUnsigned(c, CC);
    d = addUnsigned(d, DD);
  }

  var temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);

  return temp.toLowerCase();
};
},{"./Constants":197,"./Grammar":204,"./URI":221}],223:[function(require,module,exports){
var WebRTC = {};

module.exports = WebRTC;

var ExSIP_C = require('./Constants');
var Utils = require('./Utils');

// getUserMedia
if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  WebRTC.getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  WebRTC.getUserMedia = navigator.mozGetUserMedia.bind(navigator);
}
else if (typeof navigator !== 'undefined' && navigator.getUserMedia) {
  WebRTC.getUserMedia = navigator.getUserMedia.bind(navigator);
}

// RTCPeerConnection
if (typeof webkitRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = webkitRTCPeerConnection;
}
else if (typeof mozRTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = mozRTCPeerConnection;
}
else if (typeof RTCPeerConnection !== 'undefined') {
  WebRTC.RTCPeerConnection = RTCPeerConnection;
}
else {
  console.log("WebRTC.RTCPeerConnection undefined");
  WebRTC.RTCPeerConnection = function(options, constraints){
    this.options = options;
    this.constraints = constraints;
  };
}

// RTCIceCandidate
if (typeof RTCIceCandidate !== 'undefined') {
  WebRTC.RTCIceCandidate = RTCIceCandidate;
}
else {
  console.log("WebRTC.RTCIceCandidate undefined");
  WebRTC.RTCIceCandidate = function(){};
}

// RTCSessionDescription
if (typeof webkitRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = webkitRTCSessionDescription;
}
else if (typeof mozRTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = mozRTCSessionDescription;
}
else if (typeof RTCSessionDescription !== 'undefined') {
  WebRTC.RTCSessionDescription = RTCSessionDescription;
}
else {
  console.log("WebRTC.RTCSessionDescription undefined");
  WebRTC.RTCSessionDescription = function(options){
    options = options || {};
    this.sdp = options.sdp;
    this.type = options.type;
  };
}

WebRTC.RTCSessionDescription.prototype.getSdp = function(options){
  options = options || {};
  var sdp = this.sdp;
  if(options.additionalSdp) {
    sdp += options.additionalSdp;
  }
  return sdp;
};
WebRTC.RTCSessionDescription.prototype.getUnsupportedMedias = function(){
  var slideMedias = this.getSlidesMedias();
  var inactiveApplicationMedias = this.getApplicationMedias('0 RTP/SAVPF');
  var unsupportedMedias = slideMedias.concat(inactiveApplicationMedias);
  return unsupportedMedias;
};
WebRTC.RTCSessionDescription.prototype.removeUnsupportedMedia = function(){
  var unsupportedMedias = this.getUnsupportedMedias();
  for(var i = 0; i < unsupportedMedias.length; i++) {
    this.sdp = this.sdp.replace(unsupportedMedias[i], '');
    console.warn('removing unsupported media from sdp : '+unsupportedMedias[i]);
  }
  return unsupportedMedias.join('');
};
WebRTC.RTCSessionDescription.prototype.getSlidesMedias = function(){
  var slideMedia = this.getVideoMedias('a=content:slides');
  return slideMedia;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedias = function(filter){
  return this.getMedias('video', filter);
};
WebRTC.RTCSessionDescription.prototype.getApplicationMedias = function(filter){
  return this.getMedias('application', filter);
};
WebRTC.RTCSessionDescription.prototype.getMedias = function(type, filter){
  var regex = new RegExp("(m="+type+"(?:(?!m=)[\\s\\S])*)", "mig");
  var match;
  var results = [];
  while((match = regex.exec(this.sdp)) !== null) {
    var media = match.pop();
    if(!filter || media.indexOf(filter) !== -1) {
      results.push(media);
    }
  }
  return results;
};
WebRTC.RTCSessionDescription.prototype.getAudioIcePwd = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIcePwd = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-pwd:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioIceUfrag = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoIceUfrag = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=ice-ufrag:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getCandidates = function(media){
  var regex = new RegExp("a=candidate:(.*)", "ig");
  var matches;
  var result = [];
  while ((matches = regex.exec(media)) !== null)
  {
    result.push(matches[matches.length-1]);
  }
  return result;
};
WebRTC.RTCSessionDescription.prototype.getAudioCandidates = function(){
  var audio = this.getAudio();
  return audio ? this.getCandidates(audio) : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCandidates = function(){
  var video = this.getVideo();
  return video ? this.getCandidates(video) : null;
};
WebRTC.RTCSessionDescription.prototype.getConnection = function(){
  var match = this.sdp.match(/v=(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudio = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideo = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioConnection = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.getVideoConnection = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*c=(.*)/mi);
  return match !== null ? match[match.length-1] : this.getConnection();
};
WebRTC.RTCSessionDescription.prototype.hasVideo = function(){
  return this.sdp.match(/m=video/) !== null;
};
WebRTC.RTCSessionDescription.prototype.hasAudio = function(){
  return this.sdp.match(/m=audio/) !== null;
};
WebRTC.RTCSessionDescription.prototype.videoPort = function(){
  var match = this.sdp.match(/m=video\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.audioPort = function(){
  var match = this.sdp.match(/m=audio\s(\d*)\s/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioMedia = function(){
  var match = this.sdp.match(/m=audio\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoMedia = function(){
  var match = this.sdp.match(/m=video\s(.*)/);
  return  match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecs = function(){
  var audioMedia = this.getAudioMedia();
  return this.getCodecs(audioMedia);
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecs = function(){
  var videoMedia = this.getVideoMedia();
  return this.getCodecs(videoMedia);
};
WebRTC.RTCSessionDescription.prototype.getCodecs = function(media){
  if(!media) {
    return null;
  }
  var mediaParts = media.split(" ");
  return mediaParts.splice(2);
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecRtpmap = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecRtpmap = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=rtpmap:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioCodecFmtp = function(codec){
  var regex = new RegExp("m=audio(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoCodecFmtp = function(codec){
  var regex = new RegExp("m=video(?:(?!m=)[\\s\\S])*a=fmtp:"+codec+"(.*)", "mi");
  var match = this.sdp.match(regex);
  return match !== null ? match[match.length-1].trim() : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioFingerprint = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoFingerprint = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=fingerprint:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getAudioRtcp = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.getVideoRtcp = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=rtcp:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.removeVideoFingerprint = function(){
  if(this.getVideoFingerprint()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.removeAudioFingerprint = function(){
  if(this.getAudioFingerprint()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=fingerprint:.*\r\n)/mi, "$1");
  }
};
WebRTC.RTCSessionDescription.prototype.hasActiveVideo = function(){
  var videoPort = this.videoPort() || 0;
  var videoConnection = this.getVideoConnection() || "";
  return this.hasVideo() && videoPort > 0 && videoConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.hasActiveAudio = function(){
  var audioPort = this.audioPort() || 0;
  var audioConnection = this.getAudioConnection() || "";
  return this.hasAudio() && audioPort > 0 && audioConnection.indexOf('0.0.0.0') === -1;
};
WebRTC.RTCSessionDescription.prototype.getVideoBandwidth = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*b=.*:(.*)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setVideoBandwidth = function(videoBandwidth){
  if(this.getVideoBandwidth()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(b=.*)/mi, "$1b=AS:" + videoBandwidth);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nb=AS:" + videoBandwidth);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoMode = function(mode){
  if(this.getVideoMode()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoPort = function(port){
  this.sdp = this.sdp.replace(/(m=video\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.getVideoMode = function(){
  var match = this.sdp.match(/m=video(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.setAudioMode = function(mode){
  if(this.getAudioMode()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=(sendrecv|sendonly|recvonly|inactive))/mi, "$1a=" + mode);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*(:?(?!m=)[\s\S])*(c=IN\s+IP4.*)?)/, "$1\r\na=" + mode);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioPort = function(port){
  this.sdp = this.sdp.replace(/(m=audio\s)(\d*)(\s)/i, "$1"+port+"$3");
};
WebRTC.RTCSessionDescription.prototype.setAudioConnection = function(audioConnection){
  if(this.getAudioConnection()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + audioConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + audioConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoConnection = function(videoConnection){
  if(this.getVideoConnection()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(c=.*)/mi, "$1c=" + videoConnection);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\nc=" + videoConnection);
  }
};
WebRTC.RTCSessionDescription.prototype.setAudioRtcp = function(audioRtcp){
  if(this.getAudioRtcp()) {
    this.sdp = this.sdp.replace(/(m=audio(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + audioRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=audio.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + audioRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.setVideoRtcp = function(videoRtcp){
  if(this.getVideoRtcp()) {
    this.sdp = this.sdp.replace(/(m=video(?:(?!m=)[\s\S])*)(a=rtcp:.*)/mi, "$1a=rtcp:" + videoRtcp);
  } else {
    this.sdp = this.sdp.replace(/(m=video.*((?!m=)[\s\S]*c=IN\s+IP4.*)?)/, "$1\r\na=rtcp:" + videoRtcp);
  }
};
WebRTC.RTCSessionDescription.prototype.getAudioMode = function(){
  var match = this.sdp.match(/m=audio(?:(?!m=)[\s\S])*a=(sendrecv|sendonly|recvonly|inactive)/mi);
  return match !== null ? match[match.length-1] : null;
};
WebRTC.RTCSessionDescription.prototype.isActive = function(){
  if(this.hasAudio() && this.audioPort() !== "0" && this.getAudioMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  if(this.hasVideo() && this.videoPort() !== "0" && this.getVideoMode() !== ExSIP_C.INACTIVE) {
    return true;
  }
  return false;
};
WebRTC.RTCSessionDescription.prototype.mediaChanges = function(otherSdp){
  var mediaChanges = [];
  if(this.hasAudio() !== otherSdp.hasAudio()) {
    mediaChanges.push("audio has changed");
  }
  if(this.hasVideo() !== otherSdp.hasVideo()) {
    mediaChanges.push("video has changed");
  }
  if(this.audioPort() !== otherSdp.audioPort()) {
    mediaChanges.push("audio port has changed : "+this.audioPort()+" - " + otherSdp.audioPort());
  }
  if(this.videoPort() !== otherSdp.videoPort()) {
    mediaChanges.push("video port has changed : "+this.videoPort()+" - " + otherSdp.videoPort());
  }
  if(this.getAudioConnection() !== otherSdp.getAudioConnection()) {
    mediaChanges.push("audio connection has changed : "+this.getAudioConnection()+" - " + otherSdp.getAudioConnection());
  }
  if(this.getVideoConnection() !== otherSdp.getVideoConnection()) {
    mediaChanges.push("video connection has changed : "+this.getVideoConnection()+" - " + otherSdp.getVideoConnection());
  }
  var audioCodecs = this.getAudioCodecs();
  if(!Utils.isEqArrays(audioCodecs, otherSdp.getAudioCodecs())) {
    mediaChanges.push("audio codecs has changed : "+audioCodecs+" - " + otherSdp.getAudioCodecs());
  }
  var videoCodecs = this.getVideoCodecs();
  if(!Utils.isEqArrays(videoCodecs, otherSdp.getVideoCodecs())) {
    mediaChanges.push("video codecs has changed : "+videoCodecs+" - " + otherSdp.getVideoCodecs());
  }

  if(audioCodecs) {
    for(var i = 0; i < audioCodecs.length; i++) {
      if(this.getAudioCodecRtpmap(audioCodecs[i]) !== otherSdp.getAudioCodecRtpmap(audioCodecs[i])) {
        mediaChanges.push("audio codec rtpmap for "+audioCodecs[i]+" has changed : "+this.getAudioCodecRtpmap(audioCodecs[i])+" - " + otherSdp.getAudioCodecRtpmap(audioCodecs[i]));
      }
//      if(this.getAudioCodecFmtp(audioCodecs[i]) !== otherSdp.getAudioCodecFmtp(audioCodecs[i])) {
//        mediaChanges.push("audio codec fmtp for "+audioCodecs[i]+" has changed : "+this.getAudioCodecFmtp(audioCodecs[i])+" - " + otherSdp.getAudioCodecFmtp(audioCodecs[i]));
//      }
    }
  }
  if(videoCodecs) {
    for(var j = 0; j < videoCodecs.length; j++) {
      if(this.getVideoCodecRtpmap(videoCodecs[j]) !== otherSdp.getVideoCodecRtpmap(videoCodecs[j])) {
        mediaChanges.push("video codec rtpmap for "+videoCodecs[j]+" has changed : "+this.getVideoCodecRtpmap(videoCodecs[j])+" - " + otherSdp.getVideoCodecRtpmap(videoCodecs[j]));
      }
//      if(this.getVideoCodecFmtp(videoCodecs[j]) !== otherSdp.getVideoCodecFmtp(videoCodecs[j])) {
//        mediaChanges.push("video codec fmtp for "+videoCodecs[j]+" has changed : "+this.getVideoCodecFmtp(videoCodecs[j])+" - " + otherSdp.getVideoCodecFmtp(videoCodecs[j]));
//      }
    }
  }

  return mediaChanges;
};

// New syntax for getting streams in Chrome M26.
if (WebRTC.RTCPeerConnection && WebRTC.RTCPeerConnection.prototype) {
  if (! WebRTC.RTCPeerConnection.prototype.getLocalStreams) {
    WebRTC.RTCPeerConnection.prototype.getLocalStreams = function() {
      return this.localStreams;
    };
    WebRTC.RTCPeerConnection.prototype.getRemoteStreams = function() {
      return this.remoteStreams;
    };
  }
  WebRTC.RTCPeerConnection.prototype.isIceCandidateReady = function(candidate) {
    // if(mozRTCPeerConnection && !candidate) {
    //   return true;
    // }
    // if(!mozRTCPeerConnection && candidate) {
    //   return true;
    // }
    return candidate;
  };
}

// isSupported attribute.
if (WebRTC.getUserMedia && WebRTC.RTCPeerConnection && WebRTC.RTCSessionDescription) {
  WebRTC.isSupported = true;
}
else {
  WebRTC.isSupported = false;
}

},{"./Constants":197,"./Utils":222}],224:[function(require,module,exports){
module.exports = sanityCheck;


/**
 * Dependencies.
 */
var ExSIP_C = require('./Constants');
var SIPMessage = require('./SIPMessage');
var Utils = require('./Utils');


var logger,
  message, ua, transport,
  requests = [],
  responses = [],
  all = [];


requests.push(rfc3261_8_2_2_1);
requests.push(rfc3261_16_3_4);
requests.push(rfc3261_18_3_request);
requests.push(rfc3261_8_2_2_2);

responses.push(rfc3261_8_1_3_3);
responses.push(rfc3261_18_3_response);

all.push(minimumHeaders);


function sanityCheck(m, u, t) {
  var len, pass;

  message = m;
  ua = u;
  transport = t;

  logger = ua.getLogger('ExSIP.sanitycheck');

  len = all.length;
  while(len--) {
    pass = all[len](message);
    if(pass === false) {
      return false;
    }
  }

  if(message instanceof SIPMessage.IncomingRequest) {
    len = requests.length;
    while(len--) {
      pass = requests[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  else if(message instanceof SIPMessage.IncomingResponse) {
    len = responses.length;
    while(len--) {
      pass = responses[len](message);
      if(pass === false) {
        return false;
      }
    }
  }

  //Everything is OK
  return true;
}


/*
 * Sanity Check for incoming Messages
 *
 * Requests:
 *  - _rfc3261_8_2_2_1_ Receive a Request with a non supported URI scheme
 *  - _rfc3261_16_3_4_ Receive a Request already sent by us
 *   Does not look at via sent-by but at exsip_id, which is inserted as
 *   a prefix in all initial requests generated by the ua
 *  - _rfc3261_18_3_request_ Body Content-Length
 *  - _rfc3261_8_2_2_2_ Merged Requests
 *
 * Responses:
 *  - _rfc3261_8_1_3_3_ Multiple Via headers
 *  - _rfc3261_18_3_response_ Body Content-Length
 *
 * All:
 *  - Minimum headers in a SIP message
 */

// Sanity Check functions for requests
function rfc3261_8_2_2_1() {
  if(message.s('to').uri.scheme !== 'sip') {
    logger.warn('Scheme ('+message.s('to').uri.scheme+') is not sip. Dropping the request', ua);
    reply(416);
    return false;
  }
}

function rfc3261_16_3_4() {
  if(!message.to_tag) {
    if(message.call_id.substr(0, 5) === ua.configuration.exsip_id) {
      logger.warn('Call_id ('+message.call_id+') is same as exsip ('+ua.configuration.exsip_id+'). Dropping the request', ua);
      reply(482);
      return false;
    }
  }
}

function rfc3261_18_3_request() {
  var len = Utils.str_utf8_length(message.body),
  contentLength = message.getHeader('content-length');

  if(len < contentLength) {
    logger.warn('Message body length ('+len+') is lower than the value in Content-Length header field ('+contentLength+'). Dropping the request', ua);
    reply(400);
    return false;
  }
}

function rfc3261_8_2_2_2() {
  var tr, idx,
    fromTag = message.from_tag,
    call_id = message.call_id,
    cseq = message.cseq;

  // Accept any in-dialog request.
  if(message.to_tag) {
    return;
  }

  // INVITE request.
  if (message.method === ExSIP_C.INVITE) {
    // If the branch matches the key of any IST then assume it is a retransmission
    // and ignore the INVITE.
    // TODO: we should reply the last response.
    if (ua.transactions.ist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.ist) {
        tr = ua.transactions.ist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
  // Non INVITE request.
  else {
    // If the branch matches the key of any NIST then assume it is a retransmission
    // and ignore the request.
    // TODO: we should reply the last response.
    if (ua.transactions.nist[message.via_branch]) {
      return false;
    }
    // Otherwise check whether it is a merged request.
    else {
      for(idx in ua.transactions.nist) {
        tr = ua.transactions.nist[idx];
        if(tr.request.from_tag === fromTag && tr.request.call_id === call_id && tr.request.cseq === cseq) {
          reply(482);
          return false;
        }
      }
    }
  }
}

// Sanity Check functions for responses
function rfc3261_8_1_3_3() {
  if(message.getHeaders('via').length > 1) {
    logger.warn('More than one Via header field present in the response. Dropping the response');
    return false;
  }
}

function rfc3261_18_3_response() {
  var
    len = Utils.str_utf8_length(message.body),
    contentLength = message.getHeader('content-length');

    if(len < contentLength) {
      logger.warn('Message body length is lower than the value in Content-Length header field. Dropping the response');
      return false;
    }
}

// Sanity Check functions for requests and responses
function minimumHeaders() {
  var
    mandatoryHeaders = ['from', 'to', 'call_id', 'cseq', 'via'],
    idx = mandatoryHeaders.length;

  while(idx--) {
    if(!message.hasHeader(mandatoryHeaders[idx])) {
      logger.warn('Missing mandatory header field : '+ mandatoryHeaders[idx] +'. Dropping the response');
      return false;
    }
  }
}

// Reply
function reply(status_code) {
  var to,
    response = "SIP/2.0 " + status_code + " " + ExSIP_C.REASON_PHRASE[status_code] + "\r\n",
    vias = message.getHeaders('via'),
    length = vias.length,
    idx = 0;

  for(idx; idx < length; idx++) {
    response += "Via: " + vias[idx] + "\r\n";
  }

  to = message.getHeader('To');

  if(!message.to_tag) {
    to += ';tag=' + Utils.newTag();
  }

  response += "To: " + to + "\r\n";
  response += "From: " + message.getHeader('From') + "\r\n";
  response += "Call-ID: " + message.call_id + "\r\n";
  response += "CSeq: " + message.cseq + " " + message.method + "\r\n";
  response += "\r\n";

  transport.send(response);
}
},{"./Constants":197,"./SIPMessage":216,"./Utils":222}],225:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Core 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.10.4",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	scrollParent: function() {
		var scrollParent;
		if (($.ui.ie && (/(static|relative)/).test(this.css("position"))) || (/absolute/).test(this.css("position"))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,"position")) && (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,"overflow")+$.css(this,"overflow-y")+$.css(this,"overflow-x"));
			}).eq(0);
		}

		return (/fixed/).test(this.css("position")) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}





// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.support.selectstart = "onselectstart" in document.createElement( "div" );
$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated. Use $.widget() extensions instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	}
});

})( jQuery );

},{"jquery":230}],226:[function(require,module,exports){
var jQuery = require('jquery');
require('./core');
require('./mouse');
require('./widget');

/*!
 * jQuery UI Draggable 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.10.4",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		if ( this.options.helper === "original" && !$.contains( this.element[ 0 ].ownerDocument, this.element[ 0 ] ) ) {
			return false;
		}

		if((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if(!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if(helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		//This needs to be actually done for all browsers, since pageX/pageY includes this information
		//Ugly IE fix
		if((this.offsetParent[0] === document.body) ||
			(this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ) ,
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top ) * mod )
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left ) * mod )
			)
		};

	},

	_generatePosition: function(event) {

		var containment, co, top, left,
			o = this.options,
			scroll = this.cssPosition === "absolute" && !( this.scrollParent[ 0 ] !== document && $.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ? this.offsetParent : this.scrollParent,
			pageX = event.pageX,
			pageY = event.pageY;

		//Cache the scroll
		if (!this.offset.scroll) {
			this.offset.scroll = {top : scroll.scrollTop(), left : scroll.scrollLeft()};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( this.originalPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				}
				else {
					containment = this.containment;
				}

				if(event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : this.offset.scroll.top )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : this.offset.scroll.left )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		//The absolute position has to be recalculated after plugins
		if(type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("ui-draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, "ui-sortable");
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("ui-draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if(this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("ui-draggable"), that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function() {
		var t = $("body"), o = $(this).data("ui-draggable").options;
		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function() {
		var o = $(this).data("ui-draggable").options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function() {
		var i = $(this).data("ui-draggable");
		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event ) {

		var i = $(this).data("ui-draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] !== document && i.scrollParent[0].tagName !== "HTML") {

			if(!o.axis || o.axis !== "x") {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if(!o.axis || o.axis !== "y") {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if(!o.axis || o.axis !== "x") {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if(!o.axis || o.axis !== "y") {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function() {

		var i = $(this).data("ui-draggable"),
			o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if(this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function(event, ui) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			inst = $(this).data("ui-draggable"),
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if(inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if(o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if(ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if(bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if(ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if(rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function() {
		var min,
			o = this.data("ui-draggable").options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("ui-draggable").options;
		if(t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("ui-draggable").options;
		if(o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

})(jQuery);

},{"./core":225,"./mouse":227,"./widget":228,"jquery":230}],227:[function(require,module,exports){
var jQuery = require('jquery');
require('./widget');

/*!
 * jQuery UI Mouse 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "1.10.4",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown."+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click."+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("."+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.bind("mouseup."+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind("mousemove."+this.widgetName, this._mouseMoveDelegate)
			.unbind("mouseup."+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});

})(jQuery);

},{"./widget":228,"jquery":230}],228:[function(require,module,exports){
var jQuery = require('jquery');

/*!
 * jQuery UI Widget 1.10.4
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			// accept selectors, DOM elements
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

})( jQuery );

},{"jquery":230}],229:[function(require,module,exports){
/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (value !== undefined && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));

},{"jquery":230}],230:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.1.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-18T15:11Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//

var arr = [];

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,

	version = "2.1.3",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {
	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >= 0;
	},

	isPlainObject: function( obj ) {
		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}
		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call(obj) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {
			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf("use strict") === 1 ) {
				script = document.createElement("script");
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {
			// Otherwise, avoid the DOM node creation, insertion
			// and removal by using an indirect global eval
				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var value,
			i = 0,
			length = obj.length,
			isArray = isArraylike( obj );

		if ( args ) {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.apply( obj[ i ], args );

					if ( value === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isArray ) {
				for ( ; i < length; i++ ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					value = callback.call( obj[ i ], i, obj[ i ] );

					if ( value === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArraylike( Object(arr) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value,
			i = 0,
			length = elems.length,
			isArray = isArraylike( elems ),
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object Error".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

function isArraylike( obj ) {
	var length = obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	if ( obj.nodeType === 1 && length ) {
		return true;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.0-pre
 * http://sizzlejs.com/
 *
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2014-12-16
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + characterEncoding + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var match, elem, m, nodeType,
		// QSA vars
		i, groups, old, nid, newContext, newSelector;

	if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
		setDocument( context );
	}

	context = context || document;
	results = results || [];
	nodeType = context.nodeType;

	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	if ( !seed && documentIsHTML ) {

		// Try to shortcut find operations when possible (e.g., not under DocumentFragment)
		if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document (jQuery #6963)
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, context.getElementsByTagName( selector ) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && support.getElementsByClassName ) {
				push.apply( results, context.getElementsByClassName( m ) );
				return results;
			}
		}

		// QSA path
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {
			nid = old = expando;
			newContext = context;
			newSelector = nodeType !== 1 && selector;

			// qSA works strangely on Element-rooted queries
			// We can work around this by specifying an extra ID on the root
			// and working up from there (Thanks to Andrew Dupont for the technique)
			// IE 8 doesn't work on object elements
			if ( nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
				groups = tokenize( selector );

				if ( (old = context.getAttribute("id")) ) {
					nid = old.replace( rescape, "\\$&" );
				} else {
					context.setAttribute( "id", nid );
				}
				nid = "[id='" + nid + "'] ";

				i = groups.length;
				while ( i-- ) {
					groups[i] = nid + toSelector( groups[i] );
				}
				newContext = rsibling.test( selector ) && testContext( context.parentNode ) || context;
				newSelector = groups.join(",");
			}

			if ( newSelector ) {
				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch(qsaError) {
				} finally {
					if ( !old ) {
						context.removeAttribute("id");
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = attrs.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// If no document and documentElement is available, return
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Set our document
	document = doc;
	docElem = doc.documentElement;
	parent = doc.defaultView;

	// Support: IE>8
	// If iframe document is assigned to "document" variable and if iframe has been reloaded,
	// IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
	// IE6-8 do not support the defaultView property so parent will be undefined
	if ( parent && parent !== parent.top ) {
		// IE11 does not have attachEvent, so all must suffer
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Support tests
	---------------------------------------------------------------------- */
	documentIsHTML = !isXML( doc );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( doc.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( doc.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !doc.getElementsByName || !doc.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\f]' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.7+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = doc.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully does not implement inclusive descendent
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === doc ? -1 :
				b === doc ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return doc;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, outerCache, node, diff, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {
										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {
							// Seek `elem` from a previously-cached index
							outerCache = parent[ expando ] || (parent[ expando ] = {});
							cache = outerCache[ type ] || [];
							nodeIndex = cache[0] === dirruns && cache[1];
							diff = cache[0] === dirruns && cache[2];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									outerCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						// Use previously-cached element index if available
						} else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {
							diff = cache[1];

						// xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
						} else {
							// Use the same loop as above to seek `elem` from the start
							while ( (node = ++nodeIndex && node && node[ dir ] ||
								(diff = nodeIndex = 0) || start.pop()) ) {

								if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {
									// Cache the index of each encountered element
									if ( useCache ) {
										(node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];
									}

									if ( node === elem ) {
										break;
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});
						if ( (oldCache = outerCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							outerCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context !== document && context;
			}

			// Add elements passing elementMatchers directly to results
			// Keep `i` a string if there are no elements so `matchedCount` will be "00" below
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is no seed and only one group
	if ( match.length === 1 ) {

		// Take a shortcut and set the context if the root selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		});

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		});

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) >= 0 ) !== not;
	});
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		}));
};

jQuery.fn.extend({
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter(function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			}) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow(this, selector || [], false) );
	},
	not: function( selector ) {
		return this.pushStack( winnow(this, selector || [], true) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
});


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[0] === "<" && selector[ selector.length - 1 ] === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[1],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {
							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {
						// Inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return typeof rootjQuery.ready !== "undefined" ?
				rootjQuery.ready( selector ) :
				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,
	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.extend({
	dir: function( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( (elem = elem[ dir ]) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}
});

jQuery.fn.extend({
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter(function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {
				// Always skip document fragments
				if ( cur.nodeType < 11 && (pos ?
					pos.index(cur) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector(cur, selectors)) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.unique(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

function sibling( cur, dir ) {
	while ( (cur = cur[dir]) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {
			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.unique( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
});
var rnotwhite = (/\S+/g);



// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				firingLength = 0;
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( list && ( !fired || stack ) ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ](function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.done( newDefer.resolve )
										.fail( newDefer.reject )
										.progress( newDefer.notify );
								} else {
									newDefer[ tuple[ 0 ] + "With" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );
								}
							});
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[0] ] = function() {
				deferred[ tuple[0] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {
	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend({
	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
});

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed, false );
	window.removeEventListener( "load", completed, false );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// We once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed, false );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = jQuery.access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {
			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[0], key ) : emptyGet;
};


/**
 * Determines whether an object can have data
 */
jQuery.acceptData = function( owner ) {
	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};


function Data() {
	// Support: Android<4,
	// Old WebKit does not have Object.preventExtensions/freeze method,
	// return new empty object instead with no [[set]] accessor
	Object.defineProperty( this.cache = {}, 0, {
		get: function() {
			return {};
		}
	});

	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;
Data.accepts = jQuery.acceptData;

Data.prototype = {
	key: function( owner ) {
		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return the key for a frozen object.
		if ( !Data.accepts( owner ) ) {
			return 0;
		}

		var descriptor = {},
			// Check if the owner object already has a cache key
			unlock = owner[ this.expando ];

		// If not, create one
		if ( !unlock ) {
			unlock = Data.uid++;

			// Secure it in a non-enumerable, non-writable property
			try {
				descriptor[ this.expando ] = { value: unlock };
				Object.defineProperties( owner, descriptor );

			// Support: Android<4
			// Fallback to a less secure definition
			} catch ( e ) {
				descriptor[ this.expando ] = unlock;
				jQuery.extend( owner, descriptor );
			}
		}

		// Ensure the cache object
		if ( !this.cache[ unlock ] ) {
			this.cache[ unlock ] = {};
		}

		return unlock;
	},
	set: function( owner, data, value ) {
		var prop,
			// There may be an unlock assigned to this node,
			// if there is no entry for this "owner", create one inline
			// and set the unlock as though an owner entry had always existed
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {
			// Fresh assignments by object are shallow copied
			if ( jQuery.isEmptyObject( cache ) ) {
				jQuery.extend( this.cache[ unlock ], data );
			// Otherwise, copy the properties one-by-one to the cache object
			} else {
				for ( prop in data ) {
					cache[ prop ] = data[ prop ];
				}
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		// Either a valid cache is found, or will be created.
		// New caches will be created and the unlock returned,
		// allowing direct access to the newly created
		// empty data object. A valid owner object must be provided.
		var cache = this.cache[ this.key( owner ) ];

		return key === undefined ?
			cache : cache[ key ];
	},
	access: function( owner, key, value ) {
		var stored;
		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				((key && typeof key === "string") && value === undefined) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase(key) );
		}

		// [*]When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			unlock = this.key( owner ),
			cache = this.cache[ unlock ];

		if ( key === undefined ) {
			this.cache[ unlock ] = {};

		} else {
			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {
				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );
				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {
					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;
			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}
	},
	hasData: function( owner ) {
		return !jQuery.isEmptyObject(
			this.cache[ owner[ this.expando ] ] || {}
		);
	},
	discard: function( owner ) {
		if ( owner[ this.expando ] ) {
			delete this.cache[ owner[ this.expando ] ];
		}
	}
};
var data_priv = new Data();

var data_user = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /([A-Z])/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :
					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			data_user.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend({
	hasData: function( elem ) {
		return data_user.hasData( elem ) || data_priv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return data_user.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		data_user.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to data_priv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return data_priv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		data_priv.remove( elem, name );
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = data_user.get( elem );

				if ( elem.nodeType === 1 && !data_priv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice(5) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					data_priv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				data_user.set( this, key );
			});
		}

		return access( this, function( value ) {
			var data,
				camelKey = jQuery.camelCase( key );

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {
				// Attempt to get data from the cache
				// with the key as-is
				data = data_user.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to get data from the cache
				// with the key camelized
				data = data_user.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each(function() {
				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = data_user.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				data_user.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf("-") !== -1 && data !== undefined ) {
					data_user.set( this, key, value );
				}
			});
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each(function() {
			data_user.remove( this, key );
		});
	}
});


jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = data_priv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = data_priv.access( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return data_priv.get( elem, key ) || data_priv.access( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				data_priv.remove( elem, [ type + "queue", key ] );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = data_priv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {
		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
	};

var rcheckableType = (/^(?:checkbox|radio)$/i);



(function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
})();
var strundefined = typeof undefined;



support.focusinBubbles = "onfocusin" in window;


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !(events = elemData.events) ) {
			events = elemData.events = {};
		}
		if ( !(eventHandle = elemData.handle) ) {
			eventHandle = elemData.handle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== strundefined && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !(handlers = events[ type ]) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = data_priv.hasData( elem ) && data_priv.get( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[t] ) || [];
			type = origType = tmp[1];
			namespaces = ( tmp[2] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[2] && new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;
			data_priv.remove( elem, "events" );
		}
	},

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split(".") : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf(".") >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf(":") < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join(".");
		event.namespace_re = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === (elem.ownerDocument || document) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( data_priv.get( cur, "events" ) || {} )[ event.type ] && data_priv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&
				jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( data_priv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( (event.result = ret) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && cur.nodeType && (!event.button || event.type !== "click") ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, handlers: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {
			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {
			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle, false );
	}
};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&
				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && e.preventDefault ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && e.stopPropagation ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && e.stopImmediatePropagation ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// Support: Chrome 15+
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// Support: Firefox, Chrome, Safari
// Create "bubbling" focus and blur events
if ( !support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				data_priv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = data_priv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					data_priv.remove( doc, fix );

				} else {
					data_priv.access( doc, fix, attaches );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		var elem = this[0];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
});


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /^$|\/(?:java|ecma)script/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,

	// We have to close these tags to support XHTML (#13200)
	wrapMap = {

		// Support: IE9
		option: [ 1, "<select multiple='multiple'>", "</select>" ],

		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: 1.x compatibility
// Manipulating tables requires a tbody
function manipulationTarget( elem, content ) {
	return jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ?

		elem.getElementsByTagName("tbody")[0] ||
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :
		elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute("type");
	}

	return elem;
}

// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		data_priv.set(
			elems[ i ], "globalEval", !refElements || data_priv.get( refElements[ i ], "globalEval" )
		);
	}
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( data_priv.hasData( src ) ) {
		pdataOld = data_priv.access( src );
		pdataCur = data_priv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( data_user.hasData( src ) ) {
		udataOld = data_user.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		data_user.set( dest, udataCur );
	}
}

function getAll( context, tag ) {
	var ret = context.getElementsByTagName ? context.getElementsByTagName( tag || "*" ) :
			context.querySelectorAll ? context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	buildFragment: function( elems, context, scripts, selection ) {
		var elem, tmp, tag, wrap, contains, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( jQuery.type( elem ) === "object" ) {
					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement("div") );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + elem.replace( rxhtmlTag, "<$1></$2>" ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					// Support: QtWebKit, PhantomJS
					// push.apply(_, arraylike) throws on ancient WebKit
					jQuery.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( (elem = nodes[ i++ ]) ) {

			// #4087 - If origin and destination elements are the same, and this is
			// that element, do not do anything
			if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {
				continue;
			}

			contains = jQuery.contains( elem.ownerDocument, elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( contains ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( (elem = tmp[ j++ ]) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	},

	cleanData: function( elems ) {
		var data, elem, type, key,
			special = jQuery.event.special,
			i = 0;

		for ( ; (elem = elems[ i ]) !== undefined; i++ ) {
			if ( jQuery.acceptData( elem ) ) {
				key = elem[ data_priv.expando ];

				if ( key && (data = data_priv.cache[ key ]) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}
					if ( data_priv.cache[ key ] ) {
						// Discard any remaining `private` data
						delete data_priv.cache[ key ];
					}
				}
			}
			// Discard any remaining `user` data
			delete data_user.cache[ elem[ data_user.expando ] ];
		}
	}
});

jQuery.fn.extend({
	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each(function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				});
		}, null, value, arguments.length );
	},

	append: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		});
	},

	before: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		});
	},

	after: function() {
		return this.domManip( arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		});
	},

	remove: function( selector, keepData /* Internal Use Only */ ) {
		var elem,
			elems = selector ? jQuery.filter( selector, this ) : this,
			i = 0;

		for ( ; (elem = elems[i]) != null; i++ ) {
			if ( !keepData && elem.nodeType === 1 ) {
				jQuery.cleanData( getAll( elem ) );
			}

			if ( elem.parentNode ) {
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {
					setGlobalEval( getAll( elem, "script" ) );
				}
				elem.parentNode.removeChild( elem );
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map(function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var arg = arguments[ 0 ];

		// Make the changes, replacing each context element with the new content
		this.domManip( arguments, function( elem ) {
			arg = this.parentNode;

			jQuery.cleanData( getAll( this ) );

			if ( arg ) {
				arg.replaceChild( elem, this );
			}
		});

		// Force removal if there was no new content (e.g., from empty arguments)
		return arg && (arg.length || arg.nodeType) ? this : this.remove();
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, callback ) {

		// Flatten any nested arrays
		args = concat.apply( [], args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = this.length,
			set = this,
			iNoClone = l - 1,
			value = args[ 0 ],
			isFunction = jQuery.isFunction( value );

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( isFunction ||
				( l > 1 && typeof value === "string" &&
					!support.checkClone && rchecked.test( value ) ) ) {
			return this.each(function( index ) {
				var self = set.eq( index );
				if ( isFunction ) {
					args[ 0 ] = value.call( this, index, self.html() );
				}
				self.domManip( args, callback );
			});
		}

		if ( l ) {
			fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, this );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							// Support: QtWebKit
							// jQuery.merge because push.apply(_, arraylike) throws
							jQuery.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( this[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!data_priv.access( node, "globalEval" ) && jQuery.contains( doc, node ) ) {

							if ( node.src ) {
								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery._evalUrl ) {
									jQuery._evalUrl( node.src );
								}
							} else {
								jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
							}
						}
					}
				}
			}
		}

		return this;
	}
});

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
});


var iframe,
	elemdisplay = {};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */
// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var style,
		elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		// getDefaultComputedStyle might be reliably used only on attached element
		display = window.getDefaultComputedStyle && ( style = window.getDefaultComputedStyle( elem[ 0 ] ) ) ?

			// Use of this method is a temporary fix (more like optimization) until something better comes along,
			// since it was removed from specification and supported only in FF
			style.display : jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = (iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" )).appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = (/^margin/);

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {
		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		if ( elem.ownerDocument.defaultView.opener ) {
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );
		}

		return window.getComputedStyle( elem, null );
	};



function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];
	}

	if ( computed ) {

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// Support: iOS < 6
		// A tribute to the "awesome hack by Dean Edwards"
		// iOS < 6 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
		// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
		if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?
		// Support: IE
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {
	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {
				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return (this.get = hookFn).apply( this, arguments );
		}
	};
}


(function() {
	var pixelPositionVal, boxSizingReliableVal,
		docElem = document.documentElement,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;" +
		"position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computePixelPositionAndBoxSizingReliable() {
		div.style.cssText =
			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +
			"border:1px;padding:1px;width:4px;position:absolute";
		div.innerHTML = "";
		docElem.appendChild( container );

		var divStyle = window.getComputedStyle( div, null );
		pixelPositionVal = divStyle.top !== "1%";
		boxSizingReliableVal = divStyle.width === "4px";

		docElem.removeChild( container );
	}

	// Support: node.js jsdom
	// Don't assume that getComputedStyle is a property of the global object
	if ( window.getComputedStyle ) {
		jQuery.extend( support, {
			pixelPosition: function() {

				// This test is executed only once but we still do memoizing
				// since we can use the boxSizingReliable pre-computing.
				// No need to check if the test was already performed, though.
				computePixelPositionAndBoxSizingReliable();
				return pixelPositionVal;
			},
			boxSizingReliable: function() {
				if ( boxSizingReliableVal == null ) {
					computePixelPositionAndBoxSizingReliable();
				}
				return boxSizingReliableVal;
			},
			reliableMarginRight: function() {

				// Support: Android 2.3
				// Check if div with explicit width and no margin-right incorrectly
				// gets computed margin-right based on width of container. (#3333)
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// This support function is only executed once so no memoizing is needed.
				var ret,
					marginDiv = div.appendChild( document.createElement( "div" ) );

				// Reset CSS: box-sizing; display; margin; border; padding
				marginDiv.style.cssText = div.style.cssText =
					// Support: Firefox<29, Android 2.3
					// Vendor-prefix box-sizing
					"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +
					"box-sizing:content-box;display:block;margin:0;border:0;padding:0";
				marginDiv.style.marginRight = marginDiv.style.width = "0";
				div.style.width = "1px";
				docElem.appendChild( container );

				ret = !parseFloat( window.getComputedStyle( marginDiv, null ).marginRight );

				docElem.removeChild( container );
				div.removeChild( marginDiv );

				return ret;
			}
		});
	}
})();


// A method for quickly swapping in/out CSS properties to get correct calculations.
jQuery.swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var
	// Swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rnumsplit = new RegExp( "^(" + pnum + ")(.*)$", "i" ),
	rrelNum = new RegExp( "^([+-])=(" + pnum + ")", "i" ),

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ];

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[0].toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {
			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = data_priv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = data_priv.access( elem, "olddisplay", defaultDisplay(elem.nodeName) );
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				data_priv.set( elem, "olddisplay", hidden ? display : jQuery.css( elem, "display" ) );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend({

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				style[ name ] = value;
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	}
});

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && elem.offsetWidth === 0 ?
					jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					}) :
					getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var styles = extra && getStyles( elem );
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				) : 0
			);
		}
	};
});

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return jQuery.swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});

jQuery.fn.extend({
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each(function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	}
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value ),
				target = tween.cur(),
				parts = rfxnum.exec( value ),
				unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

				// Starting value computation is required for potential unit mismatches
				start = ( jQuery.cssNumber[ prop ] || unit !== "px" && +target ) &&
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),
				scale = 1,
				maxIterations = 20;

			if ( start && start[ 3 ] !== unit ) {
				// Trust units reported by jQuery.css
				unit = unit || start[ 3 ];

				// Make sure we update the tween properties later on
				parts = parts || [];

				// Iteratively approximate from a nonzero starting point
				start = +target || 1;

				do {
					// If previous iteration zeroed out, double until we get *something*.
					// Use string for doubling so we don't accidentally see scale as unchanged below
					scale = scale || ".5";

					// Adjust and apply
					start = start / scale;
					jQuery.style( tween.elem, prop, start + unit );

				// Update scale, tolerating zero or NaN from tween.cur(),
				// break the loop if scale is unchanged or perfect, or if we've just had enough
				} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
			}

			// Update tween properties
			if ( parts ) {
				start = tween.start = +start || +target || 0;
				tween.unit = unit;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[ 1 ] ?
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :
					+parts[ 2 ];
			}

			return tween;
		} ]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	});
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( (tween = collection[ index ].call( animation, prop, value )) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = data_priv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// Ensure the complete handler is called before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			data_priv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always(function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		});
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = data_priv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;

			data_priv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( (display === "none" ? defaultDisplay( elem.nodeName ) : display) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// Don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || data_priv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = data_priv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each(function() {
			var index,
				data = data_priv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		});
	}
});

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;

jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = setTimeout( next, time );
		hooks.stop = function() {
			clearTimeout( timeout );
		};
	});
};


(function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
})();


var nodeHook, boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend({
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	}
});

jQuery.extend({
	attr: function( elem, name, value ) {
		var hooks, ret,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === strundefined ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );

			} else if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {
			ret = jQuery.find.attr( elem, name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( (name = attrNames[i++]) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {
					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	}
});

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {
			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
});




var rfocusable = /^(?:input|select|textarea|button)$/i;

jQuery.fn.extend({
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each(function() {
			delete this[ jQuery.propFix[ name ] || name ];
		});
	}
});

jQuery.extend({
	propFix: {
		"for": "htmlFor",
		"class": "className"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			return hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?
				ret :
				( elem[ name ] = value );

		} else {
			return hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ?
				ret :
				elem[ name ];
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				return elem.hasAttribute( "tabindex" ) || rfocusable.test( elem.nodeName ) || elem.href ?
					elem.tabIndex :
					-1;
			}
		}
	}
});

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each([
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
});




var rclass = /[\t\r\n\f]/g;

jQuery.fn.extend({
	addClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call( this, j, this.className ) );
			});
		}

		if ( proceed ) {
			// The disjunction here is for better compressibility (see removeClass)
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					" "
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, clazz, j, finalValue,
			proceed = arguments.length === 0 || typeof value === "string" && value,
			i = 0,
			len = this.length;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call( this, j, this.className ) );
			});
		}
		if ( proceed ) {
			classes = ( value || "" ).match( rnotwhite ) || [];

			for ( ; i < len; i++ ) {
				elem = this[ i ];
				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( elem.className ?
					( " " + elem.className + " " ).replace( rclass, " " ) :
					""
				);

				if ( cur ) {
					j = 0;
					while ( (clazz = classes[j++]) ) {
						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) >= 0 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = value ? jQuery.trim( cur ) : "";
					if ( elem.className !== finalValue ) {
						elem.className = finalValue;
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// Toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					classNames = value.match( rnotwhite ) || [];

				while ( (className = classNames[ i++ ]) ) {
					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( type === strundefined || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					data_priv.set( this, "__className__", this.className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				this.className = this.className || value === false ? "" : data_priv.get( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	}
});




var rreturn = /\r/g;

jQuery.fn.extend({
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// Handle most common string cases
					ret.replace(rreturn, "") :
					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :
					// Support: IE10-11+
					// option.text throws exceptions (#14686, #14858)
					jQuery.trim( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE6-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ? !option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
});

// Radios and checkboxes getter/setter
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute("value") === null ? "on" : elem.value;
		};
	}
});




// Return jQuery for attributes-only inclusion


jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
});

jQuery.fn.extend({
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	}
});


var nonce = jQuery.now();

var rquery = (/\?/);



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, tmp;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		tmp = new DOMParser();
		xml = tmp.parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Document location
	ajaxLocation = window.location.href,

	// Segment location into parts
	ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			while ( (dataType = dataTypes[i++]) ) {
				// Prepend if requested
				if ( dataType[0] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					(structure[ dataType ] = structure[ dataType ] || []).unshift( func );

				// Otherwise append
				} else {
					(structure[ dataType ] = structure[ dataType ] || []).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {
				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		});
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s[ "throws" ] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: ajaxLocation,
		type: "GET",
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,
			// URL without anti-cache param
			cacheURL,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks("once memory"),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( (match = rheaders.exec( responseHeadersString )) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {
								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {
							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" )
			.replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? "80" : "443" ) ) !==
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? "80" : "443" ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger("ajaxStart");
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout(function() {
					jqXHR.abort("timeout");
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader("etag");
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {
				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger("ajaxStop");
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		});
	};
});


jQuery._evalUrl = function( url ) {
	return jQuery.ajax({
		url: url,
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	});
};


jQuery.fn.extend({
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapAll( html.call(this, i) );
			});
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function( i ) {
				jQuery( this ).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	}
});


jQuery.expr.filters.hidden = function( elem ) {
	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	return elem.offsetWidth <= 0 && elem.offsetHeight <= 0;
};
jQuery.expr.filters.visible = function( elem ) {
	return !jQuery.expr.filters.hidden( elem );
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// Item is non-scalar (array or object), encode its numeric index.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function() {
			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		})
		.filter(function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		})
		.map(function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});


jQuery.ajaxSettings.xhr = function() {
	try {
		return new XMLHttpRequest();
	} catch( e ) {}
};

var xhrId = 0,
	xhrCallbacks = {},
	xhrSuccessStatus = {
		// file protocol always yields status code 0, assume 200
		0: 200,
		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

// Support: IE9
// Open requests must be manually aborted on unload (#5280)
// See https://support.microsoft.com/kb/2856746 for more info
if ( window.attachEvent ) {
	window.attachEvent( "onunload", function() {
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]();
		}
	});
}

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport(function( options ) {
	var callback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr(),
					id = ++xhrId;

				xhr.open( options.type, options.url, options.async, options.username, options.password );

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers["X-Requested-With"] ) {
					headers["X-Requested-With"] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							delete xhrCallbacks[ id ];
							callback = xhr.onload = xhr.onerror = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(
									// file: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,
									// Support: IE9
									// Accessing binary-data responseText throws an exception
									// (#11426)
									typeof xhr.responseText === "string" ? {
										text: xhr.responseText
									} : undefined,
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onerror = callback("error");

				// Create the abort callback
				callback = xhrCallbacks[ id ] = callback("abort");

				try {
					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {
					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /(?:java|ecma)script/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {
	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery("<script>").prop({
					async: true,
					charset: s.scriptCharset,
					src: s.url
				}).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
});




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" && !( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});




// data: string of html
// context (optional): If specified, the fragment will be created in this context, defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}
	context = context || document;

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[1] ) ];
	}

	parsed = jQuery.buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax({
			url: url,

			// if "type" variable is undefined, then "GET" method will be used
			type: type,
			dataType: "html",
			data: params
		}).done(function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		}).complete( callback && function( jqXHR, status ) {
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
		});
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
});




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep(jQuery.timers, function( fn ) {
		return elem === fn.elem;
	}).length;
};




var docElem = window.document.documentElement;

/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf("auto") > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend({
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each(function( i ) {
					jQuery.offset.setOffset( this, options, i );
				});
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		// Support: BlackBerry 5, iOS 3 (original iPhone)
		// If we don't have gBCR, just use 0,0 rather than error
		if ( typeof elem.getBoundingClientRect !== strundefined ) {
			box = elem.getBoundingClientRect();
		}
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {
			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {
			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true );
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true );
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || docElem;

			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && jQuery.css( offsetParent, "position" ) === "static" ) ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || docElem;
		});
	}
});

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : window.pageXOffset,
					top ? val : window.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

// Support: Safari<7+, Chrome<37+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );
				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
});


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});


// The number of elements contained in the matched element set
jQuery.fn.size = function() {
	return this.length;
};

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	});
}




var
	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === strundefined ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;

}));

},{}],231:[function(require,module,exports){
// Domain Public by Eric Wendelin http://www.eriwen.com/ (2008)
//                  Luke Smith http://lucassmith.name/ (2008)
//                  Loic Dachary <loic@dachary.org> (2008)
//                  Johan Euphrosine <proppy@aminche.com> (2008)
//                  Oyvind Sean Kinsey http://kinsey.no/blog (2010)
//                  Victor Homyakov <victor-homyakov@users.sourceforge.net> (2010)
/*global module, exports, define, ActiveXObject*/
(function(global, factory) {
    if (typeof exports === 'object') {
        // Node
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // Browser globals
        global.printStackTrace = factory();
    }
}(this, function() {
    /**
     * Main function giving a function stack trace with a forced or passed in Error
     *
     * @cfg {Error} e The error to create a stacktrace from (optional)
     * @cfg {Boolean} guess If we should try to resolve the names of anonymous functions
     * @return {Array} of Strings with functions, lines, files, and arguments where possible
     */
    function printStackTrace(options) {
        options = options || {guess: true};
        var ex = options.e || null, guess = !!options.guess, mode = options.mode || null;
        var p = new printStackTrace.implementation(), result = p.run(ex, mode);
        return (guess) ? p.guessAnonymousFunctions(result) : result;
    }

    printStackTrace.implementation = function() {
    };

    printStackTrace.implementation.prototype = {
        /**
         * @param {Error} [ex] The error to create a stacktrace from (optional)
         * @param {String} [mode] Forced mode (optional, mostly for unit tests)
         */
        run: function(ex, mode) {
            ex = ex || this.createException();
            mode = mode || this.mode(ex);
            if (mode === 'other') {
                return this.other(arguments.callee);
            } else {
                return this[mode](ex);
            }
        },

        createException: function() {
            try {
                this.undef();
            } catch (e) {
                return e;
            }
        },

        /**
         * Mode could differ for different exception, e.g.
         * exceptions in Chrome may or may not have arguments or stack.
         *
         * @return {String} mode of operation for the exception
         */
        mode: function(e) {
            if (typeof window !== 'undefined' && window.navigator.userAgent.indexOf('PhantomJS') > -1) {
                return 'phantomjs';
            }

            if (e['arguments'] && e.stack) {
                return 'chrome';
            }

            if (e.stack && e.sourceURL) {
                return 'safari';
            }

            if (e.stack && e.number) {
                return 'ie';
            }

            if (e.stack && e.fileName) {
                return 'firefox';
            }

            if (e.message && e['opera#sourceloc']) {
                // e.message.indexOf("Backtrace:") > -1 -> opera9
                // 'opera#sourceloc' in e -> opera9, opera10a
                // !e.stacktrace -> opera9
                if (!e.stacktrace) {
                    return 'opera9'; // use e.message
                }
                if (e.message.indexOf('\n') > -1 && e.message.split('\n').length > e.stacktrace.split('\n').length) {
                    // e.message may have more stack entries than e.stacktrace
                    return 'opera9'; // use e.message
                }
                return 'opera10a'; // use e.stacktrace
            }

            if (e.message && e.stack && e.stacktrace) {
                // e.stacktrace && e.stack -> opera10b
                if (e.stacktrace.indexOf("called from line") < 0) {
                    return 'opera10b'; // use e.stacktrace, format differs from 'opera10a'
                }
                // e.stacktrace && e.stack -> opera11
                return 'opera11'; // use e.stacktrace, format differs from 'opera10a', 'opera10b'
            }

            if (e.stack && !e.fileName) {
                // Chrome 27 does not have e.arguments as earlier versions,
                // but still does not have e.fileName as Firefox
                return 'chrome';
            }

            return 'other';
        },

        /**
         * Given a context, function name, and callback function, overwrite it so that it calls
         * printStackTrace() first with a callback and then runs the rest of the body.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to instrument
         * @param {Function} callback function to call with a stack trace on invocation
         */
        instrumentFunction: function(context, functionName, callback) {
            context = context || window;
            var original = context[functionName];
            context[functionName] = function instrumented() {
                callback.call(this, printStackTrace().slice(4));
                return context[functionName]._instrumented.apply(this, arguments);
            };
            context[functionName]._instrumented = original;
        },

        /**
         * Given a context and function name of a function that has been
         * instrumented, revert the function to it's original (non-instrumented)
         * state.
         *
         * @param {Object} context of execution (e.g. window)
         * @param {String} functionName to de-instrument
         */
        deinstrumentFunction: function(context, functionName) {
            if (context[functionName].constructor === Function &&
                context[functionName]._instrumented &&
                context[functionName]._instrumented.constructor === Function) {
                context[functionName] = context[functionName]._instrumented;
            }
        },

        /**
         * Given an Error object, return a formatted Array based on Chrome's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        chrome: function(e) {
            return (e.stack + '\n')
                .replace(/^[\s\S]+?\s+at\s+/, ' at ') // remove message
                .replace(/^\s+(at eval )?at\s+/gm, '') // remove 'at' and indentation
                .replace(/^([^\(]+?)([\n$])/gm, '{anonymous}() ($1)$2')
                .replace(/^Object.<anonymous>\s*\(([^\)]+)\)/gm, '{anonymous}() ($1)')
                .replace(/^(.+) \((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(0, -1);
        },

        /**
         * Given an Error object, return a formatted Array based on Safari's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        safari: function(e) {
            return e.stack.replace(/\[native code\]\n/m, '')
                .replace(/^(?=\w+Error\:).*$\n/m, '')
                .replace(/^@/gm, '{anonymous}()@')
                .split('\n');
        },

        /**
         * Given an Error object, return a formatted Array based on IE's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        ie: function(e) {
            return e.stack
                .replace(/^\s*at\s+(.*)$/gm, '$1')
                .replace(/^Anonymous function\s+/gm, '{anonymous}() ')
                .replace(/^(.+)\s+\((.+)\)$/gm, '$1@$2')
                .split('\n')
                .slice(1);
        },

        /**
         * Given an Error object, return a formatted Array based on Firefox's stack string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        firefox: function(e) {
            return e.stack.replace(/(?:\n@:0)?\s+$/m, '')
                .replace(/^(?:\((\S*)\))?@/gm, '{anonymous}($1)@')
                .split('\n');
        },

        opera11: function(e) {
            var ANON = '{anonymous}', lineRE = /^.*line (\d+), column (\d+)(?: in (.+))? in (\S+):$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var location = match[4] + ':' + match[1] + ':' + match[2];
                    var fnName = match[3] || "global code";
                    fnName = fnName.replace(/<anonymous function: (\S+)>/, "$1").replace(/<anonymous function>/, ANON);
                    result.push(fnName + '@' + location + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        opera10b: function(e) {
            // "<anonymous function: run>([arguments not available])@file://localhost/G:/js/stacktrace.js:27\n" +
            // "printStackTrace([arguments not available])@file://localhost/G:/js/stacktrace.js:18\n" +
            // "@file://localhost/G:/js/test/functional/testcase1.html:15"
            var lineRE = /^(.*)@(.+):(\d+)$/;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i++) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[1] ? (match[1] + '()') : "global code";
                    result.push(fnName + '@' + match[2] + ':' + match[3]);
                }
            }

            return result;
        },

        /**
         * Given an Error object, return a formatted Array based on Opera 10's stacktrace string.
         *
         * @param e - Error object to inspect
         * @return Array<String> of function calls, files and line numbers
         */
        opera10a: function(e) {
            // "  Line 27 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 11 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html: In function foo\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
            var lines = e.stacktrace.split('\n'), result = [];

            for (var i = 0, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    var fnName = match[3] || ANON;
                    result.push(fnName + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        // Opera 7.x-9.2x only!
        opera9: function(e) {
            // "  Line 43 of linked script file://localhost/G:/js/stacktrace.js\n"
            // "  Line 7 of inline#1 script in file://localhost/G:/js/test/functional/testcase1.html\n"
            var ANON = '{anonymous}', lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
            var lines = e.message.split('\n'), result = [];

            for (var i = 2, len = lines.length; i < len; i += 2) {
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(ANON + '()@' + match[2] + ':' + match[1] + ' -- ' + lines[i + 1].replace(/^\s+/, ''));
                }
            }

            return result;
        },

        phantomjs: function(e) {
            var ANON = '{anonymous}', lineRE = /(\S+) \((\S+)\)/i;
            var lines = e.stack.split('\n'), result = [];

            for (var i = 1, len = lines.length; i < len; i++) {
                lines[i] = lines[i].replace(/^\s+at\s+/gm, '');
                var match = lineRE.exec(lines[i]);
                if (match) {
                    result.push(match[1] + '()@' + match[2]);
                }
                else {
                    result.push(ANON + '()@' + lines[i]);
                }
            }

            return result;
        },

        // Safari 5-, IE 9-, and others
        other: function(curr) {
            var ANON = '{anonymous}', fnRE = /function(?:\s+([\w$]+))?\s*\(/, stack = [], fn, args, maxStackSize = 10;
            var slice = Array.prototype.slice;
            while (curr && stack.length < maxStackSize) {
                fn = fnRE.test(curr.toString()) ? RegExp.$1 || ANON : ANON;
                try {
                    args = slice.call(curr['arguments'] || []);
                } catch (e) {
                    args = ['Cannot access arguments: ' + e];
                }
                stack[stack.length] = fn + '(' + this.stringifyArguments(args) + ')';
                try {
                    curr = curr.caller;
                } catch (e) {
                    stack[stack.length] = 'Cannot access caller: ' + e;
                    break;
                }
            }
            return stack;
        },

        /**
         * Given arguments array as a String, substituting type names for non-string types.
         *
         * @param {Arguments,Array} args
         * @return {String} stringified arguments
         */
        stringifyArguments: function(args) {
            var result = [];
            var slice = Array.prototype.slice;
            for (var i = 0; i < args.length; ++i) {
                var arg = args[i];
                if (arg === undefined) {
                    result[i] = 'undefined';
                } else if (arg === null) {
                    result[i] = 'null';
                } else if (arg.constructor) {
                    // TODO constructor comparison does not work for iframes
                    if (arg.constructor === Array) {
                        if (arg.length < 3) {
                            result[i] = '[' + this.stringifyArguments(arg) + ']';
                        } else {
                            result[i] = '[' + this.stringifyArguments(slice.call(arg, 0, 1)) + '...' + this.stringifyArguments(slice.call(arg, -1)) + ']';
                        }
                    } else if (arg.constructor === Object) {
                        result[i] = '#object';
                    } else if (arg.constructor === Function) {
                        result[i] = '#function';
                    } else if (arg.constructor === String) {
                        result[i] = '"' + arg + '"';
                    } else if (arg.constructor === Number) {
                        result[i] = arg;
                    } else {
                        result[i] = '?';
                    }
                }
            }
            return result.join(',');
        },

        sourceCache: {},

        /**
         * @return {String} the text from a given URL
         */
        ajax: function(url) {
            var req = this.createXMLHTTPObject();
            if (req) {
                try {
                    req.open('GET', url, false);
                    //req.overrideMimeType('text/plain');
                    //req.overrideMimeType('text/javascript');
                    req.send(null);
                    //return req.status == 200 ? req.responseText : '';
                    return req.responseText;
                } catch (e) {
                }
            }
            return '';
        },

        /**
         * Try XHR methods in order and store XHR factory.
         *
         * @return {XMLHttpRequest} XHR function or equivalent
         */
        createXMLHTTPObject: function() {
            var xmlhttp, XMLHttpFactories = [
                function() {
                    return new XMLHttpRequest();
                }, function() {
                    return new ActiveXObject('Msxml2.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Msxml3.XMLHTTP');
                }, function() {
                    return new ActiveXObject('Microsoft.XMLHTTP');
                }
            ];
            for (var i = 0; i < XMLHttpFactories.length; i++) {
                try {
                    xmlhttp = XMLHttpFactories[i]();
                    // Use memoization to cache the factory
                    this.createXMLHTTPObject = XMLHttpFactories[i];
                    return xmlhttp;
                } catch (e) {
                }
            }
        },

        /**
         * Given a URL, check if it is in the same domain (so we can get the source
         * via Ajax).
         *
         * @param url {String} source url
         * @return {Boolean} False if we need a cross-domain request
         */
        isSameDomain: function(url) {
            return typeof location !== "undefined" && url.indexOf(location.hostname) !== -1; // location may not be defined, e.g. when running from nodejs.
        },

        /**
         * Get source code from given URL if in the same domain.
         *
         * @param url {String} JS source URL
         * @return {Array} Array of source code lines
         */
        getSource: function(url) {
            // TODO reuse source from script tags?
            if (!(url in this.sourceCache)) {
                this.sourceCache[url] = this.ajax(url).split('\n');
            }
            return this.sourceCache[url];
        },

        guessAnonymousFunctions: function(stack) {
            for (var i = 0; i < stack.length; ++i) {
                var reStack = /\{anonymous\}\(.*\)@(.*)/,
                    reRef = /^(.*?)(?::(\d+))(?::(\d+))?(?: -- .+)?$/,
                    frame = stack[i], ref = reStack.exec(frame);

                if (ref) {
                    var m = reRef.exec(ref[1]);
                    if (m) { // If falsey, we did not get any file/line information
                        var file = m[1], lineno = m[2], charno = m[3] || 0;
                        if (file && this.isSameDomain(file) && lineno) {
                            var functionName = this.guessAnonymousFunction(file, lineno, charno);
                            stack[i] = frame.replace('{anonymous}', functionName);
                        }
                    }
                }
            }
            return stack;
        },

        guessAnonymousFunction: function(url, lineNo, charNo) {
            var ret;
            try {
                ret = this.findFunctionName(this.getSource(url), lineNo);
            } catch (e) {
                ret = 'getSource failed with url: ' + url + ', exception: ' + e.toString();
            }
            return ret;
        },

        findFunctionName: function(source, lineNo) {
            // FIXME findFunctionName fails for compressed source
            // (more than one function on the same line)
            // function {name}({args}) m[1]=name m[2]=args
            var reFunctionDeclaration = /function\s+([^(]*?)\s*\(([^)]*)\)/;
            // {name} = function ({args}) TODO args capture
            // /['"]?([0-9A-Za-z_]+)['"]?\s*[:=]\s*function(?:[^(]*)/
            var reFunctionExpression = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*function\b/;
            // {name} = eval()
            var reFunctionEvaluation = /['"]?([$_A-Za-z][$_A-Za-z0-9]*)['"]?\s*[:=]\s*(?:eval|new Function)\b/;
            // Walk backwards in the source lines until we find
            // the line which matches one of the patterns above
            var code = "", line, maxLines = Math.min(lineNo, 20), m, commentPos;
            for (var i = 0; i < maxLines; ++i) {
                // lineNo is 1-based, source[] is 0-based
                line = source[lineNo - i - 1];
                commentPos = line.indexOf('//');
                if (commentPos >= 0) {
                    line = line.substr(0, commentPos);
                }
                // TODO check other types of comments? Commented code may lead to false positive
                if (line) {
                    code = line + code;
                    m = reFunctionExpression.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                    m = reFunctionDeclaration.exec(code);
                    if (m && m[1]) {
                        //return m[1] + "(" + (m[2] || "") + ")";
                        return m[1];
                    }
                    m = reFunctionEvaluation.exec(code);
                    if (m && m[1]) {
                        return m[1];
                    }
                }
            }
            return '(?)';
        }
    };

    return printStackTrace;
}));

},{}],232:[function(require,module,exports){
'use strict';

exports.VERSION = '7.0.6';

exports.JID = require('xmpp-jid').JID;
exports.Client = require('./lib/client');


exports.createClient = function (opts) {
    var client = new exports.Client(opts);
    client.use(require('./lib/plugins'));

    return client;
};

},{"./lib/client":233,"./lib/plugins":256,"xmpp-jid":450}],233:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var jxt = require('jxt');
var WildEmitter = require('wildemitter');
var util = require('util');
var BPromise = require('bluebird');
var uuid = require('node-uuid');
var JID = require('xmpp-jid').JID;
var StreamManagement = require('./sm');
var getHostMeta = require('hostmeta');
var SASLFactory = require('saslmechanisms');


var SASL_MECHS = {
    external: require('sasl-external'),
    'scram-sha-1': require('sasl-scram-sha-1'),
    'digest-md5': require('alt-sasl-digest-md5'),
    plain: require('sasl-plain'),
    anonymous: require('sasl-anonymous')
};


function Client(opts) {
    var self = this;

    WildEmitter.call(this);

    opts = opts || {};
    this._initConfig(opts);

    this.stanzas = jxt.getGlobalJXT();

    this.jid = new JID();

    this.stanzas = jxt.createRegistry();
    this.stanzas.use(require('jxt-xmpp-types'));
    this.stanzas.use(require('./stanza/message'));
    this.stanzas.use(require('./stanza/presence'));
    this.stanzas.use(require('./stanza/iq'));
    this.stanzas.use(require('./stanza/error'));
    this.stanzas.use(require('./stanza/streamError'));

    this.use(require('./plugins/features'));
    this.use(require('./plugins/sasl'));
    this.use(require('./plugins/smacks'));
    this.use(require('./plugins/bind'));
    this.use(require('./plugins/session'));

    this.sm = new StreamManagement(this);

    this.transports = {};

    this.use(require('./plugins/websocket'));
    this.use(require('./plugins/oldwebsocket'));
    this.use(require('./plugins/bosh'));


    this.on('stream:data', function (data) {
        var json = data.toJSON();

        if (data._name === 'iq') {
            json._xmlChildCount = 0;
            _.each(data.xml.childNodes, function (child) {
                if (child.nodeType === 1) {
                    json._xmlChildCount += 1;
                }
            });
        }

        self.emit(data._eventname || data._name, json);
        if (data._name === 'message' || data._name === 'presence' || data._name === 'iq') {
            self.sm.handle(json);
            self.emit('stanza', json);
        } else if (data._name === 'smAck') {
            return self.sm.process(json);
        } else if (data._name === 'smRequest') {
            return self.sm.ack();
        }

        if (json.id) {
            self.emit('id:' + json.id, json);
            self.emit(data._name + ':id:' + json.id, json);
        }
    });

    this.on('disconnected', function () {
        if (self.transport) {
            self.transport.off('*');
            delete self.transport;
        }
        self.releaseGroup('connection');
    });

    this.on('iq', function (iq) {
        var iqType = iq.type;
        var xmlChildCount = iq._xmlChildCount;
        delete iq._xmlChildCount;

        var exts = Object.keys(iq);

        if (iq.type === 'get' || iq.type === 'set') {
            // Invalid request
            if (xmlChildCount !== 1) {
                return self.sendIq(iq.errorReply({
                    error: {
                        type: 'modify',
                        condition: 'bad-request'
                    }
                }));
            }

            // Valid request, but we don't have support for the
            // payload data.
            if (!exts.length) {
                return self.sendIq(iq.errorReply({
                    error: {
                        type: 'cancel',
                        condition: 'feature-not-implemented'
                    }
                }));
            }

            var iqEvent = 'iq:' + iqType + ':' + exts[0];
            if (self.callbacks[iqEvent]) {
                self.emit(iqEvent, iq);
            } else {
                // We support the payload data, but there's
                // nothing registered to handle it.
                self.sendIq(iq.errorReply({
                    error: {
                        type: 'cancel',
                        condition: 'feature-not-implemented'
                    }
                }));
            }
        }
    });

    this.on('message', function (msg) {
        if (Object.keys(msg.$body || {}).length) {
            if (msg.type === 'chat' || msg.type === 'normal') {
                self.emit('chat', msg);
            } else if (msg.type === 'groupchat') {
                self.emit('groupchat', msg);
            }
        }
        if (msg.type === 'error') {
            self.emit('message:error', msg);
        }
    });

    this.on('presence', function (pres) {
        var presType = pres.type || 'available';
        if (presType === 'error') {
            presType = 'presence:error';
        }
        self.emit(presType, pres);
    });
}

util.inherits(Client, WildEmitter);

Object.defineProperty(Client.prototype, 'stream', {
    get: function () {
        return this.transport ? this.transport.stream : undefined;
    }
});

Client.prototype._initConfig = function (opts) {
    var self = this;
    var currConfig = this.config || {};

    this.config = _.extend({
        useStreamManagement: true,
        transports: ['websocket', 'bosh'],
        sasl: ['external', 'scram-sha-1', 'digest-md5', 'plain', 'anonymous']
    }, currConfig, opts);

    // Enable SASL authentication mechanisms (and their preferred order)
    // based on user configuration.
    if (!_.isArray(this.config.sasl)) {
        this.config.sasl = [this.config.sasl];
    }

    this.SASLFactory = new SASLFactory();
    this.config.sasl.forEach(function (mech) {
        if (typeof mech === 'string') {
            var existingMech = SASL_MECHS[mech.toLowerCase()];
            if (existingMech) {
                self.SASLFactory.use(existingMech);
            }
        } else {
            self.SASLFactory.use(mech);
        }
    });

    this.config.jid = new JID(this.config.jid);

    if (!this.config.server) {
        this.config.server = this.config.jid.domain;
    }

    if (this.config.password) {
        this.config.credentials = this.config.credentials || {};
        this.config.credentials.password = this.config.password;
        delete this.config.password;
    }

    if (this.config.transport) {
        this.config.transports = [this.config.transport];
    }

    if (!_.isArray(this.config.transports)) {
        this.config.transports = [this.config.transports];
    }
};

Client.prototype.use = function (pluginInit) {
    pluginInit(this, this.stanzas, this.config);
};

Client.prototype.nextId = function () {
    return uuid.v4();
};

Client.prototype.discoverBindings = function (server, cb) {
    getHostMeta(server, function (err, data) {
        if (err) {
            return cb(err, []);
        }

        var results = {
            websocket: [],
            bosh: []
        };
        var links = data.links || [];

        links.forEach(function (link) {
            if (link.href && link.rel === 'urn:xmpp:alt-connections:websocket') {
                results.websocket.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:altconnect:websocket') {
                results.websocket.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:alt-connections:xbosh') {
                results.bosh.push(link.href);
            }
            if (link.href && link.rel === 'urn:xmpp:altconnect:bosh') {
                results.bosh.push(link.href);
            }
        });

        cb(false, results);
    });
};

Client.prototype.getCredentials = function () {
    var creds = this.config.credentials || {};
    var requestedJID = new JID(this.config.jid);

    var username = creds.username || requestedJID.local;
    var server = creds.server || requestedJID.domain;

    var defaultCreds = {
        username: username,
        password: this.config.password,
        server: server,
        host: server,
        realm: server,
        serviceType: 'xmpp',
        serviceName: server
    };

    var result = _.extend(defaultCreds, creds);
    return result;
};

Client.prototype.connect = function (opts, transInfo) {
    var self = this;

    this._initConfig(opts);

    if (transInfo && transInfo.name && transInfo.url) {
        var trans = self.transport = new self.transports[transInfo.name](self.sm, self.stanzas);
        trans.on('*', function (event, data) {
            self.emit(event, data);
        });
        return trans.connect(self.config);
    }

    if (!transInfo && self.config.transports.length === 1) {
        transInfo = {};
        transInfo.name = self.config.transports[0];
        if (transInfo.name === 'websocket' || transInfo.name === 'old-websocket') {
            transInfo.url = self.config.wsURL;
        }
        if (transInfo.name === 'bosh') {
            transInfo.url = self.config.boshURL;
        }
        if (transInfo.name && transInfo.url) {
            return self.connect(null, transInfo);
        }
    }

    return self.discoverBindings(self.config.server, function (err, endpoints) {
        if (err) {
            console.error('Could not find https://' + self.config.server + '/.well-known/host-meta file to discover connection endpoints for the requested transports.');
            return self.disconnect();
        }

        for (var t = 0, tlen = self.config.transports.length; t < tlen; t++) {
            var transport = self.config.transports[t];
            console.log('Checking for %s endpoints', transport);
            for (var i = 0, len = (endpoints[transport] || []).length; i < len; i++) {
                var uri = endpoints[transport][i];
                if (uri.indexOf('wss://') === 0 || uri.indexOf('https://') === 0) {
                    if (transport === 'websocket') {
                        self.config.wsURL = uri;
                    } else {
                        self.config.boshURL = uri;
                    }
                    console.log('Using %s endpoint: %s', transport, uri);
                    return self.connect(null, {
                        name: transport,
                        url: uri
                    });
                } else {
                    console.warn('Discovered unencrypted %s endpoint (%s). Ignoring', transport, uri);
                }
            }
        }
        console.error('No endpoints found for the requested transports.');
        return self.disconnect();
    });
};

Client.prototype.disconnect = function () {
    if (this.sessionStarted) {
        this.releaseGroup('session');
        if (!this.sm.started) {
            // Only emit session:end if we had a session, and we aren't using
            // stream management to keep the session alive.
            this.emit('session:end');
        }
    }
    this.sessionStarted = false;
    this.releaseGroup('connection');
    if (this.transport) {
        this.transport.disconnect();
    } else {
        this.emit('disconnected');
    }
};

Client.prototype.send = function (data) {
    this.sm.track(data);
    if (this.transport) {
        this.transport.send(data);
    }
};

Client.prototype.sendMessage = function (data) {
    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }

    var Message = this.stanzas.getMessage();
    var msg = new Message(data);

    this.emit('message:sent', msg.toJSON());
    this.send(msg);

    return data.id;
};

Client.prototype.sendPresence = function (data) {
    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }
    var Presence = this.stanzas.getPresence();
    this.send(new Presence(data));

    return data.id;
};

Client.prototype.sendIq = function (data, cb) {
    var result, respEvent, allowed, dest;
    var self = this;

    data = data || {};
    if (!data.id) {
        data.id = this.nextId();
    }

    var Iq = this.stanzas.getIq();
    var iq = (!data.toJSON) ? new Iq(data) : data;

    if (data.type === 'error' || data.type === 'result') {
        this.send(iq);
        return;
    }

    dest = new JID(data.to);
    allowed = {};
    allowed[''] = true;
    allowed[dest.full] = true;
    allowed[dest.bare] = true;
    allowed[dest.domain] = true;
    allowed[self.jid.bare] = true;
    allowed[self.jid.domain] = true;

    respEvent = 'iq:id:' + data.id;
    result = new BPromise(function (resolve, reject) {
        var handler = function (res) {
            // Only process result from the correct responder
            if (!allowed[res.from.full]) {
                return;
            }

            // Only process result or error responses, if the responder
            // happened to send us a request using the same ID value at
            // the same time.
            if (res.type !== 'result' && res.type !== 'error') {
                return;
            }

            self.off(respEvent, handler);
            if (!res.error) {
                resolve(res);
            } else {
                reject(res);
            }
        };
        self.on(respEvent, 'session', handler);
    });

    this.send(iq);

    return result.timeout(self.config.timeout * 1000 || 15000)
        .catch(BPromise.TimeoutError, function () {
            throw {
                id: data.id,
                type: 'error',
                error: {
                    condition: 'timeout'
                }
            };
        })
        .nodeify(cb);
};

Client.prototype.sendStreamError = function (data) {
    data = data || {};

    var StreamError = this.stanzas.getStreamError();
    var error = new StreamError(data);

    this.emit('stream:error', error.toJSON());
    this.send(error);
    this.disconnect();
};


module.exports = Client;

},{"./plugins/bind":236,"./plugins/bosh":240,"./plugins/features":251,"./plugins/oldwebsocket":267,"./plugins/sasl":278,"./plugins/session":279,"./plugins/smacks":281,"./plugins/websocket":285,"./sm":286,"./stanza/error":300,"./stanza/iq":309,"./stanza/message":315,"./stanza/presence":321,"./stanza/streamError":339,"alt-sasl-digest-md5":348,"bluebird":363,"hostmeta":365,"jxt":407,"jxt-xmpp-types":406,"node-uuid":420,"sasl-anonymous":422,"sasl-external":424,"sasl-plain":426,"sasl-scram-sha-1":427,"saslmechanisms":447,"underscore":448,"util":165,"wildemitter":449,"xmpp-jid":450}],234:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:attention:0');


    client.getAttention = function (jid, opts) {
        opts = opts || {};
        opts.to = jid;
        opts.type = 'headline';
        opts.attention = true;
        client.sendMessage(opts);
    };

    client.on('message', function (msg) {
        if (msg.attention) {
            client.emit('attention', msg);
        }
    });
};

},{}],235:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/avatar'));

    client.disco.addFeature('urn:xmpp:avatar:metadata+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'urn:xmpp:avatar:metadata') {
            return;
        }

        client.emit('avatar', {
            jid: msg.from,
            source: 'pubsub',
            avatars: msg.event.updated.published[0].avatars
        });
    });

    client.on('presence', function (pres) {
        if (pres.avatarId) {
            client.emit('avatar', {
                jid: pres.from,
                source: 'vcard',
                avatars: [{
                    id: pres.avatarId
                }]
            });
        }
    });

    client.publishAvatar = function (id, data, cb) {
        return this.publish('', 'urn:xmpp:avatar:data', {
            id: id,
            avatarData: data
        }, cb);
    };

    client.useAvatars = function (info, cb) {
        return this.publish('', 'urn:xmpp:avatar:metadata', {
            id: 'current',
            avatars: info
        }, cb);
    };

    client.getAvatar = function (jid, id, cb) {
        return this.getItem(jid, 'urn:xmpp:avatar:data', id, cb);
    };
};

},{"../stanza/avatar":287}],236:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas, config) {
    stanzas.use(require('../stanza/bind'));

    client.registerFeature('bind', 300, function (features, cb) {
        var self = this;

        self.sendIq({
            type: 'set',
            bind: {
                resource: config.resource
            }
        }, function (err, resp) {
            if (err) {
                self.emit('session:error', err);
                return cb('disconnect', 'JID binding failed');
            }

            self.features.negotiated.bind = true;
            self.jid = new JID(resp.bind.jid);
            self.emit('session:bound', self.jid);

            var canStartSession = !features.session || (features.session && features.session.optional);
            if (!self.sessionStarted && canStartSession) {
                self.sessionStarted = true;
                self.emit('session:started', self.jid);
            }
            return cb();
        });
    });

    client.on('disconnected', function () {
        client.sessionStarted = false;
        client.features.negotiated.bind = false;
    });
};

},{"../stanza/bind":288,"xmpp-jid":450}],237:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/blocking'));

    client.disco.addFeature('urn:xmpp:blocking');

    client.block = function (jid, cb) {
        return client.sendIq({
            type: 'set',
            block: {
                jids: [jid]
            }
        }, cb);
    };

    client.unblock = function (jid, cb) {
        return client.sendIq({
            type: 'set',
            unblock: {
                jids: [jid]
            }
        }, cb);
    };

    client.getBlocked = function (cb) {
        return client.sendIq({
            type: 'get',
            blockList: true
        }, cb);
    };

    client.on('iq:set:block', function (iq) {
        client.emit('block', {
            jids: iq.block.jids || []
        });
        client.sendIq(iq.resultReply());
    });

    client.on('iq:set:unblock', function (iq) {
        client.emit('unblock', {
            jids: iq.unblock.jids || []
        });
        client.sendIq(iq.resultReply());
    });
};

},{"../stanza/blocking":289}],238:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bob'));

    client.disco.addFeature('urn:xmpp:bob');

    client.getBits = function (jid, cid, cb) {
        return client.sendIq({
            to: jid,
            type: 'get',
            bob: {
                cid: cid
            }
        }, cb);
    };
};

},{"../stanza/bob":290}],239:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bookmarks'));

    client.getBookmarks = function (cb) {
        return this.getPrivateData({bookmarks: true}, cb);
    };

    client.setBookmarks = function (opts, cb) {
        return this.setPrivateData({bookmarks: opts}, cb);
    };

    client.addBookmark = function (bookmark, cb) {
        bookmark.jid = new JID(bookmark.jid);

        return this.getBookmarks().then(function (res) {
            var bookmarks = res.privateStorage.bookmarks.conferences || [];
            var existing = _.filter(bookmarks, function (bm) {
                return bm.jid.bare === bookmark.jid.bare;
            });

            if (existing.length) {
                _.extend(existing[0], bookmark);
            } else {
                bookmarks.push(bookmark);
            }

            return client.setBookmarks({conferences: bookmarks});
        }).nodeify(cb);
    };

    client.removeBookmark = function (jid, cb) {
        jid = new JID(jid);
        return this.getBookmarks().then(function (res) {
            var bookmarks = res.privateStorage.bookmarks.conferences || [];
            bookmarks = _.filter(bookmarks, function (bm) {
                return jid.bare !== bm.jid.bare;
            });
            return client.setBookmarks({conferences: bookmarks});
        }).nodeify(cb);
    };
};

},{"../stanza/bookmarks":291,"underscore":448,"xmpp-jid":450}],240:[function(require,module,exports){
'use strict';

var BOSHConnection = require('../transports/bosh');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/bosh'));

    client.transports.bosh = BOSHConnection;
};

},{"../stanza/bosh":292,"../transports/bosh":345}],241:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/carbons'));

    client.disco.addFeature('urn:xmpp:carbons:2');

    client.enableCarbons = function (cb) {
        return this.sendIq({
            type: 'set',
            enableCarbons: true
        }, cb);
    };

    client.disableCarbons = function (cb) {
        return this.sendIq({
            type: 'set',
            disableCarbons: true
        }, cb);
    };

    client.on('message', function (msg) {
        if (msg.carbonSent) {
            return client.emit('carbon:sent', msg);
        }
        if (msg.carbonReceived) {
            return client.emit('carbon:received', msg);
        }
    });

    client.on('carbon:*', function (name, carbon) {
        var dir = name.split(':')[1];

        if (carbon.from.bare !== client.jid.bare) {
            return;
        }

        var msg, delay;
        if (dir === 'received') {
            msg = carbon.carbonReceived.forwarded.message;
            delay = carbon.carbonReceived.forwarded.delay;
        } else {
            msg = carbon.carbonSent.forwarded.message;
            delay = carbon.carbonSent.forwarded.delay;
        }

        if (!msg.delay) {
            if (delay) {
                msg.delay.stamp = delay.stamp;
            } else {
                msg.delay = {
                    stamp: new Date(Date.now())
                };
            }
        }

        msg.carbon = true;

        // Treat the carbon copied message however we would
        // have originally treated it ourself.
        if (msg.from.bare === client.jid.bare) {
            client.emit('message:sent', msg);
        } else {
            client.emit('message', msg);
        }
    });
};

},{"../stanza/carbons":294}],242:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('http://jabber.org/protocol/chatstates');

    client.on('message', function (msg) {
        if (msg.chatState) {
            client.emit('chat:state', {
                to: msg.to,
                from: msg.from,
                chatState: msg.chatState
            });
            client.emit('chatState', {
                to: msg.to,
                from: msg.from,
                chatState: msg.chatState
            });
        }
    });
};

},{}],243:[function(require,module,exports){
'use strict';


var NS = 'http://jabber.org/protocol/commands';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/command'));

    client.disco.addFeature(NS);
    client.disco.addItem({
        name: 'Ad-Hoc Commands',
        node: NS
    });


    client.getCommands = function (jid, cb) {
        return client.getDiscoItems(jid, NS, cb);
    };
};

},{"../stanza/command":295}],244:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:message-correct:0');

    client.on('message', function (msg) {
        if (msg.replace) {
            client.emit('replace', msg);
            client.emit('replace:' + msg.id, msg);
        }
    });
};

},{}],245:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/csi'));

    var Active = stanzas.getDefinition('active', 'urn:xmpp:csi');
    var Inactive = stanzas.getDefinition('inactive', 'urn:xmpp:csi');


    client.registerFeature('clientStateIndication', 400, function (features, cb) {
        this.features.negotiated.clientStateIndication = true;
        cb();
    });

    client.markActive = function () {
        if (this.features.negotiated.clientStateIndication) {
            this.send(new Active());
        }
    };

    client.markInactive = function () {
        if (this.features.negotiated.clientStateIndication) {
            this.send(new Inactive());
        }
    };
};

},{"../stanza/csi":296}],246:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/dataforms'));

    client.disco.addFeature('jabber:x:data');
    client.disco.addFeature('urn:xmpp:media-element');
    client.disco.addFeature('http://jabber.org/protocol/xdata-validate');
    client.disco.addFeature('http://jabber.org/protocol/xdata-layout');

    client.on('message', function (msg) {
        if (msg.form) {
            client.emit('dataform', msg);
        }
    });
};

},{"../stanza/dataforms":297}],247:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/delayed'));
    client.disco.addFeature('urn:xmpp:delay');
};

},{"../stanza/delayed":298}],248:[function(require,module,exports){
(function (Buffer){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;
var hashes = require('iana-hashes');


function generateVerString(info, hash) {
    var S = '';
    var features = info.features.sort();
    var identities = [];
    var formTypes = {};
    var formOrder = [];

    _.forEach(info.identities, function (identity) {
        identities.push([
            identity.category || '',
            identity.type || '',
            identity.lang || '',
            identity.name || ''
        ].join('/'));
    });

    identities.sort();

    var idLen = identities.length;
    var featureLen = features.length;

    identities = _.unique(identities, true);
    features = _.unique(features, true);

    if (featureLen !== features.length || idLen !== identities.length) {
        return false;
    }


    S += identities.join('<') + '<';
    S += features.join('<') + '<';


    var illFormed = false;
    _.forEach(info.extensions, function (ext) {
        var fields = ext.fields;
        for (var i = 0, len = fields.length; i < len; i++) {
            if (fields[i].name === 'FORM_TYPE' && fields[i].type === 'hidden') {
                var name = fields[i].value;
                if (formTypes[name]) {
                    illFormed = true;
                    return;
                }
                formTypes[name] = ext;
                formOrder.push(name);
                return;
            }
        }
    });
    if (illFormed) {
        return false;
    }

    formOrder.sort();

    _.forEach(formOrder, function (name) {
        var ext = formTypes[name];
        var fields = {};
        var fieldOrder = [];

        S += '<' + name;

        _.forEach(ext.fields, function (field) {
            var fieldName = field.name;
            if (fieldName !== 'FORM_TYPE') {
                var values = field.value || '';
                if (typeof values !== 'object') {
                    values = values.split('\n');
                }
                fields[fieldName] = values.sort();
                fieldOrder.push(fieldName);
            }
        });

        fieldOrder.sort();

        _.forEach(fieldOrder, function (fieldName) {
            S += '<' + fieldName;
            _.forEach(fields[fieldName], function (val) {
                S += '<' + val;
            });
        });
    });

    var ver = hashes.createHash(hash).update(new Buffer(S, 'utf8')).digest('base64');
    var padding = 4 - ver.length % 4;
    if (padding === 4) {
        padding = 0;
    }

    for (var i = 0; i < padding; i++) {
        ver += '=';
    }
    return ver;
}

function verifyVerString(info, hash, check) {
    var computed = generateVerString(info, hash);
    return computed && computed === check;
}


function Disco() {
    this.features = {};
    this.identities = {};
    this.extensions = {};
    this.items = {};
    this.caps = {};
}

Disco.prototype = {
    constructor: {
        value: Disco
    },
    addFeature: function (feature, node) {
        node = node || '';
        if (!this.features[node]) {
            this.features[node] = [];
        }
        this.features[node].push(feature);
    },
    addIdentity: function (identity, node) {
        node = node || '';
        if (!this.identities[node]) {
            this.identities[node] = [];
        }
        this.identities[node].push(identity);
    },
    addItem: function (item, node) {
        node = node || '';
        if (!this.items[node]) {
            this.items[node] = [];
        }
        this.items[node].push(item);
    },
    addExtension: function (form, node) {
        node = node || '';
        if (!this.extensions[node]) {
            this.extensions[node] = [];
        }
        this.extensions[node].push(form);
    }
};

module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/disco'));
    stanzas.use(require('../stanza/caps'));
    stanzas.use(require('../stanza/rsm'));


    client.disco = new Disco(client);

    client.disco.addFeature('http://jabber.org/protocol/disco#info');
    client.disco.addFeature('http://jabber.org/protocol/disco#items');
    client.disco.addIdentity({
        category: 'client',
        type: 'web'
    });

    client.registerFeature('caps', 100, function (features, cb) {
        this.emit('disco:caps', {
            from: new JID(this.jid.domain),
            caps: features.caps
        });
        this.features.negotiated.caps = true;
        cb();
    });

    client.getDiscoInfo = function (jid, node, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            discoInfo: {
                node: node
            }
        }, cb);
    };

    client.getDiscoItems = function (jid, node, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            discoItems: {
                node: node
            }
        }, cb);
    };

    client.updateCaps = function () {
        var node = this.config.capsNode || 'https://stanza.io';
        var data = JSON.parse(JSON.stringify({
            identities: this.disco.identities[''],
            features: this.disco.features[''],
            extensions: this.disco.extensions['']
        }));

        var ver = generateVerString(data, 'sha-1');

        this.disco.caps = {
            node: node,
            hash: 'sha-1',
            ver: ver
        };

        node = node + '#' + ver;
        this.disco.features[node] = data.features;
        this.disco.identities[node] = data.identities;
        this.disco.extensions[node] = data.extensions;

        return client.getCurrentCaps();
    };

    client.getCurrentCaps = function () {
        var caps = client.disco.caps;
        if (!caps.ver) {
            return {ver: null, discoInfo: null};
        }

        var node = caps.node + '#' + caps.ver;
        return {
            ver: caps.ver,
            discoInfo: {
                identities: client.disco.identities[node],
                features: client.disco.features[node],
                extensions: client.disco.extensions[node]
            }
        };
    };

    client.on('presence', function (pres) {
        if (pres.caps) {
            client.emit('disco:caps', pres);
        }
    });

    client.on('iq:get:discoInfo', function (iq) {
        var node = iq.discoInfo.node || '';
        var reportedNode = iq.discoInfo.node || '';

        if (node === client.disco.caps.node + '#' + client.disco.caps.ver) {
            reportedNode = node;
            node = '';
        }

        client.sendIq(iq.resultReply({
            discoInfo: {
                node: reportedNode,
                identities: client.disco.identities[node] || [],
                features: client.disco.features[node] || [],
                extensions: client.disco.extensions[node] || []
            }
        }));
    });

    client.on('iq:get:discoItems', function (iq) {
        var node = iq.discoItems.node;
        client.sendIq(iq.resultReply({
            discoItems: {
                node: node,
                items: client.disco.items[node] || []
            }
        }));
    });

    client.verifyVerString = verifyVerString;
    client.generateVerString = generateVerString;

    // Ensure we always have some caps data
    client.updateCaps();
};

}).call(this,require("buffer").Buffer)
},{"../stanza/caps":293,"../stanza/disco":299,"../stanza/rsm":331,"buffer":5,"iana-hashes":368,"underscore":448,"xmpp-jid":450}],249:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('jid\\20escaping');
};

},{}],250:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/extdisco'));

    client.disco.addFeature('urn:xmpp:extdisco:1');

    client.getServices = function (jid, type, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            services: {
                type: type
            }
        }, cb);
    };

    client.getServiceCredentials = function (jid, host, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            credentials: {
                service: {
                    host: host
                }
            }
        }, cb);
    };
};

},{"../stanza/extdisco":301}],251:[function(require,module,exports){
'use strict';

var async = require('async');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/streamFeatures'));

    client.features = {
        negotiated: {},
        order: [],
        handlers: {}
    };

    client.registerFeature = function (name, priority, handler) {
        this.features.order.push({
            priority: priority,
            name: name
        });
        this.features.order.sort(function (a, b) {
            if (a.priority < b.priority) {
                return -1;
            }
            if (a.priority > b.priority) {
                return 1;
            }
            return 0;
        });
        this.features.handlers[name] = handler.bind(client);
    };

    client.on('streamFeatures', function (features) {
        var series = [];
        var negotiated = client.features.negotiated;
        var handlers = client.features.handlers;

        client.features.order.forEach(function (feature) {
            var name = feature.name;
            if (features[name] && handlers[name] && !negotiated[name]) {
                series.push(function (cb) {
                    if (!negotiated[name]) {
                        handlers[name](features, cb);
                    } else {
                        cb();
                    }
                });
            }
        });

        async.series(series, function (cmd, msg) {
            if (cmd === 'restart') {
                client.transport.restart();
            } else if (cmd === 'disconnect') {
                client.emit('stream:error', {
                    condition: 'policy-violation',
                    text: 'Failed to negotiate stream features: ' + msg
                });
                client.disconnect();
            }
        });
    });
};

},{"../stanza/streamFeatures":340,"async":362}],252:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/forwarded'));

    client.disco.addFeature('urn:xmpp:forward:0');
};

},{"../stanza/forwarded":303}],253:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/geoloc'));

    client.disco.addFeature('http://jabber.org/protocol/geoloc');
    client.disco.addFeature('http://jabber.org/protocol/geoloc+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'http://jabber.org/protocol/geoloc') {
            return;
        }

        client.emit('geoloc', {
            jid: msg.from,
            geoloc: msg.event.updated.published[0].geoloc
        });
    });

    client.publishGeoLoc = function (data, cb) {
        return this.publish('', 'http://jabber.org/protocol/geoloc', {
            geoloc: data
        }, cb);
    };
};

},{"../stanza/geoloc":305}],254:[function(require,module,exports){
'use strict';

var hashes = require('iana-hashes');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/hash'));

    client.disco.addFeature('urn:xmpp:hashes:1');

    var names = hashes.getHashes();
    names.forEach(function (name) {
        client.disco.addFeature('urn:xmpp:hash-function-text-names:' + name);
    });
};

},{"../stanza/hash":306,"iana-hashes":368}],255:[function(require,module,exports){
'use strict';


module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:idle:1');
};

},{}],256:[function(require,module,exports){
'use strict';

module.exports = function (client) {
    // We always need this one first
    client.use(require('./disco'));

    client.use(require('./attention'));
    client.use(require('./avatar'));
    client.use(require('./blocking'));
    client.use(require('./bob'));
    client.use(require('./bookmarks'));
    client.use(require('./carbons'));
    client.use(require('./chatstates'));
    client.use(require('./command'));
    client.use(require('./correction'));
    client.use(require('./csi'));
    client.use(require('./dataforms'));
    client.use(require('./delayed'));
    client.use(require('./escaping'));
    client.use(require('./extdisco'));
    client.use(require('./forwarding'));
    client.use(require('./geoloc'));
    client.use(require('./hashes'));
    client.use(require('./idle'));
    client.use(require('./invisible'));
    client.use(require('./jidprep'));
    client.use(require('./jingle'));
    client.use(require('./json'));
    client.use(require('./keepalive'));
    client.use(require('./logging'));
    client.use(require('./mam'));
    client.use(require('./muc'));
    client.use(require('./mood'));
    client.use(require('./nick'));
    client.use(require('./oob'));
    client.use(require('./ping'));
    client.use(require('./private'));
    client.use(require('./psa'));
    client.use(require('./pubsub'));
    client.use(require('./reach'));
    client.use(require('./receipts'));
    client.use(require('./register'));
    client.use(require('./roster'));
    client.use(require('./rtt'));
    client.use(require('./shim'));
    client.use(require('./time'));
    client.use(require('./vcard'));
    client.use(require('./version'));
};

},{"./attention":234,"./avatar":235,"./blocking":237,"./bob":238,"./bookmarks":239,"./carbons":241,"./chatstates":242,"./command":243,"./correction":244,"./csi":245,"./dataforms":246,"./delayed":247,"./disco":248,"./escaping":249,"./extdisco":250,"./forwarding":252,"./geoloc":253,"./hashes":254,"./idle":255,"./invisible":257,"./jidprep":258,"./jingle":259,"./json":260,"./keepalive":261,"./logging":262,"./mam":263,"./mood":264,"./muc":265,"./nick":266,"./oob":268,"./ping":269,"./private":270,"./psa":271,"./pubsub":272,"./reach":273,"./receipts":274,"./register":275,"./roster":276,"./rtt":277,"./shim":280,"./time":282,"./vcard":283,"./version":284}],257:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/visibility'));

    client.goInvisible = function (cb) {
        return this.sendIq({
            type: 'set',
            invisible: true
        }, cb);
    };

    client.goVisible = function (cb) {
        return this.sendIq({
            type: 'set',
            visible: true
        }, cb);
    };
};

},{"../stanza/visibility":344}],258:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/jidprep'));

    client.prepJID = function (jid, cb) {
        return client.sendIq({
            to: client.jid.domain,
            type: 'get',
            jidPrep: jid
        }, cb);
    };
};

},{"../stanza/jidprep":310}],259:[function(require,module,exports){
'use strict';

var Jingle = require('jingle');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/jingle'));
    stanzas.use(require('../stanza/rtp'));
    stanzas.use(require('../stanza/iceUdp'));
    stanzas.use(require('../stanza/file'));


    var jingle = client.jingle = new Jingle();

    jingle.capabilities.forEach(function (cap) {
        client.disco.addFeature(cap);
    });

    var mappedEvents = [
        'outgoing', 'incoming', 'accepted', 'terminated',
        'ringing', 'mute', 'unmute', 'hold', 'resumed'
    ];
    mappedEvents.forEach(function (event) {
        jingle.on(event, function (session, arg1) {
            client.emit('jingle:' + event, session, arg1);
        });
    });

    jingle.on('createdSession', function (session) {
        client.emit('jingle:created', session);
    });

    jingle.on('peerStreamAdded', function (session, stream) {
        client.emit('jingle:remotestream:added', session, stream);
    });

    jingle.on('peerStreamRemoved', function (session, stream) {
        client.emit('jingle:remotestream:removed', session, stream);
    });

    jingle.on('send', function (data) {
        client.sendIq(data, function (err) {
            if (err) {
                client.emit('jingle:error', err);
            }
        });
    });

    client.on('session:bound', function (jid) {
        jingle.jid = jid;
        jingle.selfID = jid.full;
    });

    client.on('iq:set:jingle', function (data) {
        jingle.process(data);
    });

    client.on('unavailable', function (pres) {
        var peer = pres.from.full;
        jingle.endPeerSessions(peer, true);
    });

    client.discoverICEServers = function (cb) {
        return this.getServices(client.config.server).then(function (res) {
            var services = res.services.services;
            var discovered = [];

            for (var i = 0; i < services.length; i++) {
                var service = services[i];
                var ice = {};
                if (service.type === 'stun' || service.type === 'stuns') {
                    ice.url = service.type + ':' + service.host;
                    if (service.port) {
                        ice.url += ':' + service.port;
                    }
                    discovered.push(ice);
                    client.jingle.addICEServer(ice);
                } else if (service.type === 'turn' || service.type === 'turns') {
                    ice.url = service.type + ':' + service.host;
                    if (service.port) {
                        ice.url += ':' + service.port;
                    }
                    if (service.transport && service.transport !== 'udp') {
                        ice.url += '?transport=' + service.transport;
                    }

                    if (service.username) {
                        ice.username = service.username;
                    }
                    if (service.password) {
                        ice.credential = service.password;
                    }
                    discovered.push(ice);
                    client.jingle.addICEServer(ice);
                }
            }

            return discovered;
        }).nodeify(cb);
    };
};

},{"../stanza/file":302,"../stanza/iceUdp":308,"../stanza/jingle":311,"../stanza/rtp":332,"jingle":384}],260:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/json'));
    client.disco.addFeature('urn:xmpp:json:0');
};

},{"../stanza/json":312}],261:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');


function checkConnection(client, timeout) {
    return new BPromise(function (resolve, reject) {
        if (client.sm.started) {
            client.once('stream:management:ack', resolve);
            client.sm.request();
        } else {
            client.ping().then(resolve).catch(function (err) {
                if (err.error && err.error.condition !== 'timeout') {
                    resolve();
                } else {
                    reject();
                }
            });
        }
    }).timeout(timeout * 1000 || 15000);
}


module.exports = function (client) {
    client.enableKeepAlive = function (opts) {
        opts = opts || {};

        // Ping every 5 minutes
        opts.interval = opts.interval || 300;

        // Disconnect if no response in 15 seconds
        opts.timeout = opts.timeout || 15;

        function keepalive() {
            if (client.sessionStarted) {
                checkConnection(client, opts.timeout).catch(function () {
                    client.sendStreamError({
                        condition: 'connection-timeout'
                    });
                });
            }
        }

        client._keepAliveInterval = setInterval(keepalive, opts.interval * 1000);
    };

    client.disableKeepAlive = function () {
        if (client._keepAliveInterval) {
            clearInterval(client._keepAliveInterval);
            delete client._keepAliveInterval;
        }
    };

    client.on('disconnected', function () {
        client.disableKeepAlive();
    });
};

},{"bluebird":363}],262:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/logging'));

    client.disco.addFeature('', 'urn:xmpp:eventlog');

    client.sendLog = function (jid, logData) {
        client.sendMessage({
            to: jid,
            type: 'normal',
            log: logData
        });
    };
};

},{"../stanza/logging":313}],263:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/mam'));

    client.disco.addFeature('urn:xmpp:mam:0');

    client.getHistorySearchForm = function (jid, cb) {
        return client.sendIq({
            to: jid,
            type: 'get',
            mam: true
        }, cb);
    };

    client.searchHistory = function (opts, cb) {
        var self = this;
        var queryid = this.nextId();

        opts = opts || {};
        opts.queryid = queryid;

        var to = opts.jid || opts.to || '';
        delete opts.jid;
        delete opts.to;

        if (!opts.form) {
            opts.form = {};
        }
        opts.form.type = 'submit';
        var fields = opts.form.fields = opts.form.fields || [];

        var defaultFields = ['FORM_TYPE', 'with', 'start', 'end'];
        defaultFields.forEach(function (name) {
            if (opts[name] || name === 'FORM_TYPE') {
                var val = opts[name];
                var isDate = (name === 'start' || name === 'end');
                if (isDate && typeof val !== 'string') {
                    val = val.toISOString();
                }
                if (name === 'FORM_TYPE') {
                    val = 'urn:xmpp:mam:0';
                }

                var existing = false;
                for (var i = 0, len = fields.length; i < len; i++) {
                    if (fields[i].name === name) {
                        continue;
                    }
                }

                if (!existing) {
                    fields.push({
                        name: name,
                        value: val
                    });
                }

                delete opts[name];
            }
        });

        var dest = new JID(to || client.jid.bare);
        var allowed = {};
        allowed[''] = true;
        allowed[dest.full] = true;
        allowed[dest.bare] = true;
        allowed[dest.domain] = true;
        allowed[client.jid.bare] = true;
        allowed[client.jid.domain] = true;

        var results = [];

        this.on('mam:item:' + queryid, 'session', function (msg) {
            if (!allowed[msg.from.full]) {
                return;
            }
            results.push(msg.mamItem);
        });

        var collectResults = new BPromise(function (resolve) {
            self.once('mam:result:' + queryid, 'session', function (msg) {
                if (!allowed[msg.from.full]) {
                    return;
                }
                msg.mamResult.items = results;
                resolve(msg);
            });
        });

        var mamQuery = this.sendIq({
            type: 'set',
            to: to,
            id: queryid,
            mam: opts
        });

        return BPromise.all([mamQuery, collectResults])
            .spread(function (iqRes, mamRes) {
                return mamRes;
            })
            .timeout(self.config.timeout * 1000 || 15000)
            .catch(BPromise.TimeoutError, function () {
                throw {
                    id: queryid,
                    type: 'error',
                    error: {
                        condition: 'timeout'
                    }
                };
            })
            .finally(function () {
                self.off('mam:item:' + queryid);
                self.off('mam:result:' + queryid);
            })
            .nodeify(cb);
    };

    client.getHistoryPreferences = function (cb) {
        return this.sendIq({
            type: 'get',
            mamPrefs: true
        }, cb);
    };

    client.setHistoryPreferences = function (opts, cb) {
        return this.sendIq({
            type: 'set',
            mamPrefs: opts
        }, cb);
    };

    client.on('message', function (msg) {
        if (msg.mamItem) {
            client.emit('mam:item:' + msg.mamItem.queryid, msg);
        }
        if (msg.mamResult) {
            client.emit('mam:result:' + msg.mamResult.queryid, msg);
        }
    });
};

},{"../stanza/mam":314,"bluebird":363,"xmpp-jid":450}],264:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/mood';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/mood'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }

        if (msg.event.updated.node !== NS) {
            return;
        }

        client.emit('mood', {
            jid: msg.from,
            mood: msg.event.updated.published[0].mood
        });
    });

    client.publishMood = function (mood, text, cb) {
        return this.publish('', NS, {
            mood: {
                value: mood,
                text: text
            }
        }, cb);
    };
};

},{"../stanza/mood":316}],265:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var JID = require('xmpp-jid').JID;


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/muc'));
    stanzas.use(require('../stanza/hats'));

    client.disco.addFeature('http://jabber.org/protocol/muc');
    client.disco.addFeature('jabber:x:conference');
    client.disco.addFeature('urn:xmpp:hats:0');

    client.joinedRooms = {};

    function rejoinRooms() {
        _.each(client.joinedRooms, function (nick, room) {
            client.joinedRooms[room] = false;
            client.joinRoom(room, nick);
        });
    }
    client.on('session:started', rejoinRooms);
    client.on('stream:management:resumed', rejoinRooms);

    client.on('message', function (msg) {
        if (msg.muc) {
            if (msg.muc.invite) {
                client.emit('muc:invite', {
                    from: msg.muc.invite.from,
                    room: msg.from,
                    reason: msg.muc.invite.reason,
                    password: msg.muc.password,
                    thread: msg.muc.invite.thread,
                    type: 'mediated'
                });
            }
            if (msg.muc.destroyed) {
                client.emit('muc:destroyed', {
                    room: msg.from,
                    newRoom: msg.muc.destroyed.jid,
                    reason: msg.muc.destroyed.reason,
                    password: msg.muc.password
                });
            }
            if (msg.muc.decline) {
                client.emit('muc:declined', {
                    room: msg.from,
                    from: msg.muc.decline.from,
                    reason: msg.muc.decline.reason
                });
            }
        } else if (msg.mucInvite) {
            client.emit('muc:invite', {
                from: msg.from,
                room: msg.mucInvite.jid,
                reason: msg.mucInvite.reason,
                password: msg.mucInvite.password,
                thread: msg.mucInvite.thread,
                type: 'direct'
            });
        }

        if (msg.type === 'groupchat' && msg.subject) {
            client.emit('muc:subject', msg);
        }
    });

    client.on('presence', function (pres) {
        if (pres.joinMuc && pres.type === 'error') {
            client.emit('muc:error', pres);
        } else if (pres.muc) {
            var isSelf = pres.muc.codes && pres.muc.codes.indexOf('110') >= 0;
            if (pres.type === 'error') {
                client.emit('muc:error', pres);
            } else if (pres.type === 'unavailable') {
                client.emit('muc:unavailable', pres);
                if (isSelf) {
                    client.emit('muc:leave', pres);
                    delete client.joinedRooms[pres.from.bare];
                }
            } else {
                client.emit('muc:available', pres);
                if (isSelf && !client.joinedRooms[pres.from.bare]) {
                    client.emit('muc:join', pres);
                    client.joinedRooms[pres.from.bare] = pres.from.resource;
                }
            }
        }
    });

    client.joinRoom = function (room, nick, opts) {
        opts = opts || {};
        opts.to = room + '/' + nick;
        opts.caps = this.disco.caps;
        opts.joinMuc = opts.joinMuc || {};

        this.sendPresence(opts);
    };

    client.leaveRoom = function (room, nick, opts) {
        opts = opts || {};
        opts.to = room + '/' + nick;
        opts.type = 'unavailable';
        this.sendPresence(opts);
    };

    client.ban = function (room, jid, reason, cb) {
        client.setRoomAffiliation(room, jid, 'outcast', reason, cb);
    };

    client.kick = function (room, nick, reason, cb) {
        client.setRoomRole(room, nick, 'none', reason, cb);
    };

    client.invite = function (room, opts) {
        client.sendMessage({
            to: room,
            muc: {
                invites: opts
            }
        });
    };

    client.directInvite = function (room, opts) {
        opts.jid = room;
        client.sendMessage({
            to: opts.to,
            mucInvite: opts
        });
    };

    client.declineInvite = function (room, sender, reason) {
        client.sendMessage({
            to: room,
            muc: {
                decline: {
                    to: sender,
                    reason: reason
                }
            }
        });
    };

    client.changeNick = function (room, nick) {
        client.sendPresence({
            to: (new JID(room)).bare + '/' + nick
        });
    };

    client.setSubject = function (room, subject) {
        client.sendMessage({
            to: room,
            type: 'groupchat',
            subject: subject
        });
    };

    client.discoverReservedNick = function (room, cb) {
        client.getDiscoInfo(room, 'x-roomuser-item', function (err, res) {
            if (err) {
                return cb(err);
            }
            var ident = res.discoInfo.identities[0] || {};
            cb(null, ident.name);
        });
    };

    client.requestRoomVoice = function (room) {
        client.sendMessage({
            to: room,
            form: {
                fields: [
                    {
                        name: 'FORM_TYPE',
                        value: 'http://jabber.org/protocol/muc#request'
                    },
                    {
                        name: 'muc#role',
                        type: 'text-single',
                        value: 'participant'
                    }
                ]
            }
        });
    };

    client.setRoomAffiliation = function (room, jid, affiliation, reason, cb) {
        return this.sendIq({
            type: 'set',
            to: room,
            mucAdmin: {
                jid: jid,
                affiliation: affiliation,
                reason: reason
            }
        }, cb);
    };

    client.setRoomRole = function (room, nick, role, reason, cb) {
        return this.sendIq({
            type: 'set',
            to: room,
            mucAdmin: {
                nick: nick,
                role: role,
                reason: reason
            }
        }, cb);
    };

    client.getRoomMembers = function (room, opts, cb) {
        return this.sendIq({
            type: 'get',
            to: room,
            mucAdmin: opts
        }, cb);
    };

    client.getRoomConfig = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            mucOwner: true
        }, cb);
    };

    client.configureRoom = function (jid, form, cb) {
        if (!form.type) {
            form.type = 'submit';
        }
        return this.sendIq({
            to: jid,
            type: 'set',
            mucOwner: {
                form: form
            }
        }, cb);
    };

    client.getUniqueRoomName = function (jid, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            mucUnique: true
        }, cb);
    };
};

},{"../stanza/hats":307,"../stanza/muc":317,"underscore":448,"xmpp-jid":450}],266:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/nick';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/nick'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== NS) {
            return;
        }

        client.emit('nick', {
            jid: msg.from,
            nick: msg.event.updated.published[0].nick
        });
    });

    client.publishNick = function (nick, cb) {
        return this.publish('', NS, {
            nick: nick
        }, cb);
    };
};

},{"../stanza/nick":318}],267:[function(require,module,exports){
'use strict';

var OldWSConnection = require('../transports/old-websocket');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/stream'));

    client.transports['old-websocket'] = OldWSConnection;
};

},{"../stanza/stream":338,"../transports/old-websocket":346}],268:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/oob'));
    client.disco.addFeature('jabber:x:oob');
};

},{"../stanza/oob":319}],269:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/ping'));

    client.disco.addFeature('urn:xmpp:ping');

    client.on('iq:get:ping', function (iq) {
        client.sendIq(iq.resultReply());
    });

    client.ping = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            ping: true
        }, cb);
    };
};

},{"../stanza/ping":320}],270:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/private'));

    client.getPrivateData = function (opts, cb) {
        return this.sendIq({
            type: 'get',
            privateStorage: opts
        }, cb);
    };

    client.setPrivateData = function (opts, cb) {
        return this.sendIq({
            type: 'set',
            privateStorage: opts
        }, cb);
    };
};

},{"../stanza/private":322}],271:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/psa'));
    client.disco.addFeature('urn:xmpp:psa');
};

},{"../stanza/psa":323}],272:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/pubsub'));
    stanzas.use(require('../stanza/pubsubOwner'));
    stanzas.use(require('../stanza/pubsubEvents'));
    stanzas.use(require('../stanza/pubsubError'));

    client.on('message', function (msg) {
        if (msg.event) {
            client.emit('pubsub:event', msg);
            client.emit('pubsubEvent', msg);

            if (msg.event.updated) {
                var published = msg.event.updated.published;
                var retracted = msg.event.updated.retracted;


                if (published && published.length) {
                    client.emit('pubsub:published', msg);
                }

                if (retracted && retracted.length) {
                    client.emit('pubsub:retracted', msg);
                }
            }

            if (msg.event.purged) {
                client.emit('pubsub:purged', msg);
            }

            if (msg.event.deleted) {
                client.emit('pubsub:deleted', msg);
            }

            if (msg.event.subscriptionChanged) {
                client.emit('pubsub:subscription', msg);
            }

            if (msg.event.configurationChanged) {
                client.emit('pubsub:config', msg);
            }
        }

        if (msg.pubsub && msg.pubsub.affiliations) {
            client.emit('pubsub:affiliation', msg);
        }
    });

    client.subscribeToNode = function (jid, opts, cb) {
        if (typeof opts === 'string') {
            opts = {
                node: opts
            };
        }
        opts.jid = opts.jid || client.jid;

        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                subscribe: opts
            }
        }, cb);
    };

    client.unsubscribeFromNode = function (jid, opts, cb) {
        if (typeof opts === 'string') {
            opts = {
                node: opts
            };
        }
        opts.jid = opts.jid || client.jid.bare;

        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                unsubscribe: opts
            }
        }, cb);
    };

    client.publish = function (jid, node, item, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                publish: {
                    node: node,
                    item: item
                }
            }
        }, cb);
    };

    client.getItem = function (jid, node, id, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                retrieve: {
                    node: node,
                    item: id
                }
            }
        }, cb);
    };

    client.getItems = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;
        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                retrieve: {
                    node: node,
                    max: opts.max
                },
                rsm: opts.rsm
            }
        }, cb);
    };

    client.retract = function (jid, node, id, notify, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsub: {
                retract: {
                    node: node,
                    notify: notify,
                    id: id
                }
            }
        }, cb);
    };

    client.purgeNode = function (jid, node, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                purge: node
            }
        }, cb);
    };

    client.deleteNode = function (jid, node, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                del: node
            }
        }, cb);
    };

    client.createNode = function (jid, node, config, cb) {
        var cmd = {
            type: 'set',
            to: jid,
            pubsubOwner: {
                create: node
            }
        };

        if (config) {
            cmd.pubsubOwner.config = {form: config};
        }

        return this.sendIq(cmd, cb);
    };

    client.getSubscriptions = function (jid, opts, cb) {
        opts = opts || {};

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                subscriptions: opts
            }
        }, cb);
    };

    client.getAffiliations = function (jid, opts, cb) {
        opts = opts || {};

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsub: {
                affiliations: opts
            }
        }, cb);
    };

    client.getNodeSubscribers = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsubOwner: {
                subscriptions: opts
            }
        }, cb);
    };

    client.updateNodeSubscriptions = function (jid, node, delta, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                subscriptions: {
                    node: node,
                    list: delta
                }
            }
        }, cb);
    };

    client.getNodeAffiliations = function (jid, node, opts, cb) {
        opts = opts || {};
        opts.node = node;

        return this.sendIq({
            type: 'get',
            to: jid,
            pubsubOwner: {
                affiliations: opts
            }
        }, cb);
    };

    client.updateNodeAffiliations = function (jid, node, delta, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            pubsubOwner: {
                affiliations: {
                    node: node,
                    list: delta
                }
            }
        }, cb);
    };
};

},{"../stanza/pubsub":324,"../stanza/pubsubError":325,"../stanza/pubsubEvents":326,"../stanza/pubsubOwner":327}],273:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/reach'));

    client.disco.addFeature('urn:xmpp:reach:0');
    client.disco.addFeature('urn:xmpp:reach:0+notify');

    client.on('pubsub:event', function (msg) {
        if (!msg.event.updated) {
            return;
        }
        if (msg.event.updated.node !== 'urn:xmpp:reach:0') {
            return;
        }

        client.emit('reachability', {
            jid: msg.from,
            addresses: msg.event.updated.published[0].reach
        });
    });

    client.on('presence', function (pres) {
        if (!pres.reach || !pres.reach.length) {
            return;
        }

        client.emit('reachability', {
            jid: pres.from,
            addresses: pres.reach
        });
    });

    client.publishReachability = function (data, cb) {
        return this.publish('', 'urn:xmpp:reach:0', {
            reach: data
        }, cb);
    };
};

},{"../stanza/reach":328}],274:[function(require,module,exports){
'use strict';

module.exports = function (client) {
    client.disco.addFeature('urn:xmpp:receipts');

    client.on('message', function (msg) {
        var ackTypes = {
            normal: true,
            chat: true,
            headline: true
        };
        if (ackTypes[msg.type] && msg.requestReceipt && !msg.receipt) {
            client.sendMessage({
                to: msg.from,
                receipt: msg.id,
                id: msg.id
            });
        }
        if (msg.receipt) {
            client.emit('receipt', msg);
            client.emit('receipt:' + msg.receipt);
        }
    });
};

},{}],275:[function(require,module,exports){
'use strict';



module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/register'));

    client.getAccountInfo = function (jid, cb) {
        return this.sendIq({
            type: 'get',
            to: jid,
            register: true
        }, cb);
    };

    client.updateAccount = function (jid, data, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            register: data
        }, cb);
    };

    client.deleteAccount = function (jid, cb) {
        return this.sendIq({
            type: 'set',
            to: jid,
            register: {
                remove: true
            }
        }, cb);
    };
};

},{"../stanza/register":329}],276:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/roster'));

    client.on('iq:set:roster', function (iq) {
        var allowed = {};
        allowed[''] = true;
        allowed[client.jid.bare] = true;
        allowed[client.jid.domain] = true;

        if (!allowed[iq.from.full]) {
            return client.sendIq(iq.errorReply({
                error: {
                    type: 'cancel',
                    condition: 'service-unavailable'
                }
            }));
        }

        client.emit('roster:update', iq);
        client.sendIq({
            id: iq.id,
            type: 'result'
        });
    });

    client.getRoster = function (cb) {
        var self = this;
        cb = cb || function () {};

        return client.sendIq({
            type: 'get',
            roster: {
                ver: self.config.rosterVer
            }
        }).then(function (resp) {
            if (resp.roster) {
                var ver = resp.roster.ver;
                if (ver) {
                    self.config.rosterVer = ver;
                    self.emit('roster:ver', ver);
                }
            }
            return resp;
        }).nodeify(cb);
    };

    client.updateRosterItem = function (item, cb) {
        return client.sendIq({
            type: 'set',
            roster: {
                items: [item]
            }
        }, cb);
    };

    client.removeRosterItem = function (jid, cb) {
        return client.updateRosterItem({jid: jid, subscription: 'remove'}, cb);
    };

    client.subscribe = function (jid) {
        client.sendPresence({type: 'subscribe', to: jid});
    };

    client.unsubscribe = function (jid) {
        client.sendPresence({type: 'unsubscribe', to: jid});
    };

    client.acceptSubscription = function (jid) {
        client.sendPresence({type: 'subscribed', to: jid});
    };

    client.denySubscription = function (jid) {
        client.sendPresence({type: 'unsubscribed', to: jid});
    };
};

},{"../stanza/roster":330}],277:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/rtt'));

    client.disco.addFeature('urn:xmpp:rtt:0');

    client.on('message', function (msg) {
        if (msg.rtt) {
            client.emit('rtt', msg);
            client.emit('rtt:' + msg.rtt.event, msg);
        }
    });
};

},{"../stanza/rtt":333}],278:[function(require,module,exports){
(function (Buffer){
'use strict';


var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/sasl'));

    var Auth = stanzas.getDefinition('auth', NS);
    var Response = stanzas.getDefinition('response', NS);

    client.registerFeature('sasl', 100, function (features, cb) {
        var self = this;

        var mech = self.SASLFactory.create(features.sasl.mechanisms);
        if (!mech) {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            return cb('disconnect', 'authentication failed');
        }

        self.on('sasl:success', 'sasl', function () {
            self.features.negotiated.sasl = true;
            self.releaseGroup('sasl');
            self.emit('auth:success', self.config.credentials);
            cb('restart');
        });

        self.on('sasl:challenge', 'sasl', function (challenge) {
            mech.challenge(challenge.value);
            self.send(new Response({
                value: mech.response(self.getCredentials())
            }));

            if (mech.cache) {
                Object.keys(mech.cache).forEach(function (key) {
                    if (!mech.cache[key]) {
                        return;
                    }

                    self.config.credentials[key] = new Buffer(mech.cache[key]);
                });

                self.emit('credentials:update', self.config.credentials);
            }
        });

        self.on('sasl:failure', 'sasl', function () {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            cb('disconnect', 'authentication failed');
        });

        self.on('sasl:abort', 'sasl', function () {
            self.releaseGroup('sasl');
            self.emit('auth:failed');
            cb('disconnect', 'authentication failed');
        });

        var auth = {
            mechanism: mech.name
        };

        if (mech.clientFirst) {
            auth.value = mech.response(self.getCredentials());
        }

        self.send(new Auth(auth));
    });

    client.on('disconnected', function () {
        client.features.negotiated.sasl = false;
    });
};

}).call(this,require("buffer").Buffer)
},{"../stanza/sasl":334,"buffer":5}],279:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/session'));

    client.registerFeature('session', 1000, function (features, cb) {
        var self = this;

        if (features.session.optional || self.sessionStarted) {
            self.features.negotiated.session = true;
            return cb();
        }

        self.sendIq({
            type: 'set',
            session: {}
        }, function (err) {
            if (err) {
                return cb('disconnect', 'session request failed');
            }

            self.features.negotiated.session = true;
            if (!self.sessionStarted) {
                self.sessionStarted = true;
                self.emit('session:started', self.jid);
            }
            cb();
        });
    });

    client.on('disconnected', function () {
        client.sessionStarted = false;
        client.features.negotiated.session = false;
    });
};

},{"../stanza/session":335}],280:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/shim';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/shim'));

    client.disco.addFeature(NS);
    client.disco.addFeature(NS + '#SubID', NS);
};

},{"../stanza/shim":336}],281:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas, config) {
    stanzas.use(require('../stanza/sm'));

    var smacks = function (features, cb) {
        var self = this;

        if (!config.useStreamManagement) {
            return cb();
        }

        self.on('stream:management:enabled', 'sm', function (enabled) {
            self.sm.enabled(enabled);
            self.features.negotiated.streamManagement = true;
            self.releaseGroup('sm');
            cb();
        });

        self.on('stream:management:resumed', 'sm', function (resumed) {
            self.sm.resumed(resumed);
            self.features.negotiated.streamManagement = true;
            self.features.negotiated.bind = true;
            self.sessionStarted = true;
            self.releaseGroup('sm');
            cb('break'); // Halt further processing of stream features
        });

        self.on('stream:management:failed', 'sm', function () {
            self.sm.failed();
            self.emit('session:end');
            self.releaseGroup('session');
            self.releaseGroup('sm');
            cb();
        });

        if (!self.sm.id) {
            if (self.features.negotiated.bind) {
                self.sm.enable();
            } else {
                cb();
            }
        } else if (self.sm.id && self.sm.allowResume) {
            self.sm.resume();
        } else {
            cb();
        }
    };

    client.on('disconnected', function () {
        client.features.negotiated.streamManagement = false;
    });

    client.registerFeature('streamManagement', 200, smacks);
    client.registerFeature('streamManagement', 500, smacks);
};

},{"../stanza/sm":337}],282:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/time'));

    client.disco.addFeature('urn:xmpp:time');

    client.getTime = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            time: true
        }, cb);
    };

    client.on('iq:get:time', function (iq) {
        var time = new Date();
        client.sendIq(iq.resultReply({
            time: {
                utc: time,
                tzo: time.getTimezoneOffset()
            }
        }));
    });
};

},{"../stanza/time":341}],283:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/vcard'));

    client.disco.addFeature('vcard-temp');

    client.getVCard = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            vCardTemp: true
        }, cb);
    };

    client.publishVCard = function (vcard, cb) {
        return this.sendIq({
            type: 'set',
            vCardTemp: vcard
        }, cb);
    };
};

},{"../stanza/vcard":342}],284:[function(require,module,exports){
'use strict';


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/version'));

    client.disco.addFeature('jabber:iq:version');

    client.on('iq:get:version', function (iq) {
        client.sendIq(iq.resultReply({
            version: client.config.softwareVersion || {
                name: 'stanza.io'
            }
        }));
    });

    client.getSoftwareVersion = function (jid, cb) {
        return this.sendIq({
            to: jid,
            type: 'get',
            version: true
        }, cb);
    };
};

},{"../stanza/version":343}],285:[function(require,module,exports){
'use strict';

var WSConnection = require('../transports/websocket');


module.exports = function (client, stanzas) {
    stanzas.use(require('../stanza/framing'));

    client.transports.websocket = WSConnection;
};

},{"../stanza/framing":304,"../transports/websocket":347}],286:[function(require,module,exports){
'use strict';

var MAX_SEQ = Math.pow(2, 32);


function mod(v, n) {
    return ((v % n) + n) % n;
}


function StreamManagement(client) {
    this.client = client;
    this.id = false;
    this.allowResume = true;
    this.started = false;
    this.inboundStarted = false;
    this.outboundStarted = false;
    this.lastAck = 0;
    this.handled = 0;
    this.windowSize = 1;
    this.unacked = [];
    this.pendingAck = false;

    var NS = 'urn:xmpp:sm:3';
    this.stanzas = {
        Enable: client.stanzas.getDefinition('enable', NS),
        Resume: client.stanzas.getDefinition('resume', NS),
        Ack: client.stanzas.getDefinition('a', NS),
        Request: client.stanzas.getDefinition('r', NS)
    };
}

StreamManagement.prototype = {
    constructor: {
        value: StreamManagement
    },
    enable: function () {
        var enable = new this.stanzas.Enable();
        enable.resume = this.allowResume;
        this.client.send(enable);
        this.handled = 0;
        this.outboundStarted = true;
    },
    resume: function () {
        var resume = new this.stanzas.Resume({
            h: this.handled,
            previd: this.id
        });
        this.client.send(resume);
        this.outboundStarted = true;
    },
    enabled: function (resp) {
        this.id = resp.id;
        this.handled = 0;
        this.inboundStarted = true;
    },
    resumed: function (resp) {
        this.id = resp.previd;
        if (resp.h) {
            this.process(resp, true);
        }
        this.inboundStarted = true;
    },
    failed: function () {
        this.inboundStarted = false;
        this.outboundStarted = false;
        this.id = false;
        this.lastAck = 0;
        this.handled = 0;
        this.unacked = [];
    },
    ack: function () {
        this.client.send(new this.stanzas.Ack({
            h: this.handled
        }));
    },
    request: function () {
        this.pendingAck = true;
        this.client.send(new this.stanzas.Request());
    },
    process: function (ack, resend) {
        var self = this;
        var numAcked = mod(ack.h - this.lastAck, MAX_SEQ);

        this.pendingAck = false;

        for (var i = 0; i < numAcked && this.unacked.length > 0; i++) {
            this.client.emit('stanza:acked', this.unacked.shift());
        }
        this.lastAck = ack.h;

        if (resend) {
            var resendUnacked = this.unacked;
            this.unacked = [];
            resendUnacked.forEach(function (stanza) {
                self.client.send(stanza);
            });
        }

        if (this.needAck()) {
            this.request();
        }
    },
    track: function (stanza) {
        var name = stanza._name;
        var acceptable = {
            message: true,
            presence: true,
            iq: true
        };

        if (this.outboundStarted && acceptable[name]) {
            this.unacked.push(stanza);
            if (this.needAck()) {
                this.request();
            }
        }
    },
    handle: function () {
        if (this.inboundStarted) {
            this.handled = mod(this.handled + 1, MAX_SEQ);
        }
    },
    needAck: function () {
        return !this.pendingAck && this.unacked.length >= this.windowSize;
    }
};

Object.defineProperties(StreamManagement.prototype, {
    started: {
        get: function () {
            return this.outboundStarted && this.inboundStarted;
        },
        set: function (value) {
            if (!value) {
                this.outboundStarted = false;
                this.inboundStarted = false;
            }
        }
    }
});

module.exports = StreamManagement;

},{}],287:[function(require,module,exports){
'use strict';

var _ = require('underscore');


module.exports = function (stanza) {
    var types = stanza.utils;

    var Avatar = stanza.define({
        name: 'avatar',
        namespace: 'urn:xmpp:avatar:metadata',
        element: 'info',
        fields: {
            id: types.attribute('id'),
            bytes: types.attribute('bytes'),
            height: types.attribute('height'),
            width: types.attribute('width'),
            type: types.attribute('type', 'image/png'),
            url: types.attribute('url')
        }
    });
    
    var avatars = {
        get: function () {
            var metadata = types.find(this.xml, 'urn:xmpp:avatar:metadata', 'metadata');
            var results = [];
            if (metadata.length) {
                var avatars = types.find(metadata[0], 'urn:xmpp:avatar:metadata', 'info');
                _.forEach(avatars, function (info) {
                    results.push(new Avatar({}, info));
                });
            }
            return results;
        },
        set: function (value) {
            var metadata = types.findOrCreate(this.xml, 'urn:xmpp:avatar:metadata', 'metadata');
            types.setAttribute(metadata, 'xmlns', 'urn:xmpp:avatar:metadata');
            _.forEach(value, function (info) {
                var avatar = new Avatar(info);
                metadata.appendChild(avatar.xml);
            });
        }
    };
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'avatars', avatars);
        stanza.add(Item, 'avatarData', types.textSub('urn:xmpp:avatar:data', 'data'));
    });
};

},{"underscore":448}],288:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-bind';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Bind = stanza.define({
        name: 'bind',
        namespace: NS,
        element: 'bind',
        fields: {
            resource: types.textSub(NS, 'resource'),
            jid: types.jidSub(NS, 'jid')
        }
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Bind);
    });
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Bind);
    });
};

},{}],289:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;

var NS = 'urn:xmpp:blocking';


module.exports = function (stanza) {
    var types = stanza.utils;

    var jids = {
        get: function () {
            var result = [];
            var items = types.find(this.xml, NS, 'item');
            if (!items.length) {
                return result;
            }
    
            items.forEach(function (item) {
                result.push(new JID(types.getAttribute(item, 'jid', '')));
            });
    
            return result;
        },
        set: function (values) {
            var self = this;
            values.forEach(function (value) {
                var item = types.createElement(NS, 'item', NS);
                types.setAttribute(item, 'jid', value.toString());
                self.xml.appendChild(item);
            });
        }
    };
    
    var Block = stanza.define({
        name: 'block',
        namespace: NS,
        element: 'block',
        fields: {
            jids: jids
        }
    });
    
    var Unblock = stanza.define({
        name: 'unblock',
        namespace: NS,
        element: 'unblock',
        fields: {
            jids: jids
        }
    });
    
    var BlockList = stanza.define({
        name: 'blockList',
        namespace: NS,
        element: 'blocklist',
        fields: {
            jids: jids
        }
    });
    
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Block);
        stanza.extend(Iq, Unblock);
        stanza.extend(Iq, BlockList);
    });
};

},{"xmpp-jid":450}],290:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:bob';


module.exports = function (stanza) {
    var types = stanza.utils;

    var BOB = stanza.define({
        name: 'bob',
        namespace: NS,
        element: 'data',
        fields: {
            cid: types.attribute('cid'),
            maxAge: types.numberAttribute('max-age'),
            type: types.attribute('type'),
            data: types.text()
        }
    });


    stanza.withIq(function (Iq) {
        stanza.extend(Iq, BOB);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, BOB);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, BOB);
    });
};

},{}],291:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Conference = stanza.define({
        name: '_conference',
        namespace: 'storage:bookmarks',
        element: 'conference',
        fields: {
            name: types.attribute('name'),
            autoJoin: types.boolAttribute('autojoin'),
            jid: types.jidAttribute('jid'),
            nick: types.textSub('storage:bookmarks', 'nick')
        }
    });
    
    var Bookmarks = stanza.define({
        name: 'bookmarks',
        namespace: 'storage:bookmarks',
        element: 'storage'
    });
    
    
    stanza.extend(Bookmarks, Conference, 'conferences');

    stanza.withDefinition('query', 'jabber:iq:private', function (PrivateStorage) {
        stanza.extend(PrivateStorage, Bookmarks);
    });
};

},{}],292:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/httpbind';
var XMPP_NS = 'urn:xmpp:xbosh';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'bosh',
        namespace: NS,
        element: 'body',
        prefixes: {
            xmpp: XMPP_NS
        },
        fields: {
            accept: types.attribute('accept'),
            ack: types.numberAttribute('ack'),
            authid: types.attribute('authid'),
            charsets: types.attribute('charsets'),
            condition: types.attribute('condition'),
            content: types.attribute('content'),
            from: types.jidAttribute('from', true),
            hold: types.numberAttribute('hold'),
            inactivity: types.numberAttribute('inactivity'),
            key: types.attribute('key'),
            maxpause: types.numberAttribute('maxpause'),
            newKey: types.attribute('newkey'),
            pause: types.numberAttribute('pause'),
            polling: types.numberAttribute('polling'),
            resport: types.numberAttribute('report'),
            requests: types.numberAttribute('requests'),
            rid: types.numberAttribute('rid'),
            sid: types.attribute('sid'),
            stream: types.attribute('stream'),
            time: types.attribute('time'),
            to: types.jidAttribute('to', true),
            type: types.attribute('type'),
            ver: types.attribute('ver'),
            wait: types.numberAttribute('wait'),
            uri: types.textSub(NS, 'uri'),
            lang: types.langAttribute(),
            // These three should be using namespaced attributes, but browsers are stupid
            // when it comes to serializing attributes with namespaces
            version: types.attribute('xmpp:version', '1.0'),
            restart: types.attribute('xmpp:restart'),
            restartLogic: types.boolAttribute('xmpp:restartLogic'),
            payload: {
                get: function () {
                    var results = [];
                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++)  {
                        var obj = stanza.build(this.xml.childNodes[i]);
                        if (obj !== undefined) {
                            results.push(obj);
                        }
                    }
                    return results;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (types) {
                        self.xml.appendChild(types.xml);
                    });
                }
            }
        }
    });
};

},{}],293:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Caps = stanza.define({
        name: 'caps',
        namespace: 'http://jabber.org/protocol/caps',
        element: 'c',
        fields: {
            ver: types.attribute('ver'),
            node: types.attribute('node'),
            hash: types.attribute('hash'),
            ext: types.attribute('ext')
        }
    });
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, Caps);
    });

    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Caps);
    });
};

},{}],294:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var Sent = stanza.define({
        name: 'carbonSent',
        eventName: 'carbon:sent',
        namespace: 'urn:xmpp:carbons:2',
        element: 'sent'
    });
    
    var Received = stanza.define({
        name: 'carbonReceived',
        eventName: 'carbon:received',
        namespace: 'urn:xmpp:carbons:2',
        element: 'received'
    });
    
    var Private = stanza.define({
        name: 'carbonPrivate',
        eventName: 'carbon:private',
        namespace: 'urn:xmpp:carbons:2',
        element: 'private'
    });
    
    var Enable = stanza.define({
        name: 'enableCarbons',
        namespace: 'urn:xmpp:carbons:2',
        element: 'enable'
    });
    
    var Disable = stanza.define({
        name: 'disableCarbons',
        namespace: 'urn:xmpp:carbons:2',
        element: 'disable'
    });
    
    
    stanza.withDefinition('forwarded', 'urn:xmpp:forward:0', function (Forwarded) {
        stanza.extend(Sent, Forwarded);
        stanza.extend(Received, Forwarded);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Sent);
        stanza.extend(Message, Received);
        stanza.extend(Message, Private);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Enable);
        stanza.extend(Iq, Disable);
    });
};

},{}],295:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/commands';
var ACTIONS = ['next', 'prev', 'complete', 'cancel'];
var CONDITIONS = [
    'bad-action',
    'bad-locale',
    'bad-payload',
    'bad-sessionid',
    'malformed-action',
    'session-expired'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Command = stanza.define({
        name: 'command',
        namespace: NS,
        element: 'command',
        fields: {
            action: types.attribute('action'),
            node: types.attribute('node'),
            sessionid: types.attribute('sessionid'),
            status: types.attribute('status'),
            execute: types.subAttribute(NS, 'actions', 'execute'),
            actions: {
                get: function () {
                    var result = [];
                    var actionSet = types.find(this.xml, NS, 'actions');
                    if (!actionSet.length) {
                        return [];
                    }
                    ACTIONS.forEach(function (action) {
                        var existing = types.find(actionSet[0], NS, action);
                        if (existing.length) {
                            result.push(action);
                        }
                    });
                    return result;
                },
                set: function (values) {
                    var actionSet = types.findOrCreate(this.xml, NS, 'actions');
                    for (var i = 0, len = actionSet.childNodes.length; i < len; i++) {
                        actionSet.removeChild(actionSet.childNodes[i]);
                    }
                    values.forEach(function (value) {
                        actionSet.appendChild(types.createElement(NS, value.toLowerCase(), NS));
                    });
                }
            }
        }
    });

    var Note = stanza.define({
        name: '_commandNote',
        namespace: NS,
        element: 'note',
        fields: {
            type: types.attribute('type'),
            value: types.text()
        }
    });


    stanza.extend(Command, Note, 'notes');
    
    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'adhocCommandCondition', types.enumSub(NS, CONDITIONS));
    });
    
    stanza.withDataForm(function (DataForm) {
        stanza.extend(Command, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Command);
    });
};

},{}],296:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:csi';


module.exports = function (stanza) {
    var CSIFeature = stanza.define({
        name: 'clientStateIndication',
        namespace: NS,
        element: 'csi'
    });
    
    stanza.define({
        name: 'csiActive',
        eventName: 'csi:active',
        namespace: NS,
        element: 'active',
        topLevel: true
    });
    
    stanza.define({
        name: 'csiInactive',
        eventName: 'csi:inactive',
        namespace: NS,
        element: 'inactive',
        topLevel: true
    });
    
    
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, CSIFeature);
    });
};

},{}],297:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;

var FORM_NS = 'jabber:x:data';
var MEDIA_NS = 'urn:xmpp:media-element';
var VALIDATE_NS = 'http://jabber.org/protocol/xdata-validate';
var LAYOUT_NS = 'http://jabber.org/protocol/xdata-layout';

var SINGLE_FIELDS = [
    'text-single',
    'text-private',
    'list-single',
    'jid-single'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Field = stanza.define({
        name: '_field',
        namespace: FORM_NS,
        element: 'field',
        init: function (data) {
            this._type = (data || {}).type || this.type;
        },
        fields: {
            type: {
                get: function () {
                    return types.getAttribute(this.xml, 'type', 'text-single');
                },
                set: function (value) {
                    this._type = value;
                    types.setAttribute(this.xml, 'type', value);
                }
            },
            name: types.attribute('var'),
            desc: types.textSub(FORM_NS, 'desc'),
            required: types.boolSub(FORM_NS, 'required'),
            label: types.attribute('label'),
            value: {
                get: function () {
                    var vals = types.getMultiSubText(this.xml, FORM_NS, 'value');
                    if (this._type === 'boolean') {
                        return vals[0] === '1' || vals[0] === 'true';
                    }
                    if (vals.length > 1) {
                        if (this._type === 'text-multi') {
                            return vals.join('\n');
                        }
    
                        if (this._type === 'jid-multi') {
                            return vals.map(function (jid) {
                                return new JID(jid);
                            });
                        }
    
                        return vals;
                    }
                    if (SINGLE_FIELDS.indexOf(this._type) >= 0) {
                        if (this._type === 'jid-single') {
                            return new JID(vals[0]);
                        }
                        return vals[0];
                    }
    
                    return vals;
                },
                set: function (value) {
                    if (this._type === 'boolean') {
                        var truthy = value === true || value === 'true' || value === '1';
                        types.setSubText(this.xml, FORM_NS, 'value', truthy ? '1' : '0');
                    } else {
                        if (this._type === 'text-multi' && typeof(value) === 'string') {
                            value = value.split('\n');
                        }
                        types.setMultiSubText(this.xml, FORM_NS, 'value', value);
                    }
                }
            }
        }
    });
    
    var Option = stanza.define({
        name: '_formoption',
        namespace: FORM_NS,
        element: 'option',
        fields: {
            label: types.attribute('label'),
            value: types.textSub(FORM_NS, 'value')
        }
    });
    
    var Item = stanza.define({
        name: '_formitem',
        namespace: FORM_NS,
        element: 'item'
    });
    
    var Media = stanza.define({
        name: 'media',
        element: 'media',
        namespace: MEDIA_NS,
        fields: {
            height: types.numberAttribute('height'),
            width: types.numberAttribute('width')
        }
    });
    
    var MediaURI = stanza.define({
        name: '_mediaURI',
        element: 'uri',
        namespace: MEDIA_NS,
        fields: {
            uri: types.text(),
            type: types.attribute('type')
        }
    });
    
    var Validation = stanza.define({
        name: 'validation',
        element: 'validate',
        namespace: VALIDATE_NS,
        fields: {
            dataType: types.attribute('datatype'),
            basic: types.boolSub(VALIDATE_NS, 'basic'),
            open: types.boolSub(VALIDATE_NS, 'open'),
            regex: types.textSub(VALIDATE_NS, 'regex')
        }
    });
    
    var Range = stanza.define({
        name: 'range',
        element: 'range',
        namespace: VALIDATE_NS,
        fields: {
            min: types.attribute('min'),
            max: types.attribute('max')
        }
    });
    
    var ListRange = stanza.define({
        name: 'select',
        element: 'list-range',
        namespace: VALIDATE_NS,
        fields: {
            min: types.numberAttribute('min'),
            max: types.numberAttribute('max')
        }
    });
    
    var layoutContents = {
        get: function () {
            var result = [];
            for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                var child = this.xml.childNodes[i];
                if (child.namespaceURI !== LAYOUT_NS) {
                    continue;
                }
    
                switch (child.localName) {
                    case 'text':
                        result.push({
                            text: child.textContent
                        });
                        break;
                    case 'fieldref':
                        result.push({
                            field: child.getAttribute('var')
                        });
                        break;
                    case 'reportedref':
                        result.push({
                            reported: true
                        });
                        break;
                    case 'section':
                        result.push({
                            section: new Section(null, child, this).toJSON()
                        });
                        break;
                }
            }
    
            return result;
        },
        set: function (values) {
            for (var i = 0, len = values.length; i < len; i++) {
                var value = values[i];
                if (value.text) {
                    var text = stanza.createElement(LAYOUT_NS, 'text', LAYOUT_NS);
                    text.textContent = value.text;
                    this.xml.appendChild(text);
                }
                if (value.field) {
                    var field = stanza.createElement(LAYOUT_NS, 'fieldref', LAYOUT_NS);
                    field.setAttribute('var', value.field);
                    this.xml.appendChild(field);
                }
                if (value.reported) {
                    this.xml.appendChild(stanza.createElement(LAYOUT_NS, 'reportedref', LAYOUT_NS));
                }
                if (value.section) {
                    var sectionXML = stanza.createElement(LAYOUT_NS, 'section', LAYOUT_NS);
                    this.xml.appendChild(sectionXML);
    
                    var section = new Section(null, sectionXML);
                    section.label = value.section.label;
                    section.contents = value.section.contents;
                }
            }
        }
    };
    
    var Section = stanza.define({
        name: '_section',
        element: 'section',
        namespace: LAYOUT_NS,
        fields: {
            label: types.attribute('label'),
            contents: layoutContents
        }
    });
    
    var Page = stanza.define({
        name: '_page',
        element: 'page',
        namespace: LAYOUT_NS,
        fields: {
            label: types.attribute('label'),
            contents: layoutContents
        }
    });
 
    var DataForm = stanza.define({
        name: 'form',
        namespace: FORM_NS,
        element: 'x',
        init: function () {
            // Propagate reported field types to items
    
            if (!this.reportedFields.length) {
                return;
            }
    
            var fieldTypes = {};
            this.reportedFields.forEach(function (reported) {
                fieldTypes[reported.name] = reported.type;
            });
            this.items.forEach(function (item) {
                item.fields.forEach(function (field) {
                    field.type = field._type = fieldTypes[field.name];
                });
            });
        },
        fields: {
            title: types.textSub(FORM_NS, 'title'),
            instructions: types.multiTextSub(FORM_NS, 'instructions'),
            type: types.attribute('type', 'form'),
            reportedFields: types.subMultiExtension(FORM_NS, 'reported', Field)
        }
    });
    
    
    stanza.extend(DataForm, Field, 'fields');
    stanza.extend(DataForm, Item, 'items');
    stanza.extend(DataForm, Page, 'layout');

    stanza.extend(Field, Media);
    stanza.extend(Field, Validation);
    stanza.extend(Field, Option, 'options');
    
    stanza.extend(Item, Field, 'fields');
    
    stanza.extend(Media, MediaURI, 'uris');
    stanza.extend(Validation, Range);
    stanza.extend(Validation, ListRange);

    stanza.withMessage(function (Message) {
        stanza.extend(Message, DataForm);
    });
};

},{"xmpp-jid":450}],298:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var DelayedDelivery = stanza.define({
        name: 'delay',
        namespace: 'urn:xmpp:delay',
        element: 'delay',
        fields: {
            from: types.jidAttribute('from'),
            stamp: types.dateAttribute('stamp'),
            reason: types.text()
        }
    });
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, DelayedDelivery);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, DelayedDelivery);
    });
};

},{}],299:[function(require,module,exports){
'use strict';

var NSInfo = 'http://jabber.org/protocol/disco#info';
var NSItems = 'http://jabber.org/protocol/disco#items';


module.exports = function (stanza) {
    var types = stanza.utils;

    var DiscoInfo = stanza.define({
        name: 'discoInfo',
        namespace: NSInfo,
        element: 'query',
        fields: {
            node: types.attribute('node'),
            features: types.multiSubAttribute(NSInfo, 'feature', 'var')
        }
    });


    var DiscoIdentity = stanza.define({
        name: '_discoIdentity',
        namespace: NSInfo,
        element: 'identity',
        fields: {
            category: types.attribute('category'),
            type: types.attribute('type'),
            name: types.attribute('name'),
            lang: types.langAttribute()
        }
    });


    var DiscoItems = stanza.define({
        name: 'discoItems',
        namespace: NSItems,
        element: 'query',
        fields: {
            node: types.attribute('node'),
        }
    });

    var DiscoItem = stanza.define({
        name: '_discoItem',
        namespace: NSItems,
        element: 'item',
        fields: {
            jid: types.jidAttribute('jid'),
            node: types.attribute('node'),
            name: types.attribute('name')
        }
    });


    stanza.extend(DiscoItems, DiscoItem, 'items');
    stanza.extend(DiscoInfo, DiscoIdentity, 'identities');

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, DiscoInfo);
        stanza.extend(Iq, DiscoItems);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(DiscoInfo, DataForm, 'extensions');
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(DiscoItems, RSM);
    });
};

},{}],300:[function(require,module,exports){
'use strict';

var ERR_NS = 'urn:ietf:params:xml:ns:xmpp-stanzas';
var CONDITIONS = [
    'bad-request',
    'conflict',
    'feature-not-implemented',
    'forbidden',
    'gone',
    'internal-server-error',
    'item-not-found',
    'jid-malformed',
    'not-acceptable',
    'not-allowed',
    'not-authorized',
    'payment-required',
    'recipient-unavailable',
    'redirect',
    'registration-required',
    'remote-server-not-found',
    'remote-server-timeout',
    'resource-constraint',
    'service-unavailable',
    'subscription-required',
    'undefined-condition',
    'unexpected-request'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var ErrorStanza = stanza.define({
        name: 'error',
        namespace: 'jabber:client',
        element: 'error',
        fields: {
            lang: {
                get: function () {
                    return (this.parent || {}).lang || '';
                }
            },
            condition: types.enumSub(ERR_NS, CONDITIONS),
            gone: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'gone');
                },
                set: function (value) {
                    this.condition = 'gone';
                    types.setSubText(this.xml, ERR_NS, 'gone', value);
                }
            },
            redirect: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'redirect');
                },
                set: function (value) {
                    this.condition = 'redirect';
                    types.setSubText(this.xml, ERR_NS, 'redirect', value);
                }
            },
            code: types.attribute('code'),
            type: types.attribute('type'),
            by: types.jidAttribute('by'),
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, ERR_NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, ERR_NS, 'text', value, this.lang);
                }
            }
        }
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, ErrorStanza);
    });
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, ErrorStanza);
    });
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, ErrorStanza);
    });
};

},{}],301:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:extdisco:1';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Services = exports.Services = stanza.define({
        name: 'services',
        namespace: NS,
        element: 'services',
        fields: {
            type: types.attribute('type')
        }
    });
    
    var Credentials = exports.Credentials = stanza.define({
        name: 'credentials',
        namespace: NS,
        element: 'credentials'
    });
    
    var Service = stanza.define({
        name: 'service',
        namespace: NS,
        element: 'service',
        fields: {
            host: types.attribute('host'),
            port: types.attribute('port'),
            transport: types.attribute('transport'),
            type: types.attribute('type'),
            username: types.attribute('username'),
            password: types.attribute('password')
        }
    });
    
    
    stanza.extend(Services, Service, 'services');
    stanza.extend(Credentials, Service);

    stanza.withDataForm(function (DataForm) {
        stanza.extend(Service, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Services);
        stanza.extend(Iq, Credentials);
    });
};

},{}],302:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:apps:file-transfer:3';
var TB_NS = 'urn:xmpp:thumbs:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var File = stanza.define({
        name: '_file',
        namespace: NS,
        element: 'file',
        fields: {
            name: types.textSub(NS, 'name'),
            desc: types.textSub(NS, 'desc'),
            size: types.numberSub(NS, 'size'),
            date: types.dateSub(NS, 'date')
        }
    });
    
    var Range = stanza.define({
        name: 'range',
        namespace: NS,
        element: 'range',
        fields: {
            offset: types.numberAttribute('offset')
        }
    });
    
    var Thumbnail = stanza.define({
        name: 'thumbnail',
        namespace: TB_NS,
        element: 'thumbnail',
        fields: {
            cid: types.attribute('cid'),
            mimeType: types.attribute('mime-type'),
            width: types.numberAttribute('width'),
            height: types.numberAttribute('height')
        }
    });
    
    var FileTransfer = stanza.define({
        name: '_filetransfer',
        namespace: NS,
        element: 'description',
        tags: ['jingle-description'],
        fields: {
            descType: {value: 'filetransfer'},
            offer: types.subExtension('offer', NS, 'offer', File),
            request: types.subExtension('request', NS, 'request', File)
        }
    });
    
    stanza.extend(File, Range);
    stanza.extend(File, Thumbnail);

    stanza.withDefinition('hash', 'urn:xmpp:hashes:1', function (Hash) {
        stanza.extend(File, Hash, 'hashes');
    });

    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, FileTransfer);
    });
};

},{}],303:[function(require,module,exports){
'use strict';

module.exports = function (stanza) {
    var Forwarded = stanza.define({
        name: 'forwarded',
        eventName: 'forward',
        namespace: 'urn:xmpp:forward:0',
        element: 'forwarded'
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, Forwarded);
        stanza.extend(Forwarded, Message);
    });

    stanza.withPresence(function (Presence) {
        stanza.extend(Forwarded, Presence);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Forwarded, Iq);
    });

    stanza.withDefinition('delay', 'urn:xmpp:delay', function (Delayed) {
        stanza.extend(Forwarded, Delayed);
    });
};

},{}],304:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-framing';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'openStream',
        namespace: NS,
        element: 'open',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            version: types.attribute('version', '1.0'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true)
        }
    });
    
    stanza.define({
        name: 'closeStream',
        namespace: NS,
        element: 'close',
        topLevel: true,
        fields: {
            seeOtherURI: types.attribute('see-other-uri')
        }
    });
};

},{}],305:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/geoloc';


module.exports = function (stanza) {
    var types = stanza.utils;

    var GeoLoc = stanza.define({
        name: 'geoloc',
        namespace: NS,
        element: 'geoloc',
        fields: {
            accuracy: types.numberSub(NS, 'accuracy', true),
            altitude: types.numberSub(NS, 'alt', true),
            area: types.textSub(NS, 'area'),
            heading: types.numberSub(NS, 'bearing', true),
            bearing: types.numberSub(NS, 'bearing', true),
            building: types.textSub(NS, 'building'),
            country: types.textSub(NS, 'country'),
            countrycode: types.textSub(NS, 'countrycode'),
            datum: types.textSub(NS, 'datum'),
            description: types.textSub(NS, 'description'),
            error: types.numberSub(NS, 'error', true),
            floor: types.textSub(NS, 'floor'),
            latitude: types.numberSub(NS, 'lat', true),
            locality: types.textSub(NS, 'locality'),
            longitude: types.numberSub(NS, 'lon', true),
            postalcode: types.textSub(NS, 'postalcode'),
            region: types.textSub(NS, 'region'),
            room: types.textSub(NS, 'room'),
            speed: types.numberSub(NS, 'speed', true),
            street: types.textSub(NS, 'street'),
            text: types.textSub(NS, 'text'),
            timestamp: types.dateSub(NS, 'timestamp'),
            tzo: types.tzoSub(NS, 'tzo'),
            uri: types.textSub(NS, 'uri')
        }
    });
    
    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, GeoLoc);
    });
};

},{}],306:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    stanza.define({
        name: 'hash',
        namespace: 'urn:xmpp:hashes:1',
        element: 'hash',
        fields: {
            algo: stanza.utils.attribute('algo'),
            value: stanza.utils.text()
        }
    });
};

},{}],307:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:hats:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Hat = stanza.define({
        name: '_hat',
        namespace: NS,
        element: 'hat',
        fields: {
            lang: types.langAttribute(),
            name: types.attribute('name'),
            displayName: types.attribute('displayName')
        }
    });
    
    
    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'hats', types.subMultiExtension(NS, 'hats', Hat));
    });
};

},{}],308:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:transports:ice-udp:1';


module.exports = function (stanza) {
    var types = stanza.utils;

    var ICE = stanza.define({
        name: '_iceUdp',
        namespace: NS,
        element: 'transport',
        tags: ['jingle-transport'],
        fields: {
            transType: {value: 'iceUdp'},
            pwd: types.attribute('pwd'),
            ufrag: types.attribute('ufrag')
        }
    });
    
    
    var RemoteCandidate = stanza.define({
        name: 'remoteCandidate',
        namespace: NS,
        element: 'remote-candidate',
        fields: {
            component: types.attribute('component'),
            ip: types.attribute('ip'),
            port: types.attribute('port')
        }
    });
    
    
    var Candidate = stanza.define({
        name: '_iceUdpCandidate',
        namespace: NS,
        element: 'candidate',
        fields: {
            component: types.attribute('component'),
            foundation: types.attribute('foundation'),
            generation: types.attribute('generation'),
            id: types.attribute('id'),
            ip: types.attribute('ip'),
            network: types.attribute('network'),
            port: types.attribute('port'),
            priority: types.attribute('priority'),
            protocol: types.attribute('protocol'),
            relAddr: types.attribute('rel-addr'),
            relPort: types.attribute('rel-port'),
            tcpType: types.attribute('tcptype'),
            type: types.attribute('type')
        }
    });
    
    
    var Fingerprint = stanza.define({
        name: '_iceFingerprint',
        namespace: 'urn:xmpp:jingle:apps:dtls:0',
        element: 'fingerprint',
        fields: {
            hash: types.attribute('hash'),
            setup: types.attribute('setup'),
            value: types.text(),
            required: types.boolAttribute('required')
        }
    });
    
    var SctpMap = stanza.define({
        name: '_sctpMap',
        namespace: 'urn:xmpp:jingle:transports:dtls-sctp:1',
        element: 'sctpmap',
        fields: {
            number: types.attribute('number'),
            protocol: types.attribute('protocol'),
            streams: types.attribute('streams')
        }
    });

    
    stanza.extend(ICE, Candidate, 'candidates');
    stanza.extend(ICE, RemoteCandidate);
    stanza.extend(ICE, Fingerprint, 'fingerprints');
    stanza.extend(ICE, SctpMap, 'sctp');

    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, ICE);
    });
};

},{}],309:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Iq = stanza.define({
        name: 'iq',
        namespace: 'jabber:client',
        element: 'iq',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            type: types.attribute('type')
        }
    });
    
    var toJSON = Iq.prototype.toJSON;
    
    Iq.prototype.toJSON = function () {
        var result = toJSON.call(this);
        result.resultReply = this.resultReply;
        result.errorReply = this.errorReply;
        return result;
    };
    
    Iq.prototype.resultReply = function (data) {
        data = data || {};
        data.to = this.from;
        data.id = this.id;
        data.type = 'result';
        return new Iq(data);
    };
    
    Iq.prototype.errorReply = function (data) {
        data = data || {};
        data.to = this.from;
        data.id = this.id;
        data.type = 'error';
        return new Iq(data);
    };
};

},{}],310:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;
var NS = 'urn:xmpp:jidprep:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'jidPrep', {
            get: function () {
                var data = types.getSubText(this.xml, NS, 'jid');
                if (data) {
                    var jid = new JID(data);
                    jid.prepped = true;
                    return jid;
                }
            },
            set: function (value) {
                types.setSubText(this.xml, NS, 'jid', (value || '').toString());
            }
        });
    });
};

},{"xmpp-jid":450}],311:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:1';
var ERRNS = 'urn:xmpp:jingle:errors:1';
var CONDITIONS = ['out-of-order', 'tie-break', 'unknown-session', 'unsupported-info'];
var REASONS = [
    'alternative-session',
    'busy',
    'cancel',
    'connectivity-error',
    'decline',
    'expired',
    'failed-application',
    'failed-transport',
    'general-error',
    'gone',
    'incompatible-parameters',
    'media-error',
    'security-error',
    'success',
    'timeout',
    'unsupported-applications',
    'unsupported-transports'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Jingle = stanza.define({
        name: 'jingle',
        namespace: NS,
        element: 'jingle',
        fields: {
            action: types.attribute('action'),
            initiator: types.attribute('initiator'),
            responder: types.attribute('responder'),
            sid: types.attribute('sid')
        }
    });
    
    
    var Content = stanza.define({
        name: '_jingleContent',
        namespace: NS,
        element: 'content',
        fields: {
            creator: types.attribute('creator'),
            disposition: types.attribute('disposition', 'session'),
            name: types.attribute('name'),
            senders: types.attribute('senders', 'both'),
            description: {
                get: function () {
                    var opts = stanza.tagged('jingle-description').map(function (Description) {
                        return Description.prototype._name;
                    });
                    for (var i = 0, len = opts.length; i < len; i++) {
                        if (this._extensions[opts[i]]) {
                            return this._extensions[opts[i]];
                        }
                    }
                },
                set: function (value) {
                    var ext = '_' + value.descType;
                    this[ext] = value;
                }
            },
            transport: {
                get: function () {
                    var opts = stanza.tagged('jingle-transport').map(function (Transport) {
                        return Transport.prototype._name;
                    });
                    for (var i = 0, len = opts.length; i < len; i++) {
                        if (this._extensions[opts[i]]) {
                            return this._extensions[opts[i]];
                        }
                    }
                },
                set: function (value) {
                    var ext = '_' + value.transType;
                    this[ext] = value;
                }
            }
        }
    });
    
    var Reason = stanza.define({
        name: 'reason',
        namespace: NS,
        element: 'reason',
        fields: {
            condition: types.enumSub(NS, REASONS),
            alternativeSession: {
                get: function () {
                    return types.getSubText(this.xml, NS, 'alternative-session');
                },
                set: function (value) {
                    this.condition = 'alternative-session';
                    types.setSubText(this.xml, NS, 'alternative-session', value);
                }
            },
            text: types.textSub(NS, 'text')
        }
    });
    
    
    stanza.extend(Jingle, Content, 'contents');
    stanza.extend(Jingle, Reason);

    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'jingleCondition', types.enumSub(ERRNS, CONDITIONS));
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Jingle);
    });
};

},{}],312:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    var JSONExtension = {
        get: function () {
            var data = types.getSubText(this.xml, 'urn:xmpp:json:0', 'json');
            if (data) {
                return JSON.parse(data);
            }
        },
        set: function (value) {
            value = JSON.stringify(value);
            if (value) {
                types.setSubText(this.xml, 'urn:xmpp:json:0', 'json', value);
            }
        }
    };
    
    
    stanza.withMessage(function (Message) {
        stanza.add(Message, 'json', JSONExtension);
    });

    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'json', JSONExtension);
    });
};

},{}],313:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:eventlog';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Log = stanza.define({
        name: 'log',
        namespace: NS,
        element: 'log',
        fields: {
            id: types.attribute('id'),
            timestamp: types.dateAttribute('timestamp'),
            type: types.attribute('type'),
            level: types.attribute('level'),
            object: types.attribute('object'),
            subject: types.attribute('subject'),
            facility: types.attribute('facility'),
            module: types.attribute('module'),
            message: types.textSub(NS, 'message'),
            stackTrace: types.textSub(NS, 'stackTrace')
        }
    });
    
    var Tag = stanza.define({
        name: '_logtag',
        namespace: NS,
        element: 'tag',
        fields: {
            name: types.attribute('name'),
            value: types.attribute('value'),
            type: types.attribute('type')
        }
    });
    
    
    stanza.extend(Log, Tag, 'tags');

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Log);
    });

    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, Log);
    });
};

},{}],314:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;
var NS = 'urn:xmpp:mam:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var MAMQuery = stanza.define({
        name: 'mam',
        namespace: NS,
        element: 'query',
        fields: {
            queryid: types.attribute('queryid')
        }
    });
    
    var Result = stanza.define({
        name: 'mamItem',
        namespace: NS,
        element: 'result',
        fields: {
            queryid: types.attribute('queryid'),
            id: types.attribute('id')
        }
    });

    var Fin = stanza.define({
        name: 'mamResult',
        namespace: NS,
        element: 'fin',
        fields: {
            queryid: types.attribute('queryid'),
            complete: types.boolAttribute('complete'),
            stable: types.boolAttribute('stable')
        }
    });
    
    var Prefs = stanza.define({
        name: 'mamPrefs',
        namespace: NS,
        element: 'prefs',
        fields: {
            defaultCondition: types.attribute('default'),
            always: {
                get: function () {
                    var results = [];
                    var container = types.find(this.xml, NS, 'always');
                    if (container.length === 0) {
                        return results;
                    }
                    container = container[0];
                    var jids = types.getMultiSubText(container, NS, 'jid');
                    jids.forEach(function (jid) {
                        results.push(new JID(jid.textContent));
                    });
                    return results;
                },
                set: function (value) {
                    if (value.length > 0) {
                        var container = types.find(this.xml, NS, 'always');
                        types.setMultiSubText(container, NS, 'jid', value);
                    }
                }
            },
            never: {
                get: function () {
                    var results = [];
                    var container = types.find(this.xml, NS, 'always');
                    if (container.length === 0) {
                        return results;
                    }
                    container = container[0];
                    var jids = types.getMultiSubText(container, NS, 'jid');
                    jids.forEach(function (jid) {
                        results.push(new JID(jid.textContent));
                    });
                    return results;
                },
                set: function (value) {
                    if (value.length > 0) {
                        var container = types.find(this.xml, NS, 'never');
                        types.setMultiSubText(container, NS, 'jid', value);
                    }
                }
            }
        }
    });
    

    stanza.withDefinition('forwarded', 'urn:xmpp:forward:0', function (Forwarded) {
        stanza.extend(Result, Forwarded);
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(MAMQuery, RSM);
        stanza.extend(Fin, RSM);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(MAMQuery, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, MAMQuery);
        stanza.extend(Iq, Prefs);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Result);
        stanza.extend(Message, Fin);
    });
};

},{"xmpp-jid":450}],315:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'message',
        namespace: 'jabber:client',
        element: 'message',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            type: types.attribute('type', 'normal'),
            thread: types.textSub('jabber:client', 'thread'),
            parentThread: types.subAttribute('jabber:client', 'thread', 'parent'),
            subject: types.textSub('jabber:client', 'subject'),
            $body: {
                get: function () {
                    return types.getSubLangText(this.xml, this._NS, 'body', this.lang);
                }
            },
            body: {
                get: function () {
                    var bodies = this.$body;
                    return bodies[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, this._NS, 'body', value, this.lang);
                }
            },
            attention: types.boolSub('urn:xmpp:attention:0', 'attention'),
            chatState: types.enumSub('http://jabber.org/protocol/chatstates', [
                'active', 'composing', 'paused', 'inactive', 'gone'
            ]),
            replace: types.subAttribute('urn:xmpp:message-correct:0', 'replace', 'id'),
            requestReceipt: types.boolSub('urn:xmpp:receipts', 'request'),
            receipt: types.subAttribute('urn:xmpp:receipts', 'received', 'id')
        }
    });
};

},{}],316:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/mood';
var MOODS = [
    'afraid',
    'amazed',
    'amorous',
    'angry',
    'annoyed',
    'anxious',
    'aroused',
    'ashamed',
    'bored',
    'brave',
    'calm',
    'cautious',
    'cold',
    'confident',
    'confused',
    'contemplative',
    'contented',
    'cranky',
    'crazy',
    'creative',
    'curious',
    'dejected',
    'depressed',
    'disappointed',
    'disgusted',
    'dismayed',
    'distracted',
    'embarrassed',
    'envious',
    'excited',
    'flirtatious',
    'frustrated',
    'grateful',
    'grieving',
    'grumpy',
    'guilty',
    'happy',
    'hopeful',
    'hot',
    'humbled',
    'humiliated',
    'hungry',
    'hurt',
    'impressed',
    'in_awe',
    'in_love',
    'indignant',
    'interested',
    'intoxicated',
    'invincible',
    'jealous',
    'lonely',
    'lucky',
    'mean',
    'moody',
    'nervous',
    'neutral',
    'offended',
    'outraged',
    'playful',
    'proud',
    'relaxed',
    'relieved',
    'remorseful',
    'restless',
    'sad',
    'sarcastic',
    'serious',
    'shocked',
    'shy',
    'sick',
    'sleepy',
    'spontaneous',
    'stressed',
    'strong',
    'surprised',
    'thankful',
    'thirsty',
    'tired',
    'undefined',
    'weak',
    'worried'
];


module.exports = function (stanza) {
    var Mood = stanza.define({
        name: 'mood',
        namespace: NS,
        element: 'mood',
        fields: {
            text: stanza.utils.textSub(NS, 'text'),
            value: stanza.utils.enumSub(NS, MOODS)
        }
    });
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.extend(Item, Mood);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, Mood);
    });
};

},{}],317:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/muc';
var USER_NS = NS + '#user';
var ADMIN_NS = NS + '#admin';
var OWNER_NS = NS + '#owner';
var UNIQ_NS = NS + '#unique';


var proxy = function (child, field) {
    return {
        get: function () {
            if (this._extensions[child]) {
                return this[child][field];
            }
        },
        set: function (value) {
            this[child][field] = value;
        }
    };
};


module.exports = function (stanza) {
    var types = stanza.utils;

    var UserItem = stanza.define({
        name: '_mucUserItem',
        namespace: USER_NS,
        element: 'item',
        fields: {
            affiliation: types.attribute('affiliation'),
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid'),
            role: types.attribute('role'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var UserActor = stanza.define({
        name: '_mucUserActor',
        namespace: USER_NS,
        element: 'actor',
        fields: {
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Destroyed = stanza.define({
        name: 'destroyed',
        namespace: USER_NS,
        element: 'destroy',
        fields: {
            jid: types.jidAttribute('jid'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var Invite = stanza.define({
        name: 'invite',
        namespace: USER_NS,
        element: 'invite',
        fields: {
            to: types.jidAttribute('to'),
            from: types.jidAttribute('from'),
            reason: types.textSub(USER_NS, 'reason'),
            thread: types.subAttribute(USER_NS, 'continue', 'thread'),
            'continue': types.boolSub(USER_NS, 'continue')
        }
    });
    
    var Decline = stanza.define({
        name: 'decline',
        namespace: USER_NS,
        element: 'decline',
        fields: {
            to: types.jidAttribute('to'),
            from: types.jidAttribute('from'),
            reason: types.textSub(USER_NS, 'reason')
        }
    });
    
    var AdminItem = stanza.define({
        name: '_mucAdminItem',
        namespace: ADMIN_NS,
        element: 'item',
        fields: {
            affiliation: types.attribute('affiliation'),
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid'),
            role: types.attribute('role'),
            reason: types.textSub(ADMIN_NS, 'reason')
        }
    });
    
    var AdminActor = stanza.define({
        name: 'actor',
        namespace: USER_NS,
        element: 'actor',
        fields: {
            nick: types.attribute('nick'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Destroy = stanza.define({
        name: 'destroy',
        namespace: OWNER_NS,
        element: 'destroy',
        fields: {
            jid: types.jidAttribute('jid'),
            password: types.textSub(OWNER_NS, 'password'),
            reason: types.textSub(OWNER_NS, 'reason')
        }
    });
    
    var MUC = stanza.define({
        name: 'muc',
        namespace: USER_NS,
        element: 'x',
        fields: {
            affiliation: proxy('_mucUserItem', 'affiliation'),
            nick: proxy('_mucUserItem', 'nick'),
            jid: proxy('_mucUserItem', 'jid'),
            role: proxy('_mucUserItem', 'role'),
            actor: proxy('_mucUserItem', '_mucUserActor'),
            reason: proxy('_mucUserItem', 'reason'),
            password: types.textSub(USER_NS, 'password'),
            codes: {
                get: function () {
                    return types.getMultiSubText(this.xml, USER_NS, 'status', function (sub) {
                        return types.getAttribute(sub, 'code');
                    });
                },
                set: function (value) {
                    var self = this;
                    types.setMultiSubText(this.xml, USER_NS, 'status', value, function (val) {
                        var child = types.createElement(USER_NS, 'status', USER_NS);
                        types.setAttribute(child, 'code', val);
                        self.xml.appendChild(child);
                    });
                }
            }
        }
    });
    
    var MUCAdmin = stanza.define({
        name: 'mucAdmin',
        namespace: ADMIN_NS,
        element: 'query',
        fields: {
            affiliation: proxy('_mucAdminItem', 'affiliation'),
            nick: proxy('_mucAdminItem', 'nick'),
            jid: proxy('_mucAdminItem', 'jid'),
            role: proxy('_mucAdminItem', 'role'),
            actor: proxy('_mucAdminItem', '_mucAdminActor'),
            reason: proxy('_mucAdminItem', 'reason')
        }
    });
    
    var MUCOwner = stanza.define({
        name: 'mucOwner',
        namespace: OWNER_NS,
        element: 'query'
    });
    
    var MUCJoin = stanza.define({
        name: 'joinMuc',
        namespace: NS,
        element: 'x',
        fields: {
            password: types.textSub(NS, 'password'),
            history: {
                get: function () {
                    var result = {};
                    var hist = types.find(this.xml, this._NS, 'history');
    
                    if (!hist.length) {
                        return {};
                    }
                    hist = hist[0];
    
                    var maxchars = hist.getAttribute('maxchars') || '';
                    var maxtypess = hist.getAttribute('maxstanas') || '';
                    var seconds = hist.getAttribute('seconds') || '';
                    var since = hist.getAttribute('since') || '';
    
    
                    if (maxchars) {
                        result.maxchars = parseInt(maxchars, 10);
                    }
                    if (maxtypess) {
                        result.maxtypess = parseInt(maxtypess, 10);
                    }
                    if (seconds) {
                        result.seconds = parseInt(seconds, 10);
                    }
                    if (since) {
                        result.since = new Date(since);
                    }
                },
                set: function (opts) {
                    var existing = types.find(this.xml, this._NS, 'history');
                    if (existing.length) {
                        for (var i = 0; i < existing.length; i++) {
                            this.xml.removeChild(existing[i]);
                        }
                    }
    
                    var hist = types.createElement(this._NS, 'history', this._NS);
                    this.xml.appendChild(hist);
    
                    if (opts.maxchars) {
                        hist.setAttribute('' + opts.maxchars);
                    }
                    if (opts.maxtypess) {
                        hist.setAttribute('' + opts.maxtypess);
                    }
                    if (opts.seconds) {
                        hist.setAttribute('' + opts.seconds);
                    }
                    if (opts.since) {
                        hist.setAttribute(opts.since.toISOString());
                    }
                }
            }
        }
    });
    
    var DirectInvite = stanza.define({
        name: 'mucInvite',
        namespace: 'jabber:x:conference',
        element: 'x',
        fields: {
            jid: types.jidAttribute('jid'),
            password: types.attribute('password'),
            reason: types.attribute('reason'),
            thread: types.attribute('thread'),
            'continue': types.boolAttribute('continue')
        }
    });
    
    
    stanza.extend(UserItem, UserActor);
    stanza.extend(MUC, UserItem);
    stanza.extend(MUC, Invite, 'invites');
    stanza.extend(MUC, Decline);
    stanza.extend(MUC, Destroyed);
    stanza.extend(AdminItem, AdminActor);
    stanza.extend(MUCAdmin, AdminItem, 'items');
    stanza.extend(MUCOwner, Destroy);

    stanza.withDataForm(function (DataForm) {
        stanza.extend(MUCOwner, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'mucUnique', types.textSub(UNIQ_NS, 'unique'));
        stanza.extend(Iq, MUCAdmin);
        stanza.extend(Iq, MUCOwner);
    });
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, MUC);
        stanza.extend(Presence, MUCJoin);
    });

    stanza.withMessage(function (Message) {
        stanza.extend(Message, MUC);
        stanza.extend(Message, DirectInvite);
    });
};

},{}],318:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var nick = stanza.utils.textSub('http://jabber.org/protocol/nick', 'nick');
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'nick', nick);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'nick', nick);
    });

    stanza.withMessage(function (Message) {
        stanza.add(Message, 'nick', nick);
    });
};

},{}],319:[function(require,module,exports){
'use strict';

var NS = 'jabber:x:oob';


module.exports = function (stanza) {
    var OOB = stanza.define({
        name: 'oob',
        element: 'x',
        namespace: NS,
        fields: {
            url: stanza.utils.textSub(NS, 'url'),
            desc: stanza.utils.textSub(NS, 'desc')
        }
    });
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, OOB, 'oobURIs');
    });
};

},{}],320:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:ping';


module.exports = function (stanza) {
    var Ping = stanza.define({
        name: 'ping',
        namespace: NS,
        element: 'ping'
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Ping);
    });
};

},{}],321:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'presence',
        namespace: 'jabber:client',
        element: 'presence',
        topLevel: true,
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true),
            priority: types.numberSub('jabber:client', 'priority', false, 0),
            show: types.textSub('jabber:client', 'show'),
            type: {
                get: function () {
                    return types.getAttribute(this.xml, 'type', 'available');
                },
                set: function (value) {
                    if (value === 'available') {
                        value = false;
                    }
                    types.setAttribute(this.xml, 'type', value);
                }
            },
            $status: {
                get: function () {
                    return types.getSubLangText(this.xml, this._NS, 'status', this.lang);
                }
            },
            status: {
                get: function () {
                    var statuses = this.$status;
                    return statuses[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, this._NS, 'status', value, this.lang);
                }
            },
            idleSince: types.dateSubAttribute('urn:xmpp:idle:1', 'idle', 'since'),
            decloak: types.subAttribute('urn:xmpp:decloak:0', 'decloak', 'reason'),
            avatarId: {
                get: function () {
                    var NS = 'vcard-temp:x:update';
                    var update = types.find(this.xml, NS, 'x');
                    if (!update.length) {
                        return '';
                    }
                    return types.getSubText(update[0], NS, 'photo');
                },
                set: function (value) {
                    var NS = 'vcard-temp:x:update';
                    var update = types.findOrCreate(this.xml, NS, 'x');
    
                    if (value === '') {
                        types.setBoolSub(update, NS, 'photo', true);
                    } else if (value === true) {
                        return;
                    } else if (value) {
                        types.setSubText(update, NS, 'photo', value);
                    } else {
                        this.xml.removeChild(update);
                    }
                }
            }
        }
    });
};

},{}],322:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var PrivateStorage = stanza.define({
        name: 'privateStorage',
        namespace: 'jabber:iq:private',
        element: 'query'
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, PrivateStorage);
    });
};


},{}],323:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:psa';
var CONDITIONS = [
    'server-unavailable', 'connection-paused'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var PSA = stanza.define({
        name: 'state',
        namespace: NS,
        element: 'state-annotation',
        fields: {
            from: types.jidAttribute('from'),
            condition: types.enumSub(NS, CONDITIONS),
            description: types.textSub(NS, 'description')
        }
    });
    
    
    stanza.withPresence(function (Presence) {
        stanza.extend(Presence, PSA);
    });
};

},{}],324:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub';


module.exports = function (stanza) {
    var types = stanza.utils;


    var Pubsub = stanza.define({
        name: 'pubsub',
        namespace: 'http://jabber.org/protocol/pubsub',
        element: 'pubsub',
        fields: {
            publishOptions: {
                get: function () {
                    var DataForm = stanza.getDefinition('x', 'jabber:x:data');
                    var conf = types.find(this.xml, this._NS, 'publish-options');
                    if (conf.length && conf[0].childNodes.length) {
                        return new DataForm({}, conf[0].childNodes[0]);
                    }
                },
                set: function (value) {
                    var DataForm = stanza.getDefinition('x', 'jabber:x:data');
                    var conf = types.findOrCreate(this.xml, this._NS, 'publish-options');
                    if (value) {
                        var form = new DataForm(value);
                        conf.appendChild(form.xml);
                    }
                }
            }
        }
    });
    
    var Subscribe = stanza.define({
        name: 'subscribe',
        namespace: NS,
        element: 'subscribe',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Subscription = stanza.define({
        name: 'subscription',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid'),
            type: types.attribute('subscription'),
            configurable: types.boolSub('subscribe-options'),
            configurationRequired: {
                get: function () {
                    var options = types.find(this.xml, NS, 'subscribe-options');
                    if (options.length) {
                        return types.getBoolSub(options[0], NS, 'required');
                    }
                    return false;
                }
            }
        }
    });

    var Subscriptions = stanza.define({
        name: 'subscriptions',
        namespace: NS,
        element: 'subscriptions',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Affiliation = stanza.define({
        name: 'affiliation',
        namespace: NS,
        element: 'affiliation',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            type: types.attribute('affiliation')
        }
    });
    
    var Affiliations = stanza.define({
        name: 'affiliations',
        namespace: NS,
        element: 'affiliations',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });

    var SubscriptionOptions = stanza.define({
        name: 'subscriptionOptions',
        namespace: NS,
        element: 'options',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid')
        }
    });
    
    var Unsubscribe = stanza.define({
        name: 'unsubscribe',
        namespace: NS,
        element: 'unsubscribe',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid')
        }
    });
    
    var Publish = stanza.define({
        name: 'publish',
        namespace: NS,
        element: 'publish',
        fields: {
            node: types.attribute('node'),
        }
    });
    
    var Retract = stanza.define({
        name: 'retract',
        namespace: NS,
        element: 'retract',
        fields: {
            node: types.attribute('node'),
            notify: types.boolAttribute('notify'),
            id: types.subAttribute(NS, 'item', 'id')
        }
    });
    
    var Retrieve = stanza.define({
        name: 'retrieve',
        namespace: NS,
        element: 'items',
        fields: {
            node: types.attribute('node'),
            max: types.attribute('max_items')
        }
    });
    
    var Item = stanza.define({
        name: 'item',
        namespace: NS,
        element: 'item',
        fields: {
            id: types.attribute('id')
        }
    });
    
    
    stanza.extend(Pubsub, Subscribe);
    stanza.extend(Pubsub, Unsubscribe);
    stanza.extend(Pubsub, Publish);
    stanza.extend(Pubsub, Retract);
    stanza.extend(Pubsub, Retrieve);
    stanza.extend(Pubsub, Subscription);
    stanza.extend(Pubsub, SubscriptionOptions);
    stanza.extend(Pubsub, Subscriptions);
    stanza.extend(Pubsub, Affiliations);
   
    stanza.extend(Publish, Item, 'items');
    stanza.extend(Retrieve, Item, 'items');
    
    stanza.extend(Subscriptions, Subscription, 'list');
    stanza.extend(Affiliations, Affiliation, 'list');

    stanza.withDataForm(function (DataForm) {
        stanza.extend(SubscriptionOptions, DataForm);
        stanza.extend(Item, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Pubsub);
    });

    stanza.withDefinition('set', 'http://jabber.org/protocol/rsm', function (RSM) {
        stanza.extend(Pubsub, RSM);
    });
};

},{}],325:[function(require,module,exports){
'use strict';

var ERRNS = 'http://jabber.org/protocol/pubsub#errors';
var CONDITIONS = [
    'closed-node',
    'configuration-required',
    'invalid-jid',
    'invalid-options',
    'invalid-payload',
    'invalid-subid',
    'item-forbidden',
    'item-required',
    'jid-required',
    'max-items-exceeded',
    'max-nodes-exceeded',
    'nodeid-required',
    'not-in-roster-group',
    'not-subscribed',
    'payload-too-big',
    'payload-required',
    'pending-subscription',
    'presence-subscription-required',
    'subid-required',
    'too-many-subscriptions',
    'unsupported',
    'unsupported-access-model'
];


module.exports = function (stanza) {
    stanza.withStanzaError(function (ErrorStanza) {
        stanza.add(ErrorStanza, 'pubsubCondition', stanza.utils.enumSub(ERRNS, CONDITIONS));
    });
};

},{}],326:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub#event';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Event = stanza.define({
        name: 'event',
        namespace: NS,
        element: 'event'
    });
    
    var EventPurge = stanza.define({
        name: 'purged',
        namespace: NS,
        element: 'purge',
        fields: {
            node: types.attribute('node'),
        }
    });
    
    var EventDelete = stanza.define({
        name: 'deleted',
        namespace: NS,
        element: 'delete',
        fields: {
            node: types.attribute('node'),
            redirect: types.subAttribute(NS, 'redirect', 'uri')
        }
    });
    
    var EventSubscription = stanza.define({
        name: 'subscriptionChanged',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            type: types.attribute('subscription'),
            subid: types.attribute('subid'),
            expiry: {
                get: function () {
                    var text = types.getAttribute(this.xml, 'expiry');
                    if (text === 'presence') {
                        return text;
                    } else if (text) {
                        return new Date(text);
                    }
                },
                set: function (value) {
                    if (!value) {
                        return;
                    }
    
                    if (typeof value !== 'string') {
                        value = value.toISOString();
                    }
    
                    types.setAttribute(this.xml, 'expiry', value);
                }
            }
        }
    });
    
    var EventConfiguration = stanza.define({
        name: 'configurationChanged',
        namespace: NS,
        element: 'configuration',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var EventItems = stanza.define({
        name: 'updated',
        namespace: NS,
        element: 'items',
        fields: {
            node: types.attribute('node'),
            retracted: {
                get: function () {
                    var results = [];
                    var retracted = types.find(this.xml, this._NS, 'retract');
    
                    retracted.forEach(function (xml) {
                        results.push(xml.getAttribute('id'));
                    });
                    return results;
                },
                set: function (value) {
                    var self = this;
                    value.forEach(function (id) {
                        var retracted = types.createElement(self._NS, 'retract', self._NS);
                        retracted.setAttribute('id', id);
                        this.xml.appendChild(retracted);
                    });
                }
            }
        }
    });
    
    var EventItem = stanza.define({
        name: '_eventItem',
        namespace: NS,
        element: 'item',
        fields: {
            id: types.attribute('id'),
            node: types.attribute('node'),
            publisher: types.jidAttribute('publisher')
        }
    });
    
    
    stanza.extend(EventItems, EventItem, 'published');
    
    stanza.extend(Event, EventItems);
    stanza.extend(Event, EventSubscription);
    stanza.extend(Event, EventConfiguration);
    stanza.extend(Event, EventDelete);
    stanza.extend(Event, EventPurge);
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, Event);
    });

    stanza.withDataForm(function (DataForm) {
        stanza.extend(EventConfiguration, DataForm);
    });
};

},{}],327:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/pubsub#owner';


module.exports = function (stanza) {
    var types = stanza.utils;

    var PubsubOwner = stanza.define({
        name: 'pubsubOwner',
        namespace: NS,
        element: 'pubsub',
        fields: {
            create: types.subAttribute(NS, 'create', 'node'),
            purge: types.subAttribute(NS, 'purge', 'node'),
            del: types.subAttribute(NS, 'delete', 'node'),
            redirect: {
                get: function () {
                    var del = types.find(this.xml, this._NS, 'delete');
                    if (del.length) {
                        return types.getSubAttribute(del[0], this._NS, 'redirect', 'uri');
                    }
                    return '';
                },
                set: function (value) {
                    var del = types.findOrCreate(this.xml, this._NS, 'delete');
                    types.setSubAttribute(del, this._NS, 'redirect', 'uri', value);
                }
            }
        }
    });

    var Subscription = stanza.define({
        name: 'subscription',
        namespace: NS,
        element: 'subscription',
        fields: {
            node: types.attribute('node'),
            jid: types.jidAttribute('jid'),
            subid: types.attribute('subid'),
            type: types.attribute('subscription'),
            configurable: types.boolSub('subscribe-options'),
            configurationRequired: {
                get: function () {
                    var options = types.find(this.xml, NS, 'subscribe-options');
                    if (options.length) {
                        return types.getBoolSub(options[0], NS, 'required');
                    }
                    return false;
                }
            }
        }
    });
    
    var Subscriptions = stanza.define({
        name: 'subscriptions',
        namespace: NS,
        element: 'subscriptions',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var Affiliation = stanza.define({
        name: 'affiliation',
        namespace: NS,
        element: 'affiliation',
        fields: {
            node: types.attribute('node'),
            type: types.attribute('affiliation')
        }
    });
    
    var Affiliations = stanza.define({
        name: 'affiliations',
        namespace: NS,
        element: 'affiliations',
        fields: {
            node: types.attribute('node')
        }
    });
    
    var Configure = stanza.define({
        name: 'config',
        namespace: NS,
        element: 'configure',
        fields: {
            node: types.attribute('node')
        }
    });
    
    
    stanza.extend(PubsubOwner, Configure);
    stanza.extend(PubsubOwner, Subscriptions);
    stanza.extend(PubsubOwner, Affiliations);
    
    stanza.extend(Subscriptions, Subscription, 'list');
    stanza.extend(Affiliations, Affiliation, 'list');

    stanza.withDataForm(function (DataForm) {
        stanza.extend(Configure, DataForm);
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, PubsubOwner);
    });
};

},{}],328:[function(require,module,exports){
'use strict';

var _ = require('underscore');
var NS = 'urn:xmpp:reach:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var ReachURI = stanza.define({
        name: '_reachAddr',
        namespace: NS,
        element: 'addr',
        fields: {
            uri: types.attribute('uri'),
            $desc: {
                get: function () {
                    return types.getSubLangText(this.xml, NS, 'desc', this.lang);
                }
            },
            desc: {
                get: function () {
                    var descs = this.$desc;
                    return descs[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, NS, 'desc', value, this.lang);
                }
            }
        }
    });
    
    var reachability = {
        get: function () {
            var reach = types.find(this.xml, NS, 'reach');
            var results = [];
            if (reach.length) {
                var addrs = types.find(reach[0], NS, 'addr');
                _.forEach(addrs, function (addr) {
                    results.push(new ReachURI({}, addr));
                });
            }
            return results;
        },
        set: function (value) {
            var reach = types.findOrCreate(this.xml, NS, 'reach');
            types.setAttribute(reach, 'xmlns', NS);
            _.forEach(value, function (info) {
                var addr = new ReachURI(info);
                reach.appendChild(addr.xml);
            });
        }
    };
    
    
    stanza.withPubsubItem(function (Item) {
        stanza.add(Item, 'reach', reachability);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'reach', reachability);
    });
};

},{"underscore":448}],329:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:register';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Register = stanza.define({
        name: 'register',
        namespace: NS,
        element: 'query',
        fields: {
            instructions: types.textSub(NS, 'instructions'),
            registered: types.boolSub(NS, 'registered'),
            remove: types.boolSub(NS, 'remove'),
            username: types.textSub(NS, 'username'),
            nick: types.textSub(NS, 'nick'),
            password: types.textSub(NS, 'password'),
            name: types.textSub(NS, 'name'),
            first: types.textSub(NS, 'first'),
            last: types.textSub(NS, 'last'),
            email: types.textSub(NS, 'email'),
            address: types.textSub(NS, 'address'),
            city: types.textSub(NS, 'city'),
            state: types.textSub(NS, 'state'),
            zip: types.textSub(NS, 'zip'),
            phone: types.textSub(NS, 'phone'),
            url: types.textSub(NS, 'url'),
            date: types.textSub(NS, 'date'),
            misc: types.textSub(NS, 'misc'),
            text: types.textSub(NS, 'text'),
            key: types.textSub(NS, 'key')
        }
    });
    

    stanza.withDefinition('x', 'jabber:x:oob', function (OOB) {
        stanza.extend(Register, OOB);
    });
    
    stanza.withDataForm(function (DataForm) {
        stanza.extend(Register, DataForm);
    });

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Register);
    });
};

},{}],330:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:roster';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Roster = stanza.define({
        name: 'roster',
        namespace: NS,
        element: 'query',
        fields: {
            ver: {
                get: function () {
                    return types.getAttribute(this.xml, 'ver');
                },
                set: function (value) {
                    var force = (value === '');
                    types.setAttribute(this.xml, 'ver', value, force);
                }
            }
        }
    });
    
    var RosterItem = stanza.define({
        name: '_rosterItem',
        namespace: NS,
        element: 'item',
        fields: {
            jid: types.jidAttribute('jid', true),
            name: types.attribute('name'),
            subscription: types.attribute('subscription', 'none'),
            subscriptionRequested: {
                get: function () {
                    var ask = types.getAttribute(this.xml, 'ask');
                    return ask === 'subscribe';
                }
            },
            preApproved: types.boolAttribute(NS, 'approved'),
            groups: types.multiTextSub(NS, 'group')
        }
    });
    
    
    stanza.extend(Roster, RosterItem, 'items');
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Roster);
    });
};

},{}],331:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/rsm';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'rsm',
        namespace: NS,
        element: 'set',
        fields: {
            after: types.textSub(NS, 'after'),
            before: {
                get: function () {
                    return types.getSubText(this.xml, this._NS, 'before');
                },
                set: function (value) {
                    if (value === true) {
                        types.findOrCreate(this.xml, this._NS, 'before');
                    } else {
                        types.setSubText(this.xml, this._NS, 'before', value);
                    }
                }
            },
            count: types.numberSub(NS, 'count', false, 0),
            first: types.textSub(NS, 'first'),
            firstIndex: types.subAttribute(NS, 'first', 'index'),
            index: types.textSub(NS, 'index'),
            last: types.textSub(NS, 'last'),
            max: types.textSub(NS, 'max')
        }
    });
};

},{}],332:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:jingle:apps:rtp:1';
var FBNS = 'urn:xmpp:jingle:apps:rtp:rtcp-fb:0';
var HDRNS = 'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0';
var INFONS = 'urn:xmpp:jingle:apps:rtp:info:1';
var SSMANS = 'urn:xmpp:jingle:apps:rtp:ssma:0';
var GROUPNS = 'urn:xmpp:jingle:apps:grouping:0';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Feedback = {
        get: function () {
            var existing = types.find(this.xml, FBNS, 'rtcp-fb');
            var result = [];
            existing.forEach(function (xml) {
                result.push({
                    type: types.getAttribute(xml, 'type'),
                    subtype: types.getAttribute(xml, 'subtype')
                });
            });
            existing = types.find(this.xml, FBNS, 'rtcp-fb-trr-int');
            existing.forEach(function (xml) {
                result.push({
                    type: types.getAttribute(xml, 'type'),
                    value: types.getAttribute(xml, 'value')
                });
            });
            return result;
        },
        set: function (values) {
            var self = this;
            var existing = types.find(this.xml, FBNS, 'rtcp-fb');
            existing.forEach(function (item) {
                self.xml.removeChild(item);
            });
            existing = types.find(this.xml, FBNS, 'rtcp-fb-trr-int');
            existing.forEach(function (item) {
                self.xml.removeChild(item);
            });
    
            values.forEach(function (value) {
                var fb;
                if (value.type === 'trr-int') {
                    fb = types.createElement(FBNS, 'rtcp-fb-trr-int', NS);
                    types.setAttribute(fb, 'type', value.type);
                    types.setAttribute(fb, 'value', value.value);
                } else {
                    fb = types.createElement(FBNS, 'rtcp-fb', NS);
                    types.setAttribute(fb, 'type', value.type);
                    types.setAttribute(fb, 'subtype', value.subtype);
                }
                self.xml.appendChild(fb);
            });
        }
    };
    
    var Bandwidth = stanza.define({
        name: 'bandwidth',
        namespace: NS,
        element: 'bandwidth',
        fields: {
            type: types.attribute('type'),
            bandwidth: types.text()
        }
    });

    var RTP = stanza.define({
        name: '_rtp',
        namespace: NS,
        element: 'description',
        tags: ['jingle-description'],
        fields: {
            descType: {value: 'rtp'},
            media: types.attribute('media'),
            ssrc: types.attribute('ssrc'),
            mux: types.boolSub(NS, 'rtcp-mux'),
            encryption: {
                get: function () {
                    var enc = types.find(this.xml, NS, 'encryption');
                    if (!enc.length) {
                        return [];
                    }
                    enc = enc[0];
    
                    var self = this;
                    var data = types.find(enc, NS, 'crypto');
                    var results = [];
    
                    data.forEach(function (xml) {
                        results.push(new Crypto({}, xml, self).toJSON());
                    });
                    return results;
                },
                set: function (values) {
                    var enc = types.find(this.xml, NS, 'encryption');
                    if (enc.length) {
                        this.xml.removeChild(enc);
                    }
    
                    if (!values.length) {
                        return;
                    }
    
                    types.setBoolSubAttribute(this.xml, NS, 'encryption', 'required', true);
                    enc = types.find(this.xml, NS, 'encryption')[0];
    
                    var self = this;
                    values.forEach(function (value) {
                        var content = new Crypto(value, null, self);
                        enc.appendChild(content.xml);
                    });
                }
            },
            feedback: Feedback,
            headerExtensions: {
                get: function () {
                    var existing = types.find(this.xml, HDRNS, 'rtp-hdrext');
                    var result = [];
                    existing.forEach(function (xml) {
                        result.push({
                            id: types.getAttribute(xml, 'id'),
                            uri: types.getAttribute(xml, 'uri'),
                            senders: types.getAttribute(xml, 'senders')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    var existing = types.find(this.xml, HDRNS, 'rtp-hdrext');
                    existing.forEach(function (item) {
                        self.xml.removeChild(item);
                    });
    
                    values.forEach(function (value) {
                        var hdr = types.createElement(HDRNS, 'rtp-hdrext', NS);
                        types.setAttribute(hdr, 'id', value.id);
                        types.setAttribute(hdr, 'uri', value.uri);
                        types.setAttribute(hdr, 'senders', value.senders);
                        self.xml.appendChild(hdr);
                    });
                }
            }
        }
    });
    
    
    var PayloadType = stanza.define({
        name: '_payloadType',
        namespace: NS,
        element: 'payload-type',
        fields: {
            channels: types.attribute('channels'),
            clockrate: types.attribute('clockrate'),
            id: types.attribute('id'),
            maxptime: types.attribute('maxptime'),
            name: types.attribute('name'),
            ptime: types.attribute('ptime'),
            feedback: Feedback,
            parameters: {
                get: function () {
                    var result = [];
                    var params = types.find(this.xml, NS, 'parameter');
                    params.forEach(function (param) {
                        result.push({
                            key: types.getAttribute(param, 'name'),
                            value: types.getAttribute(param, 'value')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (value) {
                        var param = types.createElement(NS, 'parameter');
                        types.setAttribute(param, 'name', value.key);
                        types.setAttribute(param, 'value', value.value);
                        self.xml.appendChild(param);
                    });
                }
            }
        }
    });
    
    
    var Crypto = stanza.define({
        name: 'crypto',
        namespace: NS,
        element: 'crypto',
        fields: {
            cipherSuite: types.attribute('crypto-suite'),
            keyParams: types.attribute('key-params'),
            sessionParams: types.attribute('session-params'),
            tag: types.attribute('tag')
        }
    });
    
    
    var ContentGroup = stanza.define({
        name: '_group',
        namespace: GROUPNS,
        element: 'group',
        fields: {
            semantics: types.attribute('semantics'),
            contents: types.multiSubAttribute(GROUPNS, 'content', 'name')
        }
    });
    
    var SourceGroup = stanza.define({
        name: '_sourceGroup',
        namespace: SSMANS,
        element: 'ssrc-group',
        fields: {
            semantics: types.attribute('semantics'),
            sources: types.multiSubAttribute(SSMANS, 'source', 'ssrc')
        }
    });
    
    var Source = stanza.define({
        name: '_source',
        namespace: SSMANS,
        element: 'source',
        fields: {
            ssrc: types.attribute('ssrc'),
            parameters: {
                get: function () {
                    var result = [];
                    var params = types.find(this.xml, SSMANS, 'parameter');
                    params.forEach(function (param) {
                        result.push({
                            key: types.getAttribute(param, 'name'),
                            value: types.getAttribute(param, 'value')
                        });
                    });
                    return result;
                },
                set: function (values) {
                    var self = this;
                    values.forEach(function (value) {
                        var param = types.createElement(SSMANS, 'parameter');
                        types.setAttribute(param, 'name', value.key);
                        types.setAttribute(param, 'value', value.value);
                        self.xml.appendChild(param);
                    });
                }
            }
        }
    });
    
    
    var Mute = stanza.define({
        name: 'mute',
        namespace: INFONS,
        element: 'mute',
        fields: {
            creator: types.attribute('creator'),
            name: types.attribute('name')
        }
    });
    
    
    var Unmute = stanza.define({
        name: 'unmute',
        namespace: INFONS,
        element: 'unmute',
        fields: {
            creator: types.attribute('creator'),
            name: types.attribute('name')
        }
    });
    
    
    stanza.extend(RTP, Bandwidth);
    stanza.extend(RTP, PayloadType, 'payloads');
    stanza.extend(RTP, Source, 'sources');
    stanza.extend(RTP, SourceGroup, 'sourceGroups');
    
    stanza.withDefinition('content', 'urn:xmpp:jingle:1', function (Content) {
        stanza.extend(Content, RTP);
    });

    stanza.withDefinition('jingle', 'urn:xmpp:jingle:1', function (Jingle) {
        stanza.extend(Jingle, Mute);
        stanza.extend(Jingle, Unmute);
        stanza.extend(Jingle, ContentGroup, 'groups');
        stanza.add(Jingle, 'ringing', types.boolSub(INFONS, 'ringing'));
        stanza.add(Jingle, 'hold', types.boolSub(INFONS, 'hold'));
        stanza.add(Jingle, 'active', types.boolSub(INFONS, 'active'));
    });
};

},{}],333:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:rtt:0';
var typemap = {
    'insert': 't',
    'erase': 'e',
    'wait': 'w',
};
var actionmap = {
    't': 'insert',
    'e': 'erase',
    'w': 'wait'
};


module.exports = function (stanza) {
    var types = stanza.utils;

    var RTT = stanza.define({
        name: 'rtt',
        namespace: NS,
        element: 'rtt',
        fields: {
            id: types.attribute('id'),
            event: types.attribute('event', 'edit'),
            seq: types.numberAttribute('seq'),
            actions: {
                get: function () {
                    var results = [];
                    for(var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                        var child = this.xml.childNodes[i];
                        var name = child.localName;
                        var action = {};
    
                        if (child.namespaceURI !== NS) {
                            continue;
                        }
    
                        if (actionmap[name]) {
                            action.type = actionmap[name];
                        } else {
                            continue;
                        }
    
                        var pos = types.getAttribute(child, 'p');
                        if (pos) {
                            action.pos = parseInt(pos, 10);
                        }
    
                        var n = types.getAttribute(child, 'n');
                        if (n) {
                            action.num = parseInt(n, 10);
                        }
    
                        var t = types.getText(child);
                        if (t && name === 't') {
                            action.text = t;
                        }
    
    
                        results.push(action);
                    }
    
                    return results;
                },
                set: function (actions) {
                    var self = this;
    
                    for (var i = 0, len = this.xml.childNodes.length; i < len; i++) {
                        this.xml.removeChild(this.xml.childNodes[i]);
                    }
    
                    actions.forEach(function (action ) {
                        if (!typemap[action.type]) {
                            return;
                        }
    
                        var child = types.createElement(NS, typemap[action.type], NS);
    
                        if (action.pos !== undefined) {
                            types.setAttribute(child, 'p', action.pos.toString());
                        }
    
                        if (action.num) {
                            types.setAttribute(child, 'n', action.num.toString());
                        }
    
                        if (action.text) {
                            types.setText(child, action.text);
                        }
    
                        self.xml.appendChild(child);
                    });
                }
            }
        }
    });
    
    
    stanza.withMessage(function (Message) {
        stanza.extend(Message, RTT);
    });
};

},{}],334:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-sasl';
var CONDITIONS = [
    'aborted',
    'account-disabled',
    'credentials-expired',
    'encryption-required',
    'incorrect-encoding',
    'invalid-authzid',
    'invalid-mechanism',
    'malformed-request',
    'mechanism-too-weak',
    'not-authorized',
    'temporary-auth-failure'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    var Mechanisms = stanza.define({
        name: 'sasl',
        namespace: NS,
        element: 'mechanisms',
        fields: {
            mechanisms: types.multiTextSub(NS, 'mechanism')
        }
    });

    stanza.define({
        name: 'saslAuth',
        eventName: 'sasl:auth',
        namespace: NS,
        element: 'auth',
        topLevel: true,
        fields: {
            value: types.b64Text(),
            mechanism: types.attribute('mechanism')
        }
    });

    stanza.define({
        name: 'saslChallenge',
        eventName: 'sasl:challenge',
        namespace: NS,
        element: 'challenge',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslResponse',
        eventName: 'sasl:response',
        namespace: NS,
        element: 'response',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslAbort',
        eventName: 'sasl:abort',
        namespace: NS,
        element: 'abort',
        topLevel: true
    });

    stanza.define({
        name: 'saslSuccess',
        eventName: 'sasl:success',
        namespace: NS,
        element: 'success',
        topLevel: true,
        fields: {
            value: types.b64Text()
        }
    });

    stanza.define({
        name: 'saslFailure',
        eventName: 'sasl:failure',
        namespace: NS,
        element: 'failure',
        topLevel: true,
        fields: {
            lang: {
                get: function () {
                    return this._lang || '';
                },
                set: function (value) {
                    this._lang = value;
                }
            },
            condition: types.enumSub(NS, CONDITIONS),
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, NS, 'text', value, this.lang);
                }
            }
        }
    });


    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Mechanisms);
    });
};

},{}],335:[function(require,module,exports){
'use strict';

var NS = 'urn:ietf:params:xml:ns:xmpp-session';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Session = stanza.define({
        name: 'session',
        namespace: NS,
        element: 'session',
        fields: {
            required: types.boolSub(NS, 'required'),
            optional: types.boolSub(NS, 'optional')
        }
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Session);
    });
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, Session);
    });
};

},{}],336:[function(require,module,exports){
'use strict';

var NS = 'http://jabber.org/protocol/shim';


module.exports = function (stanza) {
    var types = stanza.utils;

    var SHIM = {
        get: function () {
            var headerSet = types.find(this.xml, NS, 'headers');
            if (headerSet.length) {
                return types.getMultiSubText(headerSet[0], NS, 'header', function (header) {
                    var name = types.getAttribute(header, 'name');
                    if (name) {
                        return {
                            name: name,
                            value: types.getText(header)
                        };
                    }
                });
            }
            return [];
        },
        set: function (values) {
            var headerSet = types.findOrCreate(this.xml, NS, 'headers');
            stanza.setMultiSubText(headerSet, NS, 'header', values, function (val) {
                var header = types.createElement(NS, 'header', NS);
                types.setAttribute(header, 'name', val.name);
                types.setText(header, val.value);
                headerSet.appendChild(header);
            });
        }
    };
    
    
    stanza.withMessage(function (Message) {
        stanza.add(Message, 'headers', SHIM);
    });

    stanza.withPresence(function (Presence) {
        stanza.add(Presence, 'headers', SHIM);
    });
};

},{}],337:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:sm:3';


module.exports = function (stanza) {
    var types = stanza.utils;

    var SMFeature = stanza.define({
        name: 'streamManagement',
        namespace: NS,
        element: 'sm'
    });

    stanza.define({
        name: 'smEnable',
        eventName: 'stream:management:enable',
        namespace: NS,
        element: 'enable',
        topLevel: true,
        fields: {
            resume: types.boolAttribute('resume')
        }
    });

    stanza.define({
        name: 'smEnabled',
        eventName: 'stream:management:enabled',
        namespace: NS,
        element: 'enabled',
        topLevel: true,
        fields: {
            id: types.attribute('id'),
            resume: types.boolAttribute('resume')
        }
    });

    stanza.define({
        name: 'smResume',
        eventName: 'stream:management:resume',
        namespace: NS,
        element: 'resume',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0),
            previd: types.attribute('previd')
        }
    });

    stanza.define({
        name: 'smResumed',
        eventName: 'stream:management:resumed',
        namespace: NS,
        element: 'resumed',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0),
            previd: types.attribute('previd')
        }
    });

    stanza.define({
        name: 'smFailed',
        eventName: 'stream:management:failed',
        namespace: NS,
        element: 'failed',
        topLevel: true
    });

    stanza.define({
        name: 'smAck',
        eventName: 'stream:management:ack',
        namespace: NS,
        element: 'a',
        topLevel: true,
        fields: {
            h: types.numberAttribute('h', false, 0)
        }
    });

    stanza.define({
        name: 'smRequest',
        eventName: 'stream:management:request',
        namespace: NS,
        element: 'r',
        topLevel: true
    });
    
    
    stanza.withStreamFeatures(function (StreamFeatures) {
        stanza.extend(StreamFeatures, SMFeature);
    });
};

},{}],338:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'stream',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'stream',
        fields: {
            lang: types.langAttribute(),
            id: types.attribute('id'),
            version: types.attribute('version', '1.0'),
            to: types.jidAttribute('to', true),
            from: types.jidAttribute('from', true)
        }
    });
};

},{}],339:[function(require,module,exports){
'use strict';

var ERR_NS = 'urn:ietf:params:xml:ns:xmpp-streams';
var CONDITIONS = [
    'bad-format',
    'bad-namespace-prefix',
    'conflict',
    'connection-timeout',
    'host-gone',
    'host-unknown',
    'improper-addressing',
    'internal-server-error',
    'invalid-from',
    'invalid-namespace',
    'invalid-xml',
    'not-authorized',
    'not-well-formed',
    'policy-violation',
    'remote-connection-failed',
    'reset',
    'resource-constraint',
    'restricted-xml',
    'see-other-host',
    'system-shutdown',
    'undefined-condition',
    'unsupported-encoding',
    'unsupported-feature',
    'unsupported-stanza-type',
    'unsupported-version'
];


module.exports = function (stanza) {
    var types = stanza.utils;

    stanza.define({
        name: 'streamError',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'error',
        topLevel: true,
        fields: {
            lang: {
                get: function () {
                    return this._lang || '';
                },
                set: function (value) {
                    this._lang = value;
                }
            },
            condition: types.enumSub(ERR_NS, CONDITIONS),
            seeOtherHost: {
                get: function () {
                    return types.getSubText(this.xml, ERR_NS, 'see-other-host');
                },
                set: function (value) {
                    this.condition = 'see-other-host';
                    types.setSubText(this.xml, ERR_NS, 'see-other-host', value);
                }
            },
            $text: {
                get: function () {
                    return types.getSubLangText(this.xml, ERR_NS, 'text', this.lang);
                }
            },
            text: {
                get: function () {
                    var text = this.$text;
                    return text[this.lang] || '';
                },
                set: function (value) {
                    types.setSubLangText(this.xml, ERR_NS, 'text', value, this.lang);
                }
            }
        }
    });
};

},{}],340:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var StreamFeatures = stanza.define({
        name: 'streamFeatures',
        namespace: 'http://etherx.jabber.org/streams',
        element: 'features',
        topLevel: true
    });
    
    var RosterVerFeature = stanza.define({
        name: 'rosterVersioning',
        namespace: 'urn:xmpp:features:rosterver',
        element: 'ver'
    });
    
    var SubscriptionPreApprovalFeature = stanza.define({
        name: 'subscriptionPreApproval',
        namespace: 'urn:xmpp:features:pre-approval',
        element: 'sub'
    });
    
    
    stanza.extend(StreamFeatures, RosterVerFeature);
    stanza.extend(StreamFeatures, SubscriptionPreApprovalFeature);
};

},{}],341:[function(require,module,exports){
'use strict';


module.exports = function (stanza) {
    var EntityTime = stanza.define({
        name: 'time',
        namespace: 'urn:xmpp:time',
        element: 'time',
        fields: {
            utc: stanza.utils.dateSub('urn:xmpp:time', 'utc'),
            tzo: stanza.utils.tzoSub('urn:xmpp:time', 'tzo', 0)
        }
    });
    
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, EntityTime);
    });
};

},{}],342:[function(require,module,exports){
'use strict';

var NS = 'vcard-temp';


module.exports = function (stanza) {
    var types = stanza.utils;

    var VCardTemp = stanza.define({
        name: 'vCardTemp',
        namespace: NS,
        element: 'vCard',
        fields: {
            role: types.textSub(NS, 'ROLE'),
            website: types.textSub(NS, 'URL'),
            title: types.textSub(NS, 'TITLE'),
            description: types.textSub(NS, 'DESC'),
            fullName: types.textSub(NS, 'FN'),
            birthday: types.dateSub(NS, 'BDAY'),
            nicknames: types.multiTextSub(NS, 'NICKNAME'),
            jids: types.multiTextSub(NS, 'JABBERID')
        }
    });
    
    var Email = stanza.define({
        name: '_email',
        namespace: NS,
        element: 'EMAIL',
        fields: {
            email: types.textSub(NS, 'USERID'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var PhoneNumber = stanza.define({
        name: '_tel',
        namespace: NS,
        element: 'TEL',
        fields: {
            number: types.textSub(NS, 'NUMBER'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            mobile: types.boolSub(NS, 'CELL'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var Address = stanza.define({
        name: '_address',
        namespace: NS,
        element: 'ADR',
        fields: {
            street: types.textSub(NS, 'STREET'),
            street2: types.textSub(NS, 'EXTADD'),
            country: types.textSub(NS, 'CTRY'),
            city: types.textSub(NS, 'LOCALITY'),
            region: types.textSub(NS, 'REGION'),
            postalCode: types.textSub(NS, 'PCODE'),
            pobox: types.textSub(NS, 'POBOX'),
            home: types.boolSub(NS, 'HOME'),
            work: types.boolSub(NS, 'WORK'),
            preferred: types.boolSub(NS, 'PREF')
        }
    });
    
    var Organization = stanza.define({
        name: 'organization',
        namespace: NS,
        element: 'ORG',
        fields: {
            name: types.textSub(NS, 'ORGNAME'),
            unit: types.textSub(NS, 'ORGUNIT')
        }
    });
    
    var Name = stanza.define({
        name: 'name',
        namespace: NS,
        element: 'N',
        fields: {
            family: types.textSub(NS, 'FAMILY'),
            given: types.textSub(NS, 'GIVEN'),
            middle: types.textSub(NS, 'MIDDLE'),
            prefix: types.textSub(NS, 'PREFIX'),
            suffix: types.textSub(NS, 'SUFFIX')
        }
    });
    
    var Photo = stanza.define({
        name: 'photo',
        namespace: NS,
        element: 'PHOTO',
        fields: {
            type: types.textSub(NS, 'TYPE'),
            data: types.textSub(NS, 'BINVAL'),
            url: types.textSub(NS, 'EXTVAL')
        }
    });
    
    
    stanza.extend(VCardTemp, Email, 'emails');
    stanza.extend(VCardTemp, Address, 'addresses');
    stanza.extend(VCardTemp, PhoneNumber, 'phoneNumbers');
    stanza.extend(VCardTemp, Organization);
    stanza.extend(VCardTemp, Name);
    stanza.extend(VCardTemp, Photo);

    stanza.withIq(function (Iq) {
        stanza.extend(Iq, VCardTemp);
    });
};

},{}],343:[function(require,module,exports){
'use strict';

var NS = 'jabber:iq:version';


module.exports = function (stanza) {
    var types = stanza.utils;

    var Version = stanza.define({
        name: 'version',
        namespace: NS,
        element: 'query',
        fields: {
            name: types.textSub(NS, 'name'),
            version: types.textSub(NS, 'version'),
            os: types.textSub(NS, 'os')
        }
    });
    
    stanza.withIq(function (Iq) {
        stanza.extend(Iq, Version);
    });
};

},{}],344:[function(require,module,exports){
'use strict';

var NS = 'urn:xmpp:invisible:0';


module.exports = function (stanza) {
    stanza.withIq(function (Iq) {
        stanza.add(Iq, 'visible', stanza.utils.boolSub(NS, 'visible'));
        stanza.add(Iq, 'invisible', stanza.utils.boolSub(NS, 'invisible'));
    });
};

},{}],345:[function(require,module,exports){
(function (process,Buffer){
'use strict';

var _ = require('underscore');
var util = require('util');
var BPromise = require('bluebird');
var request = BPromise.promisify(require('request'));

var WildEmitter = require('wildemitter');


function ConnectionError() {}
util.inherits(ConnectionError, Error);


function retryRequest(opts, timeout, allowedRetries, retries) {
    retries = retries || 0;

    var req = request(opts).cancellable().timeout((timeout || 20) * 1000);
    console.log('retryRequest : opts : ', opts);
    console.log('retryRequest : timeout : ', timeout);
    console.log('retryRequest : allowedRetries : ', allowedRetries);
    return req.spread(function (req, body) {
        if (req.statusCode < 200 || req.statusCode >= 400) {
            throw new ConnectionError('HTTP Status Error');
        }
        return body;
    }).catch(BPromise.TimeoutError, function () {
        throw new ConnectionError('Dead Connection, exceeded timeout limit');
    }).catch(function () {
        if (retries < allowedRetries) {
            return BPromise.delay(100).then(function () {
                return retryRequest(opts, timeout, allowedRetries, retries + 1);
            });
        } else {
            throw new ConnectionError('Dead Connection, exceeded retry limit');
        }
    });
}


function BOSHConnection(sm, stanzas) {
    var self = this;

    WildEmitter.call(this);

    self.sm = sm;

    self.stanzas = {
        BOSH: stanzas.getDefinition('body', 'http://jabber.org/protocol/httpbind'),
        StreamError: stanzas.getStreamError()
    };

    self.sendQueue = [];
    self.requests = [];
    self.maxRequests = 2;
    self.sid = '';

    self.on('raw:incoming', function (data) {
        data = data.trim();
        if (data === '') {
            return;
        }

        var bosh, err;

        try {
            bosh = stanzas.parse(data, self.stanzas.BOSH);
        } catch (e) {
            err = new self.stanzas.StreamError({
                condition: 'invalid-xml'
            });
            self.emit('stream:error', err, e);
            self.send(err);
            return self.disconnect();
        }

        if (!self.hasStream) {
            self.hasStream = true;
            self.stream = {
                id: bosh.sid,
                lang: bosh.lang || 'en',
                version: bosh.version || '1.0',
                to: bosh.to,
                from: bosh.from
            };
            self.sid = bosh.sid;
            self.maxRequests = bosh.requests;
        }

        var payload = bosh.payload;
        payload.forEach(function (stanzaObj) {
            if (!stanzaObj.lang) {
                stanzaObj.lang = self.stream.lang;
            }

            self.emit('stream:data', stanzaObj);
        });

        if (bosh.type === 'terminate') {
            self.rid = undefined;
            self.sid = undefined;
            self.emit('bosh:terminate', bosh);
            self.emit('stream:end');
            self.emit('disconnected', self);
        }
    });
}

util.inherits(BOSHConnection, WildEmitter);

BOSHConnection.prototype.connect = function (opts) {
    var self = this;

    self.config = _.extend({
        rid: Math.ceil(Math.random() * 9999999999),
        wait: 30,
        maxRetries: 5
    }, opts);

    self.hasStream = false;
    self.sm.started = false;
    self.url = opts.boshURL;

    self.rid = self.config.rid;

    self.requests = [];

    self.rid++;
    self.request(new self.stanzas.BOSH({
        version: self.config.version || '1.0',
        to: self.config.server,
        lang: self.config.lang || 'en',
        wait: self.config.wait,
        ver: '1.6',
        hold: 1
    }));
};

BOSHConnection.prototype.disconnect = function () {
    if (this.hasStream) {
        this.rid++;
        this.request(new this.stanzas.BOSH({
            type: 'terminate'
        }));
    } else {
        this.requests.forEach(function (ticket) {
            ticket.request.cancel();
        });
        this.stream = undefined;
        this.sid = undefined;
        this.rid = undefined;
        this.emit('disconnected', this);
    }
};

BOSHConnection.prototype.restart = function () {
    var self = this;
    self.rid++;
    self.request(new self.stanzas.BOSH({
        to: self.config.server,
        lang: self.config.lang || 'en',
        restart: 'true'
    }));
};

BOSHConnection.prototype.send = function (data) {
    var self = this;
    if (self.hasStream) {
        self.sendQueue.push(data);
        process.nextTick(self.longPoll.bind(self));
    }
};

BOSHConnection.prototype.longPoll = function () {
    var canReceive = this.requests.length === 0;
    var canSend = this.sendQueue.length > 0 && this.requests.length < this.maxRequests;

    if (!this.sid || (!canReceive && !canSend)) {
        return;
    }

    var stanzas = this.sendQueue;
    this.sendQueue = [];
    this.rid++;

    this.request(new this.stanzas.BOSH({
        payload: stanzas
    }));
};

BOSHConnection.prototype.request = function (bosh) {
    var self = this;

    var ticket = {id: self.rid, request: null};
    bosh.rid = self.rid;
    bosh.sid = self.sid;

    var body = new Buffer(bosh.toString(), 'utf8').toString();

    self.emit('raw:outgoing', body);

    self.requests.push(ticket);

    var req = retryRequest({
        uri: self.url,
        body: body,
        method: 'POST',
        strictSSL: true
    }, self.config.wait * 1.5, this.config.maxRetries);

    ticket.request = req;

    return req.then(function (body) {
        self.emit('raw:incoming', new Buffer(body, 'utf8').toString());
    }).catch(ConnectionError, function (err) {
        self.hasStream = false;
        var serr = new self.stanzas.StreamError({
            condition: 'connection-timeout'
        });
        self.emit('stream:error', serr, err);
        self.disconnect();
    }).catch(BPromise.CancellationError, function () {
        return; // We only cancel on manual disconnect, so let things die silently
    }).finally(function () {
        self.requests = _.filter(self.requests, function (item) {
            return item.id !== ticket.id;
        });
        if (bosh.type !== 'terminate') {
            // Delay next auto-request by two ticks since we're likely
            // to send data anyway next tick.
            process.nextTick(function () {
                process.nextTick(self.longPoll.bind(self));
            });
        }
    });
};

module.exports = BOSHConnection;

}).call(this,require('_process'),require("buffer").Buffer)
},{"_process":149,"bluebird":363,"buffer":5,"request":364,"underscore":448,"util":165,"wildemitter":449}],346:[function(require,module,exports){
'use strict';

var WSConnection = require('./websocket');
var _ = require('underscore');
var util = require('util');



function OldWSConnection(sm, stanzas) {
    WSConnection.call(this, sm, stanzas);

    var self = this;


    function wrap(data) {
        return [self.streamStart, data, self.streamEnd].join('');
    }


    self.on('connected', function () {
        self.streamStart = '<stream:stream xmlns:stream="http://etherx.jabber.org/streams">';
        self.streamEnd = '</stream:stream>';
    });

    self.off('raw:incoming');
    self.on('raw:incoming', function (data) {
        var streamData, ended, err;

        data = data.trim();
        data = data.replace(/^(\s*<\?.*\?>\s*)*/, '');
        if (data === '') {
            return;
        }

        if (data.match(self.streamEnd)) {
            return self.disconnect();
        } else if (self.hasStream) {
            try {
                streamData = stanzas.parse(wrap(data));
            } catch (e) {
                err = new this.stanzas.StreamError({
                    condition: 'invalid-xml'
                });
                self.emit('stream:error', err, e);
                self.send(err);
                return self.disconnect();
            }
        } else {
            // Inspect start of stream element to get NS prefix name
            var parts = data.match(/^<(\S+:)?(\S+) /);
            self.streamStart = data;
            self.streamEnd = '</' + (parts[1] || '') + parts[2] + '>';

            ended = false;
            try {
                streamData = stanzas.parse(data + self.streamEnd);
            } catch (e) {
                try {
                    streamData = stanzas.parse(data);
                    ended = true;
                } catch (e2) {
                    err = new this.stanzas.StreamError({
                        condition: 'invalid-xml'
                    });
                    self.emit('stream:error', err, e2);
                    self.send(err);
                    return self.disconnect();
                }
            }

            self.hasStream = true;
            self.stream = streamData;
            self.emit('stream:start', streamData);
        }

        _.each(streamData._extensions, function (stanzaObj) {
            if (!stanzaObj.lang && self.stream) {
                stanzaObj.lang = self.stream.lang;
            }

            self.emit('stream:data', stanzaObj);
        });

        if (ended) {
            self.emit('stream:end');
        }
    });
}

util.inherits(OldWSConnection, WSConnection);


OldWSConnection.prototype.startHeader = function () {
    return [
        '<stream:stream',
        'xmlns:stream="http://etherx.jabber.org/streams"',
        'xmlns="jabber:client"',
        'version="' + (this.config.version || '1.0') + '"',
        'xml:lang="' + (this.config.lang || 'en') + '"',
        'to="' + this.config.server + '">'
    ].join(' ');
};

OldWSConnection.prototype.closeHeader = function () {
    return '</stream:stream>';
};


module.exports = OldWSConnection;

},{"./websocket":347,"underscore":448,"util":165}],347:[function(require,module,exports){
(function (Buffer){
'use strict';

var util = require('util');
var WildEmitter = require('wildemitter');
var async = require('async');

var WS = (require('faye-websocket') && require('faye-websocket').Client) ?
                                       require('faye-websocket').Client :
                                       window.WebSocket;

var WS_OPEN = 1;



function WSConnection(sm, stanzas) {
    var self = this;

    WildEmitter.call(this);

    self.sm = sm;
    self.closing = false;

    self.stanzas = {
        Open: stanzas.getDefinition('open', 'urn:ietf:params:xml:ns:xmpp-framing', true),
        Close: stanzas.getDefinition('close', 'urn:ietf:params:xml:ns:xmpp-framing', true),
        StreamError: stanzas.getStreamError()
    };

    self.sendQueue = async.queue(function (data, cb) {
        if (self.conn) {
            if (typeof data !== 'string') {
                data = data.toString();
            }

            data = new Buffer(data, 'utf8').toString();

            self.emit('raw:outgoing', data);
            if (self.conn.readyState === WS_OPEN) {
                self.conn.send(data);
            }
        }
        cb();
    }, 1);

    self.on('connected', function () {
        self.send(self.startHeader());
    });

    self.on('raw:incoming', function (data) {
        var stanzaObj, err;

        data = data.trim();
        if (data === '') {
            return;
        }

        try {
            stanzaObj = stanzas.parse(data);
        } catch (e) {
            err = new this.stanzas.StreamError({
                condition: 'invalid-xml'
            });
            self.emit('stream:error', err, e);
            self.send(err);
            return self.disconnect();
        }

        if (stanzaObj._name === 'openStream') {
            self.hasStream = true;
            self.stream = stanzaObj;
            return self.emit('stream:start', stanzaObj.toJSON());
        }
        if (stanzaObj._name === 'closeStream') {
            self.emit('stream:end');
            return self.disconnect();
        }

        if (!stanzaObj.lang && self.stream) {
            stanzaObj.lang = self.stream.lang;
        }

        self.emit('stream:data', stanzaObj);
    });
}

util.inherits(WSConnection, WildEmitter);

WSConnection.prototype.connect = function (opts) {
    var self = this;

    self.config = opts;

    self.hasStream = false;
    self.closing = false;

    self.conn = new WS(opts.wsURL, 'xmpp');
    self.conn.onerror = function (e) {
        e.preventDefault();
        self.emit('disconnected', self);
    };

    self.conn.onclose = function () {
        self.emit('disconnected', self);
    };

    self.conn.onopen = function () {
        self.sm.started = false;
        self.emit('connected', self);
    };

    self.conn.onmessage = function (wsMsg) {
        self.emit('raw:incoming', new Buffer(wsMsg.data, 'utf8').toString());
    };
};

WSConnection.prototype.startHeader = function () {
    return new this.stanzas.Open({
        version: this.config.version || '1.0',
        lang: this.config.lang || 'en',
        to: this.config.server
    });
};

WSConnection.prototype.closeHeader = function () {
    return new this.stanzas.Close();
};

WSConnection.prototype.disconnect = function () {
    if (this.conn && !this.closing) {
        this.closing = true;
        this.send(this.closeHeader());
    } else {
        this.hasStream = false;
        this.stream = undefined;
        if (this.conn.readyState === WS_OPEN) {
            this.conn.close();
        }
        this.conn = undefined;
    }
};

WSConnection.prototype.restart = function () {
    var self = this;
    self.hasStream = false;
    self.send(this.startHeader());
};

WSConnection.prototype.send = function (data) {
    this.sendQueue.push(data);
};


module.exports = WSConnection;

}).call(this,require("buffer").Buffer)
},{"async":362,"buffer":5,"faye-websocket":4,"util":165,"wildemitter":449}],348:[function(require,module,exports){
var randomBytes = require('randombytes');
var createHash = require('create-hash');


function parse(chal) {
    var dtives = {};
    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
    for (var i = 0, len = tokens.length; i < len; i++) {
        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
        if (dtiv) {
            dtives[dtiv[1]] = dtiv[2];
        }
    }
    return dtives;
}

function genNonce() {
    return randomBytes(16).toString('hex');
}



function Mechanism(options) {
    options = options || {};
    this._genNonce = options.genNonce || genNonce;
}

// Conform to the SASL lib's expectations
Mechanism.Mechanism = Mechanism;


Mechanism.prototype.name = 'DIGEST-MD5';
Mechanism.prototype.clientFirst = false;


Mechanism.prototype.response = function(cred) {
    if (this._completed) {
        return undefined;
    }

    var uri = cred.serviceType + '/' + cred.host;

    if (cred.serviceName && cred.host !== cred.serviceName) {
        uri += '/' + cred.serviceName;
    }

    var realm = cred.realm || this._realm || '';
    var cnonce = this._genNonce();
    var nc = '00000001';
    var qop = 'auth';

    var str = '';
    str += 'username="' + cred.username + '"';
    if (realm) {
        str += ',realm="' + realm + '"';
    }
    str += ',nonce="' + this._nonce + '"';
    str += ',cnonce="' + cnonce + '"';
    str += ',nc=' + nc;
    str += ',qop=' + qop;
    str += ',digest-uri="' + uri + '"';
  
    var base = createHash('md5').update(cred.username)
                                .update(':')
                                .update(realm)
                                .update(':')
                                .update(cred.password)
                                .digest();

    var ha1 = createHash('md5').update(base)
                               .update(':')
                               .update(this._nonce)
                               .update(':')
                               .update(cnonce);


    if (cred.authzid) {
        ha1.update(':').update(cred.authzid);
    }

    ha1 = ha1.digest('hex');
  
    var ha2 = createHash('md5').update('AUTHENTICATE:')
                               .update(uri);
    
    if (qop === 'auth-int' || qop === 'auth-conf') {
        ha2.update(':00000000000000000000000000000000');
    }

    ha2 = ha2.digest('hex');
  
    var digest = createHash('md5').update(ha1)
                                  .update(':')
                                  .update(this._nonce)
                                  .update(':')
                                  .update(nc)
                                  .update(':')
                                  .update(cnonce)
                                  .update(':')
                                  .update(qop)
                                  .update(':')
                                  .update(ha2)
                                  .digest('hex');

    str += ',response=' + digest;
  
    if (this._charset === 'utf-8') {
        str += ',charset=utf-8';
    }
    if (cred.authzid) {
        str += 'authzid="' + cred.authzid + '"';
    }
  
    return str;
};

Mechanism.prototype.challenge = function(chal) {
    var dtives = parse(chal);

    this._completed = !!dtives.rspauth;

    this._realm = dtives.realm;
    this._nonce = dtives.nonce;
    this._qop = (dtives.qop || 'auth').split(',');
    this._stale = dtives.stale;
    this._maxbuf = parseInt(dtives.maxbuf) || 65536;
    this._charset = dtives.charset;
    this._algo = dtives.algorithm;
    this._cipher = dtives.cipher;
    if (this._cipher) {
        this._cipher.split(',');
    }

    return this;
};



module.exports = Mechanism;

},{"create-hash":349,"randombytes":361}],349:[function(require,module,exports){
module.exports=require(97)
},{"./md5":351,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js":97,"buffer":5,"inherits":352,"ripemd160":353,"sha.js":355,"stream":163}],350:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/helpers.js":98,"buffer":5}],351:[function(require,module,exports){
module.exports=require(99)
},{"./helpers":350,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js":99}],352:[function(require,module,exports){
module.exports=require(146)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/inherits/inherits_browser.js":146}],353:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":100,"buffer":5}],354:[function(require,module,exports){
module.exports=require(101)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js":101,"buffer":5}],355:[function(require,module,exports){
module.exports=require(102)
},{"./sha1":356,"./sha224":357,"./sha256":358,"./sha384":359,"./sha512":360,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/index.js":102}],356:[function(require,module,exports){
module.exports=require(103)
},{"./hash":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha1.js":103,"buffer":5,"inherits":352}],357:[function(require,module,exports){
module.exports=require(104)
},{"./hash":354,"./sha256":358,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha224.js":104,"buffer":5,"inherits":352}],358:[function(require,module,exports){
module.exports=require(105)
},{"./hash":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js":105,"buffer":5,"inherits":352}],359:[function(require,module,exports){
module.exports=require(106)
},{"./hash":354,"./sha512":360,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha384.js":106,"buffer":5,"inherits":352}],360:[function(require,module,exports){
module.exports=require(107)
},{"./hash":354,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js":107,"buffer":5,"inherits":352}],361:[function(require,module,exports){
module.exports=require(144)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js":144,"_process":149,"buffer":5}],362:[function(require,module,exports){
(function (process){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        if (arr.forEach) {
            return arr.forEach(iterator);
        }
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        }
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
                q.process();
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                q.process();
            }
        };
        return q;
    };
    
    async.priorityQueue = function (worker, concurrency) {
        
        function _compareTasks(a, b){
          return a.priority - b.priority;
        };
        
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }
        
        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };
              
              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }
        
        // Start with a normal queue
        var q = async.queue(worker, concurrency);
        
        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };
        
        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]))
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define !== 'undefined' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'))
},{"_process":149}],363:[function(require,module,exports){
(function (process,global){
/* @preserve
 * The MIT License (MIT)
 * 
 * Copyright (c) 2014 Petka Antonov
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:</p>
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
/**
 * bluebird build version 2.9.9
 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, progress, cancel, using, filter, any, each, timers
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var SomePromiseArray = Promise._SomePromiseArray;
function any(promises) {
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(1);
    ret.setUnwrap();
    ret.init();
    return promise;
}

Promise.any = function (promises) {
    return any(promises);
};

Promise.prototype.any = function () {
    return any(this);
};

};

},{}],2:[function(_dereq_,module,exports){
"use strict";
var firstLineError;
try {throw new Error(); } catch (e) {firstLineError = e;}
var schedule = _dereq_("./schedule.js");
var Queue = _dereq_("./queue.js");
var _process = typeof process !== "undefined" ? process : undefined;

function Async() {
    this._isTickUsed = false;
    this._lateQueue = new Queue(16);
    this._normalQueue = new Queue(16);
    var self = this;
    this.drainQueues = function () {
        self._drainQueues();
    };
    this._schedule =
        schedule.isStatic ? schedule(this.drainQueues) : schedule;
}

Async.prototype.haveItemsQueued = function () {
    return this._normalQueue.length() > 0;
};

Async.prototype._withDomain = function(fn) {
    if (_process !== undefined &&
        _process.domain != null &&
        !fn.domain) {
        fn = _process.domain.bind(fn);
    }
    return fn;
};

Async.prototype.throwLater = function(fn, arg) {
    if (arguments.length === 1) {
        arg = fn;
        fn = function () { throw arg; };
    }
    fn = this._withDomain(fn);
    if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
            fn(arg);
        }, 0);
    } else try {
        this._schedule(function() {
            fn(arg);
        });
    } catch (e) {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    }
};

Async.prototype.invokeLater = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._lateQueue.push(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.invokeFirst = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._normalQueue.unshift(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.invoke = function (fn, receiver, arg) {
    fn = this._withDomain(fn);
    this._normalQueue.push(fn, receiver, arg);
    this._queueTick();
};

Async.prototype.settlePromises = function(promise) {
    this._normalQueue._pushOne(promise);
    this._queueTick();
};

Async.prototype._drainQueue = function(queue) {
    while (queue.length() > 0) {
        var fn = queue.shift();
        if (typeof fn !== "function") {
            fn._settlePromises();
            continue;
        }
        var receiver = queue.shift();
        var arg = queue.shift();
        fn.call(receiver, arg);
    }
};

Async.prototype._drainQueues = function () {
    this._drainQueue(this._normalQueue);
    this._reset();
    this._drainQueue(this._lateQueue);
};

Async.prototype._queueTick = function () {
    if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
    }
};

Async.prototype._reset = function () {
    this._isTickUsed = false;
};

module.exports = new Async();
module.exports.firstLineError = firstLineError;

},{"./queue.js":28,"./schedule.js":31}],3:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise) {
function returnThis() { return this.value; }
function throwThis() { throw this.reason; }
function awaitBindingThenResolve(value) {
    return this._then(returnThis, null, null, {value: value}, undefined);
}
function awaitBindingThenReject(reason) {
    return this._then(throwThis, throwThis, null, {reason: reason}, undefined);
}
function setBinding(binding) { this._setBoundTo(binding); }
Promise.prototype.bind = function (thisArg) {
    var maybePromise = tryConvertToPromise(thisArg);
    if (maybePromise instanceof Promise) {
        if (maybePromise.isFulfilled()) {
            thisArg = maybePromise.value();
        } else if (maybePromise.isRejected()) {
            return Promise.reject(maybePromise.reason());
        } else {
            var ret = this.then();
            var parent = ret;
            ret = ret._then(awaitBindingThenResolve,
                            awaitBindingThenReject,
                            null, maybePromise, undefined);
            maybePromise._then(setBinding, ret._reject, null, ret, null);
            if (!ret._cancellable()) ret._setPendingCancellationParent(parent);
            return ret;
        }
    }
    var ret = this.then();
    ret._setBoundTo(thisArg);
    return ret;
};

Promise.bind = function (thisArg, value) {
    return Promise.resolve(value).bind(thisArg);
};

Promise.prototype._setPendingCancellationParent = function(parent) {
    this._settledValue = parent;
};

Promise.prototype._pendingCancellationParent = function() {
    if (this.isPending() && this._settledValue !== undefined) {
        var ret = this._settledValue;
        ret.cancellable();
        this._settledValue = undefined;
        return ret;
    }
};

Promise.prototype._setIsBound = function () {
    this._bitField = this._bitField | 131072;
};

Promise.prototype._unsetIsBound = function () {
    this._bitField = this._bitField & (~131072);
};

Promise.prototype._isBound = function () {
    return (this._bitField & 131072) === 131072;
};

Promise.prototype._setIsMigratingBinding = function () {
    this._bitField = this._bitField | 8388608;
};

Promise.prototype._unsetIsMigratingBinding = function () {
    this._bitField = this._bitField & (~8388608);
};

Promise.prototype._isMigratingBinding = function () {
    return (this._bitField & 8388608) === 8388608;
};

Promise.prototype._setBoundTo = function (obj) {
    if (obj === undefined) {
        if (this._isBound()) {
            this._boundTo = undefined;
        }
        this._unsetIsBound();
    } else {
        this._setIsBound();
        this._boundTo = obj;
    }
};
};

},{}],4:[function(_dereq_,module,exports){
"use strict";
var old;
if (typeof Promise !== "undefined") old = Promise;
function noConflict() {
    try { if (Promise === bluebird) Promise = old; }
    catch (e) {}
    return bluebird;
}
var bluebird = _dereq_("./promise.js")();
bluebird.noConflict = noConflict;
module.exports = bluebird;

},{"./promise.js":23}],5:[function(_dereq_,module,exports){
"use strict";
var cr = Object.create;
if (cr) {
    var callerCache = cr(null);
    var getterCache = cr(null);
    callerCache[" size"] = getterCache[" size"] = 0;
}

module.exports = function(Promise) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var isIdentifier = util.isIdentifier;

var getMethodCaller;
var getGetter;
if (!true) {
var makeMethodCaller = function (methodName) {
    return new Function("ensureMethod", "                                    \n\
        return function(obj) {                                               \n\
            'use strict'                                                     \n\
            var len = this.length;                                           \n\
            ensureMethod(obj, 'methodName');                                 \n\
            switch(len) {                                                    \n\
                case 1: return obj.methodName(this[0]);                      \n\
                case 2: return obj.methodName(this[0], this[1]);             \n\
                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
                case 0: return obj.methodName();                             \n\
                default:                                                     \n\
                    return obj.methodName.apply(obj, this);                  \n\
            }                                                                \n\
        };                                                                   \n\
        ".replace(/methodName/g, methodName))(ensureMethod);
};

var makeGetter = function (propertyName) {
    return new Function("obj", "                                             \n\
        'use strict';                                                        \n\
        return obj.propertyName;                                             \n\
        ".replace("propertyName", propertyName));
};

var getCompiled = function(name, compiler, cache) {
    var ret = cache[name];
    if (typeof ret !== "function") {
        if (!isIdentifier(name)) {
            return null;
        }
        ret = compiler(name);
        cache[name] = ret;
        cache[" size"]++;
        if (cache[" size"] > 512) {
            var keys = Object.keys(cache);
            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
            cache[" size"] = keys.length - 256;
        }
    }
    return ret;
};

getMethodCaller = function(name) {
    return getCompiled(name, makeMethodCaller, callerCache);
};

getGetter = function(name) {
    return getCompiled(name, makeGetter, getterCache);
};
}

function ensureMethod(obj, methodName) {
    var fn;
    if (obj != null) fn = obj[methodName];
    if (typeof fn !== "function") {
        var message = "Object " + util.classString(obj) + " has no method '" +
            util.toString(methodName) + "'";
        throw new Promise.TypeError(message);
    }
    return fn;
}

function caller(obj) {
    var methodName = this.pop();
    var fn = ensureMethod(obj, methodName);
    return fn.apply(obj, this);
}
Promise.prototype.call = function (methodName) {
    var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
    if (!true) {
        if (canEvaluate) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
                return this._then(
                    maybeCaller, undefined, undefined, args, undefined);
            }
        }
    }
    args.push(methodName);
    return this._then(caller, undefined, undefined, args, undefined);
};

function namedGetter(obj) {
    return obj[this];
}
function indexedGetter(obj) {
    var index = +this;
    if (index < 0) index = Math.max(0, index + obj.length);
    return obj[index];
}
Promise.prototype.get = function (propertyName) {
    var isIndex = (typeof propertyName === "number");
    var getter;
    if (!isIndex) {
        if (canEvaluate) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
        } else {
            getter = namedGetter;
        }
    } else {
        getter = indexedGetter;
    }
    return this._then(getter, undefined, undefined, propertyName, undefined);
};
};

},{"./util.js":38}],6:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var errors = _dereq_("./errors.js");
var async = _dereq_("./async.js");
var CancellationError = errors.CancellationError;

Promise.prototype._cancel = function (reason) {
    if (!this.isCancellable()) return this;
    var parent;
    var promiseToReject = this;
    while ((parent = promiseToReject._cancellationParent) !== undefined &&
        parent.isCancellable()) {
        promiseToReject = parent;
    }
    this._unsetCancellable();
    promiseToReject._target()._rejectCallback(reason, false, true);
};

Promise.prototype.cancel = function (reason) {
    if (!this.isCancellable()) return this;
    if (reason === undefined) reason = new CancellationError();
    async.invokeLater(this._cancel, this, reason);
    return this;
};

Promise.prototype.cancellable = function () {
    if (this._cancellable()) return this;
    this._setCancellable();
    this._cancellationParent = this._pendingCancellationParent();
    return this;
};

Promise.prototype.uncancellable = function () {
    var ret = this.then();
    ret._unsetCancellable();
    return ret;
};

Promise.prototype.fork = function (didFulfill, didReject, didProgress) {
    var ret = this._then(didFulfill, didReject, didProgress,
                         undefined, undefined);

    ret._setCancellable();
    ret._cancellationParent = undefined;
    return ret;
};
};

},{"./async.js":2,"./errors.js":13}],7:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var async = _dereq_("./async.js");
var util = _dereq_("./util.js");
var bluebirdFramePattern =
    /[\\\/]bluebird[\\\/]js[\\\/](main|debug|zalgo|instrumented)/;
var stackFramePattern = null;
var formatStack = null;
var indentStackFrames = false;
var warn;

function CapturedTrace(parent) {
    this._parent = parent;
    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
    captureStackTrace(this, CapturedTrace);
    if (length > 32) this.uncycle();
}
util.inherits(CapturedTrace, Error);

CapturedTrace.prototype.uncycle = function() {
    var length = this._length;
    if (length < 2) return;
    var nodes = [];
    var stackToIndex = {};

    for (var i = 0, node = this; node !== undefined; ++i) {
        nodes.push(node);
        node = node._parent;
    }
    length = this._length = i;
    for (var i = length - 1; i >= 0; --i) {
        var stack = nodes[i].stack;
        if (stackToIndex[stack] === undefined) {
            stackToIndex[stack] = i;
        }
    }
    for (var i = 0; i < length; ++i) {
        var currentStack = nodes[i].stack;
        var index = stackToIndex[currentStack];
        if (index !== undefined && index !== i) {
            if (index > 0) {
                nodes[index - 1]._parent = undefined;
                nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = undefined;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

            if (index < length - 1) {
                cycleEdgeNode._parent = nodes[index + 1];
                cycleEdgeNode._parent.uncycle();
                cycleEdgeNode._length =
                    cycleEdgeNode._parent._length + 1;
            } else {
                cycleEdgeNode._parent = undefined;
                cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
                nodes[j]._length = currentChildLength;
                currentChildLength++;
            }
            return;
        }
    }
};

CapturedTrace.prototype.parent = function() {
    return this._parent;
};

CapturedTrace.prototype.hasParent = function() {
    return this._parent !== undefined;
};

CapturedTrace.prototype.attachExtraTrace = function(error) {
    if (error.__stackCleaned__) return;
    this.uncycle();
    var parsed = CapturedTrace.parseStackAndMessage(error);
    var message = parsed.message;
    var stacks = [parsed.stack];

    var trace = this;
    while (trace !== undefined) {
        stacks.push(cleanStack(trace.stack.split("\n")));
        trace = trace._parent;
    }
    removeCommonRoots(stacks);
    removeDuplicateOrEmptyJumps(stacks);
    error.stack = reconstructStack(message, stacks);
    error.__stackCleaned__ = true;
};

function reconstructStack(message, stacks) {
    for (var i = 0; i < stacks.length - 1; ++i) {
        stacks[i].push("From previous event:");
        stacks[i] = stacks[i].join("\n");
    }
    if (i < stacks.length) {
        stacks[i] = stacks[i].join("\n");
    }
    return message + "\n" + stacks.join("\n");
}

function removeDuplicateOrEmptyJumps(stacks) {
    for (var i = 0; i < stacks.length; ++i) {
        if (stacks[i].length === 0 ||
            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
            stacks.splice(i, 1);
            i--;
        }
    }
}

function removeCommonRoots(stacks) {
    var current = stacks[0];
    for (var i = 1; i < stacks.length; ++i) {
        var prev = stacks[i];
        var currentLastIndex = current.length - 1;
        var currentLastLine = current[currentLastIndex];
        var commonRootMeetPoint = -1;

        for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
                commonRootMeetPoint = j;
                break;
            }
        }

        for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
                current.pop();
                currentLastIndex--;
            } else {
                break;
            }
        }
        current = prev;
    }
}

function cleanStack(stack) {
    var ret = [];
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        var isTraceLine = stackFramePattern.test(line) ||
            "    (No stack trace)" === line;
        var isInternalFrame = isTraceLine && shouldIgnore(line);
        if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
                line = "    " + line;
            }
            ret.push(line);
        }
    }
    return ret;
}

function stackFramesAsArray(error) {
    var stack = error.stack.replace(/\s+$/g, "").split("\n");
    for (var i = 0; i < stack.length; ++i) {
        var line = stack[i];
        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
        }
    }
    if (i > 0) {
        stack = stack.slice(i);
    }
    return stack;
}

CapturedTrace.parseStackAndMessage = function(error) {
    var stack = error.stack;
    var message = error.toString();
    stack = typeof stack === "string" && stack.length > 0
                ? stackFramesAsArray(error) : ["    (No stack trace)"];
    return {
        message: message,
        stack: cleanStack(stack)
    };
};

CapturedTrace.formatAndLogError = function(error, title) {
    if (typeof console !== "undefined") {
        var message;
        if (typeof error === "object" || typeof error === "function") {
            var stack = error.stack;
            message = title + formatStack(stack, error);
        } else {
            message = title + String(error);
        }
        if (typeof warn === "function") {
            warn(message);
        } else if (typeof console.log === "function" ||
            typeof console.log === "object") {
            console.log(message);
        }
    }
};

CapturedTrace.unhandledRejection = function (reason) {
    CapturedTrace.formatAndLogError(reason, "^--- With additional stack trace: ");
};

CapturedTrace.isSupported = function () {
    return typeof captureStackTrace === "function";
};

CapturedTrace.fireRejectionEvent =
function(name, localHandler, reason, promise) {
    var localEventFired = false;
    try {
        if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
                localHandler(promise);
            } else {
                localHandler(reason, promise);
            }
        }
    } catch (e) {
        async.throwLater(e);
    }

    var globalEventFired = false;
    try {
        globalEventFired = fireGlobalEvent(name, reason, promise);
    } catch (e) {
        globalEventFired = true;
        async.throwLater(e);
    }

    var domEventFired = false;
    if (fireDomEvent) {
        try {
            domEventFired = fireDomEvent(name.toLowerCase(), {
                reason: reason,
                promise: promise
            });
        } catch (e) {
            domEventFired = true;
            async.throwLater(e);
        }
    }

    if (!globalEventFired && !localEventFired && !domEventFired &&
        name === "unhandledRejection") {
        CapturedTrace.formatAndLogError(reason, "Unhandled rejection ");
    }
};

function formatNonError(obj) {
    var str;
    if (typeof obj === "function") {
        str = "[function " +
            (obj.name || "anonymous") +
            "]";
    } else {
        str = obj.toString();
        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
        if (ruselessToString.test(str)) {
            try {
                var newStr = JSON.stringify(obj);
                str = newStr;
            }
            catch(e) {

            }
        }
        if (str.length === 0) {
            str = "(empty array)";
        }
    }
    return ("(<" + snip(str) + ">, no stack trace)");
}

function snip(str) {
    var maxChars = 41;
    if (str.length < maxChars) {
        return str;
    }
    return str.substr(0, maxChars - 3) + "...";
}

var shouldIgnore = function() { return false; };
var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
function parseLineInfo(line) {
    var matches = line.match(parseLineInfoRegex);
    if (matches) {
        return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
        };
    }
}
CapturedTrace.setBounds = function(firstLineError, lastLineError) {
    if (!CapturedTrace.isSupported()) return;
    var firstStackLines = firstLineError.stack.split("\n");
    var lastStackLines = lastLineError.stack.split("\n");
    var firstIndex = -1;
    var lastIndex = -1;
    var firstFileName;
    var lastFileName;
    for (var i = 0; i < firstStackLines.length; ++i) {
        var result = parseLineInfo(firstStackLines[i]);
        if (result) {
            firstFileName = result.fileName;
            firstIndex = result.line;
            break;
        }
    }
    for (var i = 0; i < lastStackLines.length; ++i) {
        var result = parseLineInfo(lastStackLines[i]);
        if (result) {
            lastFileName = result.fileName;
            lastIndex = result.line;
            break;
        }
    }
    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
        firstFileName !== lastFileName || firstIndex >= lastIndex) {
        return;
    }

    shouldIgnore = function(line) {
        if (bluebirdFramePattern.test(line)) return true;
        var info = parseLineInfo(line);
        if (info) {
            if (info.fileName === firstFileName &&
                (firstIndex <= info.line && info.line <= lastIndex)) {
                return true;
            }
        }
        return false;
    };
};

var captureStackTrace = (function stackDetection() {
    var v8stackFramePattern = /^\s*at\s*/;
    var v8stackFormatter = function(stack, error) {
        if (typeof stack === "string") return stack;

        if (error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    if (typeof Error.stackTraceLimit === "number" &&
        typeof Error.captureStackTrace === "function") {
        Error.stackTraceLimit = Error.stackTraceLimit + 6;
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        var captureStackTrace = Error.captureStackTrace;

        shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
        };
        return function(receiver, ignoreUntil) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            captureStackTrace(receiver, ignoreUntil);
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }
    var err = new Error();

    if (typeof err.stack === "string" &&
        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
        stackFramePattern = /@/;
        formatStack = v8stackFormatter;
        indentStackFrames = true;
        return function captureStackTrace(o) {
            o.stack = new Error().stack;
        };
    }

    var hasStackAfterThrow;
    try { throw new Error(); }
    catch(e) {
        hasStackAfterThrow = ("stack" in e);
    }
    if (!("stack" in err) && hasStackAfterThrow) {
        stackFramePattern = v8stackFramePattern;
        formatStack = v8stackFormatter;
        return function captureStackTrace(o) {
            Error.stackTraceLimit = Error.stackTraceLimit + 6;
            try { throw new Error(); }
            catch(e) { o.stack = e.stack; }
            Error.stackTraceLimit = Error.stackTraceLimit - 6;
        };
    }

    formatStack = function(stack, error) {
        if (typeof stack === "string") return stack;

        if ((typeof error === "object" ||
            typeof error === "function") &&
            error.name !== undefined &&
            error.message !== undefined) {
            return error.toString();
        }
        return formatNonError(error);
    };

    return null;

})([]);

var fireDomEvent;
var fireGlobalEvent = (function() {
    if (util.isNode) {
        return function(name, reason, promise) {
            if (name === "rejectionHandled") {
                return process.emit(name, promise);
            } else {
                return process.emit(name, reason, promise);
            }
        };
    } else {
        var customEventWorks = false;
        var anyEventWorks = true;
        try {
            var ev = new self.CustomEvent("test");
            customEventWorks = ev instanceof CustomEvent;
        } catch (e) {}
        if (!customEventWorks) {
            try {
                var event = document.createEvent("CustomEvent");
                event.initCustomEvent("testingtheevent", false, true, {});
                self.dispatchEvent(event);
            } catch (e) {
                anyEventWorks = false;
            }
        }
        if (anyEventWorks) {
            fireDomEvent = function(type, detail) {
                var event;
                if (customEventWorks) {
                    event = new self.CustomEvent(type, {
                        detail: detail,
                        bubbles: false,
                        cancelable: true
                    });
                } else if (self.dispatchEvent) {
                    event = document.createEvent("CustomEvent");
                    event.initCustomEvent(type, false, true, detail);
                }

                return event ? !self.dispatchEvent(event) : false;
            };
        }

        var toWindowMethodNameMap = {};
        toWindowMethodNameMap["unhandledRejection"] = ("on" +
            "unhandledRejection").toLowerCase();
        toWindowMethodNameMap["rejectionHandled"] = ("on" +
            "rejectionHandled").toLowerCase();

        return function(name, reason, promise) {
            var methodName = toWindowMethodNameMap[name];
            var method = self[methodName];
            if (!method) return false;
            if (name === "rejectionHandled") {
                method.call(self, promise);
            } else {
                method.call(self, reason, promise);
            }
            return true;
        };
    }
})();

if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
    warn = function (message) {
        console.warn(message);
    };
    if (util.isNode && process.stderr.isTTY) {
        warn = function(message) {
            process.stderr.write("\u001b[31m" + message + "\u001b[39m\n");
        };
    } else if (!util.isNode && typeof (new Error().stack) === "string") {
        warn = function(message) {
            console.warn("%c" + message, "color: red");
        };
    }
}

return CapturedTrace;
};

},{"./async.js":2,"./util.js":38}],8:[function(_dereq_,module,exports){
"use strict";
module.exports = function(NEXT_FILTER) {
var util = _dereq_("./util.js");
var errors = _dereq_("./errors.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var keys = _dereq_("./es5.js").keys;
var TypeError = errors.TypeError;

function CatchFilter(instances, callback, promise) {
    this._instances = instances;
    this._callback = callback;
    this._promise = promise;
}

function safePredicate(predicate, e) {
    var safeObject = {};
    var retfilter = tryCatch(predicate).call(safeObject, e);

    if (retfilter === errorObj) return retfilter;

    var safeKeys = keys(safeObject);
    if (safeKeys.length) {
        errorObj.e = new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a");
        return errorObj;
    }
    return retfilter;
}

CatchFilter.prototype.doFilter = function (e) {
    var cb = this._callback;
    var promise = this._promise;
    var boundTo = promise._boundTo;
    for (var i = 0, len = this._instances.length; i < len; ++i) {
        var item = this._instances[i];
        var itemIsErrorType = item === Error ||
            (item != null && item.prototype instanceof Error);

        if (itemIsErrorType && e instanceof item) {
            var ret = tryCatch(cb).call(boundTo, e);
            if (ret === errorObj) {
                NEXT_FILTER.e = ret.e;
                return NEXT_FILTER;
            }
            return ret;
        } else if (typeof item === "function" && !itemIsErrorType) {
            var shouldHandle = safePredicate(item, e);
            if (shouldHandle === errorObj) {
                e = errorObj.e;
                break;
            } else if (shouldHandle) {
                var ret = tryCatch(cb).call(boundTo, e);
                if (ret === errorObj) {
                    NEXT_FILTER.e = ret.e;
                    return NEXT_FILTER;
                }
                return ret;
            }
        }
    }
    NEXT_FILTER.e = e;
    return NEXT_FILTER;
};

return CatchFilter;
};

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],9:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace, isDebugging) {
var contextStack = [];
function Context() {
    this._trace = new CapturedTrace(peekContext());
}
Context.prototype._pushContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.push(this._trace);
    }
};

Context.prototype._popContext = function () {
    if (!isDebugging()) return;
    if (this._trace !== undefined) {
        contextStack.pop();
    }
};

function createContext() {
    if (isDebugging()) return new Context();
}

function peekContext() {
    var lastIndex = contextStack.length - 1;
    if (lastIndex >= 0) {
        return contextStack[lastIndex];
    }
    return undefined;
}

Promise.prototype._peekContext = peekContext;
Promise.prototype._pushContext = Context.prototype._pushContext;
Promise.prototype._popContext = Context.prototype._popContext;

return createContext;
};

},{}],10:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, CapturedTrace) {
var async = _dereq_("./async.js");
var Warning = _dereq_("./errors.js").Warning;
var util = _dereq_("./util.js");
var canAttachTrace = util.canAttachTrace;
var unhandledRejectionHandled;
var possiblyUnhandledRejection;
var debugging = false || (util.isNode &&
                    (!!process.env["BLUEBIRD_DEBUG"] ||
                     process.env["NODE_ENV"] === "development"));

Promise.prototype._ensurePossibleRejectionHandled = function () {
    this._setRejectionIsUnhandled();
    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
};

Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
    CapturedTrace.fireRejectionEvent("rejectionHandled",
                                  unhandledRejectionHandled, undefined, this);
};

Promise.prototype._notifyUnhandledRejection = function () {
    if (this._isRejectionUnhandled()) {
        var reason = this._getCarriedStackTrace() || this._settledValue;
        this._setUnhandledRejectionIsNotified();
        CapturedTrace.fireRejectionEvent("unhandledRejection",
                                      possiblyUnhandledRejection, reason, this);
    }
};

Promise.prototype._setUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField | 524288;
};

Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
    this._bitField = this._bitField & (~524288);
};

Promise.prototype._isUnhandledRejectionNotified = function () {
    return (this._bitField & 524288) > 0;
};

Promise.prototype._setRejectionIsUnhandled = function () {
    this._bitField = this._bitField | 2097152;
};

Promise.prototype._unsetRejectionIsUnhandled = function () {
    this._bitField = this._bitField & (~2097152);
    if (this._isUnhandledRejectionNotified()) {
        this._unsetUnhandledRejectionIsNotified();
        this._notifyUnhandledRejectionIsHandled();
    }
};

Promise.prototype._isRejectionUnhandled = function () {
    return (this._bitField & 2097152) > 0;
};

Promise.prototype._setCarriedStackTrace = function (capturedTrace) {
    this._bitField = this._bitField | 1048576;
    this._fulfillmentHandler0 = capturedTrace;
};

Promise.prototype._isCarryingStackTrace = function () {
    return (this._bitField & 1048576) > 0;
};

Promise.prototype._getCarriedStackTrace = function () {
    return this._isCarryingStackTrace()
        ? this._fulfillmentHandler0
        : undefined;
};

Promise.prototype._captureStackTrace = function () {
    if (debugging) {
        this._trace = new CapturedTrace(this._peekContext());
    }
    return this;
};

Promise.prototype._attachExtraTrace = function (error, ignoreSelf) {
    if (debugging && canAttachTrace(error)) {
        var trace = this._trace;
        if (trace !== undefined) {
            if (ignoreSelf) trace = trace._parent;
        }
        if (trace !== undefined) {
            trace.attachExtraTrace(error);
        } else if (!error.__stackCleaned__) {
            var parsed = CapturedTrace.parseStackAndMessage(error);
            error.stack = parsed.message + "\n" + parsed.stack.join("\n");
            error.__stackCleaned__ = true;
        }
    }
};

Promise.prototype._warn = function(message) {
    var warning = new Warning(message);
    var ctx = this._peekContext();
    if (ctx) {
        ctx.attachExtraTrace(warning);
    } else {
        var parsed = CapturedTrace.parseStackAndMessage(warning);
        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
    }
    CapturedTrace.formatAndLogError(warning, "");
};

Promise.onPossiblyUnhandledRejection = function (fn) {
    possiblyUnhandledRejection = typeof fn === "function" ? fn : undefined;
};

Promise.onUnhandledRejectionHandled = function (fn) {
    unhandledRejectionHandled = typeof fn === "function" ? fn : undefined;
};

Promise.longStackTraces = function () {
    if (async.haveItemsQueued() &&
        debugging === false
   ) {
        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/DT1qyG\u000a");
    }
    debugging = CapturedTrace.isSupported();
};

Promise.hasLongStackTraces = function () {
    return debugging && CapturedTrace.isSupported();
};

if (!CapturedTrace.isSupported()) {
    Promise.longStackTraces = function(){};
    debugging = false;
}

return function() {
    return debugging;
};
};

},{"./async.js":2,"./errors.js":13,"./util.js":38}],11:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var isPrimitive = util.isPrimitive;
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;

module.exports = function(Promise) {
var returner = function () {
    return this;
};
var thrower = function () {
    throw this;
};

var wrapper = function (value, action) {
    if (action === 1) {
        return function () {
            throw value;
        };
    } else if (action === 2) {
        return function () {
            return value;
        };
    }
};


Promise.prototype["return"] =
Promise.prototype.thenReturn = function (value) {
    if (wrapsPrimitiveReceiver && isPrimitive(value)) {
        return this._then(
            wrapper(value, 2),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(returner, undefined, undefined, value, undefined);
};

Promise.prototype["throw"] =
Promise.prototype.thenThrow = function (reason) {
    if (wrapsPrimitiveReceiver && isPrimitive(reason)) {
        return this._then(
            wrapper(reason, 1),
            undefined,
            undefined,
            undefined,
            undefined
       );
    }
    return this._then(thrower, undefined, undefined, reason, undefined);
};
};

},{"./util.js":38}],12:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseReduce = Promise.reduce;

Promise.prototype.each = function (fn) {
    return PromiseReduce(this, fn, null, INTERNAL);
};

Promise.each = function (promises, fn) {
    return PromiseReduce(promises, fn, null, INTERNAL);
};
};

},{}],13:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var Objectfreeze = es5.freeze;
var util = _dereq_("./util.js");
var inherits = util.inherits;
var notEnumerableProp = util.notEnumerableProp;

function subError(nameProperty, defaultMessage) {
    function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp(this, "message",
            typeof message === "string" ? message : defaultMessage);
        notEnumerableProp(this, "name", nameProperty);
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        } else {
            Error.call(this);
        }
    }
    inherits(SubError, Error);
    return SubError;
}

var _TypeError, _RangeError;
var Warning = subError("Warning", "warning");
var CancellationError = subError("CancellationError", "cancellation error");
var TimeoutError = subError("TimeoutError", "timeout error");
var AggregateError = subError("AggregateError", "aggregate error");
try {
    _TypeError = TypeError;
    _RangeError = RangeError;
} catch(e) {
    _TypeError = subError("TypeError", "type error");
    _RangeError = subError("RangeError", "range error");
}

var methods = ("join pop push shift unshift slice filter forEach some " +
    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

for (var i = 0; i < methods.length; ++i) {
    if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
    }
}

es5.defineProperty(AggregateError.prototype, "length", {
    value: 0,
    configurable: false,
    writable: true,
    enumerable: true
});
AggregateError.prototype["isOperational"] = true;
var level = 0;
AggregateError.prototype.toString = function() {
    var indent = Array(level * 4 + 1).join(" ");
    var ret = "\n" + indent + "AggregateError of:" + "\n";
    level++;
    indent = Array(level * 4 + 1).join(" ");
    for (var i = 0; i < this.length; ++i) {
        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
            lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret += str + "\n";
    }
    level--;
    return ret;
};

function OperationalError(message) {
    if (!(this instanceof OperationalError))
        return new OperationalError(message);
    notEnumerableProp(this, "name", "OperationalError");
    notEnumerableProp(this, "message", message);
    this.cause = message;
    this["isOperational"] = true;

    if (message instanceof Error) {
        notEnumerableProp(this, "message", message.message);
        notEnumerableProp(this, "stack", message.stack);
    } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }

}
inherits(OperationalError, Error);

var errorTypes = Error["__BluebirdErrorTypes__"];
if (!errorTypes) {
    errorTypes = Objectfreeze({
        CancellationError: CancellationError,
        TimeoutError: TimeoutError,
        OperationalError: OperationalError,
        RejectionError: OperationalError,
        AggregateError: AggregateError
    });
    notEnumerableProp(Error, "__BluebirdErrorTypes__", errorTypes);
}

module.exports = {
    Error: Error,
    TypeError: _TypeError,
    RangeError: _RangeError,
    CancellationError: errorTypes.CancellationError,
    OperationalError: errorTypes.OperationalError,
    TimeoutError: errorTypes.TimeoutError,
    AggregateError: errorTypes.AggregateError,
    Warning: Warning
};

},{"./es5.js":14,"./util.js":38}],14:[function(_dereq_,module,exports){
var isES5 = (function(){
    "use strict";
    return this === undefined;
})();

if (isES5) {
    module.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5: isES5,
        propertyIsWritable: function(obj, prop) {
            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
            return !!(!descriptor || descriptor.writable || descriptor.set);
        }
    };
} else {
    var has = {}.hasOwnProperty;
    var str = {}.toString;
    var proto = {}.constructor.prototype;

    var ObjectKeys = function (o) {
        var ret = [];
        for (var key in o) {
            if (has.call(o, key)) {
                ret.push(key);
            }
        }
        return ret;
    };

    var ObjectGetDescriptor = function(o, key) {
        return {value: o[key]};
    };

    var ObjectDefineProperty = function (o, key, desc) {
        o[key] = desc.value;
        return o;
    };

    var ObjectFreeze = function (obj) {
        return obj;
    };

    var ObjectGetPrototypeOf = function (obj) {
        try {
            return Object(obj).constructor.prototype;
        }
        catch (e) {
            return proto;
        }
    };

    var ArrayIsArray = function (obj) {
        try {
            return str.call(obj) === "[object Array]";
        }
        catch(e) {
            return false;
        }
    };

    module.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5: isES5,
        propertyIsWritable: function() {
            return true;
        }
    };
}

},{}],15:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var PromiseMap = Promise.map;

Promise.prototype.filter = function (fn, options) {
    return PromiseMap(this, fn, options, INTERNAL);
};

Promise.filter = function (promises, fn, options) {
    return PromiseMap(promises, fn, options, INTERNAL);
};
};

},{}],16:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, NEXT_FILTER, tryConvertToPromise) {
var util = _dereq_("./util.js");
var wrapsPrimitiveReceiver = util.wrapsPrimitiveReceiver;
var isPrimitive = util.isPrimitive;
var thrower = util.thrower;

function returnThis() {
    return this;
}
function throwThis() {
    throw this;
}
function return$(r) {
    return function() {
        return r;
    };
}
function throw$(r) {
    return function() {
        throw r;
    };
}
function promisedFinally(ret, reasonOrValue, isFulfilled) {
    var then;
    if (wrapsPrimitiveReceiver && isPrimitive(reasonOrValue)) {
        then = isFulfilled ? return$(reasonOrValue) : throw$(reasonOrValue);
    } else {
        then = isFulfilled ? returnThis : throwThis;
    }
    return ret._then(then, thrower, undefined, reasonOrValue, undefined);
}

function finallyHandler(reasonOrValue) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo)
                    : handler();

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, reasonOrValue,
                                    promise.isFulfilled());
        }
    }

    if (promise.isRejected()) {
        NEXT_FILTER.e = reasonOrValue;
        return NEXT_FILTER;
    } else {
        return reasonOrValue;
    }
}

function tapHandler(value) {
    var promise = this.promise;
    var handler = this.handler;

    var ret = promise._isBound()
                    ? handler.call(promise._boundTo, value)
                    : handler(value);

    if (ret !== undefined) {
        var maybePromise = tryConvertToPromise(ret, promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            return promisedFinally(maybePromise, value, true);
        }
    }
    return value;
}

Promise.prototype._passThroughHandler = function (handler, isFinally) {
    if (typeof handler !== "function") return this.then();

    var promiseAndHandler = {
        promise: this,
        handler: handler
    };

    return this._then(
            isFinally ? finallyHandler : tapHandler,
            isFinally ? finallyHandler : undefined, undefined,
            promiseAndHandler, undefined);
};

Promise.prototype.lastly =
Promise.prototype["finally"] = function (handler) {
    return this._passThroughHandler(handler, true);
};

Promise.prototype.tap = function (handler) {
    return this._passThroughHandler(handler, false);
};
};

},{"./util.js":38}],17:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          apiRejection,
                          INTERNAL,
                          tryConvertToPromise) {
var errors = _dereq_("./errors.js");
var TypeError = errors.TypeError;
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
var yieldHandlers = [];

function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
    for (var i = 0; i < yieldHandlers.length; ++i) {
        traceParent._pushContext();
        var result = tryCatch(yieldHandlers[i])(value);
        traceParent._popContext();
        if (result === errorObj) {
            traceParent._pushContext();
            var ret = Promise.reject(errorObj.e);
            traceParent._popContext();
            return ret;
        }
        var maybePromise = tryConvertToPromise(result, traceParent);
        if (maybePromise instanceof Promise) return maybePromise;
    }
    return null;
}

function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
    var promise = this._promise = new Promise(INTERNAL);
    promise._captureStackTrace();
    this._stack = stack;
    this._generatorFunction = generatorFunction;
    this._receiver = receiver;
    this._generator = undefined;
    this._yieldHandlers = typeof yieldHandler === "function"
        ? [yieldHandler].concat(yieldHandlers)
        : yieldHandlers;
}

PromiseSpawn.prototype.promise = function () {
    return this._promise;
};

PromiseSpawn.prototype._run = function () {
    this._generator = this._generatorFunction.call(this._receiver);
    this._receiver =
        this._generatorFunction = undefined;
    this._next(undefined);
};

PromiseSpawn.prototype._continue = function (result) {
    if (result === errorObj) {
        return this._promise._rejectCallback(result.e, false, true);
    }

    var value = result.value;
    if (result.done === true) {
        this._promise._resolveCallback(value);
    } else {
        var maybePromise = tryConvertToPromise(value, this._promise);
        if (!(maybePromise instanceof Promise)) {
            maybePromise =
                promiseFromYieldHandler(maybePromise,
                                        this._yieldHandlers,
                                        this._promise);
            if (maybePromise === null) {
                this._throw(
                    new TypeError(
                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/4Y4pDk\u000a\u000a".replace("%s", value) +
                        "From coroutine:\u000a" +
                        this._stack.split("\n").slice(1, -7).join("\n")
                    )
                );
                return;
            }
        }
        maybePromise._then(
            this._next,
            this._throw,
            undefined,
            this,
            null
       );
    }
};

PromiseSpawn.prototype._throw = function (reason) {
    this._promise._attachExtraTrace(reason);
    this._promise._pushContext();
    var result = tryCatch(this._generator["throw"])
        .call(this._generator, reason);
    this._promise._popContext();
    this._continue(result);
};

PromiseSpawn.prototype._next = function (value) {
    this._promise._pushContext();
    var result = tryCatch(this._generator.next).call(this._generator, value);
    this._promise._popContext();
    this._continue(result);
};

Promise.coroutine = function (generatorFunction, options) {
    if (typeof generatorFunction !== "function") {
        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var yieldHandler = Object(options).yieldHandler;
    var PromiseSpawn$ = PromiseSpawn;
    var stack = new Error().stack;
    return function () {
        var generator = generatorFunction.apply(this, arguments);
        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
                                      stack);
        spawn._generator = generator;
        spawn._next(undefined);
        return spawn.promise();
    };
};

Promise.coroutine.addYieldHandler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    yieldHandlers.push(fn);
};

Promise.spawn = function (generatorFunction) {
    if (typeof generatorFunction !== "function") {
        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/6Vqhm0\u000a");
    }
    var spawn = new PromiseSpawn(generatorFunction, this);
    var ret = spawn.promise();
    spawn._run(Promise.spawn);
    return ret;
};
};

},{"./errors.js":13,"./util.js":38}],18:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, tryConvertToPromise, INTERNAL) {
var util = _dereq_("./util.js");
var canEvaluate = util.canEvaluate;
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var reject;

if (!true) {
if (canEvaluate) {
    var thenCallback = function(i) {
        return new Function("value", "holder", "                             \n\
            'use strict';                                                    \n\
            holder.pIndex = value;                                           \n\
            holder.checkFulfillment(this);                                   \n\
            ".replace(/Index/g, i));
    };

    var caller = function(count) {
        var values = [];
        for (var i = 1; i <= count; ++i) values.push("holder.p" + i);
        return new Function("holder", "                                      \n\
            'use strict';                                                    \n\
            var callback = holder.fn;                                        \n\
            return callback(values);                                         \n\
            ".replace(/values/g, values.join(", ")));
    };
    var thenCallbacks = [];
    var callers = [undefined];
    for (var i = 1; i <= 5; ++i) {
        thenCallbacks.push(thenCallback(i));
        callers.push(caller(i));
    }

    var Holder = function(total, fn) {
        this.p1 = this.p2 = this.p3 = this.p4 = this.p5 = null;
        this.fn = fn;
        this.total = total;
        this.now = 0;
    };

    Holder.prototype.callers = callers;
    Holder.prototype.checkFulfillment = function(promise) {
        var now = this.now;
        now++;
        var total = this.total;
        if (now >= total) {
            var handler = this.callers[total];
            promise._pushContext();
            var ret = tryCatch(handler)(this);
            promise._popContext();
            if (ret === errorObj) {
                promise._rejectCallback(ret.e, false, true);
            } else {
                promise._resolveCallback(ret);
            }
        } else {
            this.now = now;
        }
    };

    var reject = function (reason) {
        this._reject(reason);
    };
}
}

Promise.join = function () {
    var last = arguments.length - 1;
    var fn;
    if (last > 0 && typeof arguments[last] === "function") {
        fn = arguments[last];
        if (!true) {
            if (last < 6 && canEvaluate) {
                var ret = new Promise(INTERNAL);
                ret._captureStackTrace();
                var holder = new Holder(last, fn);
                var callbacks = thenCallbacks;
                for (var i = 0; i < last; ++i) {
                    var maybePromise = tryConvertToPromise(arguments[i], ret);
                    if (maybePromise instanceof Promise) {
                        maybePromise = maybePromise._target();
                        if (maybePromise._isPending()) {
                            maybePromise._then(callbacks[i], reject,
                                               undefined, ret, holder);
                        } else if (maybePromise._isFulfilled()) {
                            callbacks[i].call(ret,
                                              maybePromise._value(), holder);
                        } else {
                            ret._reject(maybePromise._reason());
                        }
                    } else {
                        callbacks[i].call(ret, maybePromise, holder);
                    }
                }
                return ret;
            }
        }
    }
    var $_len = arguments.length;var args = new Array($_len); for(var $_i = 0; $_i < $_len; ++$_i) {args[$_i] = arguments[$_i];}
    if (fn) args.pop();
    var ret = new PromiseArray(args).promise();
    return fn !== undefined ? ret.spread(fn) : ret;
};

};

},{"./util.js":38}],19:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
var PENDING = {};
var EMPTY_ARRAY = [];

function MappingPromiseArray(promises, fn, limit, _filter) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._callback = fn;
    this._preservedValues = _filter === INTERNAL
        ? new Array(this.length())
        : null;
    this._limit = limit;
    this._inFlight = 0;
    this._queue = limit >= 1 ? [] : EMPTY_ARRAY;
    this._init$(undefined, -2);
}
util.inherits(MappingPromiseArray, PromiseArray);

MappingPromiseArray.prototype._init = function () {};

MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var limit = this._limit;
    if (values[index] === PENDING) {
        values[index] = value;
        if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return;
        }
    } else {
        if (limit >= 1 && this._inFlight >= limit) {
            values[index] = value;
            this._queue.push(index);
            return;
        }
        if (preservedValues !== null) preservedValues[index] = value;

        var callback = this._callback;
        var receiver = this._promise._boundTo;
        this._promise._pushContext();
        var ret = tryCatch(callback).call(receiver, value, index, length);
        this._promise._popContext();
        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                if (limit >= 1) this._inFlight++;
                values[index] = PENDING;
                return maybePromise._proxyPromiseArray(this, index);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }
        values[index] = ret;
    }
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= length) {
        if (preservedValues !== null) {
            this._filter(values, preservedValues);
        } else {
            this._resolve(values);
        }

    }
};

MappingPromiseArray.prototype._drainQueue = function () {
    var queue = this._queue;
    var limit = this._limit;
    var values = this._values;
    while (queue.length > 0 && this._inFlight < limit) {
        if (this._isResolved()) return;
        var index = queue.pop();
        this._promiseFulfilled(values[index], index);
    }
};

MappingPromiseArray.prototype._filter = function (booleans, values) {
    var len = values.length;
    var ret = new Array(len);
    var j = 0;
    for (var i = 0; i < len; ++i) {
        if (booleans[i]) ret[j++] = values[i];
    }
    ret.length = j;
    this._resolve(ret);
};

MappingPromiseArray.prototype.preservedValues = function () {
    return this._preservedValues;
};

function map(promises, fn, options, _filter) {
    var limit = typeof options === "object" && options !== null
        ? options.concurrency
        : 0;
    limit = typeof limit === "number" &&
        isFinite(limit) && limit >= 1 ? limit : 0;
    return new MappingPromiseArray(promises, fn, limit, _filter);
}

Promise.prototype.map = function (fn, options) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");

    return map(this, fn, options, null).promise();
};

Promise.map = function (promises, fn, options, _filter) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    return map(promises, fn, options, _filter).promise();
};


};

},{"./util.js":38}],20:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;

Promise.method = function (fn) {
    if (typeof fn !== "function") {
        throw new Promise.TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    return function () {
        var ret = new Promise(INTERNAL);
        ret._captureStackTrace();
        ret._pushContext();
        var value = tryCatch(fn).apply(this, arguments);
        ret._popContext();
        ret._resolveFromSyncValue(value);
        return ret;
    };
};

Promise.attempt = Promise["try"] = function (fn, args, ctx) {
    if (typeof fn !== "function") {
        return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._pushContext();
    var value = util.isArray(args)
        ? tryCatch(fn).apply(ctx, args)
        : tryCatch(fn).call(ctx, args);
    ret._popContext();
    ret._resolveFromSyncValue(value);
    return ret;
};

Promise.prototype._resolveFromSyncValue = function (value) {
    if (value === util.errorObj) {
        this._rejectCallback(value.e, false, true);
    } else {
        this._resolveCallback(value, true);
    }
};
};

},{"./util.js":38}],21:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

function spreadAdapter(val, nodeback) {
    var promise = this;
    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
    var ret = tryCatch(nodeback).apply(promise._boundTo, [null].concat(val));
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

function successAdapter(val, nodeback) {
    var promise = this;
    var receiver = promise._boundTo;
    var ret = val === undefined
        ? tryCatch(nodeback).call(receiver, null)
        : tryCatch(nodeback).call(receiver, null, val);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}
function errorAdapter(reason, nodeback) {
    var promise = this;
    if (!reason) {
        var target = promise._target();
        var newReason = target._getCarriedStackTrace();
        newReason.cause = reason;
        reason = newReason;
    }
    var ret = tryCatch(nodeback).call(promise._boundTo, reason);
    if (ret === errorObj) {
        async.throwLater(ret.e);
    }
}

Promise.prototype.nodeify = function (nodeback, options) {
    if (typeof nodeback == "function") {
        var adapter = successAdapter;
        if (options !== undefined && Object(options).spread) {
            adapter = spreadAdapter;
        }
        this._then(
            adapter,
            errorAdapter,
            undefined,
            this,
            nodeback
        );
    }
    return this;
};
};

},{"./async.js":2,"./util.js":38}],22:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, PromiseArray) {
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;

Promise.prototype.progressed = function (handler) {
    return this._then(undefined, undefined, handler, undefined, undefined);
};

Promise.prototype._progress = function (progressValue) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._target()._progressUnchecked(progressValue);

};

Promise.prototype._progressHandlerAt = function (index) {
    return index === 0
        ? this._progressHandler0
        : this[(index << 2) + index - 5 + 2];
};

Promise.prototype._doProgressWith = function (progression) {
    var progressValue = progression.value;
    var handler = progression.handler;
    var promise = progression.promise;
    var receiver = progression.receiver;

    var ret = tryCatch(handler).call(receiver, progressValue);
    if (ret === errorObj) {
        if (ret.e != null &&
            ret.e.name !== "StopProgressPropagation") {
            var trace = util.canAttachTrace(ret.e)
                ? ret.e : new Error(util.toString(ret.e));
            promise._attachExtraTrace(trace);
            promise._progress(ret.e);
        }
    } else if (ret instanceof Promise) {
        ret._then(promise._progress, null, null, promise, undefined);
    } else {
        promise._progress(ret);
    }
};


Promise.prototype._progressUnchecked = function (progressValue) {
    var len = this._length();
    var progress = this._progress;
    for (var i = 0; i < len; i++) {
        var handler = this._progressHandlerAt(i);
        var promise = this._promiseAt(i);
        if (!(promise instanceof Promise)) {
            var receiver = this._receiverAt(i);
            if (typeof handler === "function") {
                handler.call(receiver, progressValue, promise);
            } else if (receiver instanceof PromiseArray &&
                       !receiver._isResolved()) {
                receiver._promiseProgressed(progressValue, promise);
            }
            continue;
        }

        if (typeof handler === "function") {
            async.invoke(this._doProgressWith, this, {
                handler: handler,
                promise: promise,
                receiver: this._receiverAt(i),
                value: progressValue
            });
        } else {
            async.invoke(progress, promise, progressValue);
        }
    }
};
};

},{"./async.js":2,"./util.js":38}],23:[function(_dereq_,module,exports){
"use strict";
module.exports = function() {
var makeSelfResolutionError = function () {
    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/LhFpo0\u000a");
};
var reflect = function() {
    return new Promise.PromiseInspection(this._target());
};
var apiRejection = function(msg) {
    return Promise.reject(new TypeError(msg));
};
var util = _dereq_("./util.js");
var async = _dereq_("./async.js");
var errors = _dereq_("./errors.js");
var TypeError = Promise.TypeError = errors.TypeError;
Promise.RangeError = errors.RangeError;
Promise.CancellationError = errors.CancellationError;
Promise.TimeoutError = errors.TimeoutError;
Promise.OperationalError = errors.OperationalError;
Promise.RejectionError = errors.OperationalError;
Promise.AggregateError = errors.AggregateError;
var INTERNAL = function(){};
var APPLY = {};
var NEXT_FILTER = {e: null};
var tryConvertToPromise = _dereq_("./thenables.js")(Promise, INTERNAL);
var PromiseArray =
    _dereq_("./promise_array.js")(Promise, INTERNAL,
                                    tryConvertToPromise, apiRejection);
var CapturedTrace = _dereq_("./captured_trace.js")();
var isDebugging = _dereq_("./debuggability.js")(Promise, CapturedTrace);
 /*jshint unused:false*/
var createContext =
    _dereq_("./context.js")(Promise, CapturedTrace, isDebugging);
var CatchFilter = _dereq_("./catch_filter.js")(NEXT_FILTER);
var PromiseResolver = _dereq_("./promise_resolver.js");
var nodebackForPromise = PromiseResolver._nodebackForPromise;
var errorObj = util.errorObj;
var tryCatch = util.tryCatch;
function Promise(resolver) {
    if (typeof resolver !== "function") {
        throw new TypeError("the promise constructor requires a resolver function\u000a\u000a    See http://goo.gl/EC22Yn\u000a");
    }
    if (this.constructor !== Promise) {
        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/KsIlge\u000a");
    }
    this._bitField = 0;
    this._fulfillmentHandler0 = undefined;
    this._rejectionHandler0 = undefined;
    this._progressHandler0 = undefined;
    this._promise0 = undefined;
    this._receiver0 = undefined;
    this._settledValue = undefined;
    if (resolver !== INTERNAL) this._resolveFromResolver(resolver);
}

Promise.prototype.toString = function () {
    return "[object Promise]";
};

Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
    var len = arguments.length;
    if (len > 1) {
        var catchInstances = new Array(len - 1),
            j = 0, i;
        for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (typeof item === "function") {
                catchInstances[j++] = item;
            } else {
                return Promise.reject(
                    new TypeError("Catch filter must inherit from Error or be a simple predicate function\u000a\u000a    See http://goo.gl/o84o68\u000a"));
            }
        }
        catchInstances.length = j;
        fn = arguments[i];
        var catchFilter = new CatchFilter(catchInstances, fn, this);
        return this._then(undefined, catchFilter.doFilter, undefined,
            catchFilter, undefined);
    }
    return this._then(undefined, fn, undefined, undefined, undefined);
};

Promise.prototype.reflect = function () {
    return this._then(reflect, reflect, undefined, this, undefined);
};

Promise.prototype.then = function (didFulfill, didReject, didProgress) {
    if (isDebugging() && arguments.length > 0 &&
        typeof didFulfill !== "function" &&
        typeof didReject !== "function") {
        var msg = ".then() only accepts functions but was passed: " +
                util.classString(didFulfill);
        if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
        }
        this._warn(msg);
    }
    return this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
};

Promise.prototype.done = function (didFulfill, didReject, didProgress) {
    var promise = this._then(didFulfill, didReject, didProgress,
        undefined, undefined);
    promise._setIsFinal();
};

Promise.prototype.spread = function (didFulfill, didReject) {
    return this.all()._then(didFulfill, didReject, undefined, APPLY, undefined);
};

Promise.prototype.isCancellable = function () {
    return !this.isResolved() &&
        this._cancellable();
};

Promise.prototype.toJSON = function () {
    var ret = {
        isFulfilled: false,
        isRejected: false,
        fulfillmentValue: undefined,
        rejectionReason: undefined
    };
    if (this.isFulfilled()) {
        ret.fulfillmentValue = this.value();
        ret.isFulfilled = true;
    } else if (this.isRejected()) {
        ret.rejectionReason = this.reason();
        ret.isRejected = true;
    }
    return ret;
};

Promise.prototype.all = function () {
    return new PromiseArray(this).promise();
};

Promise.prototype.error = function (fn) {
    return this.caught(util.originatesFromRejection, fn);
};

Promise.is = function (val) {
    return val instanceof Promise;
};

Promise.fromNode = function(fn) {
    var ret = new Promise(INTERNAL);
    var result = tryCatch(fn)(nodebackForPromise(ret));
    if (result === errorObj) {
        ret._rejectCallback(result.e, true, true);
    }
    return ret;
};

Promise.all = function (promises) {
    return new PromiseArray(promises).promise();
};

Promise.defer = Promise.pending = function () {
    var promise = new Promise(INTERNAL);
    return new PromiseResolver(promise);
};

Promise.cast = function (obj) {
    var ret = tryConvertToPromise(obj);
    if (!(ret instanceof Promise)) {
        var val = ret;
        ret = new Promise(INTERNAL);
        ret._fulfillUnchecked(val);
    }
    return ret;
};

Promise.resolve = Promise.fulfilled = Promise.cast;

Promise.reject = Promise.rejected = function (reason) {
    var ret = new Promise(INTERNAL);
    ret._captureStackTrace();
    ret._rejectCallback(reason, true);
    return ret;
};

Promise.setScheduler = function(fn) {
    if (typeof fn !== "function") throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var prev = async._schedule;
    async._schedule = fn;
    return prev;
};

Promise.prototype._then = function (
    didFulfill,
    didReject,
    didProgress,
    receiver,
    internalData
) {
    var haveInternalData = internalData !== undefined;
    var ret = haveInternalData ? internalData : new Promise(INTERNAL);

    if (!haveInternalData) {
        ret._propagateFrom(this, 4 | 1);
        ret._captureStackTrace();
    }

    var target = this._target();
    if (target !== this) {
        if (!haveInternalData) {
            ret._setIsMigrated();
            if (receiver === undefined) {
                ret._setIsMigratingBinding();
                receiver = this;
            }
        }
    }

    var callbackIndex =
        target._addCallbacks(didFulfill, didReject, didProgress, ret, receiver);

    if (target._isResolved() && !target._isSettlePromisesQueued()) {
        async.invoke(
            target._settlePromiseAtPostResolution, target, callbackIndex);
    }

    return ret;
};

Promise.prototype._settlePromiseAtPostResolution = function (index) {
    if (this._isRejectionUnhandled()) this._unsetRejectionIsUnhandled();
    this._settlePromiseAt(index);
};

Promise.prototype._length = function () {
    return this._bitField & 131071;
};

Promise.prototype._isFollowingOrFulfilledOrRejected = function () {
    return (this._bitField & 939524096) > 0;
};

Promise.prototype._isFollowing = function () {
    return (this._bitField & 536870912) === 536870912;
};

Promise.prototype._setLength = function (len) {
    this._bitField = (this._bitField & -131072) |
        (len & 131071);
};

Promise.prototype._setFulfilled = function () {
    this._bitField = this._bitField | 268435456;
};

Promise.prototype._setRejected = function () {
    this._bitField = this._bitField | 134217728;
};

Promise.prototype._setFollowing = function () {
    this._bitField = this._bitField | 536870912;
};

Promise.prototype._setIsFinal = function () {
    this._bitField = this._bitField | 33554432;
};

Promise.prototype._isFinal = function () {
    return (this._bitField & 33554432) > 0;
};

Promise.prototype._cancellable = function () {
    return (this._bitField & 67108864) > 0;
};

Promise.prototype._setCancellable = function () {
    this._bitField = this._bitField | 67108864;
};

Promise.prototype._unsetCancellable = function () {
    this._bitField = this._bitField & (~67108864);
};

Promise.prototype._setIsMigrated = function () {
    this._bitField = this._bitField | 4194304;
};

Promise.prototype._unsetIsMigrated = function () {
    this._bitField = this._bitField & (~4194304);
};

Promise.prototype._isMigrated = function () {
    return (this._bitField & 4194304) > 0;
};

Promise.prototype._receiverAt = function (index) {
    var ret = index === 0
        ? this._receiver0
        : this[
            index * 5 - 5 + 4];
    if (ret === undefined && this._isBound()) {
        return this._boundTo;
    }
    return ret;
};

Promise.prototype._promiseAt = function (index) {
    return index === 0
        ? this._promise0
        : this[index * 5 - 5 + 3];
};

Promise.prototype._fulfillmentHandlerAt = function (index) {
    return index === 0
        ? this._fulfillmentHandler0
        : this[index * 5 - 5 + 0];
};

Promise.prototype._rejectionHandlerAt = function (index) {
    return index === 0
        ? this._rejectionHandler0
        : this[index * 5 - 5 + 1];
};

Promise.prototype._migrateCallbacks = function (follower, index) {
    var fulfill = follower._fulfillmentHandlerAt(index);
    var reject = follower._rejectionHandlerAt(index);
    var progress = follower._progressHandlerAt(index);
    var promise = follower._promiseAt(index);
    var receiver = follower._receiverAt(index);
    if (promise instanceof Promise) {
        promise._setIsMigrated();
        if (receiver === undefined) {
            receiver = follower;
            promise._setIsMigratingBinding();
        }
    }
    this._addCallbacks(fulfill, reject, progress, promise, receiver);
};

Promise.prototype._addCallbacks = function (
    fulfill,
    reject,
    progress,
    promise,
    receiver
) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }

    if (index === 0) {
        this._promise0 = promise;
        if (receiver !== undefined) this._receiver0 = receiver;
        if (typeof fulfill === "function" && !this._isCarryingStackTrace())
            this._fulfillmentHandler0 = fulfill;
        if (typeof reject === "function") this._rejectionHandler0 = reject;
        if (typeof progress === "function") this._progressHandler0 = progress;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promise;
        this[base + 4] = receiver;
        if (typeof fulfill === "function")
            this[base + 0] = fulfill;
        if (typeof reject === "function")
            this[base + 1] = reject;
        if (typeof progress === "function")
            this[base + 2] = progress;
    }
    this._setLength(index + 1);
    return index;
};

Promise.prototype._setProxyHandlers = function (receiver, promiseSlotValue) {
    var index = this._length();

    if (index >= 131071 - 5) {
        index = 0;
        this._setLength(0);
    }
    if (index === 0) {
        this._promise0 = promiseSlotValue;
        this._receiver0 = receiver;
    } else {
        var base = index * 5 - 5;
        this[base + 3] = promiseSlotValue;
        this[base + 4] = receiver;
    }
    this._setLength(index + 1);
};

Promise.prototype._proxyPromiseArray = function (promiseArray, index) {
    this._setProxyHandlers(promiseArray, index);
};

Promise.prototype._resolveCallback = function(value, shouldBind) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    if (value === this)
        return this._rejectCallback(makeSelfResolutionError(), false, true);
    var maybePromise = tryConvertToPromise(value, this);
    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

    var propagationFlags = 1 | (shouldBind ? 4 : 0);
    this._propagateFrom(maybePromise, propagationFlags);
    var promise = maybePromise._target();
    if (promise._isPending()) {
        var len = this._length();
        for (var i = 0; i < len; ++i) {
            promise._migrateCallbacks(this, i);
        }
        this._setFollowing();
        this._setLength(0);
        this._setFollowee(promise);
    } else if (promise._isFulfilled()) {
        this._fulfillUnchecked(promise._value());
    } else {
        this._rejectUnchecked(promise._reason(),
            promise._getCarriedStackTrace());
    }
};

Promise.prototype._rejectCallback =
function(reason, synchronous, shouldNotMarkOriginatingFromRejection) {
    if (!shouldNotMarkOriginatingFromRejection) {
        util.markAsOriginatingFromRejection(reason);
    }
    var trace = util.ensureErrorObject(reason);
    var hasStack = util.canAttachTrace(reason) &&
        typeof trace.stack === "string" && trace.stack.length > 0;
    this._attachExtraTrace(trace, synchronous ? hasStack : false);
    this._reject(reason, trace === reason ? undefined : trace);
};

Promise.prototype._resolveFromResolver = function (resolver) {
    var promise = this;
    this._captureStackTrace();
    this._pushContext();
    var synchronous = true;
    var r = tryCatch(resolver)(function(value) {
        if (promise === null) return;
        promise._resolveCallback(value);
        promise = null;
    }, function (reason) {
        if (promise === null) return;
        promise._rejectCallback(reason, synchronous);
        promise = null;
    });
    synchronous = false;
    this._popContext();

    if (r !== undefined && r === errorObj && promise !== null) {
        promise._rejectCallback(r.e, true, true);
        promise = null;
    }
};

Promise.prototype._settlePromiseFromHandler = function (
    handler, receiver, value, promise
) {
    if (promise._isRejected()) return;
    promise._pushContext();
    var x;
    if (receiver === APPLY && !this._isRejected()) {
        x = tryCatch(handler).apply(this._boundTo, value);
    } else {
        x = tryCatch(handler).call(receiver, value);
    }
    promise._popContext();

    if (x === errorObj || x === promise || x === NEXT_FILTER) {
        var err = x === promise ? makeSelfResolutionError() : x.e;
        promise._rejectCallback(err, false, true);
    } else {
        promise._resolveCallback(x);
    }
};

Promise.prototype._target = function() {
    var ret = this;
    while (ret._isFollowing()) ret = ret._followee();
    return ret;
};

Promise.prototype._followee = function() {
    return this._rejectionHandler0;
};

Promise.prototype._setFollowee = function(promise) {
    this._rejectionHandler0 = promise;
};

Promise.prototype._cleanValues = function () {
    if (this._cancellable()) {
        this._cancellationParent = undefined;
    }
};

Promise.prototype._propagateFrom = function (parent, flags) {
    if ((flags & 1) > 0 && parent._cancellable()) {
        this._setCancellable();
        this._cancellationParent = parent;
    }
    if ((flags & 4) > 0 && parent._isBound()) {
        this._setBoundTo(parent._boundTo);
    }
};

Promise.prototype._fulfill = function (value) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._fulfillUnchecked(value);
};

Promise.prototype._reject = function (reason, carriedStackTrace) {
    if (this._isFollowingOrFulfilledOrRejected()) return;
    this._rejectUnchecked(reason, carriedStackTrace);
};

Promise.prototype._settlePromiseAt = function (index) {
    var promise = this._promiseAt(index);
    var isPromise = promise instanceof Promise;

    if (isPromise && promise._isMigrated()) {
        promise._unsetIsMigrated();
        return async.invoke(this._settlePromiseAt, this, index);
    }
    var handler = this._isFulfilled()
        ? this._fulfillmentHandlerAt(index)
        : this._rejectionHandlerAt(index);

    var carriedStackTrace =
        this._isCarryingStackTrace() ? this._getCarriedStackTrace() : undefined;
    var value = this._settledValue;
    var receiver = this._receiverAt(index);
    if (isPromise && promise._isMigratingBinding()) {
        promise._unsetIsMigratingBinding();
        receiver = receiver._boundTo;
    }

    this._clearCallbackDataAtIndex(index);

    if (typeof handler === "function") {
        if (!isPromise) {
            handler.call(receiver, value, promise);
        } else {
            this._settlePromiseFromHandler(handler, receiver, value, promise);
        }
    } else if (receiver instanceof PromiseArray) {
        if (!receiver._isResolved()) {
            if (this._isFulfilled()) {
                receiver._promiseFulfilled(value, promise);
            }
            else {
                receiver._promiseRejected(value, promise);
            }
        }
    } else if (isPromise) {
        if (this._isFulfilled()) {
            promise._fulfill(value);
        } else {
            promise._reject(value, carriedStackTrace);
        }
    }

    if (index >= 4 && (index & 31) === 4)
        async.invokeLater(this._setLength, this, 0);
};

Promise.prototype._clearCallbackDataAtIndex = function(index) {
    if (index === 0) {
        if (!this._isCarryingStackTrace()) {
            this._fulfillmentHandler0 = undefined;
        }
        this._rejectionHandler0 =
        this._progressHandler0 =
        this._receiver0 =
        this._promise0 = undefined;
    } else {
        var base = index * 5 - 5;
        this[base + 3] =
        this[base + 4] =
        this[base + 0] =
        this[base + 1] =
        this[base + 2] = undefined;
    }
};

Promise.prototype._isSettlePromisesQueued = function () {
    return (this._bitField &
            -1073741824) === -1073741824;
};

Promise.prototype._setSettlePromisesQueued = function () {
    this._bitField = this._bitField | -1073741824;
};

Promise.prototype._unsetSettlePromisesQueued = function () {
    this._bitField = this._bitField & (~-1073741824);
};

Promise.prototype._queueSettlePromises = function() {
    async.settlePromises(this);
    this._setSettlePromisesQueued();
};

Promise.prototype._fulfillUnchecked = function (value) {
    if (value === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err, undefined);
    }
    this._setFulfilled();
    this._settledValue = value;
    this._cleanValues();

    if (this._length() > 0) {
        this._queueSettlePromises();
    }
};

Promise.prototype._rejectUncheckedCheckError = function (reason) {
    var trace = util.ensureErrorObject(reason);
    this._rejectUnchecked(reason, trace === reason ? undefined : trace);
};

Promise.prototype._rejectUnchecked = function (reason, trace) {
    if (reason === this) {
        var err = makeSelfResolutionError();
        this._attachExtraTrace(err);
        return this._rejectUnchecked(err);
    }
    this._setRejected();
    this._settledValue = reason;
    this._cleanValues();

    if (this._isFinal()) {
        async.throwLater(function(e) {
            if ("stack" in e) {
                async.invokeFirst(
                    CapturedTrace.unhandledRejection, undefined, e);
            }
            throw e;
        }, trace === undefined ? reason : trace);
        return;
    }

    if (trace !== undefined && trace !== reason) {
        this._setCarriedStackTrace(trace);
    }

    if (this._length() > 0) {
        this._queueSettlePromises();
    } else {
        this._ensurePossibleRejectionHandled();
    }
};

Promise.prototype._settlePromises = function () {
    this._unsetSettlePromisesQueued();
    var len = this._length();
    for (var i = 0; i < len; i++) {
        this._settlePromiseAt(i);
    }
};

Promise._makeSelfResolutionError = makeSelfResolutionError;
_dereq_("./method.js")(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_("./bind.js")(Promise, INTERNAL, tryConvertToPromise);
_dereq_("./finally.js")(Promise, NEXT_FILTER, tryConvertToPromise);
_dereq_("./direct_resolve.js")(Promise);
_dereq_("./synchronous_inspection.js")(Promise);
_dereq_("./join.js")(Promise, PromiseArray, tryConvertToPromise, INTERNAL);
Promise.Promise = Promise;
_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext);
_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise);
_dereq_('./nodeify.js')(Promise);
_dereq_('./cancel.js')(Promise);
_dereq_('./promisify.js')(Promise, INTERNAL);
_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL);
_dereq_('./settle.js')(Promise, PromiseArray);
_dereq_('./call_get.js')(Promise);
_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
_dereq_('./progress.js')(Promise, PromiseArray);
_dereq_('./any.js')(Promise);
_dereq_('./each.js')(Promise, INTERNAL);
_dereq_('./timers.js')(Promise, INTERNAL);
_dereq_('./filter.js')(Promise, INTERNAL);
                                                         
    util.toFastProperties(Promise);                                          
    util.toFastProperties(Promise.prototype);                                
    function fillTypes(value) {                                              
        var p = new Promise(INTERNAL);                                       
        p._fulfillmentHandler0 = value;                                      
        p._rejectionHandler0 = value;                                        
        p._progressHandler0 = value;                                         
        p._promise0 = value;                                                 
        p._receiver0 = value;                                                
        p._settledValue = value;                                             
    }                                                                        
    // Complete slack tracking, opt out of field-type tracking and           
    // stabilize map                                                         
    fillTypes({a: 1});                                                       
    fillTypes({b: 2});                                                       
    fillTypes({c: 3});                                                       
    fillTypes(1);                                                            
    fillTypes(function(){});                                                 
    fillTypes(undefined);                                                    
    fillTypes(false);                                                        
    fillTypes(new Promise(INTERNAL));                                        
    CapturedTrace.setBounds(async.firstLineError, util.lastLineError);       
    return Promise;                                                          

};

},{"./any.js":1,"./async.js":2,"./bind.js":3,"./call_get.js":5,"./cancel.js":6,"./captured_trace.js":7,"./catch_filter.js":8,"./context.js":9,"./debuggability.js":10,"./direct_resolve.js":11,"./each.js":12,"./errors.js":13,"./filter.js":15,"./finally.js":16,"./generators.js":17,"./join.js":18,"./map.js":19,"./method.js":20,"./nodeify.js":21,"./progress.js":22,"./promise_array.js":24,"./promise_resolver.js":25,"./promisify.js":26,"./props.js":27,"./race.js":29,"./reduce.js":30,"./settle.js":32,"./some.js":33,"./synchronous_inspection.js":34,"./thenables.js":35,"./timers.js":36,"./using.js":37,"./util.js":38}],24:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL, tryConvertToPromise,
    apiRejection) {
var util = _dereq_("./util.js");
var isArray = util.isArray;

function toResolutionValue(val) {
    switch(val) {
    case -2: return [];
    case -3: return {};
    }
}

function PromiseArray(values) {
    var promise = this._promise = new Promise(INTERNAL);
    var parent;
    if (values instanceof Promise) {
        parent = values;
        promise._propagateFrom(parent, 1 | 4);
    }
    this._values = values;
    this._length = 0;
    this._totalResolved = 0;
    this._init(undefined, -2);
}
PromiseArray.prototype.length = function () {
    return this._length;
};

PromiseArray.prototype.promise = function () {
    return this._promise;
};

PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
    var values = tryConvertToPromise(this._values, this._promise);
    if (values instanceof Promise) {
        values = values._target();
        this._values = values;
        if (values._isFulfilled()) {
            values = values._value();
            if (!isArray(values)) {
                var err = new Promise.TypeError("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
                this.__hardReject__(err);
                return;
            }
        } else if (values._isPending()) {
            values._then(
                init,
                this._reject,
                undefined,
                this,
                resolveValueIfEmpty
           );
            return;
        } else {
            this._reject(values._reason());
            return;
        }
    } else if (!isArray(values)) {
        this._promise._reject(apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a")._reason());
        return;
    }

    if (values.length === 0) {
        if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
        }
        else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
        }
        return;
    }
    var len = this.getActualLength(values.length);
    this._length = len;
    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
    var promise = this._promise;
    for (var i = 0; i < len; ++i) {
        var isResolved = this._isResolved();
        var maybePromise = tryConvertToPromise(values[i], promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (isResolved) {
                maybePromise._unsetRejectionIsUnhandled();
            } else if (maybePromise._isPending()) {
                maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                this._promiseFulfilled(maybePromise._value(), i);
            } else {
                this._promiseRejected(maybePromise._reason(), i);
            }
        } else if (!isResolved) {
            this._promiseFulfilled(maybePromise, i);
        }
    }
};

PromiseArray.prototype._isResolved = function () {
    return this._values === null;
};

PromiseArray.prototype._resolve = function (value) {
    this._values = null;
    this._promise._fulfill(value);
};

PromiseArray.prototype.__hardReject__ =
PromiseArray.prototype._reject = function (reason) {
    this._values = null;
    this._promise._rejectCallback(reason, false, true);
};

PromiseArray.prototype._promiseProgressed = function (progressValue, index) {
    this._promise._progress({
        index: index,
        value: progressValue
    });
};


PromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

PromiseArray.prototype._promiseRejected = function (reason, index) {
    this._totalResolved++;
    this._reject(reason);
};

PromiseArray.prototype.shouldCopyValues = function () {
    return true;
};

PromiseArray.prototype.getActualLength = function (len) {
    return len;
};

return PromiseArray;
};

},{"./util.js":38}],25:[function(_dereq_,module,exports){
"use strict";
var util = _dereq_("./util.js");
var maybeWrapAsError = util.maybeWrapAsError;
var errors = _dereq_("./errors.js");
var TimeoutError = errors.TimeoutError;
var OperationalError = errors.OperationalError;
var haveGetters = util.haveGetters;
var es5 = _dereq_("./es5.js");

function isUntypedError(obj) {
    return obj instanceof Error &&
        es5.getPrototypeOf(obj) === Error.prototype;
}

var rErrorKey = /^(?:name|message|stack|cause)$/;
function wrapAsOperationalError(obj) {
    var ret;
    if (isUntypedError(obj)) {
        ret = new OperationalError(obj);
        ret.name = obj.name;
        ret.message = obj.message;
        ret.stack = obj.stack;
        var keys = es5.keys(obj);
        for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!rErrorKey.test(key)) {
                ret[key] = obj[key];
            }
        }
        return ret;
    }
    util.markAsOriginatingFromRejection(obj);
    return obj;
}

function nodebackForPromise(promise) {
    return function(err, value) {
        if (promise === null) return;

        if (err) {
            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
            promise._attachExtraTrace(wrapped);
            promise._reject(wrapped);
        } else if (arguments.length > 2) {
            var $_len = arguments.length;var args = new Array($_len - 1); for(var $_i = 1; $_i < $_len; ++$_i) {args[$_i - 1] = arguments[$_i];}
            promise._fulfill(args);
        } else {
            promise._fulfill(value);
        }

        promise = null;
    };
}


var PromiseResolver;
if (!haveGetters) {
    PromiseResolver = function (promise) {
        this.promise = promise;
        this.asCallback = nodebackForPromise(promise);
        this.callback = this.asCallback;
    };
}
else {
    PromiseResolver = function (promise) {
        this.promise = promise;
    };
}
if (haveGetters) {
    var prop = {
        get: function() {
            return nodebackForPromise(this.promise);
        }
    };
    es5.defineProperty(PromiseResolver.prototype, "asCallback", prop);
    es5.defineProperty(PromiseResolver.prototype, "callback", prop);
}

PromiseResolver._nodebackForPromise = nodebackForPromise;

PromiseResolver.prototype.toString = function () {
    return "[object PromiseResolver]";
};

PromiseResolver.prototype.resolve =
PromiseResolver.prototype.fulfill = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._resolveCallback(value);
};

PromiseResolver.prototype.reject = function (reason) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._rejectCallback(reason);
};

PromiseResolver.prototype.progress = function (value) {
    if (!(this instanceof PromiseResolver)) {
        throw new TypeError("Illegal invocation, resolver resolve/reject must be called within a resolver context. Consider using the promise constructor instead.\u000a\u000a    See http://goo.gl/sdkXL9\u000a");
    }
    this.promise._progress(value);
};

PromiseResolver.prototype.cancel = function (err) {
    this.promise.cancel(err);
};

PromiseResolver.prototype.timeout = function () {
    this.reject(new TimeoutError("timeout"));
};

PromiseResolver.prototype.isResolved = function () {
    return this.promise.isResolved();
};

PromiseResolver.prototype.toJSON = function () {
    return this.promise.toJSON();
};

module.exports = PromiseResolver;

},{"./errors.js":13,"./es5.js":14,"./util.js":38}],26:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var THIS = {};
var util = _dereq_("./util.js");
var nodebackForPromise = _dereq_("./promise_resolver.js")
    ._nodebackForPromise;
var withAppended = util.withAppended;
var maybeWrapAsError = util.maybeWrapAsError;
var canEvaluate = util.canEvaluate;
var TypeError = _dereq_("./errors").TypeError;
var defaultSuffix = "Async";
var defaultPromisified = {__isPromisified__: true};
var noCopyPropsPattern =
    /^(?:length|name|arguments|caller|prototype|__isPromisified__)$/;
var defaultFilter = function(name, func) {
    return util.isIdentifier(name) &&
        name.charAt(0) !== "_" &&
        !util.isClass(func);
};

function propsFilter(key) {
    return !noCopyPropsPattern.test(key);
}

function isPromisified(fn) {
    try {
        return fn.__isPromisified__ === true;
    }
    catch (e) {
        return false;
    }
}

function hasPromisified(obj, key, suffix) {
    var val = util.getDataPropertyOrDefault(obj, key + suffix,
                                            defaultPromisified);
    return val ? isPromisified(val) : false;
}
function checkValid(ret, suffix, suffixRegexp) {
    for (var i = 0; i < ret.length; i += 2) {
        var key = ret[i];
        if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret.length; j += 2) {
                if (ret[j] === keyWithoutAsyncSuffix) {
                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/iWrZbw\u000a"
                        .replace("%s", suffix));
                }
            }
        }
    }
}

function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
    var keys = util.inheritedDataKeys(obj);
    var ret = [];
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var value = obj[key];
        var passesDefaultFilter = filter === defaultFilter
            ? true : defaultFilter(key, value, obj);
        if (typeof value === "function" &&
            !isPromisified(value) &&
            !hasPromisified(obj, key, suffix) &&
            filter(key, value, obj, passesDefaultFilter)) {
            ret.push(key, value);
        }
    }
    checkValid(ret, suffix, suffixRegexp);
    return ret;
}

var escapeIdentRegex = function(str) {
    return str.replace(/([$])/, "\\$");
};

var makeNodePromisifiedEval;
if (!true) {
var switchCaseArgumentOrder = function(likelyArgumentCount) {
    var ret = [likelyArgumentCount];
    var min = Math.max(0, likelyArgumentCount - 1 - 3);
    for(var i = likelyArgumentCount - 1; i >= min; --i) {
        ret.push(i);
    }
    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
        ret.push(i);
    }
    return ret;
};

var argumentSequence = function(argumentCount) {
    return util.filledRange(argumentCount, "_arg", "");
};

var parameterDeclaration = function(parameterCount) {
    return util.filledRange(
        Math.max(parameterCount, 3), "_arg", "");
};

var parameterCount = function(fn) {
    if (typeof fn.length === "number") {
        return Math.max(Math.min(fn.length, 1023 + 1), 0);
    }
    return 0;
};

makeNodePromisifiedEval =
function(callback, receiver, originalName, fn) {
    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

    function generateCallForArgumentCount(count) {
        var args = argumentSequence(count).join(", ");
        var comma = count > 0 ? ", " : "";
        var ret;
        if (shouldProxyThis) {
            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
        } else {
            ret = receiver === undefined
                ? "ret = callback({{args}}, nodeback); break;\n"
                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
        }
        return ret.replace("{{args}}", args).replace(", ", comma);
    }

    function generateArgumentSwitchCase() {
        var ret = "";
        for (var i = 0; i < argumentOrder.length; ++i) {
            ret += "case " + argumentOrder[i] +":" +
                generateCallForArgumentCount(argumentOrder[i]);
        }

        ret += "                                                             \n\
        default:                                                             \n\
            var args = new Array(len + 1);                                   \n\
            var i = 0;                                                       \n\
            for (var i = 0; i < len; ++i) {                                  \n\
               args[i] = arguments[i];                                       \n\
            }                                                                \n\
            args[i] = nodeback;                                              \n\
            [CodeForCall]                                                    \n\
            break;                                                           \n\
        ".replace("[CodeForCall]", (shouldProxyThis
                                ? "ret = callback.apply(this, args);\n"
                                : "ret = callback.apply(receiver, args);\n"));
        return ret;
    }

    var getFunctionCode = typeof callback === "string"
                                ? ("this != null ? this['"+callback+"'] : fn")
                                : "fn";

    return new Function("Promise",
                        "fn",
                        "receiver",
                        "withAppended",
                        "maybeWrapAsError",
                        "nodebackForPromise",
                        "tryCatch",
                        "errorObj",
                        "INTERNAL","'use strict';                            \n\
        var ret = function (Parameters) {                                    \n\
            'use strict';                                                    \n\
            var len = arguments.length;                                      \n\
            var promise = new Promise(INTERNAL);                             \n\
            promise._captureStackTrace();                                    \n\
            var nodeback = nodebackForPromise(promise);                      \n\
            var ret;                                                         \n\
            var callback = tryCatch([GetFunctionCode]);                      \n\
            switch(len) {                                                    \n\
                [CodeForSwitchCase]                                          \n\
            }                                                                \n\
            if (ret === errorObj) {                                          \n\
                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
            }                                                                \n\
            return promise;                                                  \n\
        };                                                                   \n\
        ret.__isPromisified__ = true;                                        \n\
        return ret;                                                          \n\
        "
        .replace("Parameters", parameterDeclaration(newParameterCount))
        .replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
        .replace("[GetFunctionCode]", getFunctionCode))(
            Promise,
            fn,
            receiver,
            withAppended,
            maybeWrapAsError,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            INTERNAL
        );
};
}

function makeNodePromisifiedClosure(callback, receiver, _, fn) {
    var defaultThis = (function() {return this;})();
    var method = callback;
    if (typeof method === "string") {
        callback = fn;
    }
    function promisified() {
        var _receiver = receiver;
        if (receiver === THIS) _receiver = this;
        var promise = new Promise(INTERNAL);
        promise._captureStackTrace();
        var cb = typeof method === "string" && this !== defaultThis
            ? this[method] : callback;
        var fn = nodebackForPromise(promise);
        try {
            cb.apply(_receiver, withAppended(arguments, fn));
        } catch(e) {
            promise._rejectCallback(maybeWrapAsError(e), true, true);
        }
        return promise;
    }
    promisified.__isPromisified__ = true;
    return promisified;
}

var makeNodePromisified = canEvaluate
    ? makeNodePromisifiedEval
    : makeNodePromisifiedClosure;

function promisifyAll(obj, suffix, filter, promisifier) {
    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
    var methods =
        promisifiableMethods(obj, suffix, suffixRegexp, filter);

    for (var i = 0, len = methods.length; i < len; i+= 2) {
        var key = methods[i];
        var fn = methods[i+1];
        var promisifiedKey = key + suffix;
        obj[promisifiedKey] = promisifier === makeNodePromisified
                ? makeNodePromisified(key, THIS, key, fn, suffix)
                : promisifier(fn, function() {
                    return makeNodePromisified(key, THIS, key, fn, suffix);
                });
    }
    util.toFastProperties(obj);
    return obj;
}

function promisify(callback, receiver) {
    return makeNodePromisified(callback, receiver, undefined, callback);
}

Promise.promisify = function (fn, receiver) {
    if (typeof fn !== "function") {
        throw new TypeError("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    }
    if (isPromisified(fn)) {
        return fn;
    }
    var ret = promisify(fn, arguments.length < 2 ? THIS : receiver);
    util.copyDescriptors(fn, ret, propsFilter);
    return ret;
};

Promise.promisifyAll = function (target, options) {
    if (typeof target !== "function" && typeof target !== "object") {
        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/9ITlV0\u000a");
    }
    options = Object(options);
    var suffix = options.suffix;
    if (typeof suffix !== "string") suffix = defaultSuffix;
    var filter = options.filter;
    if (typeof filter !== "function") filter = defaultFilter;
    var promisifier = options.promisifier;
    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

    if (!util.isIdentifier(suffix)) {
        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/8FZo5V\u000a");
    }

    var keys = util.inheritedDataKeys(target);
    for (var i = 0; i < keys.length; ++i) {
        var value = target[keys[i]];
        if (keys[i] !== "constructor" &&
            util.isClass(value)) {
            promisifyAll(value.prototype, suffix, filter, promisifier);
            promisifyAll(value, suffix, filter, promisifier);
        }
    }

    return promisifyAll(target, suffix, filter, promisifier);
};
};


},{"./errors":13,"./promise_resolver.js":25,"./util.js":38}],27:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
var util = _dereq_("./util.js");
var isObject = util.isObject;
var es5 = _dereq_("./es5.js");

function PropertiesPromiseArray(obj) {
    var keys = es5.keys(obj);
    var len = keys.length;
    var values = new Array(len * 2);
    for (var i = 0; i < len; ++i) {
        var key = keys[i];
        values[i] = obj[key];
        values[i + len] = key;
    }
    this.constructor$(values);
}
util.inherits(PropertiesPromiseArray, PromiseArray);

PropertiesPromiseArray.prototype._init = function () {
    this._init$(undefined, -3) ;
};

PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
    this._values[index] = value;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        var val = {};
        var keyOffset = this.length();
        for (var i = 0, len = this.length(); i < len; ++i) {
            val[this._values[i + keyOffset]] = this._values[i];
        }
        this._resolve(val);
    }
};

PropertiesPromiseArray.prototype._promiseProgressed = function (value, index) {
    this._promise._progress({
        key: this._values[index + this.length()],
        value: value
    });
};

PropertiesPromiseArray.prototype.shouldCopyValues = function () {
    return false;
};

PropertiesPromiseArray.prototype.getActualLength = function (len) {
    return len >> 1;
};

function props(promises) {
    var ret;
    var castValue = tryConvertToPromise(promises);

    if (!isObject(castValue)) {
        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/OsFKC8\u000a");
    } else if (castValue instanceof Promise) {
        ret = castValue._then(
            Promise.props, undefined, undefined, undefined, undefined);
    } else {
        ret = new PropertiesPromiseArray(castValue).promise();
    }

    if (castValue instanceof Promise) {
        ret._propagateFrom(castValue, 4);
    }
    return ret;
}

Promise.prototype.props = function () {
    return props(this);
};

Promise.props = function (promises) {
    return props(promises);
};
};

},{"./es5.js":14,"./util.js":38}],28:[function(_dereq_,module,exports){
"use strict";
function arrayMove(src, srcIndex, dst, dstIndex, len) {
    for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
    }
}

function Queue(capacity) {
    this._capacity = capacity;
    this._length = 0;
    this._front = 0;
}

Queue.prototype._willBeOverCapacity = function (size) {
    return this._capacity < size;
};

Queue.prototype._pushOne = function (arg) {
    var length = this.length();
    this._checkCapacity(length + 1);
    var i = (this._front + length) & (this._capacity - 1);
    this[i] = arg;
    this._length = length + 1;
};

Queue.prototype._unshiftOne = function(value) {
    var capacity = this._capacity;
    this._checkCapacity(this.length() + 1);
    var front = this._front;
    var i = (((( front - 1 ) &
                    ( capacity - 1) ) ^ capacity ) - capacity );
    this[i] = value;
    this._front = i;
    this._length = this.length() + 1;
};

Queue.prototype.unshift = function(fn, receiver, arg) {
    this._unshiftOne(arg);
    this._unshiftOne(receiver);
    this._unshiftOne(fn);
};

Queue.prototype.push = function (fn, receiver, arg) {
    var length = this.length() + 3;
    if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
    }
    var j = this._front + length - 3;
    this._checkCapacity(length);
    var wrapMask = this._capacity - 1;
    this[(j + 0) & wrapMask] = fn;
    this[(j + 1) & wrapMask] = receiver;
    this[(j + 2) & wrapMask] = arg;
    this._length = length;
};

Queue.prototype.shift = function () {
    var front = this._front,
        ret = this[front];

    this[front] = undefined;
    this._front = (front + 1) & (this._capacity - 1);
    this._length--;
    return ret;
};

Queue.prototype.length = function () {
    return this._length;
};

Queue.prototype._checkCapacity = function (size) {
    if (this._capacity < size) {
        this._resizeTo(this._capacity << 1);
    }
};

Queue.prototype._resizeTo = function (capacity) {
    var oldCapacity = this._capacity;
    this._capacity = capacity;
    var front = this._front;
    var length = this._length;
    var moveItemsCount = (front + length) & (oldCapacity - 1);
    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
};

module.exports = Queue;

},{}],29:[function(_dereq_,module,exports){
"use strict";
module.exports = function(
    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
var isArray = _dereq_("./util.js").isArray;

var raceLater = function (promise) {
    return promise.then(function(array) {
        return race(array, promise);
    });
};

function race(promises, parent) {
    var maybePromise = tryConvertToPromise(promises);

    if (maybePromise instanceof Promise) {
        return raceLater(maybePromise);
    } else if (!isArray(promises)) {
        return apiRejection("expecting an array, a promise or a thenable\u000a\u000a    See http://goo.gl/s8MMhc\u000a");
    }

    var ret = new Promise(INTERNAL);
    if (parent !== undefined) {
        ret._propagateFrom(parent, 4 | 1);
    }
    var fulfill = ret._fulfill;
    var reject = ret._reject;
    for (var i = 0, len = promises.length; i < len; ++i) {
        var val = promises[i];

        if (val === undefined && !(i in promises)) {
            continue;
        }

        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
    }
    return ret;
}

Promise.race = function (promises) {
    return race(promises, undefined);
};

Promise.prototype.race = function () {
    return race(this, undefined);
};

};

},{"./util.js":38}],30:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise,
                          PromiseArray,
                          apiRejection,
                          tryConvertToPromise,
                          INTERNAL) {
var util = _dereq_("./util.js");
var tryCatch = util.tryCatch;
var errorObj = util.errorObj;
function ReductionPromiseArray(promises, fn, accum, _each) {
    this.constructor$(promises);
    this._promise._captureStackTrace();
    this._preservedValues = _each === INTERNAL ? [] : null;
    this._zerothIsAccum = (accum === undefined);
    this._gotAccum = false;
    this._reducingIndex = (this._zerothIsAccum ? 1 : 0);
    this._valuesPhase = undefined;
    var maybePromise = tryConvertToPromise(accum, this._promise);
    var rejected = false;
    var isPromise = maybePromise instanceof Promise;
    if (isPromise) {
        maybePromise = maybePromise._target();
        if (maybePromise._isPending()) {
            maybePromise._proxyPromiseArray(this, -1);
        } else if (maybePromise._isFulfilled()) {
            accum = maybePromise._value();
            this._gotAccum = true;
        } else {
            this._reject(maybePromise._reason());
            rejected = true;
        }
    }
    if (!(isPromise || this._zerothIsAccum)) this._gotAccum = true;
    this._callback = fn;
    this._accum = accum;
    if (!rejected) this._init$(undefined, -5);
}
util.inherits(ReductionPromiseArray, PromiseArray);

ReductionPromiseArray.prototype._init = function () {};

ReductionPromiseArray.prototype._resolveEmptyArray = function () {
    if (this._gotAccum || this._zerothIsAccum) {
        this._resolve(this._preservedValues !== null
                        ? [] : this._accum);
    }
};

ReductionPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var values = this._values;
    values[index] = value;
    var length = this.length();
    var preservedValues = this._preservedValues;
    var isEach = preservedValues !== null;
    var gotAccum = this._gotAccum;
    var valuesPhase = this._valuesPhase;
    var valuesPhaseIndex;
    if (!valuesPhase) {
        valuesPhase = this._valuesPhase = new Array(length);
        for (valuesPhaseIndex=0; valuesPhaseIndex<length; ++valuesPhaseIndex) {
            valuesPhase[valuesPhaseIndex] = 0;
        }
    }
    valuesPhaseIndex = valuesPhase[index];

    if (index === 0 && this._zerothIsAccum) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
        valuesPhase[index] = ((valuesPhaseIndex === 0)
            ? 1 : 2);
    } else if (index === -1) {
        this._accum = value;
        this._gotAccum = gotAccum = true;
    } else {
        if (valuesPhaseIndex === 0) {
            valuesPhase[index] = 1;
        } else {
            valuesPhase[index] = 2;
            this._accum = value;
        }
    }
    if (!gotAccum) return;

    var callback = this._callback;
    var receiver = this._promise._boundTo;
    var ret;

    for (var i = this._reducingIndex; i < length; ++i) {
        valuesPhaseIndex = valuesPhase[i];
        if (valuesPhaseIndex === 2) {
            this._reducingIndex = i + 1;
            continue;
        }
        if (valuesPhaseIndex !== 1) return;
        value = values[i];
        this._promise._pushContext();
        if (isEach) {
            preservedValues.push(value);
            ret = tryCatch(callback).call(receiver, value, i, length);
        }
        else {
            ret = tryCatch(callback)
                .call(receiver, this._accum, value, i, length);
        }
        this._promise._popContext();

        if (ret === errorObj) return this._reject(ret.e);

        var maybePromise = tryConvertToPromise(ret, this._promise);
        if (maybePromise instanceof Promise) {
            maybePromise = maybePromise._target();
            if (maybePromise._isPending()) {
                valuesPhase[i] = 4;
                return maybePromise._proxyPromiseArray(this, i);
            } else if (maybePromise._isFulfilled()) {
                ret = maybePromise._value();
            } else {
                return this._reject(maybePromise._reason());
            }
        }

        this._reducingIndex = i + 1;
        this._accum = ret;
    }

    this._resolve(isEach ? preservedValues : this._accum);
};

function reduce(promises, fn, initialValue, _each) {
    if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
    return array.promise();
}

Promise.prototype.reduce = function (fn, initialValue) {
    return reduce(this, fn, initialValue, null);
};

Promise.reduce = function (promises, fn, initialValue, _each) {
    return reduce(promises, fn, initialValue, _each);
};
};

},{"./util.js":38}],31:[function(_dereq_,module,exports){
"use strict";
var schedule;
if (_dereq_("./util.js").isNode) {
    var version = process.versions.node.split(".").map(Number);
    schedule = (version[0] === 0 && version[1] > 10) || (version[0] > 0)
        ? global.setImmediate : process.nextTick;
}
else if (typeof MutationObserver !== "undefined") {
    schedule = function(fn) {
        var div = document.createElement("div");
        var observer = new MutationObserver(fn);
        observer.observe(div, {attributes: true});
        return function() { div.classList.toggle("foo"); };
    };
    schedule.isStatic = true;
}
else if (typeof setTimeout !== "undefined") {
    schedule = function (fn) {
        setTimeout(fn, 0);
    };
}
else {
    schedule = function() {
        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/m3OTXk\u000a");
    };
}
module.exports = schedule;

},{"./util.js":38}],32:[function(_dereq_,module,exports){
"use strict";
module.exports =
    function(Promise, PromiseArray) {
var PromiseInspection = Promise.PromiseInspection;
var util = _dereq_("./util.js");

function SettledPromiseArray(values) {
    this.constructor$(values);
}
util.inherits(SettledPromiseArray, PromiseArray);

SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
    this._values[index] = inspection;
    var totalResolved = ++this._totalResolved;
    if (totalResolved >= this._length) {
        this._resolve(this._values);
    }
};

SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
    var ret = new PromiseInspection();
    ret._bitField = 268435456;
    ret._settledValue = value;
    this._promiseResolved(index, ret);
};
SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
    var ret = new PromiseInspection();
    ret._bitField = 134217728;
    ret._settledValue = reason;
    this._promiseResolved(index, ret);
};

Promise.settle = function (promises) {
    return new SettledPromiseArray(promises).promise();
};

Promise.prototype.settle = function () {
    return new SettledPromiseArray(this).promise();
};
};

},{"./util.js":38}],33:[function(_dereq_,module,exports){
"use strict";
module.exports =
function(Promise, PromiseArray, apiRejection) {
var util = _dereq_("./util.js");
var RangeError = _dereq_("./errors.js").RangeError;
var AggregateError = _dereq_("./errors.js").AggregateError;
var isArray = util.isArray;


function SomePromiseArray(values) {
    this.constructor$(values);
    this._howMany = 0;
    this._unwrap = false;
    this._initialized = false;
}
util.inherits(SomePromiseArray, PromiseArray);

SomePromiseArray.prototype._init = function () {
    if (!this._initialized) {
        return;
    }
    if (this._howMany === 0) {
        this._resolve([]);
        return;
    }
    this._init$(undefined, -5);
    var isArrayResolved = isArray(this._values);
    if (!this._isResolved() &&
        isArrayResolved &&
        this._howMany > this._canPossiblyFulfill()) {
        this._reject(this._getRangeError(this.length()));
    }
};

SomePromiseArray.prototype.init = function () {
    this._initialized = true;
    this._init();
};

SomePromiseArray.prototype.setUnwrap = function () {
    this._unwrap = true;
};

SomePromiseArray.prototype.howMany = function () {
    return this._howMany;
};

SomePromiseArray.prototype.setHowMany = function (count) {
    this._howMany = count;
};

SomePromiseArray.prototype._promiseFulfilled = function (value) {
    this._addFulfilled(value);
    if (this._fulfilled() === this.howMany()) {
        this._values.length = this.howMany();
        if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
        } else {
            this._resolve(this._values);
        }
    }

};
SomePromiseArray.prototype._promiseRejected = function (reason) {
    this._addRejected(reason);
    if (this.howMany() > this._canPossiblyFulfill()) {
        var e = new AggregateError();
        for (var i = this.length(); i < this._values.length; ++i) {
            e.push(this._values[i]);
        }
        this._reject(e);
    }
};

SomePromiseArray.prototype._fulfilled = function () {
    return this._totalResolved;
};

SomePromiseArray.prototype._rejected = function () {
    return this._values.length - this.length();
};

SomePromiseArray.prototype._addRejected = function (reason) {
    this._values.push(reason);
};

SomePromiseArray.prototype._addFulfilled = function (value) {
    this._values[this._totalResolved++] = value;
};

SomePromiseArray.prototype._canPossiblyFulfill = function () {
    return this.length() - this._rejected();
};

SomePromiseArray.prototype._getRangeError = function (count) {
    var message = "Input array must contain at least " +
            this._howMany + " items but contains only " + count + " items";
    return new RangeError(message);
};

SomePromiseArray.prototype._resolveEmptyArray = function () {
    this._reject(this._getRangeError(0));
};

function some(promises, howMany) {
    if ((howMany | 0) !== howMany || howMany < 0) {
        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/1wAmHx\u000a");
    }
    var ret = new SomePromiseArray(promises);
    var promise = ret.promise();
    ret.setHowMany(howMany);
    ret.init();
    return promise;
}

Promise.some = function (promises, howMany) {
    return some(promises, howMany);
};

Promise.prototype.some = function (howMany) {
    return some(this, howMany);
};

Promise._SomePromiseArray = SomePromiseArray;
};

},{"./errors.js":13,"./util.js":38}],34:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise) {
function PromiseInspection(promise) {
    if (promise !== undefined) {
        promise = promise._target();
        this._bitField = promise._bitField;
        this._settledValue = promise._settledValue;
    }
    else {
        this._bitField = 0;
        this._settledValue = undefined;
    }
}

PromiseInspection.prototype.value = function () {
    if (!this.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.error =
PromiseInspection.prototype.reason = function () {
    if (!this.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    return this._settledValue;
};

PromiseInspection.prototype.isFulfilled =
Promise.prototype._isFulfilled = function () {
    return (this._bitField & 268435456) > 0;
};

PromiseInspection.prototype.isRejected =
Promise.prototype._isRejected = function () {
    return (this._bitField & 134217728) > 0;
};

PromiseInspection.prototype.isPending =
Promise.prototype._isPending = function () {
    return (this._bitField & 402653184) === 0;
};

PromiseInspection.prototype.isResolved =
Promise.prototype._isResolved = function () {
    return (this._bitField & 402653184) > 0;
};

Promise.prototype.isPending = function() {
    return this._target()._isPending();
};

Promise.prototype.isRejected = function() {
    return this._target()._isRejected();
};

Promise.prototype.isFulfilled = function() {
    return this._target()._isFulfilled();
};

Promise.prototype.isResolved = function() {
    return this._target()._isResolved();
};

Promise.prototype._value = function() {
    return this._settledValue;
};

Promise.prototype._reason = function() {
    this._unsetRejectionIsUnhandled();
    return this._settledValue;
};

Promise.prototype.value = function() {
    var target = this._target();
    if (!target.isFulfilled()) {
        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/hc1DLj\u000a");
    }
    return target._settledValue;
};

Promise.prototype.reason = function() {
    var target = this._target();
    if (!target.isRejected()) {
        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/hPuiwB\u000a");
    }
    target._unsetRejectionIsUnhandled();
    return target._settledValue;
};


Promise.PromiseInspection = PromiseInspection;
};

},{}],35:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var errorObj = util.errorObj;
var isObject = util.isObject;

function tryConvertToPromise(obj, context) {
    if (isObject(obj)) {
        if (obj instanceof Promise) {
            return obj;
        }
        else if (isAnyBluebirdPromise(obj)) {
            var ret = new Promise(INTERNAL);
            obj._then(
                ret._fulfillUnchecked,
                ret._rejectUncheckedCheckError,
                ret._progressUnchecked,
                ret,
                null
            );
            return ret;
        }
        var then = util.tryCatch(getThen)(obj);
        if (then === errorObj) {
            if (context) context._pushContext();
            var ret = Promise.reject(then.e);
            if (context) context._popContext();
            return ret;
        } else if (typeof then === "function") {
            return doThenable(obj, then, context);
        }
    }
    return obj;
}

function getThen(obj) {
    return obj.then;
}

var hasProp = {}.hasOwnProperty;
function isAnyBluebirdPromise(obj) {
    return hasProp.call(obj, "_promise0");
}

function doThenable(x, then, context) {
    var promise = new Promise(INTERNAL);
    var ret = promise;
    if (context) context._pushContext();
    promise._captureStackTrace();
    if (context) context._popContext();
    var synchronous = true;
    var result = util.tryCatch(then).call(x,
                                        resolveFromThenable,
                                        rejectFromThenable,
                                        progressFromThenable);
    synchronous = false;
    if (promise && result === errorObj) {
        promise._rejectCallback(result.e, true, true);
        promise = null;
    }

    function resolveFromThenable(value) {
        if (!promise) return;
        if (x === value) {
            promise._rejectCallback(
                Promise._makeSelfResolutionError(), false, true);
        } else {
            promise._resolveCallback(value);
        }
        promise = null;
    }

    function rejectFromThenable(reason) {
        if (!promise) return;
        promise._rejectCallback(reason, synchronous, true);
        promise = null;
    }

    function progressFromThenable(value) {
        if (!promise) return;
        if (typeof promise._progress === "function") {
            promise._progress(value);
        }
    }
    return ret;
}

return tryConvertToPromise;
};

},{"./util.js":38}],36:[function(_dereq_,module,exports){
"use strict";
module.exports = function(Promise, INTERNAL) {
var util = _dereq_("./util.js");
var TimeoutError = Promise.TimeoutError;

var afterTimeout = function (promise, message) {
    if (!promise.isPending()) return;
    if (typeof message !== "string") {
        message = "operation timed out";
    }
    var err = new TimeoutError(message);
    util.markAsOriginatingFromRejection(err);
    promise._attachExtraTrace(err);
    promise._cancel(err);
};

var afterValue = function(value) { return delay(+this).thenReturn(value); };
var delay = Promise.delay = function (value, ms) {
    if (ms === undefined) {
        ms = value;
        value = undefined;
        var ret = new Promise(INTERNAL);
        setTimeout(function() { ret._fulfill(); }, ms);
        return ret;
    }
    ms = +ms;
    return Promise.resolve(value)._then(afterValue, null, null, ms, undefined);
};

Promise.prototype.delay = function (ms) {
    return delay(this, ms);
};

function successClear(value) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    return value;
}

function failureClear(reason) {
    var handle = this;
    if (handle instanceof Number) handle = +handle;
    clearTimeout(handle);
    throw reason;
}

Promise.prototype.timeout = function (ms, message) {
    ms = +ms;
    var ret = this.then().cancellable();
    ret._cancellationParent = this;
    var handle = setTimeout(function timeoutTimeout() {
        afterTimeout(ret, message);
    }, ms);
    return ret._then(successClear, failureClear, undefined, handle, undefined);
};

};

},{"./util.js":38}],37:[function(_dereq_,module,exports){
"use strict";
module.exports = function (Promise, apiRejection, tryConvertToPromise,
    createContext) {
    var TypeError = _dereq_("./errors.js").TypeError;
    var inherits = _dereq_("./util.js").inherits;
    var PromiseInspection = Promise.PromiseInspection;

    function inspectionMapper(inspections) {
        var len = inspections.length;
        for (var i = 0; i < len; ++i) {
            var inspection = inspections[i];
            if (inspection.isRejected()) {
                return Promise.reject(inspection.error());
            }
            inspections[i] = inspection._settledValue;
        }
        return inspections;
    }

    function thrower(e) {
        setTimeout(function(){throw e;}, 0);
    }

    function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable &&
            typeof thenable._isDisposable === "function" &&
            typeof thenable._getDisposer === "function" &&
            thenable._isDisposable()) {
            maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
    }
    function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret = Promise.defer();
        function iterator() {
            if (i >= len) return ret.resolve();
            var maybePromise = castPreservingDisposable(resources[i++]);
            if (maybePromise instanceof Promise &&
                maybePromise._isDisposable()) {
                try {
                    maybePromise = tryConvertToPromise(
                        maybePromise._getDisposer().tryDispose(inspection),
                        resources.promise);
                } catch (e) {
                    return thrower(e);
                }
                if (maybePromise instanceof Promise) {
                    return maybePromise._then(iterator, thrower,
                                              null, null, null);
                }
            }
            iterator();
        }
        iterator();
        return ret.promise;
    }

    function disposerSuccess(value) {
        var inspection = new PromiseInspection();
        inspection._settledValue = value;
        inspection._bitField = 268435456;
        return dispose(this, inspection).thenReturn(value);
    }

    function disposerFail(reason) {
        var inspection = new PromiseInspection();
        inspection._settledValue = reason;
        inspection._bitField = 134217728;
        return dispose(this, inspection).thenThrow(reason);
    }

    function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
    }

    Disposer.prototype.data = function () {
        return this._data;
    };

    Disposer.prototype.promise = function () {
        return this._promise;
    };

    Disposer.prototype.resource = function () {
        if (this.promise().isFulfilled()) {
            return this.promise().value();
        }
        return null;
    };

    Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== undefined) context._pushContext();
        var ret = resource !== null
            ? this.doDispose(resource, inspection) : null;
        if (context !== undefined) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret;
    };

    Disposer.isDisposer = function (d) {
        return (d != null &&
                typeof d.resource === "function" &&
                typeof d.tryDispose === "function");
    };

    function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
    }
    inherits(FunctionDisposer, Disposer);

    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
    };

    function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
            this.resources[this.index]._setDisposable(value);
            return value.promise();
        }
        return value;
    }

    Promise.using = function () {
        var len = arguments.length;
        if (len < 2) return apiRejection(
                        "you must pass at least 2 arguments to Promise.using");
        var fn = arguments[len - 1];
        if (typeof fn !== "function") return apiRejection("fn must be a function\u000a\u000a    See http://goo.gl/916lJJ\u000a");
        len--;
        var resources = new Array(len);
        for (var i = 0; i < len; ++i) {
            var resource = arguments[i];
            if (Disposer.isDisposer(resource)) {
                var disposer = resource;
                resource = resource.promise();
                resource._setDisposable(disposer);
            } else {
                var maybePromise = tryConvertToPromise(resource);
                if (maybePromise instanceof Promise) {
                    resource =
                        maybePromise._then(maybeUnwrapDisposer, null, null, {
                            resources: resources,
                            index: i
                    }, undefined);
                }
            }
            resources[i] = resource;
        }

        var promise = Promise.settle(resources)
            .then(inspectionMapper)
            .then(function(vals) {
                promise._pushContext();
                var ret;
                try {
                    ret = fn.apply(undefined, vals);
                } finally {
                    promise._popContext();
                }
                return ret;
            })
            ._then(
                disposerSuccess, disposerFail, undefined, resources, undefined);
        resources.promise = promise;
        return promise;
    };

    Promise.prototype._setDisposable = function (disposer) {
        this._bitField = this._bitField | 262144;
        this._disposer = disposer;
    };

    Promise.prototype._isDisposable = function () {
        return (this._bitField & 262144) > 0;
    };

    Promise.prototype._getDisposer = function () {
        return this._disposer;
    };

    Promise.prototype._unsetDisposable = function () {
        this._bitField = this._bitField & (~262144);
        this._disposer = undefined;
    };

    Promise.prototype.disposer = function (fn) {
        if (typeof fn === "function") {
            return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError();
    };

};

},{"./errors.js":13,"./util.js":38}],38:[function(_dereq_,module,exports){
"use strict";
var es5 = _dereq_("./es5.js");
var canEvaluate = typeof navigator == "undefined";
var haveGetters = (function(){
    try {
        var o = {};
        es5.defineProperty(o, "f", {
            get: function () {
                return 3;
            }
        });
        return o.f === 3;
    }
    catch (e) {
        return false;
    }

})();

var errorObj = {e: {}};
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    } catch (e) {
        errorObj.e = e;
        return errorObj;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

var inherits = function(Child, Parent) {
    var hasProp = {}.hasOwnProperty;

    function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
            if (hasProp.call(Parent.prototype, propertyName) &&
                propertyName.charAt(propertyName.length-1) !== "$"
           ) {
                this[propertyName + "$"] = Parent.prototype[propertyName];
            }
        }
    }
    T.prototype = Parent.prototype;
    Child.prototype = new T();
    return Child.prototype;
};


function isPrimitive(val) {
    return val == null || val === true || val === false ||
        typeof val === "string" || typeof val === "number";

}

function isObject(value) {
    return !isPrimitive(value);
}

function maybeWrapAsError(maybeError) {
    if (!isPrimitive(maybeError)) return maybeError;

    return new Error(safeToString(maybeError));
}

function withAppended(target, appendee) {
    var len = target.length;
    var ret = new Array(len + 1);
    var i;
    for (i = 0; i < len; ++i) {
        ret[i] = target[i];
    }
    ret[i] = appendee;
    return ret;
}

function getDataPropertyOrDefault(obj, key, defaultValue) {
    if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj, key);
        if (desc != null) {
            return desc.get == null && desc.set == null
                    ? desc.value
                    : defaultValue;
        }
    } else {
        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
    }
}

function notEnumerableProp(obj, name, value) {
    if (isPrimitive(obj)) return obj;
    var descriptor = {
        value: value,
        configurable: true,
        enumerable: false,
        writable: true
    };
    es5.defineProperty(obj, name, descriptor);
    return obj;
}


var wrapsPrimitiveReceiver = (function() {
    return this !== "string";
}).call("string");

function thrower(r) {
    throw r;
}

var inheritedDataKeys = (function() {
    if (es5.isES5) {
        var oProto = Object.prototype;
        var getKeys = Object.getOwnPropertyNames;
        return function(obj) {
            var ret = [];
            var visitedKeys = Object.create(null);
            while (obj != null && obj !== oProto) {
                var keys;
                try {
                    keys = getKeys(obj);
                } catch (e) {
                    return ret;
                }
                for (var i = 0; i < keys.length; ++i) {
                    var key = keys[i];
                    if (visitedKeys[key]) continue;
                    visitedKeys[key] = true;
                    var desc = Object.getOwnPropertyDescriptor(obj, key);
                    if (desc != null && desc.get == null && desc.set == null) {
                        ret.push(key);
                    }
                }
                obj = es5.getPrototypeOf(obj);
            }
            return ret;
        };
    } else {
        return function(obj) {
            var ret = [];
            /*jshint forin:false */
            for (var key in obj) {
                ret.push(key);
            }
            return ret;
        };
    }

})();

function isClass(fn) {
    try {
        if (typeof fn === "function") {
            var keys = es5.names(fn.prototype);
            if (es5.isES5) return keys.length > 1;
            return keys.length > 0 &&
                   !(keys.length === 1 && keys[0] === "constructor");
        }
        return false;
    } catch (e) {
        return false;
    }
}

function toFastProperties(obj) {
    /*jshint -W027*/
    function f() {}
    f.prototype = obj;
    return f;
    eval(obj);
}

var rident = /^[a-z$_][a-z$_0-9]*$/i;
function isIdentifier(str) {
    return rident.test(str);
}

function filledRange(count, prefix, suffix) {
    var ret = new Array(count);
    for(var i = 0; i < count; ++i) {
        ret[i] = prefix + i + suffix;
    }
    return ret;
}

function safeToString(obj) {
    try {
        return obj + "";
    } catch (e) {
        return "[no string representation]";
    }
}

function markAsOriginatingFromRejection(e) {
    try {
        notEnumerableProp(e, "isOperational", true);
    }
    catch(ignore) {}
}

function originatesFromRejection(e) {
    if (e == null) return false;
    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
        e["isOperational"] === true);
}

function canAttachTrace(obj) {
    return obj instanceof Error && es5.propertyIsWritable(obj, "stack");
}

var ensureErrorObject = (function() {
    if (!("stack" in new Error())) {
        return function(value) {
            if (canAttachTrace(value)) return value;
            try {throw new Error(safeToString(value));}
            catch(err) {return err;}
        };
    } else {
        return function(value) {
            if (canAttachTrace(value)) return value;
            return new Error(safeToString(value));
        };
    }
})();

function classString(obj) {
    return {}.toString.call(obj);
}

function copyDescriptors(from, to, filter) {
    var keys = es5.names(from);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        if (filter(key)) {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
        }
    }
}

var ret = {
    isClass: isClass,
    isIdentifier: isIdentifier,
    inheritedDataKeys: inheritedDataKeys,
    getDataPropertyOrDefault: getDataPropertyOrDefault,
    thrower: thrower,
    isArray: es5.isArray,
    haveGetters: haveGetters,
    notEnumerableProp: notEnumerableProp,
    isPrimitive: isPrimitive,
    isObject: isObject,
    canEvaluate: canEvaluate,
    errorObj: errorObj,
    tryCatch: tryCatch,
    inherits: inherits,
    withAppended: withAppended,
    maybeWrapAsError: maybeWrapAsError,
    wrapsPrimitiveReceiver: wrapsPrimitiveReceiver,
    toFastProperties: toFastProperties,
    filledRange: filledRange,
    toString: safeToString,
    canAttachTrace: canAttachTrace,
    ensureErrorObject: ensureErrorObject,
    originatesFromRejection: originatesFromRejection,
    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
    classString: classString,
    copyDescriptors: copyDescriptors,
    isNode: typeof process !== "undefined" &&
        classString(process).toLowerCase() === "[object process]"
};
try {throw new Error(); } catch (e) {ret.lastLineError = e;}
module.exports = ret;

},{"./es5.js":14}]},{},[4])(4)
});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":149}],364:[function(require,module,exports){
// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// UMD HEADER START 
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define([], factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
  }
}(this, function () {
// UMD HEADER END

var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')
request.log = {
  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
}

var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

//
// request
//

function request(options, callback) {
  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
  if(typeof callback !== 'function')
    throw new Error('Bad callback given: ' + callback)

  if(!options)
    throw new Error('No options given')

  var options_onResponse = options.onResponse; // Save this for later.

  if(typeof options === 'string')
    options = {'uri':options};
  else
    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

  options.onResponse = options_onResponse // And put it back.

  if (options.verbose) request.log = getLogger();

  if(options.url) {
    options.uri = options.url;
    delete options.url;
  }

  if(!options.uri && options.uri !== "")
    throw new Error("options.uri is a required argument");

  if(typeof options.uri != "string")
    throw new Error("options.uri must be a string");

  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
  for (var i = 0; i < unsupported_options.length; i++)
    if(options[ unsupported_options[i] ])
      throw new Error("options." + unsupported_options[i] + " is not supported")

  options.callback = callback
  options.method = options.method || 'GET';
  options.headers = options.headers || {};
  options.body    = options.body || null
  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

  if(options.headers.host)
    throw new Error("Options.headers.host is not supported");

  if(options.json) {
    options.headers.accept = options.headers.accept || 'application/json'
    if(options.method !== 'GET')
      options.headers['content-type'] = 'application/json'

    if(typeof options.json !== 'boolean')
      options.body = JSON.stringify(options.json)
    else if(typeof options.body !== 'string')
      options.body = JSON.stringify(options.body)
  }
  
  //BEGIN QS Hack
  var serialize = function(obj) {
    var str = [];
    for(var p in obj)
      if (obj.hasOwnProperty(p)) {
        str.push(encodeURIComponent(p) + "=" + encodeURIComponent(obj[p]));
      }
    return str.join("&");
  }
  
  if(options.qs){
    var qs = (typeof options.qs == 'string')? options.qs : serialize(options.qs);
    if(options.uri.indexOf('?') !== -1){ //no get params
        options.uri = options.uri+'&'+qs;
    }else{ //existing get params
        options.uri = options.uri+'?'+qs;
    }
  }
  //END QS Hack
  
  //BEGIN FORM Hack
  var multipart = function(obj) {
    //todo: support file type (useful?)
    var result = {};
    result.boundry = '-------------------------------'+Math.floor(Math.random()*1000000000);
    var lines = [];
    for(var p in obj){
        if (obj.hasOwnProperty(p)) {
            lines.push(
                '--'+result.boundry+"\n"+
                'Content-Disposition: form-data; name="'+p+'"'+"\n"+
                "\n"+
                obj[p]+"\n"
            );
        }
    }
    lines.push( '--'+result.boundry+'--' );
    result.body = lines.join('');
    result.length = result.body.length;
    result.type = 'multipart/form-data; boundary='+result.boundry;
    return result;
  }
  
  if(options.form){
    if(typeof options.form == 'string') throw('form name unsupported');
    if(options.method === 'POST'){
        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();
        options.headers['content-type'] = encoding;
        switch(encoding){
            case 'application/x-www-form-urlencoded':
                options.body = serialize(options.form).replace(/%20/g, "+");
                break;
            case 'multipart/form-data':
                var multi = multipart(options.form);
                //options.headers['content-length'] = multi.length;
                options.body = multi.body;
                options.headers['content-type'] = multi.type;
                break;
            default : throw new Error('unsupported encoding:'+encoding);
        }
    }
  }
  //END FORM Hack

  // If onResponse is boolean true, call back immediately when the response is known,
  // not when the full request is complete.
  options.onResponse = options.onResponse || noop
  if(options.onResponse === true) {
    options.onResponse = callback
    options.callback = noop
  }

  // XXX Browsers do not like this.
  //if(options.body)
  //  options.headers['content-length'] = options.body.length;

  // HTTP basic authentication
  if(!options.headers.authorization && options.auth)
    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

  return run_xhr(options)
}

var req_seq = 0
function run_xhr(options) {
  var xhr = new XHR
    , timed_out = false
    , is_cors = is_crossDomain(options.uri)
    , supports_cors = ('withCredentials' in xhr)

  req_seq += 1
  xhr.seq_id = req_seq
  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

  if(is_cors && !supports_cors) {
    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
    cors_err.cors = 'unsupported'
    return options.callback(cors_err, xhr)
  }

  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
  function too_late() {
    timed_out = true
    var er = new Error('ETIMEDOUT')
    er.code = 'ETIMEDOUT'
    er.duration = options.timeout

    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
    return options.callback(er, xhr)
  }

  // Some states can be skipped over, so remember what is still incomplete.
  var did = {'response':false, 'loading':false, 'end':false}

  xhr.onreadystatechange = on_state_change
  xhr.open(options.method, options.uri, true) // asynchronous
  if(is_cors)
    xhr.withCredentials = !! options.withCredentials
  xhr.send(options.body)
  return xhr

  function on_state_change(event) {
    if(timed_out)
      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

    if(xhr.readyState === XHR.OPENED) {
      request.log.debug('Request started', {'id':xhr.id})
      for (var key in options.headers)
        xhr.setRequestHeader(key, options.headers[key])
    }

    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
      on_response()

    else if(xhr.readyState === XHR.LOADING) {
      on_response()
      on_loading()
    }

    else if(xhr.readyState === XHR.DONE) {
      on_response()
      on_loading()
      on_end()
    }
  }

  function on_response() {
    if(did.response)
      return

    did.response = true
    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
    clearTimeout(xhr.timeoutTimer)
    xhr.statusCode = xhr.status // Node request compatibility

    // Detect failed CORS requests.
    if(is_cors && xhr.statusCode == 0) {
      var cors_err = new Error('CORS request rejected: ' + options.uri)
      cors_err.cors = 'rejected'

      // Do not process this request further.
      did.loading = true
      did.end = true

      return options.callback(cors_err, xhr)
    }

    options.onResponse(null, xhr)
  }

  function on_loading() {
    if(did.loading)
      return

    did.loading = true
    request.log.debug('Response body loading', {'id':xhr.id})
    // TODO: Maybe simulate "data" events by watching xhr.responseText
  }

  function on_end() {
    if(did.end)
      return

    did.end = true
    request.log.debug('Request done', {'id':xhr.id})

    xhr.body = xhr.responseText
    if(options.json) {
      try        { xhr.body = JSON.parse(xhr.responseText) }
      catch (er) { return options.callback(er, xhr)        }
    }

    options.callback(null, xhr, xhr.body)
  }

} // request

request.withCredentials = false;
request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

//
// defaults
//

request.defaults = function(options, requester) {
  var def = function (method) {
    var d = function (params, callback) {
      if(typeof params === 'string')
        params = {'uri': params};
      else {
        params = JSON.parse(JSON.stringify(params));
      }
      for (var i in options) {
        if (params[i] === undefined) params[i] = options[i]
      }
      return method(params, callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  return de
}

//
// HTTP method shortcuts
//

var shortcuts = [ 'get', 'put', 'post', 'head' ];
shortcuts.forEach(function(shortcut) {
  var method = shortcut.toUpperCase();
  var func   = shortcut.toLowerCase();

  request[func] = function(opts) {
    if(typeof opts === 'string')
      opts = {'method':method, 'uri':opts};
    else {
      opts = JSON.parse(JSON.stringify(opts));
      opts.method = method;
    }

    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
    return request.apply(this, args);
  }
})

//
// CouchDB shortcut
//

request.couch = function(options, callback) {
  if(typeof options === 'string')
    options = {'uri':options}

  // Just use the request API to do JSON.
  options.json = true
  if(options.body)
    options.json = options.body
  delete options.body

  callback = callback || noop

  var xhr = request(options, couch_handler)
  return xhr

  function couch_handler(er, resp, body) {
    if(er)
      return callback(er, resp, body)

    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
      // The body is a Couch JSON object indicating the error.
      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
      for (var key in body)
        er[key] = body[key]
      return callback(er, resp, body);
    }

    return callback(er, resp, body);
  }
}

//
// Utility
//

function noop() {}

function getLogger() {
  var logger = {}
    , levels = ['trace', 'debug', 'info', 'warn', 'error']
    , level, i

  for(i = 0; i < levels.length; i++) {
    level = levels[i]

    logger[level] = noop
    if(typeof console !== 'undefined' && console && console[level])
      logger[level] = formatted(console, level)
  }

  return logger
}

function formatted(obj, method) {
  return formatted_logger

  function formatted_logger(str, context) {
    if(typeof context === 'object')
      str += ' ' + JSON.stringify(context)

    return obj[method].call(obj, str)
  }
}

// Return whether a URL is a cross-domain request.
function is_crossDomain(url) {
  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

  // jQuery #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  var ajaxLocation
  try { ajaxLocation = location.href }
  catch (e) {
    // Use the href attribute of an A element since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  }

  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
    , parts = rurl.exec(url.toLowerCase() )

  var result = !!(
    parts &&
    (  parts[1] != ajaxLocParts[1]
    || parts[2] != ajaxLocParts[2]
    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
    )
  )

  //console.debug('is_crossDomain('+url+') -> ' + result)
  return result
}

// MIT License from http://phpjs.org/functions/base64_encode:358
function b64_enc (data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

    if (!data) {
        return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1<<16 | o2<<8 | o3;

        h1 = bits>>18 & 0x3f;
        h2 = bits>>12 & 0x3f;
        h3 = bits>>6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
        break;
        case 2:
            enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
}
    return request;
//UMD FOOTER START
}));
//UMD FOOTER END

},{}],365:[function(require,module,exports){
'use strict';

var BPromise = require('bluebird');
var request = BPromise.promisify(require('request'));

var JXT = require('jxt').createRegistry();

JXT.use(require('./lib/xrd'));


module.exports = function (opts, cb) {
    if (typeof opts === 'string') {
        opts = {host: opts};
    }

    var config = {
        ssl: true,
        json: true,
        xrd: true
    };

    for (var prop in opts) {
        config[prop] = opts[prop];
    }

    var scheme = config.ssl ? 'https://' : 'http://';

    var getJSON = new BPromise(function (resolve, reject) {
        request(scheme + config.host + '/.well-known/host-meta.json').spread(function (req, body) {
            resolve(JSON.parse(body));
        }).catch(reject);
    });

    var getXRD = new BPromise(function (resolve, reject) {
        request(scheme + config.host + '/.well-known/host-meta').spread(function (req, body) {
            var xrd = JXT.parse(body);
            resolve(xrd.toJSON());
        }).catch(reject);
    });


    return new BPromise(function (resolve, reject) {
        BPromise.some([getJSON, getXRD], 1).spread(resolve).catch(function () {
            reject('no-host-meta');
        });
    }).nodeify(cb);
};

},{"./lib/xrd":366,"bluebird":363,"jxt":407,"request":367}],366:[function(require,module,exports){
'use strict';

var jxt = require('jxt');
var NS = 'http://docs.oasis-open.org/ns/xri/xrd-1.0';


module.exports = function (registry) {
    var Properties = {
        get: function () {
            var results = {};
            var props = jxt.find(this.xml, NS, 'Property');
    
            for (var i = 0, len = props.length; i < len; i++) {
                var property = props[i];
                var type = jxt.getAttribute(property, 'type');
                results[type] = property.textContent;
            }
    
            return results;
        }
    };
    
    var XRD = registry.define({
        name: 'xrd',
        namespace: NS,
        element: 'XRD',
        fields: {
            subject: jxt.subText(NS, 'Subject'),
            expires: jxt.dateSub(NS, 'Expires'),
            aliases: jxt.multiSubText(NS, 'Alias'),
            properties: Properties
        }
    });
    
    
    var Link = registry.define({
        name: '_xrdlink',
        namespace: NS,
        element: 'Link',
        fields: {
            rel: jxt.attribute('rel'),
            href: jxt.attribute('href'),
            type: jxt.attribute('type'),
            template: jxt.attribute('template'),
            titles: jxt.subLangText(NS, 'Title', 'default'),
            properties: Properties
        }
    });
    
    registry.extend(XRD, Link, 'links');

    return XRD;
};

},{"jxt":407}],367:[function(require,module,exports){
// Browser Request
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

var XHR = XMLHttpRequest
if (!XHR) throw new Error('missing XMLHttpRequest')

module.exports = request
request.log = {
  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop
}

var DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes

//
// request
//

function request(options, callback) {
  // The entry-point to the API: prep the options object and pass the real work to run_xhr.
  if(typeof callback !== 'function')
    throw new Error('Bad callback given: ' + callback)

  if(!options)
    throw new Error('No options given')

  var options_onResponse = options.onResponse; // Save this for later.

  if(typeof options === 'string')
    options = {'uri':options};
  else
    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.

  options.onResponse = options_onResponse // And put it back.

  if (options.verbose) request.log = getLogger();

  if(options.url) {
    options.uri = options.url;
    delete options.url;
  }

  if(!options.uri && options.uri !== "")
    throw new Error("options.uri is a required argument");

  if(typeof options.uri != "string")
    throw new Error("options.uri must be a string");

  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']
  for (var i = 0; i < unsupported_options.length; i++)
    if(options[ unsupported_options[i] ])
      throw new Error("options." + unsupported_options[i] + " is not supported")

  options.callback = callback
  options.method = options.method || 'GET';
  options.headers = options.headers || {};
  options.body    = options.body || null
  options.timeout = options.timeout || request.DEFAULT_TIMEOUT

  if(options.headers.host)
    throw new Error("Options.headers.host is not supported");

  if(options.json) {
    options.headers.accept = options.headers.accept || 'application/json'
    if(options.method !== 'GET')
      options.headers['content-type'] = 'application/json'

    if(typeof options.json !== 'boolean')
      options.body = JSON.stringify(options.json)
    else if(typeof options.body !== 'string')
      options.body = JSON.stringify(options.body)
  }

  // If onResponse is boolean true, call back immediately when the response is known,
  // not when the full request is complete.
  options.onResponse = options.onResponse || noop
  if(options.onResponse === true) {
    options.onResponse = callback
    options.callback = noop
  }

  // XXX Browsers do not like this.
  //if(options.body)
  //  options.headers['content-length'] = options.body.length;

  // HTTP basic authentication
  if(!options.headers.authorization && options.auth)
    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);

  return run_xhr(options)
}

var req_seq = 0
function run_xhr(options) {
  var xhr = new XHR
    , timed_out = false
    , is_cors = is_crossDomain(options.uri)
    , supports_cors = ('withCredentials' in xhr)

  req_seq += 1
  xhr.seq_id = req_seq
  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri
  xhr._id = xhr.id // I know I will type "_id" from habit all the time.

  if(is_cors && !supports_cors) {
    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)
    cors_err.cors = 'unsupported'
    return options.callback(cors_err, xhr)
  }

  xhr.timeoutTimer = setTimeout(too_late, options.timeout)
  function too_late() {
    timed_out = true
    var er = new Error('ETIMEDOUT')
    er.code = 'ETIMEDOUT'
    er.duration = options.timeout

    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })
    return options.callback(er, xhr)
  }

  // Some states can be skipped over, so remember what is still incomplete.
  var did = {'response':false, 'loading':false, 'end':false}

  xhr.onreadystatechange = on_state_change
  xhr.open(options.method, options.uri, true) // asynchronous
  if(is_cors)
    xhr.withCredentials = !! options.withCredentials
  xhr.send(options.body)
  return xhr

  function on_state_change(event) {
    if(timed_out)
      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})

    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})

    if(xhr.readyState === XHR.OPENED) {
      request.log.debug('Request started', {'id':xhr.id})
      for (var key in options.headers)
        xhr.setRequestHeader(key, options.headers[key])
    }

    else if(xhr.readyState === XHR.HEADERS_RECEIVED)
      on_response()

    else if(xhr.readyState === XHR.LOADING) {
      on_response()
      on_loading()
    }

    else if(xhr.readyState === XHR.DONE) {
      on_response()
      on_loading()
      on_end()
    }
  }

  function on_response() {
    if(did.response)
      return

    did.response = true
    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})
    clearTimeout(xhr.timeoutTimer)
    xhr.statusCode = xhr.status // Node request compatibility

    // Detect failed CORS requests.
    if(is_cors && xhr.statusCode == 0) {
      var cors_err = new Error('CORS request rejected: ' + options.uri)
      cors_err.cors = 'rejected'

      // Do not process this request further.
      did.loading = true
      did.end = true

      return options.callback(cors_err, xhr)
    }

    options.onResponse(null, xhr)
  }

  function on_loading() {
    if(did.loading)
      return

    did.loading = true
    request.log.debug('Response body loading', {'id':xhr.id})
    // TODO: Maybe simulate "data" events by watching xhr.responseText
  }

  function on_end() {
    if(did.end)
      return

    did.end = true
    request.log.debug('Request done', {'id':xhr.id})

    xhr.body = xhr.responseText
    if(options.json) {
      try        { xhr.body = JSON.parse(xhr.responseText) }
      catch (er) { return options.callback(er, xhr)        }
    }

    options.callback(null, xhr, xhr.body)
  }

} // request

request.withCredentials = false;
request.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;

//
// defaults
//

request.defaults = function(options, requester) {
  var def = function (method) {
    var d = function (params, callback) {
      if(typeof params === 'string')
        params = {'uri': params};
      else {
        params = JSON.parse(JSON.stringify(params));
      }
      for (var i in options) {
        if (params[i] === undefined) params[i] = options[i]
      }
      return method(params, callback)
    }
    return d
  }
  var de = def(request)
  de.get = def(request.get)
  de.post = def(request.post)
  de.put = def(request.put)
  de.head = def(request.head)
  return de
}

//
// HTTP method shortcuts
//

var shortcuts = [ 'get', 'put', 'post', 'head' ];
shortcuts.forEach(function(shortcut) {
  var method = shortcut.toUpperCase();
  var func   = shortcut.toLowerCase();

  request[func] = function(opts) {
    if(typeof opts === 'string')
      opts = {'method':method, 'uri':opts};
    else {
      opts = JSON.parse(JSON.stringify(opts));
      opts.method = method;
    }

    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));
    return request.apply(this, args);
  }
})

//
// CouchDB shortcut
//

request.couch = function(options, callback) {
  if(typeof options === 'string')
    options = {'uri':options}

  // Just use the request API to do JSON.
  options.json = true
  if(options.body)
    options.json = options.body
  delete options.body

  callback = callback || noop

  var xhr = request(options, couch_handler)
  return xhr

  function couch_handler(er, resp, body) {
    if(er)
      return callback(er, resp, body)

    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {
      // The body is a Couch JSON object indicating the error.
      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))
      for (var key in body)
        er[key] = body[key]
      return callback(er, resp, body);
    }

    return callback(er, resp, body);
  }
}

//
// Utility
//

function noop() {}

function getLogger() {
  var logger = {}
    , levels = ['trace', 'debug', 'info', 'warn', 'error']
    , level, i

  for(i = 0; i < levels.length; i++) {
    level = levels[i]

    logger[level] = noop
    if(typeof console !== 'undefined' && console && console[level])
      logger[level] = formatted(console, level)
  }

  return logger
}

function formatted(obj, method) {
  return formatted_logger

  function formatted_logger(str, context) {
    if(typeof context === 'object')
      str += ' ' + JSON.stringify(context)

    return obj[method].call(obj, str)
  }
}

// Return whether a URL is a cross-domain request.
function is_crossDomain(url) {
  var rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/

  // jQuery #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  var ajaxLocation
  try { ajaxLocation = location.href }
  catch (e) {
    // Use the href attribute of an A element since IE will modify it given document.location
    ajaxLocation = document.createElement( "a" );
    ajaxLocation.href = "";
    ajaxLocation = ajaxLocation.href;
  }

  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []
    , parts = rurl.exec(url.toLowerCase() )

  var result = !!(
    parts &&
    (  parts[1] != ajaxLocParts[1]
    || parts[2] != ajaxLocParts[2]
    || (parts[3] || (parts[1] === "http:" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === "http:" ? 80 : 443))
    )
  )

  //console.debug('is_crossDomain('+url+') -> ' + result)
  return result
}

// MIT License from http://phpjs.org/functions/base64_encode:358
function b64_enc (data) {
    // Encodes string using MIME base64 algorithm
    var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc="", tmp_arr = [];

    if (!data) {
        return data;
    }

    // assume utf8 data
    // data = this.utf8_encode(data+'');

    do { // pack three octets into four hexets
        o1 = data.charCodeAt(i++);
        o2 = data.charCodeAt(i++);
        o3 = data.charCodeAt(i++);

        bits = o1<<16 | o2<<8 | o3;

        h1 = bits>>18 & 0x3f;
        h2 = bits>>12 & 0x3f;
        h3 = bits>>6 & 0x3f;
        h4 = bits & 0x3f;

        // use hexets to index into b64, and append result to encoded string
        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
    } while (i < data.length);

    enc = tmp_arr.join('');

    switch (data.length % 3) {
        case 1:
            enc = enc.slice(0, -2) + '==';
        break;
        case 2:
            enc = enc.slice(0, -1) + '=';
        break;
    }

    return enc;
}

},{}],368:[function(require,module,exports){
var createHash = require('create-hash');
var createHmac = require('create-hmac');
var getHashes = require('./lib/get-hashes');

var mapping = {
    md2: 'md2',
    md5: 'md5',
    'sha-1': 'sha1',
    'sha-224': 'sha224',
    'sha-256': 'sha256',
    'sha-384': 'sha384',
    'sha-512': 'sha512'
};

var names = Object.keys(mapping);


exports.getHashes = function () {
    var result = [];
    var available = getHashes();
    for (var i = 0, len = names.length; i < len; i++) {
        if (available.indexOf(mapping[names[i]]) >= 0) {
            result.push(names[i]);
        }
    }
    return result;
};

exports.createHash = function (algorithm) {
    algorithm = algorithm.toLowerCase();
    if (mapping[algorithm]) {
        algorithm = mapping[algorithm];
    }
    return createHash(algorithm);
};

exports.createHmac = function (algorithm, key) {
    algorithm = algorithm.toLowerCase();
    if (mapping[algorithm]) {
        algorithm = mapping[algorithm];
    }
    return createHmac(algorithm, key);
};

},{"./lib/get-hashes":369,"create-hash":370,"create-hmac":382}],369:[function(require,module,exports){
var crypto = require('crypto');


module.exports = function () {
    return crypto.getHashes();
};

},{"crypto":9}],370:[function(require,module,exports){
module.exports=require(97)
},{"./md5":372,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js":97,"buffer":5,"inherits":373,"ripemd160":374,"sha.js":376,"stream":163}],371:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/helpers.js":98,"buffer":5}],372:[function(require,module,exports){
module.exports=require(99)
},{"./helpers":371,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js":99}],373:[function(require,module,exports){
module.exports=require(146)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/inherits/inherits_browser.js":146}],374:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":100,"buffer":5}],375:[function(require,module,exports){
module.exports=require(101)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js":101,"buffer":5}],376:[function(require,module,exports){
module.exports=require(102)
},{"./sha1":377,"./sha224":378,"./sha256":379,"./sha384":380,"./sha512":381,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/index.js":102}],377:[function(require,module,exports){
module.exports=require(103)
},{"./hash":375,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha1.js":103,"buffer":5,"inherits":373}],378:[function(require,module,exports){
module.exports=require(104)
},{"./hash":375,"./sha256":379,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha224.js":104,"buffer":5,"inherits":373}],379:[function(require,module,exports){
module.exports=require(105)
},{"./hash":375,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js":105,"buffer":5,"inherits":373}],380:[function(require,module,exports){
module.exports=require(106)
},{"./hash":375,"./sha512":381,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha384.js":106,"buffer":5,"inherits":373}],381:[function(require,module,exports){
module.exports=require(107)
},{"./hash":375,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js":107,"buffer":5,"inherits":373}],382:[function(require,module,exports){
module.exports=require(108)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js":108,"buffer":5,"create-hash/browser":370,"inherits":383,"stream":163}],383:[function(require,module,exports){
module.exports=require(146)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/inherits/inherits_browser.js":146}],384:[function(require,module,exports){
var util = require('util');
var intersect = require('intersect');
var WildEmitter = require('wildemitter');
var webrtc = require('webrtcsupport');

var BaseSession = require('jingle-session');
var MediaSession = require('jingle-media-session');
var FileSession = require('jingle-filetransfer-session');


function SessionManager(conf) {
    WildEmitter.call(this);

    conf = conf || {};

    this.jid = conf.jid;
    this.selfID = conf.selfID || (this.jid && this.jid.full) || this.jid || '';

    this.sessions = {};
    this.peers = {};

    this.prepareSession = conf.prepareSession || function (opts) {
        if (opts.descriptionTypes.indexOf('rtp') >= 0) {
            return new MediaSession(opts);
        }
        if (opts.descriptionTypes.indexOf('filetransfer') >= 0) {
            return new FileSession(opts);
        }
    };

    this.screenSharingSupport = webrtc.screenSharing;

    this.capabilities = [
        'urn:xmpp:jingle:1'
    ];
    if (webrtc.support) {
        this.capabilities = [
            'urn:xmpp:jingle:1',
            'urn:xmpp:jingle:apps:rtp:1',
            'urn:xmpp:jingle:apps:rtp:audio',
            'urn:xmpp:jingle:apps:rtp:video',
            'urn:xmpp:jingle:apps:rtp:rtcb-fb:0',
            'urn:xmpp:jingle:apps:rtp:rtp-hdrext:0',
            'urn:xmpp:jingle:apps:rtp:ssma:0',
            'urn:xmpp:jingle:apps:dtls:0',
            'urn:xmpp:jingle:apps:grouping:0',
            'urn:xmpp:jingle:apps:file-transfer:3',
            'urn:xmpp:jingle:transports:ice-udp:1',
            'urn:xmpp:jingle:transports.dtls-sctp:1',
            'urn:ietf:rfc:3264',
            'urn:ietf:rfc:5576',
            'urn:ietf:rfc:5888'
        ];
    }

    this.config = {
        debug: false,
        peerConnectionConfig: {
            iceServers: conf.iceServers || [{'url': 'stun:stun.l.google.com:19302'}]
        },
        peerConnectionConstraints: {
            optional: [
                {DtlsSrtpKeyAgreement: true},
                {RtpDataChannels: false}
            ]
        },
        media: {
            audio: true,
            video: true
        }
    };

    for (var item in conf) {
        this.config[item] = conf[item];
    }

    this.iceServers = this.config.peerConnectionConfig.iceServers;
}


util.inherits(SessionManager, WildEmitter);


SessionManager.prototype.addICEServer = function (server) {
    // server == {
    //    url: '',
    //    [username: '',]
    //    [credential: '']
    // }
    if (typeof server === 'string') {
        server = {url: server};
    }
    this.iceServers.push(server);
};

SessionManager.prototype.addSession = function (session) {
    var self = this;

    var sid = session.sid;
    var peer = session.peerID;

    this.sessions[sid] = session;
    if (!this.peers[peer]) {
        this.peers[peer] = [];
    }

    this.peers[peer].push(session);

    // Automatically clean up tracked sessions
    session.on('terminated', function () {
        var peers = self.peers[peer] || [];
        if (peers.length) {
            peers.splice(peers.indexOf(session), 1);
        }
        delete self.sessions[sid];
    });

    // Proxy session events
    session.on('*', function (name, data, extraData, extraData2) {
        // Listen for when we actually try to start a session to
        // trigger the outgoing event.
        if (name === 'send') {
            var action = data.jingle && data.jingle.action;
            if (session.isInitiator && action === 'session-initiate') {
                self.emit('outgoing', session);
            }
        }

        if (self.config.debug && (name === 'log:debug' || name === 'log:error')) {
            console.log('Jingle:', data, extraData, extraData2);
        }

        // Don't proxy change:* events, since those don't apply to
        // the session manager itself.
        if (name.indexOf('change') === 0) {
            return;
        }

        self.emit(name, data, extraData, extraData2);
    });

    this.emit('createdSession', session);

    return session;
};

SessionManager.prototype.createMediaSession = function (peer, sid, stream) {
    var session = new MediaSession({
        sid: sid,
        peer: peer,
        initiator: true,
        stream: stream,
        parent: this,
        iceServers: this.iceServers,
        constraints: this.config.peerConnectionConstraints
    });

    this.addSession(session);

    return session;
};

SessionManager.prototype.createFileTransferSession = function (peer, sid) {
    var session = new FileSession({
        sid: sid,
        peer: peer,
        initiator: true,
        parent: this
    });

    this.addSession(session);

    return session;
};

SessionManager.prototype.endPeerSessions = function (peer, reason, silent) {
    peer = peer.full || peer;

    var sessions = this.peers[peer] || [];
    delete this.peers[peer];

    sessions.forEach(function (session) {
        session.end(reason || 'gone', silent);
    });
};

SessionManager.prototype.endAllSessions = function (reason, silent) {
    var self = this;
    Object.keys(this.peers).forEach(function (peer) {
        self.endPeerSessions(peer, reason, silent);
    });
};

SessionManager.prototype._createIncomingSession = function (meta, req) {
    var session;

    if (this.prepareSession) {
        session = this.prepareSession(meta, req);
    }

    // Fallback to a generic session type, which can
    // only be used to end the session.

    if (!session) {
        session = new BaseSession(meta);
    }

    this.addSession(session);

    return session;
};

SessionManager.prototype._sendError = function (to, id, data) {
    if (!data.type) {
        data.type = 'cancel';
    }
    this.emit('send', {
        to: to,
        id: id,
        type: 'error',
        error: data
    });
};

SessionManager.prototype._log = function (level, message) {
    this.emit('log:' + level, message);
};

SessionManager.prototype.process = function (req) {
    var self = this;

    // Extract the request metadata that we need to verify
    var sid = !!req.jingle ? req.jingle.sid : null;
    var session = this.sessions[sid] || null;
    var rid = req.id;
    var sender = req.from.full || req.from;


    if (req.type === 'error') {
        var isTieBreak = req.error && req.error.jingleCondition === 'tie-break';
        if (session && session.pending && isTieBreak) {
            return session.end('alternative-session', true);
        } else {
            if (session) {
                session.pendingAction = false;
            }
            return this.emit('error', req);
        }
    }

    if (req.type === 'result') {
        if (session) {
            session.pendingAction = false;
        }
        return;
    }

    var action = req.jingle.action;
    var contents = req.jingle.contents || [];

    var descriptionTypes = contents.map(function (content) {
        if (content.description) {
            return content.description.descType;
        }
    });
    var transportTypes = contents.map(function (content) {
        if (content.transport) {
            return content.transport.transType;
        }
    });


    // Now verify that we are allowed to actually process the
    // requested action

    if (action !== 'session-initiate') {
        // Can't modify a session that we don't have.
        if (!session) {
            this._log('error', 'Unknown session', sid);
            return this._sendError(sender, rid, {
                condition: 'item-not-found',
                jingleCondition: 'unknown-session'
            });
        }

        // Check if someone is trying to hijack a session.
        if (session.peerID !== sender || session.ended) {
            this._log('error', 'Session has ended, or action has wrong sender');
            return this._sendError(sender, rid, {
                condition: 'item-not-found',
                jingleCondition: 'unknown-session'
            });
        }

        // Can't accept a session twice
        if (action === 'session-accept' && !session.pending) {
            this._log('error', 'Tried to accept session twice', sid);
            return this._sendError(sender, rid, {
                condition: 'unexpected-request',
                jingleCondition: 'out-of-order'
            });
        }

        // Can't process two requests at once, need to tie break
        if (action !== 'session-terminate' && action === session.pendingAction) {
            this._log('error', 'Tie break during pending request');
            if (session.isInitiator) {
                return this._sendError(sender, rid, {
                    condition: 'conflict',
                    jingleCondition: 'tie-break'
                });
            }
        }
    } else if (session) {
        // Don't accept a new session if we already have one.
        if (session.peerID !== sender) {
            this._log('error', 'Duplicate sid from new sender');
            return this._sendError(sender, rid, {
                condition: 'service-unavailable'
            });
        }

        // Check if we need to have a tie breaker because both parties
        // happened to pick the same random sid.
        if (session.pending) {
            if (this.selfID > session.peerID) {
                this._log('error', 'Tie break new session because of duplicate sids');
                return this._sendError(sender, rid, {
                    condition: 'conflict',
                    jingleCondition: 'tie-break'
                });
            }
        } else {
            // The other side is just doing it wrong.
            this._log('error', 'Someone is doing this wrong');
            return this._sendError(sender, rid, {
                condition: 'unexpected-request',
                jingleCondition: 'out-of-order'
            });
        }
    } else if (this.peers[sender] && this.peers[sender].length) {
        // Check if we need to have a tie breaker because we already have
        // a different session with this peer that is using the requested
        // content description types.
        for (var i = 0, len = this.peers[sender].length; i < len; i++) {
            var sess = this.peers[sender][i];
            if (sess && sess.pending) {
                if (intersect(descriptionTypes, sess.pendingDescriptionTypes).length) {
                    // We already have a pending session request for this content type.
                    if (sess.sid > sid) {
                        // We won the tie breaker
                        this._log('info', 'Tie break');
                        return this._sendError(sender, rid, {
                            condition: 'conflict',
                            jingleCondition: 'tie-break'
                        });
                    }
                }
            }
        }
    }

    // We've now weeded out invalid requests, so we can process the action now.

    if (action === 'session-initiate') {
        if (!contents.length) {
            return self._sendError(sender, rid, {
                condition: 'bad-request'
            });
        }

        session = this._createIncomingSession({
            sid: sid,
            peer: req.from,
            peerID: sender,
            initiator: false,
            parent: this,
            descriptionTypes: descriptionTypes,
            transportTypes: transportTypes,
            iceServers: this.iceServers,
            constraints: this.peerConnectionConstraints
        }, req);
    }

    session.process(action, req.jingle, function (err) {
        if (err) {
            self._log('error', 'Could not process request', req, err);
            self._sendError(sender, rid, err);
        } else {
            self.emit('send', {
                to: sender,
                id: rid,
                type: 'result',
            });

            // Wait for the initial action to be processed before emitting
            // the session for the user to accept/reject.
            if (action === 'session-initiate') {
                self.emit('incoming', session);
            }
        }
    });
};


module.exports = SessionManager;

},{"intersect":386,"jingle-filetransfer-session":387,"jingle-media-session":396,"jingle-session":404,"util":165,"webrtcsupport":405,"wildemitter":449}],385:[function(require,module,exports){
var arr = [];
var each = arr.forEach;
var slice = arr.slice;


module.exports = function(obj) {
    each.call(slice.call(arguments, 1), function(source) {
        if (source) {
            for (var prop in source) {
                obj[prop] = source[prop];
            }
        }
    });
    return obj;
};

},{}],386:[function(require,module,exports){
module.exports = intersect;

function intersect (a, b) {
  var res = [];
  for (var i = 0; i < a.length; i++) {
    if (indexOf(b, a[i]) > -1) res.push(a[i]);
  }
  return res;
}

intersect.big = function(a, b) {
  var ret = [];
  var temp = {};
  
  for (var i = 0; i < b.length; i++) {
    temp[b[i]] = true;
  }
  for (var i = 0; i < a.length; i++) {
    if (temp[a[i]]) ret.push(a[i]);
  }
  
  return ret;
}

function indexOf(arr, el) {
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === el) return i;
  }
  return -1;
}

},{}],387:[function(require,module,exports){
var util = require('util');
var extend = require('extend-object');
var BaseSession = require('jingle-session');
var RTCPeerConnection = require('rtcpeerconnection');
var FileTransfer = require('filetransfer');


function FileTransferSession(opts) {
    BaseSession.call(this, opts);

    var self = this;

    this.pc = new RTCPeerConnection({
        iceServers: opts.iceServers || [],
        useJingle: true
    }, opts.constraints || {});

    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
    this.pc.on('addChannel', this.onChannelAdded.bind(this));

    this.sender = new FileTransfer.Sender();
    this.sender.on('progress', function (sent, size) {
        self._log('info', 'Send progress ' + sent + '/' + size);
    });
    this.sender.on('sentFile', function (meta) {
        self._log('info', 'Sent file', meta.name);

        var content = self.pc.localDescription.contents[0];
        delete content.transport;

        content.description = {
            descType: 'filetransfer',
            offer: {
                hash: {
                    algo: meta.algo,
                    value: meta.hash
                }
            }
        };

        self.send('description-info', {
            contents: [content]
        });
        self.emit('sentFile', self, meta);
    });

    this.receiver = new FileTransfer.Receiver();
    this.receiver.on('progress', function (received, size) {
        self._log('info', 'Receive progress ' + received + '/' + size);
    });
    this.receiver.on('receivedFile', function (file) {
        self.receivedFile = file;
        self.maybeReceivedFile();
    });
}


util.inherits(FileTransferSession, BaseSession);


FileTransferSession.prototype = extend(FileTransferSession.prototype, {

    // ----------------------------------------------------------------
    // Session control methods
    // ----------------------------------------------------------------

    start: function (file) {
        var self = this;
        this.state = 'pending';

        this.pc.isInitiator = true;

        var sendChannel = this.pc.createDataChannel('filetransfer');
        sendChannel.onopen = function () {
            self.sender.send(file, sendChannel);
        };

        var constraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };

        this.pc.offer(constraints, function (err, offer) {
            if (err) {
                self._log('error', 'Could not create WebRTC offer', err);
                return self.end('failed-application', true);
            }

            offer.jingle.contents[0].description = {
                descType: 'filetransfer',
                offer: {
                    date: file.lastModifiedDate,
                    name: file.name,
                    size: file.size,
                    hash: {
                        algo: 'sha-1',
                        value: ''
                    }
                }
            };

            self.send('session-initiate', offer.jingle);
        });
    },

    accept: function () {
        var self = this;

        this._log('info', 'Accepted incoming session');

        this.state = 'active';

        this.pc.answer(function (err, answer) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer', err);
                return self.end('failed-application');
            }

            answer.jingle.contents[0].name = 'data';

            self.send('session-accept', answer.jingle);
        });
    },

    end: function (reason, silent) {
        this.pc.close();
        BaseSession.prototype.end.call(this, reason, silent);
    },

    maybeReceivedFile: function () {
        if (!this.receiver.metadata.hash.value) {
            // unknown hash, file transfer not completed
        } else if (this.receiver.metadata.hash.value === this.receiver.metadata.actualhash) {
            this._log('info', 'File hash matches');
            this.emit('receivedFile', this, this.receivedFile, this.receiver.metadata);
            this.end('success');
        } else {
            this._log('error', 'File hash does not match');
            this.end('media-error');
        }
    },

    // ----------------------------------------------------------------
    // ICE action handers
    // ----------------------------------------------------------------

    onIceCandidate: function (candidate) {
        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
        candidate.jingle.contents[0].name = 'data';
        this.send('transport-info', candidate.jingle);
    },

    onIceStateChange: function () {
        switch (this.pc.iceConnectionState) {
            case 'checking':
                this.connectionState = 'connecting';
                break;
            case 'completed':
            case 'connected':
                this.connectionState = 'connected';
                break;
            case 'disconnected':
                if (this.pc.signalingState === 'stable') {
                    this.connectionState = 'interrupted';
                } else {
                    this.connectionState = 'disconnected';
                }
                break;
            case 'failed':
                this.connectionState = 'failed';
                this.end('failed-transport');
                break;
            case 'closed':
                this.connectionState = 'disconnected';
                break;
        }
    },

    onChannelAdded: function (channel) {
        this.receiver.receive(null, channel);
    },

    // ----------------------------------------------------------------
    // Jingle action handers
    // ----------------------------------------------------------------

    onSessionInitiate: function (changes, cb) {
        var self = this;

        this._log('info', 'Initiating incoming session');

        this.state = 'pending';

        this.pc.isInitiator = false;

        var desc = changes.contents[0].description;
        this.receiver.metadata = desc.offer.toJSON();

        if (this.receiver.metadata.hash) {
            this.receiver.config.hash = this.receiver.metadata.hash.algo;
        }

        changes.contents[0].description = {
            descType: 'datachannel'
        };

        this.pc.handleOffer({
            type: 'offer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer');
                return cb({condition: 'general-error'});
            }
            cb();
        });
    },

    onSessionAccept: function (changes, cb) {
        var self = this;

        this.state = 'active';
        
        changes.contents[0].description = {
            descType: 'datachannel'
        };

        this.pc.handleAnswer({
            type: 'answer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process WebRTC answer');
                return cb({condition: 'general-error'});
            }
            self.emit('accepted', self);
            cb();
        });
    },

    onSessionTerminate: function (changes, cb) {
        this._log('info', 'Terminating session');
        this.pc.close();
        BaseSession.prototype.end.call(this, changes.reason, true);
        cb();
    },

    onDescriptionInfo: function (info, cb) {
        var hash = info.contents[0].description.offer.hash;
        this.receiver.metadata.hash = hash;
        if (this.receiver.metadata.actualhash) {
            this.maybeReceivedFile();
        }
        cb();
    },

    onTransportInfo: function (changes, cb) {
        this.pc.processIce(changes, function () {
            cb();
        });
    }
});


module.exports = FileTransferSession;

},{"extend-object":385,"filetransfer":388,"jingle-session":404,"rtcpeerconnection":395,"util":165}],388:[function(require,module,exports){
var async = require('async');
//var webrtcsupport = require('webrtcsupport');
var WildEmitter = require('wildemitter');
var util = require('util');
var hashes = require('iana-hashes');

function Sender(opts) {
    WildEmitter.call(this);
    var self = this;
    var options = opts || {};
    this.config = {
        chunksize: 16384,
        pacing: 10,
        hash: 'sha-1' // note: this uses iana hash names
    };
    // set our config from options
    var item;
    for (item in options) {
        this.config[item] = options[item];
    }

    this.file = null;
    this.channel = null;
    this.hash = null;

    // paced sender
    // TODO: do we have to do this?
    this.processingQueue = async.queue(function (task, next) {
        if (task.type == 'chunk') {
            var reader = new window.FileReader();
            reader.onload = (function() {
                return function(e) {
                    self.channel.send(e.target.result);

                    self.hash.update(new Uint8Array(e.target.result));

                    self.emit('progress', task.start, task.file.size);

                    window.setTimeout(next, self.config.pacing); // pacing
                };
            })(task.file);
            var slice = task.file.slice(task.start, task.start + task.size);
            reader.readAsArrayBuffer(slice);
        } else if (task.type == 'complete') {
            self.emit('sentFile', {hash: self.hash.digest('hex'), algo: self.config.hash });
            next();
        }
    });
}
util.inherits(Sender, WildEmitter);

Sender.prototype.send = function (file, channel) {
    this.file = file;
    this.hash = hashes.createHash(this.config.hash);

    this.channel = channel;
    // FIXME: hook to channel.onopen?
    for (var start = 0; start < this.file.size; start += this.config.chunksize) {
        this.processingQueue.push({
            type: 'chunk',
            file: file,
            start: start,
            size: this.config.chunksize
        });
    }
    this.processingQueue.push({
        type: 'complete'
    });
};

function Receiver(opts) {
    WildEmitter.call(this);

    var options = opts || {};
    this.config = {
        hash: 'sha-1'
    };
    // set our config from options
    var item;
    for (item in options) {
        this.config[item] = options[item];
    }
    this.receiveBuffer = [];
    this.received = 0;
    this.metadata = {};
    this.channel = null;
    this.hash = null;
}
util.inherits(Receiver, WildEmitter);

Receiver.prototype.receive = function (metadata, channel) {
    var self = this;

    if (metadata) {
        this.metadata = metadata;
    }
    this.hash = hashes.createHash(this.config.hash);

    this.channel = channel;
    // chrome only supports arraybuffers and those make it easier to calc the hash
    channel.binaryType = 'arraybuffer';
    this.channel.onmessage = function (event) {
        var len = event.data.byteLength;
        self.received += len;
        self.receiveBuffer.push(event.data);

        self.hash.update(new Uint8Array(event.data));

        self.emit('progress', self.received, self.metadata.size);
        if (self.received == self.metadata.size) {
            self.metadata.actualhash = self.hash.digest('hex');
            self.emit('receivedFile', new window.Blob(self.receiveBuffer), self.metadata);
            self.receiveBuffer = []; // discard receivebuffer
        } else if (self.received > self.metadata.size) {
            // FIXME
            console.error('received more than expected, discarding...');
            self.receiveBuffer = []; // just discard...

        }
    };
};

module.exports = {};
module.exports.support = window && window.File && window.FileReader && window.Blob;
module.exports.Sender = Sender;
module.exports.Receiver = Receiver;

},{"async":362,"iana-hashes":368,"util":165,"wildemitter":449}],389:[function(require,module,exports){
var toSDP = require('./lib/tosdp');
var toJSON = require('./lib/tojson');


// Converstion from JSON to SDP

exports.toIncomingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPOffer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingSDPAnswer = function (session) {
    return toSDP.toSessionSDP(session, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPOffer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'outgoing'
    });
};
exports.toIncomingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'initiator',
        direction: 'incoming'
    });
};
exports.toOutgoingMediaSDPAnswer = function (media) {
    return toSDP.toMediaSDP(media, {
        role: 'responder',
        direction: 'outgoing'
    });
};
exports.toCandidateSDP = toSDP.toCandidateSDP;
exports.toMediaSDP = toSDP.toMediaSDP;
exports.toSessionSDP = toSDP.toSessionSDP;


// Conversion from SDP to JSON

exports.toIncomingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONOffer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creators: creators
    });
};
exports.toOutgoingJSONAnswer = function (sdp, creators) {
    return toJSON.toSessionJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creators: creators
    });
};
exports.toIncomingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONOffer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toIncomingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'initiator',
        direction: 'incoming',
        creator: creator
    });
};
exports.toOutgoingMediaJSONAnswer = function (sdp, creator) {
    return toJSON.toMediaJSON(sdp, {
        role: 'responder',
        direction: 'outgoing',
        creator: creator
    });
};
exports.toCandidateJSON = toJSON.toCandidateJSON;
exports.toMediaJSON = toJSON.toMediaJSON;
exports.toSessionJSON = toJSON.toSessionJSON;

},{"./lib/tojson":392,"./lib/tosdp":393}],390:[function(require,module,exports){
exports.lines = function (sdp) {
    return sdp.split('\r\n').filter(function (line) {
        return line.length > 0;
    });
};

exports.findLine = function (prefix, mediaLines, sessionLines) {
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            return mediaLines[i];
        }
    }
    // Continue searching in parent session section
    if (!sessionLines) {
        return false;
    }

    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            return sessionLines[j];
        }
    }

    return false;
};

exports.findLines = function (prefix, mediaLines, sessionLines) {
    var results = [];
    var prefixLength = prefix.length;
    for (var i = 0; i < mediaLines.length; i++) {
        if (mediaLines[i].substr(0, prefixLength) === prefix) {
            results.push(mediaLines[i]);
        }
    }
    if (results.length || !sessionLines) {
        return results;
    }
    for (var j = 0; j < sessionLines.length; j++) {
        if (sessionLines[j].substr(0, prefixLength) === prefix) {
            results.push(sessionLines[j]);
        }
    }
    return results;
};

exports.mline = function (line) {
    var parts = line.substr(2).split(' ');
    var parsed = {
        media: parts[0],
        port: parts[1],
        proto: parts[2],
        formats: []
    };
    for (var i = 3; i < parts.length; i++) {
        if (parts[i]) {
            parsed.formats.push(parts[i]);
        }
    }
    return parsed;
};

exports.rtpmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        id: parts.shift()
    };

    parts = parts[0].split('/');

    parsed.name = parts[0];
    parsed.clockrate = parts[1];
    parsed.channels = parts.length == 3 ? parts[2] : '1';
    return parsed;
};

exports.sctpmap = function (line) {
    // based on -05 draft
    var parts = line.substr(10).split(' ');
    var parsed = {
        number: parts.shift(),
        protocol: parts.shift(),
        streams: parts.shift()
    };
    return parsed;
};


exports.fmtp = function (line) {
    var kv, key, value;
    var parts = line.substr(line.indexOf(' ') + 1).split(';');
    var parsed = [];
    for (var i = 0; i < parts.length; i++) {
        kv = parts[i].split('=');
        key = kv[0].trim();
        value = kv[1];
        if (key && value) {
            parsed.push({key: key, value: value});
        } else if (key) {
            parsed.push({key: '', value: key});
        }
    }
    return parsed;
};

exports.crypto = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {
        tag: parts[0],
        cipherSuite: parts[1],
        keyParams: parts[2],
        sessionParams: parts.slice(3).join(' ')
    };
    return parsed;
};

exports.fingerprint = function (line) {
    var parts = line.substr(14).split(' ');
    return {
        hash: parts[0],
        value: parts[1]
    };
};

exports.extmap = function (line) {
    var parts = line.substr(9).split(' ');
    var parsed = {};

    var idpart = parts.shift();
    var sp = idpart.indexOf('/');
    if (sp >= 0) {
        parsed.id = idpart.substr(0, sp);
        parsed.senders = idpart.substr(sp + 1);
    } else {
        parsed.id = idpart;
        parsed.senders = 'sendrecv';
    }

    parsed.uri = parts.shift() || '';

    return parsed;
};

exports.rtcpfb = function (line) {
    var parts = line.substr(10).split(' ');
    var parsed = {};
    parsed.id = parts.shift();
    parsed.type = parts.shift();
    if (parsed.type === 'trr-int') {
        parsed.value = parts.shift();
    } else {
        parsed.subtype = parts.shift() || '';
    }
    parsed.parameters = parts;
    return parsed;
};

exports.candidate = function (line) {
    var parts;
    if (line.indexOf('a=candidate:') === 0) {
        parts = line.substring(12).split(' ');
    } else { // no a=candidate
        parts = line.substring(10).split(' ');
    }

    var candidate = {
        foundation: parts[0],
        component: parts[1],
        protocol: parts[2].toLowerCase(),
        priority: parts[3],
        ip: parts[4],
        port: parts[5],
        // skip parts[6] == 'typ'
        type: parts[7],
        generation: '0'
    };

    for (var i = 8; i < parts.length; i += 2) {
        if (parts[i] === 'raddr') {
            candidate.relAddr = parts[i + 1];
        } else if (parts[i] === 'rport') {
            candidate.relPort = parts[i + 1];
        } else if (parts[i] === 'generation') {
            candidate.generation = parts[i + 1];
        } else if (parts[i] === 'tcptype') {
            candidate.tcpType = parts[i + 1];
        }
    }

    candidate.network = '1';

    return candidate;
};

exports.sourceGroups = function (lines) {
    var parsed = [];
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(13).split(' ');
        parsed.push({
            semantics: parts.shift(),
            sources: parts
        });
    }
    return parsed;
};

exports.sources = function (lines) {
    // http://tools.ietf.org/html/rfc5576
    var parsed = [];
    var sources = {};
    for (var i = 0; i < lines.length; i++) {
        var parts = lines[i].substr(7).split(' ');
        var ssrc = parts.shift();

        if (!sources[ssrc]) {
            var source = {
                ssrc: ssrc,
                parameters: []
            };
            parsed.push(source);

            // Keep an index
            sources[ssrc] = source;
        }

        parts = parts.join(' ').split(':');
        var attribute = parts.shift();
        var value = parts.join(':') || null;

        sources[ssrc].parameters.push({
            key: attribute,
            value: value
        });
    }

    return parsed;
};

exports.groups = function (lines) {
    // http://tools.ietf.org/html/rfc5888
    var parsed = [];
    var parts;
    for (var i = 0; i < lines.length; i++) {
        parts = lines[i].substr(8).split(' ');
        parsed.push({
            semantics: parts.shift(),
            contents: parts
        });
    }
    return parsed;
};

exports.bandwidth = function (line) {
    var parts = line.substr(2).split(':');
    var parsed = {};
    parsed.type = parts.shift();
    parsed.bandwidth = parts.shift();
    return parsed;
};

},{}],391:[function(require,module,exports){
module.exports = {
    initiator: {
        incoming: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        }
    },
    responder: {
        incoming: {
            initiator: 'sendonly',
            responder: 'recvonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'responder',
            sendonly: 'initiator',
            sendrecv: 'both',
            inactive: 'none'
        },
        outgoing: {
            initiator: 'recvonly',
            responder: 'sendonly',
            both: 'sendrecv',
            none: 'inactive',
            recvonly: 'initiator',
            sendonly: 'responder',
            sendrecv: 'both',
            inactive: 'none'
        }
    }
};

},{}],392:[function(require,module,exports){
var SENDERS = require('./senders');
var parsers = require('./parsers');
var idCounter = Math.random();


exports._setIdCounter = function (counter) {
    idCounter = counter;
};

exports.toSessionJSON = function (sdp, opts) {
    var i;
    var creators = opts.creators || [];
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';


    // Divide the SDP into session and media sections.
    var media = sdp.split('\r\nm=');
    for (i = 1; i < media.length; i++) {
        media[i] = 'm=' + media[i];
        if (i !== media.length - 1) {
            media[i] += '\r\n';
        }
    }
    var session = media.shift() + '\r\n';
    var sessionLines = parsers.lines(session);
    var parsed = {};

    var contents = [];
    for (i = 0; i < media.length; i++) {
        contents.push(exports.toMediaJSON(media[i], session, {
            role: role,
            direction: direction,
            creator: creators[i] || 'initiator'
        }));
    }
    parsed.contents = contents;

    var groupLines = parsers.findLines('a=group:', sessionLines);
    if (groupLines.length) {
        parsed.groups = parsers.groups(groupLines);
    }

    return parsed;
};

exports.toMediaJSON = function (media, session, opts) {
    var creator = opts.creator || 'initiator';
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var lines = parsers.lines(media);
    var sessionLines = parsers.lines(session);
    var mline = parsers.mline(lines[0]);

    var content = {
        creator: creator,
        name: mline.media,
        description: {
            descType: 'rtp',
            media: mline.media,
            payloads: [],
            encryption: [],
            feedback: [],
            headerExtensions: []
        },
        transport: {
            transType: 'iceUdp',
            candidates: [],
            fingerprints: [],
        }
    };
    if (mline.media == 'application') {
        // FIXME: the description is most likely to be independent
        // of the SDP and should be processed by other parts of the library
        content.description = {
            descType: 'datachannel'
        };
        content.transport.sctp = [];
    }
    var desc = content.description;
    var trans = content.transport;

    // If we have a mid, use that for the content name instead.
    var mid = parsers.findLine('a=mid:', lines);
    if (mid) {
        content.name = mid.substr(6);
    }

    if (parsers.findLine('a=sendrecv', lines, sessionLines)) {
        content.senders = 'both';
    } else if (parsers.findLine('a=sendonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].sendonly;
    } else if (parsers.findLine('a=recvonly', lines, sessionLines)) {
        content.senders = SENDERS[role][direction].recvonly;
    } else if (parsers.findLine('a=inactive', lines, sessionLines)) {
        content.senders = 'none';
    }

    if (desc.descType == 'rtp') {
        var bandwidth = parsers.findLine('b=', lines);
        if (bandwidth) {
            desc.bandwidth = parsers.bandwidth(bandwidth);
        }

        var ssrc = parsers.findLine('a=ssrc:', lines);
        if (ssrc) {
            desc.ssrc = ssrc.substr(7).split(' ')[0];
        }

        var rtpmapLines = parsers.findLines('a=rtpmap:', lines);
        rtpmapLines.forEach(function (line) {
            var payload = parsers.rtpmap(line);
            payload.parameters = [];
            payload.feedback = [];

            var fmtpLines = parsers.findLines('a=fmtp:' + payload.id, lines);
            // There should only be one fmtp line per payload
            fmtpLines.forEach(function (line) {
                payload.parameters = parsers.fmtp(line);
            });

            var fbLines = parsers.findLines('a=rtcp-fb:' + payload.id, lines);
            fbLines.forEach(function (line) {
                payload.feedback.push(parsers.rtcpfb(line));
            });

            desc.payloads.push(payload);
        });

        var cryptoLines = parsers.findLines('a=crypto:', lines, sessionLines);
        cryptoLines.forEach(function (line) {
            desc.encryption.push(parsers.crypto(line));
        });

        if (parsers.findLine('a=rtcp-mux', lines)) {
            desc.mux = true;
        }

        var fbLines = parsers.findLines('a=rtcp-fb:*', lines);
        fbLines.forEach(function (line) {
            desc.feedback.push(parsers.rtcpfb(line));
        });

        var extLines = parsers.findLines('a=extmap:', lines);
        extLines.forEach(function (line) {
            var ext = parsers.extmap(line);

            ext.senders = SENDERS[role][direction][ext.senders];

            desc.headerExtensions.push(ext);
        });

        var ssrcGroupLines = parsers.findLines('a=ssrc-group:', lines);
        desc.sourceGroups = parsers.sourceGroups(ssrcGroupLines || []);

        var ssrcLines = parsers.findLines('a=ssrc:', lines);
        desc.sources = parsers.sources(ssrcLines || []);

        if (parsers.findLine('a=x-google-flag:conference', lines, sessionLines)) {
            desc.googConferenceFlag = true;
        }
    }

    // transport specific attributes
    var fingerprintLines = parsers.findLines('a=fingerprint:', lines, sessionLines);
    var setup = parsers.findLine('a=setup:', lines, sessionLines);
    fingerprintLines.forEach(function (line) {
        var fp = parsers.fingerprint(line);
        if (setup) {
            fp.setup = setup.substr(8);
        }
        trans.fingerprints.push(fp);
    });

    var ufragLine = parsers.findLine('a=ice-ufrag:', lines, sessionLines);
    var pwdLine = parsers.findLine('a=ice-pwd:', lines, sessionLines);
    if (ufragLine && pwdLine) {
        trans.ufrag = ufragLine.substr(12);
        trans.pwd = pwdLine.substr(10);
        trans.candidates = [];

        var candidateLines = parsers.findLines('a=candidate:', lines, sessionLines);
        candidateLines.forEach(function (line) {
            trans.candidates.push(exports.toCandidateJSON(line));
        });
    }

    if (desc.descType == 'datachannel') {
        var sctpmapLines = parsers.findLines('a=sctpmap:', lines);
        sctpmapLines.forEach(function (line) {
            var sctp = parsers.sctpmap(line);
            trans.sctp.push(sctp);
        });
    }

    return content;
};

exports.toCandidateJSON = function (line) {
    var candidate = parsers.candidate(line.split('\r\n')[0]);
    candidate.id = (idCounter++).toString(36).substr(0, 12);
    return candidate;
};

},{"./parsers":390,"./senders":391}],393:[function(require,module,exports){
var SENDERS = require('./senders');


exports.toSessionSDP = function (session, opts) {
    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';
    var sid = opts.sid || session.sid || Date.now();
    var time = opts.time || Date.now();

    var sdp = [
        'v=0',
        'o=- ' + sid + ' ' + time + ' IN IP4 0.0.0.0',
        's=-',
        't=0 0'
    ];

    var groups = session.groups || [];
    groups.forEach(function (group) {
        sdp.push('a=group:' + group.semantics + ' ' + group.contents.join(' '));
    });

    var contents = session.contents || [];
    contents.forEach(function (content) {
        sdp.push(exports.toMediaSDP(content, opts));
    });

    return sdp.join('\r\n') + '\r\n';
};

exports.toMediaSDP = function (content, opts) {
    var sdp = [];

    var role = opts.role || 'initiator';
    var direction = opts.direction || 'outgoing';

    var desc = content.description;
    var transport = content.transport;
    var payloads = desc.payloads || [];
    var fingerprints = (transport && transport.fingerprints) || [];

    var mline = [];
    if (desc.descType == 'datachannel') {
        mline.push('application');
        mline.push('1');
        mline.push('DTLS/SCTP');
        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                mline.push(map.number);
            });
        }
    } else {
        mline.push(desc.media);
        mline.push('1');
        if ((desc.encryption && desc.encryption.length > 0) || (fingerprints.length > 0)) {
            mline.push('RTP/SAVPF');
        } else {
            mline.push('RTP/AVPF');
        }
        payloads.forEach(function (payload) {
            mline.push(payload.id);
        });
    }


    sdp.push('m=' + mline.join(' '));

    sdp.push('c=IN IP4 0.0.0.0');
    if (desc.bandwidth && desc.bandwidth.type && desc.bandwidth.bandwidth) {
        sdp.push('b=' + desc.bandwidth.type + ':' + desc.bandwidth.bandwidth);
    }
    if (desc.descType == 'rtp') {
        sdp.push('a=rtcp:1 IN IP4 0.0.0.0');
    }

    if (transport) {
        if (transport.ufrag) {
            sdp.push('a=ice-ufrag:' + transport.ufrag);
        }
        if (transport.pwd) {
            sdp.push('a=ice-pwd:' + transport.pwd);
        }

        var pushedSetup = false;
        fingerprints.forEach(function (fingerprint) {
            sdp.push('a=fingerprint:' + fingerprint.hash + ' ' + fingerprint.value);
            if (fingerprint.setup && !pushedSetup) {
                sdp.push('a=setup:' + fingerprint.setup);
            }
        });

        if (transport.sctp) {
            transport.sctp.forEach(function (map) {
                sdp.push('a=sctpmap:' + map.number + ' ' + map.protocol + ' ' + map.streams);
            });
        }
    }

    if (desc.descType == 'rtp') {
        sdp.push('a=' + (SENDERS[role][direction][content.senders] || 'sendrecv'));
    }
    sdp.push('a=mid:' + content.name);

    if (desc.mux) {
        sdp.push('a=rtcp-mux');
    }

    var encryption = desc.encryption || [];
    encryption.forEach(function (crypto) {
        sdp.push('a=crypto:' + crypto.tag + ' ' + crypto.cipherSuite + ' ' + crypto.keyParams + (crypto.sessionParams ? ' ' + crypto.sessionParams : ''));
    });
    if (desc.googConferenceFlag) {
        sdp.push('a=x-google-flag:conference');
    }

    payloads.forEach(function (payload) {
        var rtpmap = 'a=rtpmap:' + payload.id + ' ' + payload.name + '/' + payload.clockrate;
        if (payload.channels && payload.channels != '1') {
            rtpmap += '/' + payload.channels;
        }
        sdp.push(rtpmap);

        if (payload.parameters && payload.parameters.length) {
            var fmtp = ['a=fmtp:' + payload.id];
            var parameters = [];
            payload.parameters.forEach(function (param) {
                parameters.push((param.key ? param.key + '=' : '') + param.value);
            });
            fmtp.push(parameters.join(';'));
            sdp.push(fmtp.join(' '));
        }

        if (payload.feedback) {
            payload.feedback.forEach(function (fb) {
                if (fb.type === 'trr-int') {
                    sdp.push('a=rtcp-fb:' + payload.id + ' trr-int ' + fb.value ? fb.value : '0');
                } else {
                    sdp.push('a=rtcp-fb:' + payload.id + ' ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
                }
            });
        }
    });

    if (desc.feedback) {
        desc.feedback.forEach(function (fb) {
            if (fb.type === 'trr-int') {
                sdp.push('a=rtcp-fb:* trr-int ' + fb.value ? fb.value : '0');
            } else {
                sdp.push('a=rtcp-fb:* ' + fb.type + (fb.subtype ? ' ' + fb.subtype : ''));
            }
        });
    }

    var hdrExts = desc.headerExtensions || [];
    hdrExts.forEach(function (hdr) {
        sdp.push('a=extmap:' + hdr.id + (hdr.senders ? '/' + SENDERS[role][direction][hdr.senders] : '') + ' ' + hdr.uri);
    });

    var ssrcGroups = desc.sourceGroups || [];
    ssrcGroups.forEach(function (ssrcGroup) {
        sdp.push('a=ssrc-group:' + ssrcGroup.semantics + ' ' + ssrcGroup.sources.join(' '));
    });

    var ssrcs = desc.sources || [];
    ssrcs.forEach(function (ssrc) {
        for (var i = 0; i < ssrc.parameters.length; i++) {
            var param = ssrc.parameters[i];
            sdp.push('a=ssrc:' + (ssrc.ssrc || desc.ssrc) + ' ' + param.key + (param.value ? (':' + param.value) : ''));
        }
    });

    var candidates = transport.candidates || [];
    candidates.forEach(function (candidate) {
        sdp.push(exports.toCandidateSDP(candidate));
    });

    return sdp.join('\r\n');
};

exports.toCandidateSDP = function (candidate) {
    var sdp = [];

    sdp.push(candidate.foundation);
    sdp.push(candidate.component);
    sdp.push(candidate.protocol.toUpperCase());
    sdp.push(candidate.priority);
    sdp.push(candidate.ip);
    sdp.push(candidate.port);

    var type = candidate.type;
    sdp.push('typ');
    sdp.push(type);
    if (type === 'srflx' || type === 'prflx' || type === 'relay') {
        if (candidate.relAddr && candidate.relPort) {
            sdp.push('raddr');
            sdp.push(candidate.relAddr);
            sdp.push('rport');
            sdp.push(candidate.relPort);
        }
    }
    if (candidate.tcpType && candidate.protocol.toUpperCase() == 'TCP') {
        sdp.push('tcptype');
        sdp.push(candidate.tcpType);
    }

    sdp.push('generation');
    sdp.push(candidate.generation || '0');

    // FIXME: apparently this is wrong per spec
    // but then, we need this when actually putting this into
    // SDP so it's going to stay.
    // decision needs to be revisited when browsers dont
    // accept this any longer
    return 'a=candidate:' + sdp.join(' ');
};

},{"./senders":391}],394:[function(require,module,exports){
// based on https://github.com/ESTOS/strophe.jingle/
// adds wildemitter support
var util = require('util');
var webrtc = require('webrtcsupport');
var WildEmitter = require('wildemitter');

function dumpSDP(description) {
    return {
        type: description.type,
        sdp: description.sdp
    };
}

function dumpStream(stream) {
    var info = {
        label: stream.id,
    };
    if (stream.getAudioTracks().length) {
        info.audio = stream.getAudioTracks().map(function (track) {
            return track.id;
        });
    }
    if (stream.getVideoTracks().length) {
        info.video = stream.getVideoTracks().map(function (track) {
            return track.id;
        });
    }
    return info;
}

function TraceablePeerConnection(config, constraints) {
    var self = this;
    WildEmitter.call(this);

    this.peerconnection = new webrtc.PeerConnection(config, constraints);

    this.trace = function (what, info) {
        self.emit('PeerConnectionTrace', {
            time: new Date(),
            type: what,
            value: info || ""
        });
    };

    this.onicecandidate = null;
    this.peerconnection.onicecandidate = function (event) {
        self.trace('onicecandidate', event.candidate);
        if (self.onicecandidate !== null) {
            self.onicecandidate(event);
        }
    };
    this.onaddstream = null;
    this.peerconnection.onaddstream = function (event) {
        self.trace('onaddstream', dumpStream(event.stream));
        if (self.onaddstream !== null) {
            self.onaddstream(event);
        }
    };
    this.onremovestream = null;
    this.peerconnection.onremovestream = function (event) {
        self.trace('onremovestream', dumpStream(event.stream));
        if (self.onremovestream !== null) {
            self.onremovestream(event);
        }
    };
    this.onsignalingstatechange = null;
    this.peerconnection.onsignalingstatechange = function (event) {
        self.trace('onsignalingstatechange', self.signalingState);
        if (self.onsignalingstatechange !== null) {
            self.onsignalingstatechange(event);
        }
    };
    this.oniceconnectionstatechange = null;
    this.peerconnection.oniceconnectionstatechange = function (event) {
        self.trace('oniceconnectionstatechange', self.iceConnectionState);
        if (self.oniceconnectionstatechange !== null) {
            self.oniceconnectionstatechange(event);
        }
    };
    this.onnegotiationneeded = null;
    this.peerconnection.onnegotiationneeded = function (event) {
        self.trace('onnegotiationneeded');
        if (self.onnegotiationneeded !== null) {
            self.onnegotiationneeded(event);
        }
    };
    self.ondatachannel = null;
    this.peerconnection.ondatachannel = function (event) {
        self.trace('ondatachannel', event);
        if (self.ondatachannel !== null) {
            self.ondatachannel(event);
        }
    };
    this.getLocalStreams = this.peerconnection.getLocalStreams.bind(this.peerconnection);
    this.getRemoteStreams = this.peerconnection.getRemoteStreams.bind(this.peerconnection);
}

util.inherits(TraceablePeerConnection, WildEmitter);

Object.defineProperty(TraceablePeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.peerconnection.signalingState;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.peerconnection.iceConnectionState;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'localDescription', {
    get: function () {
        return this.peerconnection.localDescription;
    }
});

Object.defineProperty(TraceablePeerConnection.prototype, 'remoteDescription', {
    get: function () {
        return this.peerconnection.remoteDescription;
    }
});

TraceablePeerConnection.prototype.addStream = function (stream) {
    this.trace('addStream', dumpStream(stream));
    this.peerconnection.addStream(stream);
};

TraceablePeerConnection.prototype.removeStream = function (stream) {
    this.trace('removeStream', dumpStream(stream));
    this.peerconnection.removeStream(stream);
};

TraceablePeerConnection.prototype.createDataChannel = function (label, opts) {
    this.trace('createDataChannel', label, opts);
    return this.peerconnection.createDataChannel(label, opts);
};

TraceablePeerConnection.prototype.setLocalDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setLocalDescription', dumpSDP(description));
    this.peerconnection.setLocalDescription(description,
        function () {
            self.trace('setLocalDescriptionOnSuccess');
            successCallback();
        },
        function (err) {
            self.trace('setLocalDescriptionOnFailure', err);
            failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.setRemoteDescription = function (description, successCallback, failureCallback) {
    var self = this;
    this.trace('setRemoteDescription', dumpSDP(description));
    this.peerconnection.setRemoteDescription(description,
        function () {
            self.trace('setRemoteDescriptionOnSuccess');
            successCallback();
        },
        function (err) {
            self.trace('setRemoteDescriptionOnFailure', err);
            failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.close = function () {
    this.trace('stop');
    if (this.statsinterval !== null) {
        window.clearInterval(this.statsinterval);
        this.statsinterval = null;
    }
    if (this.peerconnection.signalingState != 'closed') {
        this.peerconnection.close();
    }
};

TraceablePeerConnection.prototype.createOffer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createOffer', constraints);
    this.peerconnection.createOffer(
        function (offer) {
            self.trace('createOfferOnSuccess', dumpSDP(offer));
            successCallback(offer);
        },
        function (err) {
            self.trace('createOfferOnFailure', err);
            failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.createAnswer = function (successCallback, failureCallback, constraints) {
    var self = this;
    this.trace('createAnswer', constraints);
    this.peerconnection.createAnswer(
        function (answer) {
            self.trace('createAnswerOnSuccess', dumpSDP(answer));
            successCallback(answer);
        },
        function (err) {
            self.trace('createAnswerOnFailure', err);
            failureCallback(err);
        },
        constraints
    );
};

TraceablePeerConnection.prototype.addIceCandidate = function (candidate, successCallback, failureCallback) {
    var self = this;
    this.trace('addIceCandidate', candidate);
    this.peerconnection.addIceCandidate(candidate,
        function () {
            //self.trace('addIceCandidateOnSuccess');
            if (successCallback) successCallback();
        },
        function (err) {
            self.trace('addIceCandidateOnFailure', err);
            if (failureCallback) failureCallback(err);
        }
    );
};

TraceablePeerConnection.prototype.getStats = function (callback, errback) {
    if (navigator.mozGetUserMedia) {
        this.peerconnection.getStats(null, callback, errback);
    } else {
        this.peerconnection.getStats(callback);
    }
};

module.exports = TraceablePeerConnection;

},{"util":165,"webrtcsupport":405,"wildemitter":449}],395:[function(require,module,exports){
var _ = require('underscore');
var util = require('util');
var webrtc = require('webrtcsupport');
var SJJ = require('sdp-jingle-json');
var WildEmitter = require('wildemitter');
var peerconn = require('traceablepeerconnection');

function PeerConnection(config, constraints) {
    var self = this;
    var item;
    WildEmitter.call(this);

    config = config || {};
    config.iceServers = config.iceServers || [];

    // make sure this only gets enabled in Google Chrome
    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableChromeNativeSimulcast = false;
    if (constraints && constraints.optional &&
            webrtc.prefix === 'webkit' &&
            navigator.appVersion.match(/Chromium\//) === null) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableChromeNativeSimulcast) {
                self.enableChromeNativeSimulcast = true;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    this.enableMultiStreamHacks = false;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.enableMultiStreamHacks) {
                self.enableMultiStreamHacks = true;
            }
        });
    }
    // EXPERIMENTAL FLAG, might get removed without notice
    this.restrictBandwidth = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetRestrictBandwidth) {
                self.restrictBandwidth = constraint.andyetRestrictBandwidth;
            }
        });
    }

    // EXPERIMENTAL FLAG, might get removed without notice
    // bundle up ice candidates, only works for jingle mode
    // number > 0 is the delay to wait for additional candidates
    // ~20ms seems good
    this.batchIceCandidates = 0;
    if (constraints && constraints.optional) {
        constraints.optional.forEach(function (constraint, idx) {
            if (constraint.andyetBatchIce) {
                self.batchIceCandidates = constraint.andyetBatchIce;
            }
        });
    }
    this.batchedIceCandidates = [];


    this.pc = new peerconn(config, constraints);

    this.getLocalStreams = this.pc.getLocalStreams.bind(this.pc);
    this.getRemoteStreams = this.pc.getRemoteStreams.bind(this.pc);
    this.addStream = this.pc.addStream.bind(this.pc);
    this.removeStream = this.pc.removeStream.bind(this.pc);

    // proxy events 
    this.pc.on('*', function () {
        self.emit.apply(self, arguments);
    });

    // proxy some events directly
    this.pc.onremovestream = this.emit.bind(this, 'removeStream');
    this.pc.onaddstream = this.emit.bind(this, 'addStream');
    this.pc.onnegotiationneeded = this.emit.bind(this, 'negotiationNeeded');
    this.pc.oniceconnectionstatechange = this.emit.bind(this, 'iceConnectionStateChange');
    this.pc.onsignalingstatechange = this.emit.bind(this, 'signalingStateChange');

    // handle ice candidate and data channel events
    this.pc.onicecandidate = this._onIce.bind(this);
    this.pc.ondatachannel = this._onDataChannel.bind(this);

    this.localDescription = {
        contents: []
    };
    this.remoteDescription = {
        contents: []
    };

    this.config = {
        debug: false,
        ice: {},
        sid: '',
        isInitiator: true,
        sdpSessionID: Date.now(),
        useJingle: false
    };

    // apply our config
    for (item in config) {
        this.config[item] = config[item];
    }

    if (this.config.debug) {
        this.on('*', function (eventName, event) {
            var logger = config.logger || console;
            logger.log('PeerConnection event:', arguments);
        });
    }
    this.hadLocalStunCandidate = false;
    this.hadRemoteStunCandidate = false;
    this.hadLocalRelayCandidate = false;
    this.hadRemoteRelayCandidate = false;

    this.hadLocalIPv6Candidate = false;
    this.hadRemoteIPv6Candidate = false;

    // keeping references for all our data channels
    // so they dont get garbage collected
    // can be removed once the following bugs have been fixed
    // https://crbug.com/405545 
    // https://bugzilla.mozilla.org/show_bug.cgi?id=964092
    // to be filed for opera
    this._remoteDataChannels = [];
    this._localDataChannels = [];
}

util.inherits(PeerConnection, WildEmitter);

Object.defineProperty(PeerConnection.prototype, 'signalingState', {
    get: function () {
        return this.pc.signalingState;
    }
});
Object.defineProperty(PeerConnection.prototype, 'iceConnectionState', {
    get: function () {
        return this.pc.iceConnectionState;
    }
});

PeerConnection.prototype._role = function () {
    return this.isInitiator ? 'initiator' : 'responder';
};

// Add a stream to the peer connection object
PeerConnection.prototype.addStream = function (stream) {
    this.localStream = stream;
    this.pc.addStream(stream);
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkLocalCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadLocalStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadLocalRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadLocalIPv6Candidate = true;
    }
};

// helper function to check if a remote candidate is a stun/relay
// candidate or an ipv6 candidate
PeerConnection.prototype._checkRemoteCandidate = function (candidate) {
    var cand = SJJ.toCandidateJSON(candidate);
    if (cand.type == 'srflx') {
        this.hadRemoteStunCandidate = true;
    } else if (cand.type == 'relay') {
        this.hadRemoteRelayCandidate = true;
    }
    if (cand.ip.indexOf(':') != -1) {
        this.hadRemoteIPv6Candidate = true;
    }
};


// Init and add ice candidate object with correct constructor
PeerConnection.prototype.processIce = function (update, cb) {
    cb = cb || function () {};
    var self = this;

    // ignore any added ice candidates to avoid errors. why does the
    // spec not do this?
    if (this.pc.signalingState === 'closed') return cb();

    if (update.contents || (update.jingle && update.jingle.contents)) {
        var contentNames = _.pluck(this.remoteDescription.contents, 'name');
        var contents = update.contents || update.jingle.contents;

        contents.forEach(function (content) {
            var transport = content.transport || {};
            var candidates = transport.candidates || [];
            var mline = contentNames.indexOf(content.name);
            var mid = content.name;

            candidates.forEach(
                function (candidate) {
                var iceCandidate = SJJ.toCandidateSDP(candidate) + '\r\n';
                self.pc.addIceCandidate(
                    new webrtc.IceCandidate({
                        candidate: iceCandidate,
                        sdpMLineIndex: mline,
                        sdpMid: mid
                    }), function () {
                        // well, this success callback is pretty meaningless
                    },
                    function (err) {
                        self.emit('error', err);
                    }
                );
                self._checkRemoteCandidate(iceCandidate);
            });
        });
    } else {
        // working around https://code.google.com/p/webrtc/issues/detail?id=3669
        if (update.candidate && update.candidate.candidate.indexOf('a=') !== 0) {
            update.candidate.candidate = 'a=' + update.candidate.candidate;
        }

        self.pc.addIceCandidate(
            new webrtc.IceCandidate(update.candidate),
            function () { },
            function (err) {
                self.emit('error', err);
            }
        );
        self._checkRemoteCandidate(update.candidate.candidate);
    }
    cb();
};

// Generate and emit an offer with the given constraints
PeerConnection.prototype.offer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var mediaConstraints = hasConstraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };
    cb = hasConstraints ? cb : constraints;
    cb = cb || function () {};

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    // Actually generate the offer
    this.pc.createOffer(
        function (offer) {
            self.pc.setLocalDescription(offer,
                function () {
                    var jingle;
                    var expandedOffer = {
                        type: 'offer',
                        sdp: offer.sdp
                    };
                    if (self.config.useJingle) {
                        jingle = SJJ.toSessionJSON(offer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;

                        // Save ICE credentials
                        _.each(jingle.contents, function (content) {
                            var transport = content.transport || {};
                            if (transport.ufrag) {
                                self.config.ice[content.name] = {
                                    ufrag: transport.ufrag,
                                    pwd: transport.pwd
                                };
                            }
                        });

                        expandedOffer.jingle = jingle;
                    }
                    expandedOffer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });

                    self.emit('offer', expandedOffer);
                    cb(null, expandedOffer);
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        mediaConstraints
    );
};


// Process an incoming offer so that ICE may proceed before deciding
// to answer the request.
PeerConnection.prototype.handleOffer = function (offer, cb) {
    cb = cb || function () {};
    var self = this;
    offer.type = 'offer';
    if (offer.jingle) {
        if (this.enableChromeNativeSimulcast) {
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    content.description.googConferenceFlag = true;
                }
            });
        }
        /*
        if (this.enableMultiStreamHacks) {
            // add a mixed video stream as first stream
            offer.jingle.contents.forEach(function (content) {
                if (content.name === 'video') {
                    var sources = content.description.sources || [];
                    if (sources.length === 0 || sources[0].ssrc !== "3735928559") {
                        sources.unshift({
                            ssrc: "3735928559", // 0xdeadbeef
                            parameters: [
                                {
                                    key: "cname",
                                    value: "deadbeef"
                                },
                                {
                                    key: "msid",
                                    value: "mixyourfecintothis please"
                                }
                            ]
                        });
                        content.description.sources = sources;
                    }
                }
            });
        }
        */
        offer.sdp = SJJ.toSessionSDP(offer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = offer.jingle;
    }
    offer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(new webrtc.SessionDescription(offer),
        function () {
            cb();
        },
        cb
    );
};

// Answer an offer with audio only
PeerConnection.prototype.answerAudioOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer without offering to recieve
PeerConnection.prototype.answerBroadcastOnly = function (cb) {
    var mediaConstraints = {
            mandatory: {
                OfferToReceiveAudio: false,
                OfferToReceiveVideo: false
            }
        };
    this._answer(mediaConstraints, cb);
};

// Answer an offer with given constraints default is audio/video
PeerConnection.prototype.answer = function (constraints, cb) {
    var self = this;
    var hasConstraints = arguments.length === 2;
    var callback = hasConstraints ? cb : constraints;
    var mediaConstraints = hasConstraints ? constraints : {
            mandatory: {
                OfferToReceiveAudio: true,
                OfferToReceiveVideo: true
            }
        };

    this._answer(mediaConstraints, callback);
};

// Process an answer
PeerConnection.prototype.handleAnswer = function (answer, cb) {
    cb = cb || function () {};
    var self = this;
    if (answer.jingle) {
        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
            sid: self.config.sdpSessionID,
            role: self._role(),
            direction: 'incoming'
        });
        self.remoteDescription = answer.jingle;
    }
    answer.sdp.split('\r\n').forEach(function (line) {
        if (line.indexOf('a=candidate:') === 0) {
            self._checkRemoteCandidate(line);
        }
    });
    self.pc.setRemoteDescription(
        new webrtc.SessionDescription(answer),
        function () {
            cb(null);
        },
        cb
    );
};

// Close the peer connection
PeerConnection.prototype.close = function () {
    this.pc.close();

    this._localDataChannels = [];
    this._remoteDataChannels = [];

    this.emit('close');
};

// Internal code sharing for various types of answer methods
PeerConnection.prototype._answer = function (constraints, cb) {
    cb = cb || function () {};
    var self = this;
    if (!this.pc.remoteDescription) {
        // the old API is used, call handleOffer
        throw new Error('remoteDescription not set');
    }

    if (this.pc.signalingState === 'closed') return cb('Already closed');

    self.pc.createAnswer(
        function (answer) {
            var sim = [];
            var rtx = [];
            if (self.enableChromeNativeSimulcast) {
                // native simulcast part 1: add another SSRC
                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
                    var hasSimgroup = false;
                    var groups = answer.jingle.contents[1].description.sourceGroups || [];
                    var hasSim = false;
                    groups.forEach(function (group) {
                        if (group.semantics == 'SIM') hasSim = true;
                    });
                    if (!hasSim &&
                        answer.jingle.contents[1].description.sources.length) {
                        var newssrc = JSON.parse(JSON.stringify(answer.jingle.contents[1].description.sources[0]));
                        newssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(newssrc);

                        sim.push(answer.jingle.contents[1].description.sources[0].ssrc);
                        sim.push(newssrc.ssrc);
                        groups.push({
                            semantics: 'SIM',
                            sources: sim
                        });

                        // also create an RTX one for the SIM one
                        var rtxssrc = JSON.parse(JSON.stringify(newssrc));
                        rtxssrc.ssrc = '' + Math.floor(Math.random() * 0xffffffff); // FIXME: look for conflicts
                        answer.jingle.contents[1].description.sources.push(rtxssrc);
                        groups.push({
                            semantics: 'FID',
                            sources: [newssrc.ssrc, rtxssrc.ssrc]
                        });

                        answer.jingle.contents[1].description.sourceGroups = groups;
                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
                            sid: self.config.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                }
            }
            if (self.restrictBandwidth > 0) {
                answer.jingle = SJJ.toSessionJSON(answer.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                if (answer.jingle.contents.length >= 2 && answer.jingle.contents[1].name === 'video') {
                    var content = answer.jingle.contents[1];
                    var hasBw = content.description && content.description.bandwidth;
                    if (!hasBw) {
                        answer.jingle.contents[1].description.bandwidth = { type:'AS', bandwidth: self.restrictBandwidth.toString() };
                        answer.sdp = SJJ.toSessionSDP(answer.jingle, {
                            sid: self.config.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                }
            }
            self.pc.setLocalDescription(answer,
                function () {
                    var expandedAnswer = {
                        type: 'answer',
                        sdp: answer.sdp
                    };
                    if (self.config.useJingle) {
                        var jingle = SJJ.toSessionJSON(answer.sdp, {
                            role: self._role(),
                            direction: 'outgoing'
                        });
                        jingle.sid = self.config.sid;
                        self.localDescription = jingle;
                        expandedAnswer.jingle = jingle;
                    }
                    if (self.enableChromeNativeSimulcast) {
                        // native simulcast part 2: 
                        // signal multiple tracks to the receiver
                        // for anything in the SIM group
                        if (!expandedAnswer.jingle) {
                            expandedAnswer.jingle = SJJ.toSessionJSON(answer.sdp, {
                                role: self._role(),
                                direction: 'outgoing'
                            });
                        }
                        var groups = expandedAnswer.jingle.contents[1].description.sourceGroups || [];
                        expandedAnswer.jingle.contents[1].description.sources.forEach(function (source, idx) {
                            // the floor idx/2 is a hack that relies on a particular order
                            // of groups, alternating between sim and rtx
                            source.parameters = source.parameters.map(function (parameter) {
                                if (parameter.key === 'msid') {
                                    parameter.value += '-' + Math.floor(idx / 2);
                                }
                                return parameter;
                            });
                        });
                        expandedAnswer.sdp = SJJ.toSessionSDP(expandedAnswer.jingle, {
                            sid: self.sdpSessionID,
                            role: self._role(),
                            direction: 'outgoing'
                        });
                    }
                    expandedAnswer.sdp.split('\r\n').forEach(function (line) {
                        if (line.indexOf('a=candidate:') === 0) {
                            self._checkLocalCandidate(line);
                        }
                    });
                    self.emit('answer', expandedAnswer);
                    cb(null, expandedAnswer);
                },
                function (err) {
                    self.emit('error', err);
                    cb(err);
                }
            );
        },
        function (err) {
            self.emit('error', err);
            cb(err);
        },
        constraints
    );
};

// Internal method for emitting ice candidates on our peer object
PeerConnection.prototype._onIce = function (event) {
    var self = this;
    if (event.candidate) {
        var ice = event.candidate;

        var expandedCandidate = {
            candidate: event.candidate
        };
        this._checkLocalCandidate(ice.candidate);

        var cand = SJJ.toCandidateJSON(ice.candidate);
        if (self.config.useJingle) {
            if (!ice.sdpMid) { // firefox doesn't set this
                ice.sdpMid = self.localDescription.contents[ice.sdpMLineIndex].name;
            }
            if (!self.config.ice[ice.sdpMid]) {
                var jingle = SJJ.toSessionJSON(self.pc.localDescription.sdp, {
                    role: self._role(),
                    direction: 'outgoing'
                });
                _.each(jingle.contents, function (content) {
                    var transport = content.transport || {};
                    if (transport.ufrag) {
                        self.config.ice[content.name] = {
                            ufrag: transport.ufrag,
                            pwd: transport.pwd
                        };
                    }
                });
            }
            expandedCandidate.jingle = {
                contents: [{
                    name: ice.sdpMid,
                    creator: self._role(),
                    transport: {
                        transType: 'iceUdp',
                        ufrag: self.config.ice[ice.sdpMid].ufrag,
                        pwd: self.config.ice[ice.sdpMid].pwd,
                        candidates: [
                            cand
                        ]
                    }
                }]
            };
            if (self.batchIceCandidates > 0) {
                if (self.batchedIceCandidates.length === 0) {
                    window.setTimeout(function () {
                        var contents = {};
                        self.batchedIceCandidates.forEach(function (content) {
                            content = content.contents[0];
                            if (!contents[content.name]) contents[content.name] = content;
                            contents[content.name].transport.candidates.push(content.transport.candidates[0]);
                        });
                        var newCand = { 
                            jingle: {
                                contents: []
                            }
                        };
                        Object.keys(contents).forEach(function (name) {
                            newCand.jingle.contents.push(contents[name]);
                        });
                        self.batchedIceCandidates = [];
                        self.emit('ice', newCand);
                    }, self.batchIceCandidates);
                }
                self.batchedIceCandidates.push(expandedCandidate.jingle);
                return;
            }

        }
        this.emit('ice', expandedCandidate);
    } else {
        this.emit('endOfCandidates');
    }
};

// Internal method for processing a new data channel being added by the
// other peer.
PeerConnection.prototype._onDataChannel = function (event) {
    // make sure we keep a reference so this doesn't get garbage collected
    var channel = event.channel;
    this._remoteDataChannels.push(channel);

    this.emit('addChannel', channel);
};

// Create a data channel spec reference:
// http://dev.w3.org/2011/webrtc/editor/webrtc.html#idl-def-RTCDataChannelInit
PeerConnection.prototype.createDataChannel = function (name, opts) {
    var channel = this.pc.createDataChannel(name, opts);

    // make sure we keep a reference so this doesn't get garbage collected
    this._localDataChannels.push(channel);

    return channel;
};

// a wrapper around getStats which hides the differences (where possible)
PeerConnection.prototype.getStats = function (cb) {
    if (webrtc.prefix === 'moz') {
        this.pc.getStats(
            function (res) {
                var items = [];
                for (var result in res) {
                    if (typeof res[result] === 'object') {
                        items.push(res[result]);
                    }
                }
                cb(null, items);
            },
            cb
        );
    } else {
        this.pc.getStats(function (res) {
            var items = [];
            res.result().forEach(function (result) {
                var item = {};
                result.names().forEach(function (name) {
                    item[name] = result.stat(name);
                });
                item.id = result.id;
                item.type = result.type;
                item.timestamp = result.timestamp;
                items.push(item);
            });
            cb(null, items);
        });
    }
};

module.exports = PeerConnection;

},{"sdp-jingle-json":389,"traceablepeerconnection":394,"underscore":448,"util":165,"webrtcsupport":405,"wildemitter":449}],396:[function(require,module,exports){
var util = require('util');
var extend = require('extend-object');
var BaseSession = require('jingle-session');
var RTCPeerConnection = require('rtcpeerconnection');


function filterContentSources(content, stream) {
    delete content.transport;
    delete content.description.payloads;
    if (content.description.sources) {
        content.description.sources = content.description.sources.filter(function (source) {
            return stream.id === source.parameters[1].value.split(' ')[0];
        });
    }
}

function filterUnusedLabels(content) {
    // Remove mslabel and label ssrc-specific attributes
    var sources = content.description.sources || [];
    sources.forEach(function (source) {
        source.parameters = source.parameters.filter(function (parameter) {
            return !(parameter.key === 'mslabel' || parameter.key === 'label');
        });
    });
}


function MediaSession(opts) {
    BaseSession.call(this, opts);

    this.pc = new RTCPeerConnection({
        iceServers: opts.iceServers || [],
        useJingle: true
    }, opts.constraints || {});

    this.pc.on('ice', this.onIceCandidate.bind(this));
    this.pc.on('iceConnectionStateChange', this.onIceStateChange.bind(this));
    this.pc.on('addStream', this.onAddStream.bind(this));
    this.pc.on('removeStream', this.onRemoveStream.bind(this));

    this._ringing = false;
}


util.inherits(MediaSession, BaseSession);


Object.defineProperties(MediaSession.prototype, {
    ringing: {
        get: function () {
            return this._ringing;
        },
        set: function (value) {
            if (value !== this._ringing) {
                this._ringing = value;
                this.emit('change:ringing', value);
            }
        }
    },
    streams: {
        get: function () {
            return this.pc.getRemoteStreams();
        }
    }
});


MediaSession.prototype = extend(MediaSession.prototype, {

    // ----------------------------------------------------------------
    // Session control methods
    // ----------------------------------------------------------------

    start: function (constraints, next) {
        var self = this;
        this.state = 'pending';

        next = next || function () {};

        this.pc.isInitiator = true;
        this.pc.offer(constraints, function (err, offer) {
            if (err) {
                self._log('error', 'Could not create WebRTC offer', err);
                return self.end('failed-application', true);
            }

            // a workaround for missing a=sendonly
            // https://code.google.com/p/webrtc/issues/detail?id=1553
            if (constraints && constraints.mandatory) {
                offer.jingle.contents.forEach(function (content) {
                    var mediaType = content.description.media;

                    if (!content.description || content.description.descType !== 'rtp') {
                        return;
                    }

                    if (!constraints.mandatory.OfferToReceiveAudio && mediaType === 'audio') {
                        content.senders = 'initiator';
                    }

                    if (!constraints.mandatory.OfferToReceiveVideo && mediaType === 'video') {
                        content.senders = 'initiator';
                    }
                });
            }

            offer.jingle.contents.forEach(filterUnusedLabels);

            self.send('session-initiate', offer.jingle);

            next();
        });
    },

    accept: function (next) {
        var self = this;

        next = next || function () {};

        this._log('info', 'Accepted incoming session');

        this.state = 'active';

        this.pc.answer(function (err, answer) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer', err);
                return self.end('failed-application');
            }

            answer.jingle.contents.forEach(filterUnusedLabels);

            self.send('session-accept', answer.jingle);

            next();
        });
    },

    end: function (reason, silent) {
        var self = this;
        this.pc.close();
        this.streams.forEach(function (stream) {
            self.onRemoveStream({stream: stream});
        });
        BaseSession.prototype.end.call(this, reason, silent);
    },

    ring: function () {
        this._log('info', 'Ringing on incoming session');
        this.ringing = true;
        this.send('session-info', {ringing: true});
    },

    mute: function (creator, name) {
        this._log('info', 'Muting', name);

        this.send('session-info', {
            mute: {
                creator: creator,
                name: name
            }
        });
    },

    unmute: function (creator, name) {
        this._log('info', 'Unmuting', name);
        this.send('session-info', {
            unmute: {
                creator: creator,
                name: name
            }
        });
    },

    hold: function () {
        this._log('info', 'Placing on hold');
        this.send('session-info', {hold: true});
    },

    resume: function () {
        this._log('info', 'Resuming from hold');
        this.send('session-info', {active: true});
    },

    // ----------------------------------------------------------------
    // Stream control methods
    // ----------------------------------------------------------------

    addStream: function (stream, renegotiate, cb) {
        var self = this;

        cb = cb || function () {};

        this.pc.addStream(stream);

        if (!renegotiate) {
            return;
        }

        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create offer for adding new stream');
                return cb(err);
            }
            self.pc.answer(function (err, answer) {
                if (err) {
                    self._log('error', 'Could not create answer for adding new stream');
                    return cb(err);
                }
                answer.jingle.contents.forEach(function (content) {
                    filterContentSources(content, stream);
                });

                self.send('source-add', answer.jingle);
                cb();
            });
        });
    },

    addStream2: function (stream, cb) {
        this.addStream(stream, true, cb);
    },

    removeStream: function (stream, renegotiate, cb) {
        var self = this;

        cb = cb || function () {};

        if (!renegotiate) {
            this.pc.removeStream(stream);
            return;
        }

        var desc = this.pc.localDescription;
        desc.contents.forEach(function (content) {
            filterContentSources(content, stream);
        });

        this.send('source-remove', desc);
        this.pc.removeStream(stream);

        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process offer for removing stream');
                return cb(err);
            }
            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Could not process answer for removing stream');
                    return cb(err);
                }
                cb();
            });
        });
    },

    removeStream2: function (stream, cb) {
        this.removeStream(stream, true, cb);
    },

    switchStream: function (oldStream, newStream, cb) {
        var self = this;

        cb = cb || function () {};

        var desc = this.pc.localDescription;
        desc.contents.forEach(function (content) {
            delete content.transport;
            delete content.description.payloads;
        });

        this.pc.removeStream(oldStream);
        this.send('source-remove', desc);

        var audioTracks = oldStream.getAudioTracks();
        if (audioTracks.length) {
            newStream.addTrack(audioTracks[0]);
        }

        this.pc.addStream(newStream);
        this.pc.handleOffer({
            type: 'offer',
            jingle: this.pc.remoteDescription
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process offer for switching streams');
                return cb(err);
            }
            self.pc.answer(function (err, answer) {
                if (err) {
                    self._log('error', 'Could not process answer for switching streams');
                    return cb(err);
                }
                answer.jingle.contents.forEach(function (content) {
                    delete content.transport;
                    delete content.description.payloads;
                });
                self.send('source-add', answer.jingle);
                cb();
            });
        });
    },

    // ----------------------------------------------------------------
    // ICE action handers
    // ----------------------------------------------------------------

    onIceCandidate: function (candidate) {
        this._log('info', 'Discovered new ICE candidate', candidate.jingle);
        this.send('transport-info', candidate.jingle);
    },

    onIceStateChange: function () {
        switch (this.pc.iceConnectionState) {
            case 'checking':
                this.connectionState = 'connecting';
                break;
            case 'completed':
            case 'connected':
                this.connectionState = 'connected';
                break;
            case 'disconnected':
                if (this.pc.signalingState === 'stable') {
                    this.connectionState = 'interrupted';
                } else {
                    this.connectionState = 'disconnected';
                }
                break;
            case 'failed':
                this.connectionState = 'failed';
                this.end('failed-transport');
                break;
            case 'closed':
                this.connectionState = 'disconnected';
                break;
        }
    },

    // ----------------------------------------------------------------
    // Stream event handlers
    // ----------------------------------------------------------------

    onAddStream: function (event) {
        this._log('info', 'Stream added');
        this.emit('peerStreamAdded', this, event.stream);
    },

    onRemoveStream: function (event) {
        this._log('info', 'Stream removed');
        this.emit('peerStreamRemoved', this, event.stream);
    },

    // ----------------------------------------------------------------
    // Jingle action handers
    // ----------------------------------------------------------------

    onSessionInitiate: function (changes, cb) {
        var self = this;

        this._log('info', 'Initiating incoming session');

        this.state = 'pending';

        this.pc.isInitiator = false;
        this.pc.handleOffer({
            type: 'offer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not create WebRTC answer');
                return cb({condition: 'general-error'});
            }
            cb();
        });
    },

    onSessionAccept: function (changes, cb) {
        var self = this;

        this.state = 'active';
        this.pc.handleAnswer({
            type: 'answer',
            jingle: changes
        }, function (err) {
            if (err) {
                self._log('error', 'Could not process WebRTC answer');
                return cb({condition: 'general-error'});
            }
            self.emit('accepted', self);
            cb();
        });
    },

    onSessionTerminate: function (changes, cb) {
        var self = this;

        this._log('info', 'Terminating session');
        this.pc.close();
        this.streams.forEach(function (stream) {
            self.onRemoveStream({stream: stream});
        });
        BaseSession.prototype.end.call(this, changes.reason, true);

        cb();
    },

    onSessionInfo: function (info, cb) {
        if (info.ringing) {
            this._log('info', 'Outgoing session is ringing');
            this.ringing = true;
            this.emit('ringing', this);
            return cb();
        }

        if (info.hold) {
            this._log('info', 'On hold');
            this.emit('hold', this);
            return cb();
        }

        if (info.active) {
            this._log('info', 'Resuming from hold');
            this.emit('resumed', this);
            return cb();
        }

        if (info.mute) {
            this._log('info', 'Muting', info.mute);
            this.emit('mute', this, info.mute);
            return cb();
        }

        if (info.unmute) {
            this._log('info', 'Unmuting', info.unmute);
            this.emit('unmute', this, info.unmute);
            return cb();
        }

        cb();
    },

    onTransportInfo: function (changes, cb) {
        this.pc.processIce(changes, function () {
            cb();
        });
    },

    onSourceAdd: function (changes, cb) {
        var self = this;
        this._log('info', 'Adding new stream source');

        var newDesc = this.pc.remoteDescription;
        this.pc.remoteDescription.contents.forEach(function (content, idx) {
            var desc = content.description;
            var ssrcs = desc.sources || [];
            var groups = desc.sourceGroups || [];

            changes.contents.forEach(function (newContent) {
                if (content.name !== newContent.name) {
                    return;
                }

                var newContentDesc = newContent.description;
                var newSSRCs = newContentDesc.sources || [];

                ssrcs = ssrcs.concat(newSSRCs);
                newDesc.contents[idx].description.sources = JSON.parse(JSON.stringify(ssrcs));

                var newGroups = newContentDesc.sourceGroups || [];
                groups = groups.concat(newGroups);
                newDesc.contents[idx].description.sourceGroups = JSON.parse(JSON.stringify(groups));
            });
        });

        this.pc.handleOffer({
            type: 'offer',
            jingle: newDesc
        }, function (err) {
            if (err) {
                self._log('error', 'Error adding new stream source');
                return cb({
                    condition: 'general-error'
                });
            }

            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Error adding new stream source');
                    return cb({
                        condition: 'general-error'
                    });
                }
                cb();
            });
        });
    },

    onSourceRemove: function (changes, cb) {
        var self = this;
        this._log('info', 'Removing stream source');

        var newDesc = this.pc.remoteDescription;
        this.pc.remoteDescription.contents.forEach(function (content, idx) {
            var desc = content.description;
            var ssrcs = desc.sources || [];
            var groups = desc.sourceGroups || [];

            changes.contents.forEach(function (newContent) {
                if (content.name !== newContent.name) {
                    return;
                }

                var newContentDesc = newContent.description;
                var newSSRCs = newContentDesc.sources || [];
                var newGroups = newContentDesc.sourceGroups || [];

                var found, i, j, k;


                for (i = 0; i < newSSRCs.length; i++) {
                    found = -1;
                    for (j = 0; j < ssrcs.length; j++) {
                        if (newSSRCs[i].ssrc === ssrcs[j].ssrc) {
                            found = j;
                            break;
                        }
                    }
                    if (found > -1) {
                        ssrcs.splice(found, 1);
                        newDesc.contents[idx].description.sources = JSON.parse(JSON.stringify(ssrcs));
                    }
                }

                // Remove ssrc-groups that are no longer needed
                for (i = 0; i < newGroups.length; i++) {
                    found = -1;
                    for (j = 0; i < groups.length; j++) {
                        if (newGroups[i].semantics === groups[j].semantics &&
                            newGroups[i].sources.length === groups[j].sources.length) {
                            var same = true;
                            for (k = 0; k < newGroups[i].sources.length; k++) {
                                if (newGroups[i].sources[k] !== groups[j].sources[k]) {
                                    same = false;
                                    break;
                                }
                            }
                            if (same) {
                                found = j;
                                break;
                            }
                        }
                    }
                    if (found > -1) {
                        groups.splice(found, 1);
                        newDesc.contents[idx].description.sourceGroups = JSON.parse(JSON.stringify(groups));
                    }
                }
            });
        });

        this.pc.handleOffer({
            type: 'offer',
            jingle: newDesc
        }, function (err) {
            if (err) {
                self._log('error', 'Error removing stream source');
                return cb({
                    condition: 'general-error'
                });
            }
            self.pc.answer(function (err) {
                if (err) {
                    self._log('error', 'Error removing stream source');
                    return cb({
                        condition: 'general-error'
                    });
                }
                cb();
            });
        });
    }
});


module.exports = MediaSession;

},{"extend-object":385,"jingle-session":404,"rtcpeerconnection":403,"util":165}],397:[function(require,module,exports){
module.exports=require(389)
},{"./lib/tojson":400,"./lib/tosdp":401,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/index.js":389}],398:[function(require,module,exports){
module.exports=require(390)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/parsers.js":390}],399:[function(require,module,exports){
module.exports=require(391)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/senders.js":391}],400:[function(require,module,exports){
module.exports=require(392)
},{"./parsers":398,"./senders":399,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/tojson.js":392}],401:[function(require,module,exports){
module.exports=require(393)
},{"./senders":399,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/sdp-jingle-json/lib/tosdp.js":393}],402:[function(require,module,exports){
module.exports=require(394)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/node_modules/traceablepeerconnection/index.js":394,"util":165,"webrtcsupport":405,"wildemitter":449}],403:[function(require,module,exports){
module.exports=require(395)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/jingle-filetransfer-session/node_modules/rtcpeerconnection/rtcpeerconnection.js":395,"sdp-jingle-json":397,"traceablepeerconnection":402,"underscore":448,"util":165,"webrtcsupport":405,"wildemitter":449}],404:[function(require,module,exports){
var util = require('util');
var async = require('async');
var extend = require('extend-object');
var WildEmitter = require('wildemitter');


var ACTIONS = {
    'content-accept': 'onContentAccept',
    'content-add': 'onContentAdd',
    'content-modify': 'onConentModify',
    'content-reject': 'onContentReject',
    'content-remove': 'onContentRemove',
    'description-info': 'onDescriptionInfo',
    'security-info': 'onSecurityInfo',
    'session-accept': 'onSessionAccept',
    'session-info': 'onSessionInfo',
    'session-initiate': 'onSessionInitiate',
    'session-terminate': 'onSessionTerminate',
    'transport-accept': 'onTransportAccept',
    'transport-info': 'onTransportInfo',
    'transport-reject': 'onTransportReject',
    'transport-replace': 'onTransportReplace',

    // Unstandardized actions: might go away anytime without notice
    'source-add': 'onSourceAdd',
    'source-remove': 'onSourceRemove'
};


function JingleSession(opts) {
    WildEmitter.call(this);

    var self = this;

    this.sid = opts.sid || Date.now().toString();
    this.peer = opts.peer;
    this.peerID = opts.peerID || this.peer.full || this.peer;
    this.isInitiator = opts.initiator || false;
    this.parent = opts.parent;
    this.state = 'starting';
    this.connectionState = 'starting';

    // We track the intial pending description types in case
    // of the need for a tie-breaker.
    this.pendingDescriptionTypes = opts.descriptionTypes || [];

    this.pendingAction = false;

    // Here is where we'll ensure that all actions are processed
    // in order, even if a particular action requires async handling.
    this.processingQueue = async.queue(function (task, next) {
        if (self.ended) {
            // Don't process anything once the session has been ended
            return next();
        }

        var action = task.action;
        var changes = task.changes;
        var cb = task.cb;

        self._log('debug', action);

        if (!ACTIONS[action]) {
            self._log('error', 'Invalid action: ' + action);
            cb({condition: 'bad-request'});
            return next();
        }

        self[ACTIONS[action]](changes, function (err, result) {
            cb(err, result);
            return next();
        });
    });
}


util.inherits(JingleSession, WildEmitter);

// We don't know how to handle any particular content types,
// so no actions are supported.
Object.keys(ACTIONS).forEach(function (action) {
    var method = ACTIONS[action];
    JingleSession.prototype[method] = function (changes, cb) {
        this._log('error', 'Unsupported action: ' + action);
        cb();
    };
});

// Provide some convenience properties for checking
// the session's state.
Object.defineProperties(JingleSession.prototype, {
    state: {
        get: function () {
            return this._sessionState;
        },
        set: function (value) {
            if (value !== this._sessionState) {
                var prev = this._sessionState;
                this._log('info', 'Changing session state to: ' + value);
                this._sessionState = value;
                this.emit('change:sessionState', this, value);
                this.emit('change:' + value, this, true);
                if (prev) {
                    this.emit('change:' + prev, this, false);
                }
            }
        }
    },
    connectionState: {
        get: function () {
            return this._connectionState;
        },
        set: function (value) {
            if (value !== this._connectionState) {
                var prev = this._connectionState;
                this._log('info', 'Changing connection state to: ' + value);
                this._connectionState = value;
                this.emit('change:connectionState', this, value);
                this.emit('change:' + value, this, true);
                if (prev) {
                    this.emit('change:' + prev, this, false);
                }
            }
        }
    },
    starting: {
        get: function () {
            return this._sessionState === 'starting';
        }
    },
    pending: {
        get: function () {
            return this._sessionState === 'pending';
        }
    },
    active: {
        get: function () {
            return this._sessionState === 'active';
        }
    },
    ended: {
        get: function () {
            return this._sessionState === 'ended';
        }
    },
    connected: {
        get: function () {
            return this._connectionState === 'connected';
        }
    },
    connecting: {
        get: function () {
            return this._connectionState === 'connecting';
        }
    },
    disconnected: {
        get: function () {
            return this._connectionState === 'disconnected';
        }
    },
    interrupted: {
        get: function () {
            return this._connectionState === 'interrupted';
        }
    }
});

JingleSession.prototype = extend(JingleSession.prototype, {
    _log: function (level, message) {
        message = this.sid + ': ' + message;
        this.emit('log:' + level, message);
    },
    
    send: function (action, data) {
        data = data || {};
        data.sid = this.sid;
        data.action = action;

        var requirePending = {
            'session-inititate': true,
            'session-accept': true,
            'content-add': true,
            'content-remove': true,
            'content-reject': true,
            'content-accept': true,
            'content-modify': true,
            'transport-replace': true,
            'transport-reject': true,
            'transport-accept': true,
            'source-add': true,
            'source-remove': true
        };

        if (requirePending[action]) {
            this.pendingAction = action;
        } else {
            this.pendingAction = false;
        }

        this.emit('send', {
            to: this.peer,
            type: 'set',
            jingle: data
        });
    },
    
    process: function (action, changes, cb) {
        this.processingQueue.push({
            action: action,
            changes: changes,
            cb: cb
        });
    },
    
    start: function () {
        this._log('error', 'Can not start base sessions');
        this.end('unsupported-applications', true);
    },
    
    accept: function () {
        this._log('error', 'Can not accept base sessions');
        this.end('unsupported-applications');
    },
    
    cancel: function () {
        this.end('cancel');
    },
    
    decline: function () {
        this.end('decline');
    },
    
    end: function (reason, silent) {
        this.state = 'ended';

        this.processingQueue.kill();

        if (!reason) {
            reason = 'success';
        }

        if (typeof reason === 'string') {
            reason = {
                condition: reason
            };
        }
    
        if (!silent) {
            this.send('session-terminate', {
                reason: reason
            });
        }
    
        this.emit('terminated', this, reason);
    },

    onSessionTerminate: function (changes, cb) {
        this.end(changes.reason, true);
        cb();
    },

    // It is mandatory to reply to a session-info action with 
    // an unsupported-info error if the info isn't recognized.
    //
    // However, a session-info action with no associated payload
    // is acceptable (works like a ping).
    onSessionInfo: function (changes, cb) {
        var okKeys = {
            sid: true,
            action: true,
            initiator: true,
            responder: true
        };

        var unknownPayload = false;
        Object.keys(changes).forEach(function (key) {
            if (!okKeys[key]) {
                unknownPayload = true;
            }
        });

        if (unknownPayload) {
            cb({
                type: 'modify',
                condition: 'feature-not-implemented',
                jingleCondition: 'unsupported-info'
            });
        } else {
            cb();
        }
    },

    // It is mandatory to reply to a description-info action with 
    // an unsupported-info error if the info isn't recognized.
    onDescriptionInfo: function (changes, cb) {
        cb({
            type: 'modify',
            condition: 'feature-not-implemented',
            jingleCondition: 'unsupported-info'
        });
    },

    // It is mandatory to reply to a transport-info action with 
    // an unsupported-info error if the info isn't recognized.
    onTransportInfo: function (changes, cb) {
        cb({
            type: 'modify',
            condition: 'feature-not-implemented',
            jingleCondition: 'unsupported-info'
        });
    },

    // It is mandatory to reply to a content-add action with either
    // a content-accept or content-reject.
    onContentAdd: function (changes, cb) {
        // Allow ack for the content-add to be sent.
        cb();

        this.send('content-reject', {
            reason: {
                condition: 'failed-application',
                text: 'content-add is not supported'
            }
        });
    },

    // It is mandatory to reply to a transport-add action with either
    // a transport-accept or transport-reject.
    onTransportReplace: function (changes, cb) {
        // Allow ack for the transport-replace be sent.
        cb();

        this.send('transport-reject', {
            reason: {
                condition: 'failed-application',
                text: 'transport-replace is not supported'
            }
        });
    }
});


module.exports = JingleSession;

},{"async":362,"extend-object":385,"util":165,"wildemitter":449}],405:[function(require,module,exports){
// created by @HenrikJoreteg
var prefix;

if (window.mozRTCPeerConnection || navigator.mozGetUserMedia) {
    prefix = 'moz';
} else if (window.webkitRTCPeerConnection || navigator.webkitGetUserMedia) {
    prefix = 'webkit';
}

var PC = window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var IceCandidate = window.mozRTCIceCandidate || window.RTCIceCandidate;
var SessionDescription = window.mozRTCSessionDescription || window.RTCSessionDescription;
var MediaStream = window.webkitMediaStream || window.MediaStream;
var screenSharing = window.location.protocol === 'https:' &&
    ((window.navigator.userAgent.match('Chrome') && parseInt(window.navigator.userAgent.match(/Chrome\/(.*) /)[1], 10) >= 26) ||
     (window.navigator.userAgent.match('Firefox') && parseInt(window.navigator.userAgent.match(/Firefox\/(.*)/)[1], 10) >= 33));
var AudioContext = window.AudioContext || window.webkitAudioContext;
var supportVp8 = document.createElement('video').canPlayType('video/webm; codecs="vp8", vorbis') === "probably";
var getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia;

// export support flags and constructors.prototype && PC
module.exports = {
    support: !!PC && supportVp8 && !!getUserMedia,
    supportRTCPeerConnection: !!PC,
    supportVp8: supportVp8,
    supportGetUserMedia: !!getUserMedia,
    supportDataChannel: !!(PC && PC.prototype && PC.prototype.createDataChannel),
    supportWebAudio: !!(AudioContext && AudioContext.prototype.createMediaStreamSource),
    supportMediaStream: !!(MediaStream && MediaStream.prototype.removeTrack),
    supportScreenSharing: !!screenSharing,
    prefix: prefix,
    AudioContext: AudioContext,
    PeerConnection: PC,
    SessionDescription: SessionDescription,
    IceCandidate: IceCandidate,
    MediaStream: MediaStream,
    getUserMedia: getUserMedia
};

},{}],406:[function(require,module,exports){
'use strict';

var JID = require('xmpp-jid').JID;


module.exports = function (JXT) {
    var types = JXT.utils;

    // ----------------------------------------------------------------
    // Shortcuts for common withDefinition calls
    // ----------------------------------------------------------------
    
    JXT.withIq = function (cb) {
        this.withDefinition('iq', 'jabber:client', cb);
        this.withDefinition('iq', 'jabber:component:accept', cb);
    };

    JXT.withMessage = function (cb) {
        this.withDefinition('message', 'jabber:client', cb);
        this.withDefinition('message', 'jabber:component:accept', cb);
    };

    JXT.withPresence = function (cb) {
        this.withDefinition('presence', 'jabber:client', cb);
        this.withDefinition('presence', 'jabber:component:accept', cb);
    };

    JXT.withStreamFeatures = function (cb) {
        this.withDefinition('features', 'http://etherx.jabber.org/streams', cb);
    };

    JXT.withStanzaError = function (cb) {
        this.withDefinition('error', 'jabber:client', cb);
        this.withDefinition('error', 'jabber:component:accept', cb);
    };

    JXT.withDataForm = function (cb) {
        this.withDefinition('x', 'jabber:x:data', cb);
    };

    JXT.withPubsubItem = function (cb) {
        this.withDefinition('item', 'http://jabber.org/protocol/pubsub', cb);
        this.withDefinition('item', 'http://jabber.org/protocol/pubsub#event', cb);
    };


    // ----------------------------------------------------------------
    // Shortcuts for common getDefinition calls
    // ----------------------------------------------------------------
   
    JXT.getMessage = function () {
        return this.getDefinition('message', 'jabber:client');
    };

    JXT.getPresence = function () {
        return this.getDefinition('presence', 'jabber:client');
    };

    JXT.getIq = function () {
        return this.getDefinition('iq', 'jabber:client');
    };

    JXT.getStreamError = function () {
        return this.getDefinition('error', 'http://etherx.jabber.org/streams');
    };
   
    JXT.getComponentMessage = function () {
        return this.getDefinition('message', 'jabber:component:accept');
    };

    JXT.getComponentPresence = function () {
        return this.getDefinition('presence', 'jabber:component:accept');
    };

    JXT.getComponentIq = function () {
        return this.getDefinition('iq', 'jabber:component:accept');
    };


    // ----------------------------------------------------------------
    // Field types
    // ----------------------------------------------------------------


    JXT.utils.jidAttribute = function (attr, prepped) {
        return {
            get: function () {
                var jid = new JID(types.getAttribute(this.xml, attr));
                if (prepped) {
                    jid.prepped = true;
                }
                return jid;
            },
            set: function (value) {
                types.setAttribute(this.xml, attr, (value || '').toString());
            }
        };
    };
    
    JXT.utils.jidSub = function (NS, sub, prepped) {
        return {
            get: function () {
                var jid = new JID(types.getSubText(this.xml, NS, sub));
                if (prepped) {
                    jid.prepped = true;
                }
                return jid;
            },
            set: function (value) {
                types.setSubText(this.xml, NS, sub, (value || '').toString());
            }
        };
    };
    
    
    JXT.utils.tzoSub = types.field(
        function (xml, NS, sub, defaultVal) {
            var split, hrs, min;
            var sign = -1;
            var formatted = types.getSubText(xml, NS, sub);
    
            if (!formatted) {
                return defaultVal;
            }
    
            if (formatted.charAt(0) === '-') {
                sign = 1;
                formatted = formatted.slice(1);
            }
    
            split = formatted.split(':');
            hrs = parseInt(split[0], 10);
            min = parseInt(split[1], 10);
            return (hrs * 60 + min) * sign;
        },
        function (xml, NS, sub, value) {
            var hrs, min;
            var formatted = '-';
            if (typeof value === 'number') {
                if (value < 0) {
                    value = -value;
                    formatted = '+';
                }
                hrs = value / 60;
                min = value % 60;
                formatted += (hrs < 10 ? '0' : '') + hrs + ':' + (min < 10 ? '0' : '') + min;
            } else {
                formatted = value;
            }
            types.setSubText(xml, NS, sub, formatted);
        }
    );
};

},{"xmpp-jid":450}],407:[function(require,module,exports){
'use strict';

var ltx = require('ltx');
var extend = require('extend-object');
var uuid = require('node-uuid');

var types = require('./lib/types');
var helpers = require('./lib/helpers');
var stanzaConstructor = require('./lib/stanza');


function JXT() {
    this._LOOKUP = {};
    this._LOOKUP_EXT = {};
    this._TAGS = {};
    this._CB_DEFINITION = {};
    this._CB_TAG = {};
    this._ID = uuid.v4();
    this.utils = extend({}, types, helpers);
}

JXT.prototype.use = function (init) {
    if (!init['__JXT_LOADED_' + this._ID]) {
        init(this);
    }
    init['__JXT_LOADED_' + this._ID] = true;
    return this;
};

JXT.prototype.getDefinition = function (el, ns, required) {
    var JXTClass = this._LOOKUP[ns + '|' + el];
    if (required && !JXTClass) {
        throw new Error('Could not find definition for <' + el + ' xmlns="' + ns + '" />');
    }
    return JXTClass;
};

JXT.prototype.getExtensions = function (el, ns) {
    return this._LOOKUP_EXT[ns + '|' + el] || {};
};

JXT.prototype.withDefinition = function (el, ns, cb) {
    var name = ns + '|' + el;
    if (!this._CB_DEFINITION[name]) {
        this._CB_DEFINITION[name] = [];
    }
    this._CB_DEFINITION[name].push(cb);

    if (this._LOOKUP[name]) {
        cb(this._LOOKUP[name]);
    }
};

JXT.prototype.withTag = function (tag, cb) {
    if (!this._CB_TAG[tag]) {
        this._CB_TAG[tag] = [];
    }
    this._CB_TAG[tag].push(cb);

    this.tagged(tag).forEach(function (stanza) {
        cb(stanza);
    });
};

JXT.prototype.tagged = function (tag) {
    return this._TAGS[tag] || [];
};

JXT.prototype.build = function (xml) {
    var JXTClass = this._LOOKUP[xml.namespaceURI + '|' + xml.localName];
    if (JXTClass) {
        return new JXTClass(null, xml);
    }
};

JXT.prototype.parse = function (str) {
    var xml= ltx.parse(str);
    if (xml.nodeType !== 1) {
        return;
    }

    var JXTClass = this.getDefinition(xml.localName, xml.namespaceURI);
    if (JXTClass) {
        return new JXTClass(null, xml);
    }
};

JXT.prototype.extend = function (ParentJXT, ChildJXT, multiName) {
    var parentName = ParentJXT.prototype._NS + '|' + ParentJXT.prototype._EL;
    var name = ChildJXT.prototype._name;
    var qName = ChildJXT.prototype._NS + '|' + ChildJXT.prototype._EL;

    this._LOOKUP[qName] = ChildJXT;
    if (!this._LOOKUP_EXT[qName]) {
        this._LOOKUP_EXT[qName] = {};
    }
    if (!this._LOOKUP_EXT[parentName]) {
        this._LOOKUP_EXT[parentName] = {};
    }
    this._LOOKUP_EXT[parentName][name] = ChildJXT;

    this.add(ParentJXT, name, types.extension(ChildJXT));
    if (multiName) {
        this.add(ParentJXT, multiName, types.multiExtension(ChildJXT));
    }
};

JXT.prototype.add = function (ParentJXT, fieldName, field) {
    field.enumerable = true;
    Object.defineProperty(ParentJXT.prototype, fieldName, field);
};

JXT.prototype.define = function (opts) {
    var self = this;

    var Stanza = stanzaConstructor(this, opts);

    var ns = Stanza.prototype._NS;
    var el = Stanza.prototype._EL;
    var tags = Stanza.prototype._TAGS;

    var name = ns + '|' + el;
    this._LOOKUP[name] = Stanza;

    tags.forEach(function (tag) {
        if (!self._TAGS[tag]) {
            self._TAGS[tag] = [];
        }
        self._TAGS[tag].push(Stanza);
    });

    var fieldNames = Object.keys(opts.fields || {});
    fieldNames.forEach(function (fieldName) {
        self.add(Stanza, fieldName, opts.fields[fieldName]);
    });

    if (this._CB_DEFINITION[name]) {
        this._CB_DEFINITION[name].forEach(function (handler) {
            handler(Stanza);
        });
    }

    tags.forEach(function (tag) {
        if (self._CB_TAG[tag]) {
            self._CB_TAG[tag].forEach(function (handler) {
                handler(Stanza);
            });
        }
    });

    return Stanza;
};


// Expose methods on the required module itself


JXT.createRegistry = function () {
    return new JXT();
};

extend(JXT, helpers);
extend(JXT, types);

// Compatibility shim for JXT 1.x

var globalJXT = new JXT();

JXT.define = globalJXT.define.bind(globalJXT);
JXT.extend = globalJXT.extend.bind(globalJXT);
JXT.add = globalJXT.add.bind(globalJXT);
JXT.parse = globalJXT.parse.bind(globalJXT);
JXT.build = globalJXT.build.bind(globalJXT);
JXT.getExtensions = globalJXT.getExtensions.bind(globalJXT);
JXT.getDefinition = globalJXT.getDefinition.bind(globalJXT);
JXT.withDefinition = globalJXT.withDefinition.bind(globalJXT);
JXT.withTag = globalJXT.withTag.bind(globalJXT);
JXT.tagged = globalJXT.tagged.bind(globalJXT);

JXT.getGlobalJXT = function () {
    return globalJXT;
};

module.exports = JXT;

},{"./lib/helpers":408,"./lib/stanza":409,"./lib/types":410,"extend-object":413,"ltx":416,"node-uuid":420}],408:[function(require,module,exports){
'use strict';

var ltx = require('ltx');

var XML_NS = exports.XML_NS = 'http://www.w3.org/XML/1998/namespace';


exports.createElement = function (NS, name, parentNS) {
    var el = new ltx.Element(name);
    if (!parentNS || parentNS !== NS) {
        exports.setAttribute(el, 'xmlns', NS);
    }
    return el;
};

var find = exports.find = function (xml, NS, selector) {
    var results = [];
    var children = xml.getElementsByTagName(selector);
    for (var i = 0, len = children.length; i < len; i++) {
        var child = children[i];
        if (child.namespaceURI === NS && child.parentNode === xml) {
            results.push(child);
        }
    }
    return results;
};

exports.findOrCreate = function (xml, NS, selector) {
    var existing = exports.find(xml, NS, selector);
    if (existing.length) {
        return existing[0];
    } else {
        var created = exports.createElement(NS, selector, xml.namespaceURI);
        xml.appendChild(created);
        return created;
    }
};

exports.getAttribute = function (xml, attr, defaultVal) {
    return xml.getAttribute(attr) || defaultVal || '';
};

exports.getAttributeNS = function (xml, NS, attr, defaultVal) {
    return xml.getAttributeNS(NS, attr) || defaultVal || '';
};

exports.setAttribute = function (xml, attr, value, force) {
    if (value || force) {
        xml.setAttribute(attr, value);
    } else {
        xml.removeAttribute(attr);
    }
};

exports.setAttributeNS = function (xml, NS, attr, value, force) {
    if (value || force) {
        xml.setAttributeNS(NS, attr, value);
    } else {
        xml.removeAttributeNS(NS, attr);
    }
};

exports.getBoolAttribute = function (xml, attr, defaultVal) {
    var val = xml.getAttribute(attr) || defaultVal || '';
    return val === 'true' || val === '1';
};

exports.setBoolAttribute = function (xml, attr, value) {
    if (value) {
        xml.setAttribute(attr, '1');
    } else {
        xml.removeAttribute(attr);
    }
};

exports.getSubAttribute = function (xml, NS, sub, attr, defaultVal) {
    var subs = find(xml, NS, sub);
    if (!subs) {
        return '';
    }

    for (var i = 0; i < subs.length; i++) {
        return subs[i].getAttribute(attr) || defaultVal || '';
    }

    return '';
};

exports.setSubAttribute = function (xml, NS, sub, attr, value) {
    var subs = find(xml, NS, sub);
    if (!subs.length) {
        if (value) {
            sub = exports.createElement(NS, sub, xml.namespaceURI);
            sub.setAttribute(attr, value);
            xml.appendChild(sub);
        }
    } else {
        for (var i = 0; i < subs.length; i++) {
            if (value) {
                subs[i].setAttribute(attr, value);
                return;
            } else {
                subs[i].removeAttribute(attr);
            }
        }
    }
};

exports.getBoolSubAttribute = function (xml, NS, sub, attr, defaultVal) {
    var val = xml.getSubAttribute(NS, sub, attr) || defaultVal || '';
    return val === 'true' || val === '1';
};

exports.setBoolSubAttribute = function (xml, NS, sub, attr, value) {
    value = value ? '1' : '';
    exports.setSubAttribute(xml, NS, sub, attr, value);
};

exports.getText = function (xml) {
    return xml.textContent;
};

exports.setText = function (xml, value) {
    xml.textContent = value;
};

exports.getSubText = exports.getTextSub = function (xml, NS, element, defaultVal) {
    var subs = find(xml, NS, element);

    defaultVal = defaultVal || '';

    if (!subs.length) {
        return defaultVal;
    }

    return subs[0].textContent || defaultVal;
};

exports.setSubText = exports.setTextSub = function (xml, NS, element, value) {
    var subs = find(xml, NS, element);
    if (subs.length) {
        for (var i = 0; i < subs.length; i++) {
            xml.removeChild(subs[i]);
        }
    }

    if (value) {
        var sub = exports.createElement(NS, element, xml.namespaceURI);
        if (value !== true) {
            sub.textContent = value;
        }
        xml.appendChild(sub);
    }
};

exports.getMultiSubText = function (xml, NS, element, extractor) {
    var subs = find(xml, NS, element);
    var results = [];

    extractor = extractor || function (sub) {
        return sub.textContent || '';
    };

    for (var i = 0; i < subs.length; i++) {
        results.push(extractor(subs[i]));
    }

    return results;
};

exports.setMultiSubText = function (xml, NS, element, value, builder) {
    var subs = find(xml, NS, element);
    var values = [];
    builder = builder || function (value) {
        if (value) {
            var sub = exports.createElement(NS, element, xml.namespaceURI);
            sub.textContent = value;
            xml.appendChild(sub);
        }
    };
    if (typeof value === 'string') {
        values = (value || '').split('\n');
    } else {
        values = value;
    }

    var i, len;
    for(i = 0, len = subs.length; i < len; i++) {
        xml.removeChild(subs[i]);
    }

    for(i = 0, len = values.length; i < len; i++) {
        builder(values[i]);
    }
};

exports.getMultiSubAttribute = function (xml, NS, element, attr) {
    return exports.getMultiSubText(xml, NS, element, function (sub) {
        return exports.getAttribute(sub, attr);
    });
};

exports.setMultiSubAttribute = function (xml, NS, element, attr, value) {
    exports.setMultiSubText(xml, NS, element, value, function (val) {
        var sub = exports.createElement(NS, element, xml.namespaceURI);
        exports.setAttribute(sub, attr, val);
        xml.appendChild(sub);
    });
};

exports.getSubLangText = function (xml, NS, element, defaultLang) {
    var subs = find(xml, NS, element);
    if (!subs.length) {
        return {};
    }

    var lang, sub;
    var results = {};
    var langs = [];

    for (var i = 0; i < subs.length; i++) {
        sub = subs[i];
        lang = sub.getAttributeNS(XML_NS, 'lang') || defaultLang;
        langs.push(lang);
        results[lang] = sub.textContent || '';
    }

    return results;
};

exports.setSubLangText = function (xml, NS, element, value, defaultLang) {
    var sub, lang;
    var subs = find(xml, NS, element);
    if (subs.length) {
        for (var i = 0; i < subs.length; i++) {
            xml.removeChild(subs[i]);
        }
    }

    if (typeof value === 'string') {
        sub = exports.createElement(NS, element, xml.namespaceURI);
        sub.textContent = value;
        xml.appendChild(sub);
    } else if (typeof value === 'object') {
        for (lang in value) {
            if (value.hasOwnProperty(lang)) {
                sub = exports.createElement(NS, element, xml.namespaceURI);
                if (lang !== defaultLang) {
                    sub.setAttributeNS(XML_NS, 'lang', lang);
                }
                sub.textContent = value[lang];
                xml.appendChild(sub);
            }
        }
    }
};

exports.getBoolSub = function (xml, NS, element) {
    var subs = find(xml, NS, element);
    return !!subs.length;
};

exports.setBoolSub = function (xml, NS, element, value) {
    var subs = find(xml, NS, element);
    if (!subs.length) {
        if (value) {
            var sub = exports.createElement(NS, element, xml.namespaceURI);
            xml.appendChild(sub);
        }
    } else {
        for (var i = 0; i < subs.length; i++) {
            if (value) {
                return;
            } else {
                xml.removeChild(subs[i]);
            }
        }
    }
};

},{"ltx":416}],409:[function(require,module,exports){
'use strict';

var helpers = require('./helpers');
var extend = require('extend-object');


var EXCLUDE = {
    constructor: true,
    parent: true,
    prototype: true,
    toJSON: true,
    toString: true,
    xml: true
};


module.exports = function (JXT, opts) {
    function Stanza(data, xml, parent) {
        var self = this;

        var parentNode = (xml || {}).parentNode || (parent || {}).xml;
        var parentNS = (parentNode || {}).namespaceURI;

        self.xml = xml || helpers.createElement(self._NS, self._EL, parentNS);

        Object.keys(self._PREFIXES).forEach(function (prefix) {
            var namespace = self._PREFIXES[prefix];
            self.xml.setAttribute('xmlns:' + prefix, namespace);
        });

        self._extensions = {};

        for (var i = 0, len = self.xml.childNodes.length; i < len; i++) {
            var child = self.xml.childNodes[i];
            var ChildJXT = JXT.getDefinition(child.localName, child.namespaceURI);
            if (ChildJXT !== undefined) {
                var name = ChildJXT.prototype._name;
                self._extensions[name] = new ChildJXT(null, child);
                self._extensions[name].parent = self;
            }
        }

        extend(self, data);

        if (opts.init) {
            opts.init.apply(self, [data]);
        }

        return self;
    }


    Stanza.prototype._name = opts.name;
    Stanza.prototype._eventname = opts.eventName;
    Stanza.prototype._NS = opts.namespace;
    Stanza.prototype._EL = opts.element || opts.name;
    Stanza.prototype._PREFIXES = opts.prefixes || {};
    Stanza.prototype._TAGS = opts.tags || [];

    Stanza.prototype.toString = function () {
        return this.xml.toString();
    };

    Stanza.prototype.toJSON = function () {
        var prop;
        var result = {};

        for (prop in this._extensions) {
            if (this._extensions[prop].toJSON && prop[0] !== '_') {
                result[prop] = this._extensions[prop].toJSON();
            }
        }

        for (prop in this) {
            var allowedName = !EXCLUDE[prop] && prop[0] !== '_';
            var isExtensionName = JXT.getExtensions(this._EL, this._NS)[prop];

            if (allowedName && !isExtensionName) {
                var val = this[prop];
                if (typeof val === 'function') {
                    continue;
                }
                var type = Object.prototype.toString.call(val);
                if (type.indexOf('Object') >= 0) {
                    if (Object.keys(val).length > 0) {
                        result[prop] = val;
                    }
                } else if (type.indexOf('Array') >= 0) {
                    if (val.length > 0) {
                        var vals = [];
                        for (var n in val) {
                            var nval = val[n];
                            if (nval.toJSON !== undefined) {
                                vals.push(nval.toJSON());
                            } else {
                                vals.push(nval);
                            }
                        }
                        result[prop] = vals;
                    }
                } else if (val !== undefined && val !== false && val !== '') {
                    result[prop] = val;
                }
            }
        }

        return result;
    };

    return Stanza;
};

},{"./helpers":408,"extend-object":413}],410:[function(require,module,exports){
'use strict';

var fromB64 = require('atob');
var toB64 = require('btoa');

var helpers = require('./helpers');
var extend = require('extend-object');

var find = helpers.find;
var createElement = helpers.createElement;


var field = exports.field = function (getter, setter) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return {
            get: function () {
                return getter.apply(null, [this.xml].concat(args));
            },
            set: function (value) {
                setter.apply(null, ([this.xml].concat(args)).concat([value]));
            }
        };
    };
};

exports.boolAttribute = field(
    helpers.getBoolAttribute,
    helpers.setBoolAttribute);

exports.subAttribute = field(
    helpers.getSubAttribute,
    helpers.setSubAttribute);

exports.boolSubAttribute = field(
    helpers.getSubBoolAttribute,
    helpers.setSubBoolAttribute);

exports.text = field(
    helpers.getText,
    helpers.setText);

exports.textSub = exports.subText = field(
    helpers.getSubText,
    helpers.setSubText);

exports.multiTextSub = exports.multiSubText = field(
    helpers.getMultiSubText,
    helpers.setMultiSubText);

exports.multiSubAttribute  = field(
    helpers.getMultiSubAttribute,
    helpers.setMultiSubAttribute);

exports.langTextSub = exports.subLangText = field(
    helpers.getSubLangText,
    helpers.setSubLangText);

exports.boolSub = field(
    helpers.getBoolSub,
    helpers.setBoolSub);

exports.langAttribute = field(
    function (xml) {
        return xml.getAttributeNS(helpers.XML_NS, 'lang') || '';
    },
    function (xml, value) {
        xml.setAttributeNS(helpers.XML_NS, 'lang', value);
    }
);

exports.b64Text = field(
    function (xml) {
        if (xml.textContent && xml.textContent !== '=') {
            return fromB64(xml.textContent);
        }
        return '';
    },
    function (xml, value) {
        if (typeof value === 'string') {
            xml.textContent = toB64(value) || '=';
        } else {
            xml.textContent = '';
        }
    }
);

exports.dateAttribute = function (attr, now) {
    return {
        get: function () {
            var data = helpers.getAttribute(this.xml, attr);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setAttribute(this.xml, attr, value);
        }
    };
};

exports.dateSub = function (NS, sub, now) {
    return {
        get: function () {
            var data = helpers.getSubText(this.xml, NS, sub);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setSubText(this.xml, NS, sub, value);
        }
    };
};

exports.dateSubAttribute = function (NS, sub, attr, now) {
    return {
        get: function () {
            var data = helpers.getSubAttribute(this.xml, NS, sub, attr);
            if (data) {
                return new Date(data);
            }
            if (now) {
                return new Date(Date.now());
            }
        },
        set: function (value) {
            if (!value) {
                return;
            }
            if (typeof value !== 'string') {
                value = value.toISOString();
            }
            helpers.setSubAttribute(this.xml, NS, sub, attr, value);
        }
    };
};

exports.numberAttribute = function (attr, isFloat, defaultVal) {
    return {
        get: function () {
            var parse = isFloat ? parseFloat : parseInt;
            var data = helpers.getAttribute(this.xml, attr, '');
            if (!data) {
                return defaultVal;
            }
            var parsed = parse(data, 10);
            if (isNaN(parsed)) {
                return defaultVal;
            }

            return parsed;
        },
        set: function (value) {
            helpers.setAttribute(this.xml, attr, value.toString());
        }
    };
};

exports.numberSub = function (NS, sub, isFloat, defaultVal) {
    return {
        get: function () {
            var parse = isFloat ? parseFloat : parseInt;
            var data = helpers.getSubText(this.xml, NS, sub, '');
            if (!data) {
                return defaultVal;
            }

            var parsed = parse(data, 10);
            if (isNaN(parsed)) {
                return defaultVal;
            }

            return parsed;
        },
        set: function (value) {
            helpers.setSubText(this.xml, NS, sub, value.toString());
        }
    };
};

exports.attribute = function (name, defaultVal) {
    return {
        get: function () {
            return helpers.getAttribute(this.xml, name, defaultVal);
        },
        set: function (value) {
            helpers.setAttribute(this.xml, name, value);
        }
    };
};

exports.attributeNS = function (NS, name, defaultVal) {
    return {
        get: function () {
            return helpers.getAttributeNS(this.xml, NS, name, defaultVal);
        },
        set: function (value) {
            helpers.setAttributeNS(this.xml, NS, name, value);
        }
    };
};

exports.extension = function (ChildJXT) {
    return {
        get: function () {
            var self = this;
            var name = ChildJXT.prototype._name;
            if (!this._extensions[name]) {
                var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
                if (!existing.length) {
                    this._extensions[name] = new ChildJXT({}, null, self);
                    this.xml.appendChild(this._extensions[name].xml);
                } else {
                    this._extensions[name] = new ChildJXT(null, existing[0], self);
                }
                this._extensions[name].parent = this;
            }
            return this._extensions[name];
        },
        set: function (value) {
            if (value) {
                var child = this[ChildJXT.prototype._name];
                if (value === true) {
                    value = {};
                }
                extend(child, value);
            }
        }
    };
};

exports.multiExtension = function (ChildJXT) {
    return {
        get: function () {
            var self = this;
            var data = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
            var results = [];

            for (var i = 0, len = data.length; i < len; i++) {
                results.push(new ChildJXT({}, data[i], self));
            }

            return results;
        },
        set: function (value) {
            value = value || [];

            var self = this;
            var existing = find(this.xml, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

            var i, len;
            for (i = 0, len = existing.length; i < len; i++) {
                self.xml.removeChild(existing[i]);
            }

            for (i = 0, len = value.length; i < len; i++) {
                var content = new ChildJXT(value[i], null, self);
                self.xml.appendChild(content.xml);
            }
        }
    };
};

exports.enumSub = function (NS, enumValues) {
    return {
        get: function () {
            var self = this;
            var result = [];
            enumValues.forEach(function (enumVal) {
                var exists = find(self.xml, NS, enumVal);
                if (exists.length) {
                    result.push(exists[0].nodeName);
                }
            });
            return result[0] || '';
        },
        set: function (value) {
            var self = this;
            enumValues.forEach(function (enumVal) {
                var exists = find(self.xml, NS, enumVal);
                if (exists.length) {
                    self.xml.removeChild(exists[0]);
                }
            });

            if (value) {
                var condition = createElement(NS, value);
                this.xml.appendChild(condition);
            }
        }
    };
};

exports.subExtension = function (name, NS, sub, ChildJXT) {
    return {
        get: function () {
            if (!this._extensions[name]) {
                var wrapper = find(this.xml, NS, sub);
                if (!wrapper.length) {
                    wrapper= createElement(NS, sub, this._NS);
                    this.xml.appendChild(wrapper);
                } else {
                    wrapper = wrapper[0];
                }

                var existing = find(wrapper, ChildJXT.prototype._NS, ChildJXT.prototype._EL);
                if (!existing.length) {
                    this._extensions[name] = new ChildJXT({}, null, {xml: wrapper});
                    wrapper.appendChild(this._extensions[name].xml);
                } else {
                    this._extensions[name] = new ChildJXT(null, existing[0], {xml: wrapper});
                }
                this._extensions[name].parent = this;
            }
            return this._extensions[name];
        },
        set: function (value) {
            var wrapper = find(this.xml, NS, sub);
            if (wrapper.length && !value) {
                this.xml.removeChild(wrapper[0]);
            }

            if (value) {
                var child = this[name];
                if (value === true) {
                    value = {};
                }
                extend(child, value);
            }
        }
    };
};

exports.subMultiExtension = function (NS, sub, ChildJXT) {
    return {
        get: function () {
            var self = this;
            var results = [];
            var existing = find(this.xml, NS, sub);
            if (!existing.length) {
                return results;
            }
            existing = existing[0];
            var data = find(existing, ChildJXT.prototype._NS, ChildJXT.prototype._EL);

            data.forEach(function (xml) {
                results.push(new ChildJXT({}, xml, self));
            });
            return results;
        },
        set: function (values) {
            var self = this;
            var existing = find(this.xml, NS, sub);
            if (existing.length) {
                self.xml.removeChild(existing[0]);
            }

            if (!values.length) {
                return;
            }

            existing = createElement(NS, sub, this._NS);

            values.forEach(function (value) {
                var content = new ChildJXT(value, null, self);
                existing.appendChild(content.xml);
            });

            self.xml.appendChild(existing);
        }
    };
};

},{"./helpers":408,"atob":411,"btoa":412,"extend-object":413}],411:[function(require,module,exports){
(function (Buffer){
(function () {
  "use strict";

  function atob(str) {
    return new Buffer(str, 'base64').toString('binary');
  }

  module.exports = atob;
}());

}).call(this,require("buffer").Buffer)
},{"buffer":5}],412:[function(require,module,exports){
(function (Buffer){
(function () {
  "use strict";

  function btoa(str) {
    var buffer
      ;

    if (str instanceof Buffer) {
      buffer = str;
    } else {
      buffer = new Buffer(str.toString(), 'binary');
    }

    return buffer.toString('base64');
  }

  module.exports = btoa;
}());

}).call(this,require("buffer").Buffer)
},{"buffer":5}],413:[function(require,module,exports){
module.exports=require(385)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/jingle/node_modules/extend-object/extend-object.js":385}],414:[function(require,module,exports){
'use strict';

var util = require('util')
  , Element = require('./element').Element

function DOMElement(name, attrs) {
    Element.call(this, name, attrs)

    this.nodeType = 1
    this.nodeName = this.localName
}

util.inherits(DOMElement, Element)

DOMElement.prototype._getElement = function(name, attrs) {
    var element = new DOMElement(name, attrs)
    return element
}

Object.defineProperty(DOMElement.prototype, 'localName', {
    get: function () {
        return this.getName()
    }
})

Object.defineProperty(DOMElement.prototype, 'namespaceURI', {
    get: function () {
        return this.getNS()
    }
})

Object.defineProperty(DOMElement.prototype, 'parentNode', {
    get: function () {
        return this.parent
    }
})

Object.defineProperty(DOMElement.prototype, 'childNodes', {
    get: function () {
        return this.children
    }
})

Object.defineProperty(DOMElement.prototype, 'textContent', {
    get: function () {
        return this.getText()
    },
    set: function (value) {
        this.children.push(value)
    }
})

DOMElement.prototype.getElementsByTagName = function (name) {
    return this.getChildren(name)
}

DOMElement.prototype.getAttribute = function (name) {
    return this.getAttr(name)
}

DOMElement.prototype.setAttribute = function (name, value) {
    this.attr(name, value)
}

DOMElement.prototype.getAttributeNS = function (ns, name) {
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        return this.getAttr(['xml', name].join(':'))
    }
    return this.getAttr(name, ns)
}

DOMElement.prototype.setAttributeNS = function (ns, name, value) {
    var prefix
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        prefix = 'xml'
    } else {
        var nss = this.getXmlns()
        prefix = nss[ns] || ''
    }
    if (prefix) {
        this.attr([prefix, name].join(':'), value)
    }
}

DOMElement.prototype.removeAttribute = function (name) {
    this.attr(name, null)
}

DOMElement.prototype.removeAttributeNS = function (ns, name) {
    var prefix
    if (ns === 'http://www.w3.org/XML/1998/namespace') {
        prefix = 'xml'
    } else {
        var nss = this.getXmlns()
        prefix = nss[ns] || ''
    }
    if (prefix) {
        this.attr([prefix, name].join(':'), null)
    }
}

DOMElement.prototype.appendChild = function (el) {
    this.cnode(el)
}

DOMElement.prototype.removeChild = function (el) {
    this.remove(el)
}

module.exports = DOMElement

},{"./element":415,"util":165}],415:[function(require,module,exports){
'use strict';

/**
 * This cheap replica of DOM/Builder puts me to shame :-)
 *
 * Attributes are in the element.attrs object. Children is a list of
 * either other Elements or Strings for text content.
 **/
function Element(name, attrs) {
    this.name = name
    this.parent = null
    this.attrs = attrs || {}
    this.children = []
}

/*** Accessors ***/

/**
 * if (element.is('message', 'jabber:client')) ...
 **/
Element.prototype.is = function(name, xmlns) {
    return (this.getName() === name) &&
        (!xmlns || (this.getNS() === xmlns))
}

/* without prefix */
Element.prototype.getName = function() {
    if (this.name.indexOf(':') >= 0)
        return this.name.substr(this.name.indexOf(':') + 1)
    else
        return this.name
}

/**
 * retrieves the namespace of the current element, upwards recursively
 **/
Element.prototype.getNS = function() {
    if (this.name.indexOf(':') >= 0) {
        var prefix = this.name.substr(0, this.name.indexOf(':'))
        return this.findNS(prefix)
    } else {
        return this.findNS()
    }
}

/**
 * find the namespace to the given prefix, upwards recursively
 **/
Element.prototype.findNS = function(prefix) {
    if (!prefix) {
        /* default namespace */
        if (this.attrs.xmlns)
            return this.attrs.xmlns
        else if (this.parent)
            return this.parent.findNS()
    } else {
        /* prefixed namespace */
        var attr = 'xmlns:' + prefix
        if (this.attrs[attr])
            return this.attrs[attr]
        else if (this.parent)
            return this.parent.findNS(prefix)
    }
}

/**
 * Recursiverly gets all xmlns defined, in the form of {url:prefix}
 **/
Element.prototype.getXmlns = function() {
    var namespaces = {}

    if (this.parent)
        namespaces = this.parent.getXmlns()

    for (var attr in this.attrs) {
        var m = attr.match('xmlns:?(.*)')
        if (this.attrs.hasOwnProperty(attr) && m) {
            namespaces[this.attrs[attr]] = m[1]
        }
    }
    return namespaces
}


/**
 * xmlns can be null, returns the matching attribute.
 **/
Element.prototype.getAttr = function(name, xmlns) {
    if (!xmlns)
        return this.attrs[name]

    var namespaces = this.getXmlns()

    if (!namespaces[xmlns])
        return null

    return this.attrs[[namespaces[xmlns], name].join(':')]
}

/**
 * xmlns can be null
 **/
Element.prototype.getChild = function(name, xmlns) {
    return this.getChildren(name, xmlns)[0]
}

/**
 * xmlns can be null
 **/
Element.prototype.getChildren = function(name, xmlns) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (child.getName &&
            (child.getName() === name) &&
            (!xmlns || (child.getNS() === xmlns)))
            result.push(child)
    }
    return result
}

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildByAttr = function(attr, val, xmlns, recursive) {
    return this.getChildrenByAttr(attr, val, xmlns, recursive)[0]
}

/**
 * xmlns and recursive can be null
 **/
Element.prototype.getChildrenByAttr = function(attr, val, xmlns, recursive) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (child.attrs &&
            (child.attrs[attr] === val) &&
            (!xmlns || (child.getNS() === xmlns)))
            result.push(child)
        if (recursive && child.getChildrenByAttr) {
            result.push(child.getChildrenByAttr(attr, val, xmlns, true))
        }
    }
    if (recursive) result = [].concat.apply([], result)
    return result
}

Element.prototype.getChildrenByFilter = function(filter, recursive) {
    var result = []
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if (filter(child))
            result.push(child)
        if (recursive && child.getChildrenByFilter){
            result.push(child.getChildrenByFilter(filter, true))
        }
    }
    if (recursive) {
        result = [].concat.apply([], result)
    }
    return result
}

Element.prototype.getText = function() {
    var text = ''
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        if ((typeof child === 'string') || (typeof child === 'number')) {
            text += child
        }
    }
    return text
}

Element.prototype.getChildText = function(name, xmlns) {
    var child = this.getChild(name, xmlns)
    return child ? child.getText() : null
}

/**
 * Return all direct descendents that are Elements.
 * This differs from `getChildren` in that it will exclude text nodes,
 * processing instructions, etc.
 */
Element.prototype.getChildElements = function() {
    return this.getChildrenByFilter(function(child) {
        return child instanceof Element
    })
}

/*** Builder ***/

/** returns uppermost parent */
Element.prototype.root = function() {
    if (this.parent)
        return this.parent.root()
    else
        return this
}
Element.prototype.tree = Element.prototype.root

/** just parent or itself */
Element.prototype.up = function() {
    if (this.parent)
        return this.parent
    else
        return this
}

Element.prototype._getElement = function(name, attrs) {
    var element = new Element(name, attrs)
    return element
}

/** create child node and return it */
Element.prototype.c = function(name, attrs) {
    return this.cnode(this._getElement(name, attrs))
}

Element.prototype.cnode = function(child) {
    this.children.push(child)
    child.parent = this
    return child
}

/** add text node and return element */
Element.prototype.t = function(text) {
    this.children.push(text)
    return this
}

/*** Manipulation ***/

/**
 * Either:
 *   el.remove(childEl)
 *   el.remove('author', 'urn:...')
 */
Element.prototype.remove = function(el, xmlns) {
    var filter
    if (typeof el === 'string') {
        /* 1st parameter is tag name */
        filter = function(child) {
            return !(child.is &&
                 child.is(el, xmlns))
        }
    } else {
        /* 1st parameter is element */
        filter = function(child) {
            return child !== el
        }
    }

    this.children = this.children.filter(filter)

    return this
}

/**
 * To use in case you want the same XML data for separate uses.
 * Please refrain from this practise unless you know what you are
 * doing. Building XML with ltx is easy!
 */
Element.prototype.clone = function() {
    var clone = this._getElement(this.name, {})
    for (var k in this.attrs) {
        if (this.attrs.hasOwnProperty(k))
            clone.attrs[k] = this.attrs[k]
    }
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        clone.cnode(child.clone ? child.clone() : child)
    }
    return clone
}

Element.prototype.text = function(val) {
    if (val && this.children.length === 1) {
        this.children[0] = val
        return this
    }
    return this.getText()
}

Element.prototype.attr = function(attr, val) {
    if (((typeof val !== 'undefined') || (val === null))) {
        if (!this.attrs) {
            this.attrs = {}
        }
        this.attrs[attr] = val
        return this
    }
    return this.attrs[attr]
}

/*** Serialization ***/

Element.prototype.toString = function() {
    var s = ''
    this.write(function(c) {
        s += c
    })
    return s
}

Element.prototype.toJSON = function() {
    return {
        name: this.name,
        attrs: this.attrs,
        children: this.children.map(function(child) {
            return child && child.toJSON ? child.toJSON() : child;
        })
    }
}

Element.prototype._addChildren = function(writer) {
    writer('>')
    for (var i = 0; i < this.children.length; i++) {
        var child = this.children[i]
        /* Skip null/undefined */
        if (child || (child === 0)) {
            if (child.write) {
                child.write(writer)
            } else if (typeof child === 'string') {
                writer(escapeXmlText(child))
            } else if (child.toString) {
                writer(escapeXmlText(child.toString(10)))
            }
        }
    }
    writer('</')
    writer(this.name)
    writer('>')
}

Element.prototype.write = function(writer) {
    writer('<')
    writer(this.name)
    for (var k in this.attrs) {
        var v = this.attrs[k]
        if (v || (v === '') || (v === 0)) {
            writer(' ')
            writer(k)
            writer('="')
            if (typeof v !== 'string') {
                v = v.toString(10)
            }
            writer(escapeXml(v))
            writer('"')
        }
    }
    if (this.children.length === 0) {
        writer('/>')
    } else {
        this._addChildren(writer)
    }
}

function escapeXml(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;').
        replace(/"/g, '&quot;').
        replace(/"/g, '&apos;')
}

function escapeXmlText(s) {
    return s.
        replace(/\&/g, '&amp;').
        replace(/</g, '&lt;').
        replace(/>/g, '&gt;')
}

exports.Element = Element
exports.escapeXml = escapeXml

},{}],416:[function(require,module,exports){
'use strict';

/* Cause browserify to bundle SAX parsers: */
var parse = require('./parse')

parse.availableSaxParsers.push(parse.bestSaxParser = require('./sax/sax_ltx'))

/* SHIM */
module.exports = require('./index')
},{"./index":417,"./parse":418,"./sax/sax_ltx":419}],417:[function(require,module,exports){
'use strict';

var parse = require('./parse')

/**
 * The only (relevant) data structure
 */
exports.Element = require('./dom-element')

/**
 * Helper
 */
exports.escapeXml = require('./element').escapeXml

/**
 * DOM parser interface
 */
exports.parse = parse.parse
exports.Parser = parse.Parser

/**
 * SAX parser interface
 */
exports.availableSaxParsers = parse.availableSaxParsers
exports.bestSaxParser = parse.bestSaxParser

},{"./dom-element":414,"./element":415,"./parse":418}],418:[function(require,module,exports){
'use strict';

var events = require('events')
  , util = require('util')
  , DOMElement = require('./dom-element')


exports.availableSaxParsers = []
exports.bestSaxParser = null

var saxParsers = [
    './sax/sax_expat.js',
    './sax/sax_ltx.js',
    /*'./sax_easysax.js', './sax_node-xml.js',*/
    './sax/sax_saxjs.js'
]

saxParsers.forEach(function(modName) {
    var mod
    try {
        mod = require(modName)
    } catch (e) {
        /* Silently missing libraries drop for debug:
        console.error(e.stack || e)
         */
    }
    if (mod) {
        exports.availableSaxParsers.push(mod)
        if (!exports.bestSaxParser) {
            exports.bestSaxParser = mod
        }
    }
})

exports.Parser = function(saxParser) {
    events.EventEmitter.call(this)
    var self = this

    var ParserMod = saxParser || exports.bestSaxParser
    if (!ParserMod) {
        throw new Error('No SAX parser available')
    }
    this.parser = new ParserMod()

    var el
    this.parser.addListener('startElement', function(name, attrs) {
        var child = new DOMElement(name, attrs)
        if (!el) {
            el = child
        } else {
            el = el.cnode(child)
        }
    })
    this.parser.addListener('endElement', function(name) {
        /* jshint -W035 */
        if (!el) {
            /* Err */
        } else if (name === el.name) {
            if (el.parent) {
                el = el.parent
            } else if (!self.tree) {
                self.tree = el
                el = undefined
            }
        }
        /* jshint +W035 */
    })
    this.parser.addListener('text', function(str) {
        if (el) {
            el.t(str)
        }
    })
    this.parser.addListener('error', function(e) {
        self.error = e
        self.emit('error', e)
    })
}

util.inherits(exports.Parser, events.EventEmitter)

exports.Parser.prototype.write = function(data) {
    this.parser.write(data)
}

exports.Parser.prototype.end = function(data) {
    this.parser.end(data)

    if (!this.error) {
        if (this.tree) {
            this.emit('tree', this.tree)
        } else {
            this.emit('error', new Error('Incomplete document'))
        }
    }
}

exports.parse = function(data, saxParser) {
    var p = new exports.Parser(saxParser)
    var result = null
      , error = null

    p.on('tree', function(tree) {
        result = tree
    })
    p.on('error', function(e) {
        error = e
    })

    p.write(data)
    p.end()

    if (error) {
        throw error
    } else {
        return result
    }
}

},{"./dom-element":414,"events":145,"util":165}],419:[function(require,module,exports){
'use strict';

var util = require('util')
  , events = require('events')

var STATE_TEXT = 0,
    STATE_IGNORE_TAG = 1,
    STATE_TAG_NAME = 2,
    STATE_TAG = 3,
    STATE_ATTR_NAME = 4,
    STATE_ATTR_EQ = 5,
    STATE_ATTR_QUOT = 6,
    STATE_ATTR_VALUE = 7

var SaxLtx = module.exports = function SaxLtx() {
    events.EventEmitter.call(this)

    var state = STATE_TEXT, remainder
    var tagName, attrs, endTag, selfClosing, attrQuote
    var recordStart = 0
    var attrName

    this._handleTagOpening = function(endTag, tagName, attrs) {
        if (!endTag) {
            this.emit('startElement', tagName, attrs)
            if (selfClosing) {
                this.emit('endElement', tagName)
            }
        } else {
            this.emit('endElement', tagName)
        }
    }

    this.write = function(data) {
        /* jshint -W071 */
        /* jshint -W074 */
        if (typeof data !== 'string') {
            data = data.toString()
        }
        var pos = 0

        /* Anything from previous write()? */
        if (remainder) {
            data = remainder + data
            pos += remainder.length
            remainder = null
        }

        function endRecording() {
            if (typeof recordStart === 'number') {
                var recorded = data.slice(recordStart, pos)
                recordStart = undefined
                return recorded
            }
        }

        for(; pos < data.length; pos++) {
            var c = data.charCodeAt(pos)
            //console.log("state", state, "c", c, data[pos])
            switch(state) {
            case STATE_TEXT:
                if (c === 60 /* < */) {
                    var text = endRecording()
                    if (text) {
                        this.emit('text', unescapeXml(text))
                    }
                    state = STATE_TAG_NAME
                    recordStart = pos + 1
                    attrs = {}
                }
                break
            case STATE_TAG_NAME:
                if (c === 47 /* / */ && recordStart === pos) {
                    recordStart = pos + 1
                    endTag = true
                } else if (c === 33 /* ! */ || c === 63 /* ? */) {
                    recordStart = undefined
                    state = STATE_IGNORE_TAG
                } else if (c <= 32 || c === 47 /* / */ || c === 62 /* > */) {
                    tagName = endRecording()
                    pos--
                    state = STATE_TAG
                }
                break
            case STATE_IGNORE_TAG:
                if (c === 62 /* > */) {
                    state = STATE_TEXT
                }
                break
            case STATE_TAG:
                if (c === 62 /* > */) {
                    this._handleTagOpening(endTag, tagName, attrs)
                    tagName = undefined
                    attrs = undefined
                    endTag = undefined
                    selfClosing = undefined
                    state = STATE_TEXT
                    recordStart = pos + 1
                } else if (c === 47 /* / */) {
                    selfClosing = true
                } else if (c > 32) {
                    recordStart = pos
                    state = STATE_ATTR_NAME
                }
                break
            case STATE_ATTR_NAME:
                if (c <= 32 || c === 61 /* = */) {
                    attrName = endRecording()
                    pos--
                    state = STATE_ATTR_EQ
                }
                break
            case STATE_ATTR_EQ:
                if (c === 61 /* = */) {
                    state = STATE_ATTR_QUOT
                }
                break
            case STATE_ATTR_QUOT:
                if (c === 34 /* " */ || c === 39 /* ' */) {
                    attrQuote = c
                    state = STATE_ATTR_VALUE
                    recordStart = pos + 1
                }
                break
            case STATE_ATTR_VALUE:
                if (c === attrQuote) {
                    var value = unescapeXml(endRecording())
                    attrs[attrName] = value
                    attrName = undefined
                    state = STATE_TAG
                }
                break
            }
        }

        if (typeof recordStart === 'number' &&
            recordStart <= data.length) {

            remainder = data.slice(recordStart)
            recordStart = 0
        }
    }

    /*var origEmit = this.emit
    this.emit = function() {
    console.log('ltx', arguments)
    origEmit.apply(this, arguments)
    }*/
}
util.inherits(SaxLtx, events.EventEmitter)


SaxLtx.prototype.end = function(data) {
    if (data) {
        this.write(data)
    }

    /* Uh, yeah */
    this.write = function() {}
}

function unescapeXml(s) {
    return s.
        replace(/\&(amp|#38);/g, '&').
        replace(/\&(lt|#60);/g, '<').
        replace(/\&(gt|#62);/g, '>').
        replace(/\&(quot|#34);/g, '"').
        replace(/\&(apos|#39);/g, '\'').
        replace(/\&(nbsp|#160);/g, '\n')
}

},{"events":145,"util":165}],420:[function(require,module,exports){
//     uuid.js
//
//     Copyright (c) 2010-2012 Robert Kieffer
//     MIT License - http://opensource.org/licenses/mit-license.php

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(_global.require) == 'function') {
    try {
      var _rb = _global.require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(_global.Buffer) == 'function' ? _global.Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);

},{}],421:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * ANONYMOUS `Mechanism` constructor.
   *
   * This class implements the ANONYMOUS SASL mechanism.
   *
   * The ANONYMOUS SASL mechanism provides support for permitting anonymous
   * access to various services
   *
   * References:
   *  - [RFC 4505](http://tools.ietf.org/html/rfc4505)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'ANONYMOUS';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using optional trace information.
   *
   * Options:
   *  - `trace`  trace information (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    return cred.trace || '';
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
  };

  exports = module.exports = Mechanism;
  
}));

},{}],422:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports,
            module,
            require('./lib/mechanism'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports',
            'module',
            './lib/mechanism'], factory);
  }
}(this, function(exports, module, Mechanism) {

  exports = module.exports = Mechanism;
  exports.Mechanism = Mechanism;
  
}));

},{"./lib/mechanism":421}],423:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * EXTERNAL `Mechanism` constructor.
   *
   * This class implements the EXTERNAL SASL mechanism.
   *
   * The EXTERNAL SASL mechanism provides support for authentication using
   * credentials established by external means. 
   *
   * References:
   *  - [RFC 4422](http://tools.ietf.org/html/rfc4422)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'EXTERNAL';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using given credential.
   *
   * Options:
   *  - `authzid`   authorization identity (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    return cred.authzid || '';
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
  };

  exports = module.exports = Mechanism;
  
}));

},{}],424:[function(require,module,exports){
arguments[4][422][0].apply(exports,arguments)
},{"./lib/mechanism":423,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/sasl-anonymous/main.js":422}],425:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {

  /**
   * PLAIN `Mechanism` constructor.
   *
   * This class implements the PLAIN SASL mechanism.
   *
   * The PLAIN SASL mechanism provides support for exchanging a clear-text
   * username and password.  This mechanism should not be used without adequate
   * security provided by an underlying transport layer. 
   *
   * References:
   *  - [RFC 4616](http://tools.ietf.org/html/rfc4616)
   *
   * @api public
   */
  function Mechanism() {
  }
  
  Mechanism.prototype.name = 'PLAIN';
  Mechanism.prototype.clientFirst = true;
  
  /**
   * Encode a response using given credential.
   *
   * Options:
   *  - `username`
   *  - `password`
   *  - `authzid`   authorization identity (optional)
   *
   * @param {Object} cred
   * @api public
   */
  Mechanism.prototype.response = function(cred) {
    var str = '';
    str += cred.authzid || '';
    str += '\0';
    str += cred.username;
    str += '\0';
    str += cred.password;
    return str;
  };
  
  /**
   * Decode a challenge issued by the server.
   *
   * @param {String} chal
   * @return {Mechanism} for chaining
   * @api public
   */
  Mechanism.prototype.challenge = function(chal) {
    return this;
  };

  exports = module.exports = Mechanism;
  
}));

},{}],426:[function(require,module,exports){
arguments[4][422][0].apply(exports,arguments)
},{"./lib/mechanism":425,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/stanza.io/node_modules/sasl-anonymous/main.js":422}],427:[function(require,module,exports){
(function (Buffer){
var bitops = require('./lib/bitops');
var utils = require('./lib/utils');

var RESP = {};


function Mechanism(options) {
    options = options || {};
    this._genNonce = options.genNonce || utils.genNonce;
    this._stage = 'initial';
}

// Conform to the SASL lib's expectations
Mechanism.Mechanism = Mechanism;


Mechanism.prototype.name = 'SCRAM-SHA-1';
Mechanism.prototype.clientFirst = true;


Mechanism.prototype.response = function (cred) {
    return RESP[this._stage](this, cred);
};

Mechanism.prototype.challenge = function (chal) {
    var values = utils.parse(chal);

    this._salt = new Buffer(values.s || '', 'base64');
    this._iterationCount = parseInt(values.i, 10);
    this._nonce = values.r;
    this._verifier = values.v;
    this._error = values.e;
    this._challenge = chal;

    return this;
};


RESP.initial = function (mech, cred) {
    mech._cnonce = mech._genNonce();

    var authzid = '';
    if (cred.authzid) {
        authzid = 'a=' + utils.saslname(cred.authzid);
    }

    mech._gs2Header = 'n,' + authzid + ',';

    var nonce = 'r=' + mech._cnonce;
    var username = 'n=' + utils.saslname(cred.username);

    mech._clientFirstMessageBare = username + ',' + nonce;
    var result = mech._gs2Header + mech._clientFirstMessageBare;

    mech._stage = 'challenge';

    return result;
};


RESP.challenge = function (mech, cred) {
    var gs2Header = new Buffer(mech._gs2Header).toString('base64');

    mech._clientFinalMessageWithoutProof = 'c=' + gs2Header + ',r=' + mech._nonce;

    var saltedPassword, clientKey, serverKey;
    if (cred.clientKey && cred.serverKey) {
        clientKey = cred.clientKey;
        serverKey = cred.serverKey;
    } else {
        saltedPassword = cred.saltedPassword || bitops.Hi(cred.password, mech._salt, mech._iterationCount);
        clientKey = bitops.HMAC(saltedPassword, 'Client Key');
        serverKey = bitops.HMAC(saltedPassword, 'Server Key');
    }

    var storedKey = bitops.H(clientKey);
    var authMessage = mech._clientFirstMessageBare + ',' +
                      mech._challenge + ',' +
                      mech._clientFinalMessageWithoutProof;
    var clientSignature = bitops.HMAC(storedKey, authMessage);

    var clientProof = bitops.XOR(clientKey, clientSignature).toString('base64');

    mech._serverSignature = bitops.HMAC(serverKey, authMessage);

    var result = mech._clientFinalMessageWithoutProof + ',p=' + clientProof;

    mech._stage = 'final';

    mech.cache = {
        saltedPassword: saltedPassword,
        clientKey: clientKey,
        serverKey: serverKey
    };

    return result;
};

RESP.final = function () {
    // TODO: Signal errors
    return '';
};



module.exports = Mechanism;

}).call(this,require("buffer").Buffer)
},{"./lib/bitops":428,"./lib/utils":429,"buffer":5}],428:[function(require,module,exports){
(function (Buffer){
var createHash = require('create-hash');
var createHmac = require('create-hmac');
var xor = require('bitwise-xor');


exports.XOR = xor;

exports.H = function (text) {
    return createHash('sha1').update(text).digest();
};

exports.HMAC = function (key, msg) {
    return createHmac('sha1', key).update(msg).digest();
};

exports.Hi = function (text, salt, iterations) {
    var ui1 = exports.HMAC(text, Buffer.concat([salt, new Buffer([0, 0, 0, 1], 'binary')]));
    var ui = ui1;
    for (var i = 0; i < iterations - 1; i++) {
        ui1 = exports.HMAC(text, ui1);
        ui = exports.XOR(ui, ui1);
    }

    return ui;
};


}).call(this,require("buffer").Buffer)
},{"bitwise-xor":430,"buffer":5,"create-hash":431,"create-hmac":443}],429:[function(require,module,exports){
var randomBytes = require('randombytes');


exports.parse = function (chal) {
    var dtives = {};
    var tokens = chal.split(/,(?=(?:[^"]|"[^"]*")*$)/);
    for (var i = 0, len = tokens.length; i < len; i++) {
        var dtiv = /(\w+)=["]?([^"]+)["]?$/.exec(tokens[i]);
        if (dtiv) {
            dtives[dtiv[1]] = dtiv[2];
        }
    }
    return dtives;
};

exports.saslname = function (name) {
    var escaped = [];
    var curr = '';
    for (var i = 0; i < name.length; i++) {
        curr = name[i];
        if (curr === ',') {
            escaped.push('=2C');
        } else if (curr === '=') {
            escaped.push('=3D');
        } else {
            escaped.push(curr);
        }
    }
    return escaped.join('');
};

exports.genNonce = function (len) {
    return randomBytes((len || 32) / 2).toString('hex');
};

},{"randombytes":445}],430:[function(require,module,exports){
(function (Buffer){
module.exports = xor

function xor(a, b) {
  if (!Buffer.isBuffer(a)) a = new Buffer(a)
  if (!Buffer.isBuffer(b)) b = new Buffer(b)
  var res = []
  if (a.length > b.length) {
    for (var i = 0; i < b.length; i++) {
      res.push(a[i] ^ b[i])
    }
  } else {
    for (var i = 0; i < a.length; i++) {
      res.push(a[i] ^ b[i])
    }
  }
  return new Buffer(res);
}

}).call(this,require("buffer").Buffer)
},{"buffer":5}],431:[function(require,module,exports){
module.exports=require(97)
},{"./md5":433,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/browser.js":97,"buffer":5,"inherits":434,"ripemd160":435,"sha.js":437,"stream":163}],432:[function(require,module,exports){
module.exports=require(98)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/helpers.js":98,"buffer":5}],433:[function(require,module,exports){
module.exports=require(99)
},{"./helpers":432,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/md5.js":99}],434:[function(require,module,exports){
module.exports=require(146)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/inherits/inherits_browser.js":146}],435:[function(require,module,exports){
module.exports=require(100)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/ripemd160/lib/ripemd160.js":100,"buffer":5}],436:[function(require,module,exports){
module.exports=require(101)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/hash.js":101,"buffer":5}],437:[function(require,module,exports){
module.exports=require(102)
},{"./sha1":438,"./sha224":439,"./sha256":440,"./sha384":441,"./sha512":442,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/index.js":102}],438:[function(require,module,exports){
module.exports=require(103)
},{"./hash":436,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha1.js":103,"buffer":5,"inherits":434}],439:[function(require,module,exports){
module.exports=require(104)
},{"./hash":436,"./sha256":440,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha224.js":104,"buffer":5,"inherits":434}],440:[function(require,module,exports){
module.exports=require(105)
},{"./hash":436,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha256.js":105,"buffer":5,"inherits":434}],441:[function(require,module,exports){
module.exports=require(106)
},{"./hash":436,"./sha512":442,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha384.js":106,"buffer":5,"inherits":434}],442:[function(require,module,exports){
module.exports=require(107)
},{"./hash":436,"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hash/node_modules/sha.js/sha512.js":107,"buffer":5,"inherits":434}],443:[function(require,module,exports){
module.exports=require(108)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/create-hmac/browser.js":108,"buffer":5,"create-hash/browser":431,"inherits":444,"stream":163}],444:[function(require,module,exports){
module.exports=require(146)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/inherits/inherits_browser.js":146}],445:[function(require,module,exports){
module.exports=require(144)
},{"/Users/dominiksteiner/Documents/workspace-broadsoft/webrtc/node_modules/browserify/node_modules/crypto-browserify/node_modules/randombytes/browser.js":144,"_process":149,"buffer":5}],446:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports, module);
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports', 'module'], factory);
  }
}(this, function(exports, module) {
  
  /**
   * `Factory` constructor.
   *
   * @api public
   */
  function Factory() {
    this._mechs = [];
  }
  
  /**
   * Utilize the given `mech` with optional `name`, overridding the mechanism's
   * default name.
   *
   * Examples:
   *
   *     factory.use(FooMechanism);
   *
   *     factory.use('XFOO', FooMechanism);
   *
   * @param {String|Mechanism} name
   * @param {Mechanism} mech
   * @return {Factory} for chaining
   * @api public
   */
  Factory.prototype.use = function(name, mech) {
    if (!mech) {
      mech = name;
      name = mech.prototype.name;
    }
    this._mechs.push({ name: name, mech: mech });
    return this;
  };
  
  /**
   * Create a new mechanism from supported list of `mechs`.
   *
   * If no mechanisms are supported, returns `null`.
   *
   * Examples:
   *
   *     var mech = factory.create(['FOO', 'BAR']);
   *
   * @param {Array} mechs
   * @return {Mechanism}
   * @api public
   */
  Factory.prototype.create = function(mechs) {
    for (var i = 0, len = this._mechs.length; i < len; i++) {
      for (var j = 0, jlen = mechs.length; j < jlen; j++) {
        var entry = this._mechs[i];
        if (entry.name == mechs[j]) {
          return new entry.mech();
        }
      }
    }
    return null;
  };

  exports = module.exports = Factory;
  
}));

},{}],447:[function(require,module,exports){
(function(root, factory) {
  if (typeof exports === 'object') {
    // CommonJS
    factory(exports,
            module,
            require('./lib/factory'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD
    define(['exports',
            'module',
            './lib/factory'], factory);
  }
}(this, function(exports, module, Factory) {
  
  exports = module.exports = Factory;
  exports.Factory = Factory;
  
}));

},{"./lib/factory":446}],448:[function(require,module,exports){
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);

},{}],449:[function(require,module,exports){
/*
WildEmitter.js is a slim little event emitter by @henrikjoreteg largely based 
on @visionmedia's Emitter from UI Kit.

Why? I wanted it standalone.

I also wanted support for wildcard emitters like this:

emitter.on('*', function (eventName, other, event, payloads) {
    
});

emitter.on('somenamespace*', function (eventName, payloads) {
    
});

Please note that callbacks triggered by wildcard registered events also get 
the event name as the first argument.
*/
module.exports = WildEmitter;

function WildEmitter() {
    this.callbacks = {};
}

// Listen on the given `event` with `fn`. Store a group name if present.
WildEmitter.prototype.on = function (event, groupName, fn) {
    var hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    func._groupName = group;
    (this.callbacks[event] = this.callbacks[event] || []).push(func);
    return this;
};

// Adds an `event` listener that will be invoked a single
// time then automatically removed.
WildEmitter.prototype.once = function (event, groupName, fn) {
    var self = this,
        hasGroup = (arguments.length === 3),
        group = hasGroup ? arguments[1] : undefined,
        func = hasGroup ? arguments[2] : arguments[1];
    function on() {
        self.off(event, on);
        func.apply(this, arguments);
    }
    this.on(event, group, on);
    return this;
};

// Unbinds an entire group
WildEmitter.prototype.releaseGroup = function (groupName) {
    var item, i, len, handlers;
    for (item in this.callbacks) {
        handlers = this.callbacks[item];
        for (i = 0, len = handlers.length; i < len; i++) {
            if (handlers[i]._groupName === groupName) {
                //console.log('removing');
                // remove it and shorten the array we're looping through
                handlers.splice(i, 1);
                i--;
                len--;
            }
        }
    }
    return this;
};

// Remove the given callback for `event` or all
// registered callbacks.
WildEmitter.prototype.off = function (event, fn) {
    var callbacks = this.callbacks[event],
        i;

    if (!callbacks) return this;

    // remove all handlers
    if (arguments.length === 1) {
        delete this.callbacks[event];
        return this;
    }

    // remove specific handler
    i = callbacks.indexOf(fn);
    callbacks.splice(i, 1);
    return this;
};

/// Emit `event` with the given args.
// also calls any `*` handlers
WildEmitter.prototype.emit = function (event) {
    var args = [].slice.call(arguments, 1),
        callbacks = this.callbacks[event],
        specialCallbacks = this.getWildcardCallbacks(event),
        i,
        len,
        item,
        listeners;

    if (callbacks) {
        listeners = callbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, args);
            } else {
                break;
            }
        }
    }

    if (specialCallbacks) {
        len = specialCallbacks.length;
        listeners = specialCallbacks.slice();
        for (i = 0, len = listeners.length; i < len; ++i) {
            if (listeners[i]) {
                listeners[i].apply(this, [event].concat(args));
            } else {
                break;
            }
        }
    }

    return this;
};

// Helper for for finding special wildcard event handlers that match the event
WildEmitter.prototype.getWildcardCallbacks = function (eventName) {
    var item,
        split,
        result = [];

    for (item in this.callbacks) {
        split = item.split('*');
        if (item === '*' || (split.length === 2 && eventName.slice(0, split[0].length) === split[0])) {
            result = result.concat(this.callbacks[item]);
        }
    }
    return result;
};

},{}],450:[function(require,module,exports){
'use strict';

var StringPrep = require('./lib/stringprep');


function bareJID(local, domain) {
    if (local) {
        return local + '@' + domain;
    }
    return domain;
}

function fullJID(local, domain, resource) {
    if (resource) {
        return bareJID(local, domain) + '/' + resource;
    }
    return bareJID(local, domain);
}


exports.prep = function (data) {
    var local = data.local;
    var domain = data.domain;
    var resource = data.resource;
    var unescapedLocal = local;

    if (local) {
        local = StringPrep.nodeprep(local);
        unescapedLocal = exports.unescape(local);
    }

    if (resource) {
        resource = StringPrep.resourceprep(resource);
    }

    if (domain[domain.length - 1] === '.') {
        domain = domain.slice(0, domain.length - 1);
    }

    domain = StringPrep.nameprep(domain.split('.').map(StringPrep.toUnicode).join('.'));

    return {
        prepped: data.prepped || StringPrep.available,
        local: local,
        domain: domain,
        resource: resource,
        bare: bareJID(local, domain),
        full: fullJID(local, domain, resource),
        unescapedLocal: unescapedLocal,
        unescapedBare: bareJID(unescapedLocal, domain),
        unescapedFull: fullJID(unescapedLocal, domain, resource)
    };
};

exports.parse = function (jid, trusted) {
    var local = '';
    var domain = '';
    var resource = '';

    // All of our StringPrep fallbacks work correctly
    // in the ASCII range, so we can reliably mark
    // ASCII-only JIDs as prepped.
    trusted = /^[\x00-\x7F]*$/.test(jid);

    var resourceStart = jid.indexOf('/');
    if (resourceStart > 0) {
        resource = jid.slice(resourceStart + 1);
        jid = jid.slice(0, resourceStart);
    }

    var localEnd = jid.indexOf('@');
    if (localEnd > 0) {
        local = jid.slice(0, localEnd);
        jid = jid.slice(localEnd + 1);
    }

    domain = jid;

    var preppedJID = exports.prep({
        local: local,
        domain: domain,
        resource: resource,
    });

    preppedJID.prepped = preppedJID.prepped || trusted;

    return preppedJID;
};

exports.equal = function (jid1, jid2, requirePrep) {
    jid1 = new exports.JID(jid1);
    jid2 = new exports.JID(jid2);
    if (arguments.length === 2) {
        requirePrep = true;
    }
    return jid1.local === jid2.local &&
           jid1.domain === jid2.domain &&
           jid1.resource === jid2.resource &&
           (requirePrep ? jid1.prepped && jid2.prepped : true);
};

exports.equalBare = function (jid1, jid2, requirePrep) {
    jid1 = new exports.JID(jid1);
    jid2 = new exports.JID(jid2);
    if (arguments.length === 2) {
        requirePrep = true;
    }
    return jid1.local === jid2.local &&
           jid1.domain === jid2.domain &&
           (requirePrep ? jid1.prepped && jid2.prepped : true);
};

exports.escape = function (val) {
    return val.replace(/^\s+|\s+$/g, '')
              .replace(/\\5c/g, '\\5c5c')
              .replace(/\\20/g, '\\5c20')
              .replace(/\\22/g, '\\5c22')
              .replace(/\\26/g, '\\5c26')
              .replace(/\\27/g, '\\5c27')
              .replace(/\\2f/g, '\\5c2f')
              .replace(/\\3a/g, '\\5c3a')
              .replace(/\\3c/g, '\\5c3c')
              .replace(/\\3e/g, '\\5c3e')
              .replace(/\\40/g, '\\5c40')
              .replace(/ /g, '\\20')
              .replace(/\"/g, '\\22')
              .replace(/\&/g, '\\26')
              .replace(/\'/g, '\\27')
              .replace(/\//g, '\\2f')
              .replace(/:/g, '\\3a')
              .replace(/</g, '\\3c')
              .replace(/>/g, '\\3e')
              .replace(/@/g, '\\40');
};

exports.unescape = function (val) {
    return val.replace(/\\20/g, ' ')
              .replace(/\\22/g, '"')
              .replace(/\\26/g, '&')
              .replace(/\\27/g, '\'')
              .replace(/\\2f/g, '/')
              .replace(/\\3a/g, ':')
              .replace(/\\3c/g, '<')
              .replace(/\\3e/g, '>')
              .replace(/\\40/g, '@')
              .replace(/\\5c/g, '\\');
};


exports.create = function (local, domain, resource) {
    return new exports.JID(local, domain, resource);
};

exports.JID = function JID(localOrJID, domain, resource) {
    var parsed = {};
    if (localOrJID && !domain && !resource) {
        if (typeof localOrJID === 'string') {
            parsed = exports.parse(localOrJID);
        } else if (localOrJID instanceof exports.JID) {
            parsed = localOrJID;
        } else {
            throw new Error('Invalid argument type');
        }
    } else if (domain) {
        parsed = exports.prep({
            local: exports.escape(localOrJID),
            domain: domain,
            resource: resource
        });
    } else {
        parsed = {};
    }

    this.local = parsed.local || '';
    this.domain = parsed.domain || '';
    this.resource = parsed.resource || '';
    this.bare = parsed.bare || '';
    this.full = parsed.full || '';

    this.unescapedLocal = parsed.unescapedLocal || '';
    this.unescapedBare = parsed.unescapedBare || '';
    this.unescapedFull = parsed.unescapedFull || '';

    this.prepped = parsed.prepped;
};

exports.JID.prototype.toString = function () {
    return this.full;
};

exports.JID.prototype.toJSON = function () {
    return this.full;
};

},{"./lib/stringprep":451}],451:[function(require,module,exports){
'use strict';

var punycode = require('punycode');


exports.available = false;

exports.toUnicode = punycode.toUnicode;

exports.nameprep = function (str) {
    return str.toLowerCase();
};

exports.nodeprep = function (str) {
    return str.toLowerCase();
};

exports.resourceprep = function (str) {
    return str;
};

},{"punycode":150}],452:[function(require,module,exports){
var C = {
    // RTCSession states
  STATE_CONNECTED: "connected",
  STATE_DISCONNECTED: "disconnected",
  STATE_CALLING: "calling",
  STATE_STARTED: "started",
  STATE_HELD: "held",
  WIDESCREEN: 'widescreen',
  STANDARD: 'standard',
  R_1280x720: '1280x720',
  R_640x360: '640x360',
  R_320x180: '320x180',
  R_960x720: '960x720',
  R_640x480: '640x480',
  R_320x240: '320x240',
  DEFAULT_DURATION: 500,
  DEFAULT_INTER_TONE_GAP: 200,
  EXPIRES: 365,

  TEMPLATES: '$TEMPLATES$',

  CSS: '$CSS$',

  MEDIA: '$MEDIA$',

  FONTS: '$FONTS$',

  STYLES: {
    iconHightlightColor: '#00adef',
    infoMessageColor: '#999999',
    successMessageColor: '#00FF00',
    warningMessageColor: '#FFFF00',
    alertMessageColor: '#FF0000',
    statsColor: '#999999',
    timerColor: '#FFFFFF'
  }

};
C.DEFAULT_RESOLUTION_ENCODING = C.R_640x480;
C.DEFAULT_RESOLUTION_DISPLAY = C.R_640x480;
C.RESOLUTION_TYPES = {
  'standard': C.STANDARD,
  'widescreen': C.WIDESCREEN
};
C.STANDARD_RESOLUTIONS = {
  '960 x 720': C.R_960x720,
  '640 x 480': C.R_640x480,
  '320 x 240': C.R_320x240
};
C.WIDESCREEN_RESOLUTIONS = {
  '1280 x 720': C.R_1280x720,
  '640 x 360': C.R_640x360,
  '320 x 180': C.R_320x180
};

module.exports = C;
},{}],453:[function(require,module,exports){
module.exports = DateFormat;
var C = {
  dayNames: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  mthNames: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
};
C.zeroPad = function(number) {
  return ("0" + number).substr(-2, 2);
};
C.dateMarkers = {
  d: ['getDate', function(v) {
    return C.zeroPad(v);
  }],
  m: ['getMonth', function(v) {
    return C.zeroPad(v + 1);
  }],
  n: ['getMonth', function(v) {
    return C.mthNames[v];
  }],
  w: ['getDay', function(v) {
    return C.dayNames[v];
  }],
  y: ['getFullYear'],
  H: ['getHours', function(v) {
    return C.zeroPad(v);
  }],
  M: ['getMinutes', function(v) {
    return C.zeroPad(v);
  }],
  S: ['getSeconds', function(v) {
    return C.zeroPad(v);
  }],
  i: ['toISOString']
};

DateFormat.C = C;

function DateFormat(fstr) {
  this.formatString = fstr;
}

DateFormat.prototype = {
  format: function(date) {
    var dateTxt = this.formatString.replace(/%(.)/g, function(m, p) {
      var dateMarker = C.dateMarkers[p];
      var method = dateMarker[0];
      var rv = date[method]();

      if (dateMarker[1] !== null) {
        rv = dateMarker[1](rv);
      }

      return rv;

    });

    return dateTxt;
  }
};
},{}],454:[function(require,module,exports){
  module.exports = Icon;

  function Icon(element, sound) {
    this.element = element;
    this.sound = sound;
    this.disabled = false;
  }

  Icon.prototype = {
    css: function(name) {
      return this.element.css(name);
    },
    attr: function(name) {
      return this.element.attr(name);
    },
    disable: function() {
      this.disabled = true;
    },
    enable: function() {
      this.disabled = false;
    },
    onClick: function(handler) {
      var self = this;
      this.element.bind("click", function(e) {
        e.preventDefault();
        if (self.disabled) {
          return;
        }
        self.sound.playClick();
        handler(e);
      });
    }
  };
},{}],455:[function(require,module,exports){
var adapter = require('./adapter');

var Utils = {
  clone: function(obj) {
    return JSON.parse(JSON.stringify(obj));
  },
  rstring: function() { 
    return Math.random().toString().slice(2,8); 
  },
  dataURItoBlob: function(dataURI) {
    // convert base64 to raw binary data held in a string
    // doesn't handle URLEncoded DataURIs - see SO answer #6850276 for code that does this
    var byteString = atob(dataURI.split(',')[1]);

    // separate out the mime component
    var mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];

    // write the bytes of the string to an ArrayBuffer
    var ab = new ArrayBuffer(byteString.length);
    var ia = new Uint8Array(ab);
    for (var i = 0; i < byteString.length; i++) {
      ia[i] = byteString.charCodeAt(i);
    }

    // write the ArrayBuffer to a blob, and you're done
    var blob = new Blob([ab], {type: mimeString});
    return blob;
  },

  camelize: function (str) {
    return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function(match, index) {
      if (+match === 0) return ""; // or if (/\s+/.test(match)) for white spaces
      return index == 0 ? match.toLowerCase() : match.toUpperCase();
    });
  },

  format: function(seconds)
  {
    var hrs = Math.floor(seconds / 3600);
    seconds %= 3600;
    var mns = Math.floor(seconds / 60);
    seconds %= 60;
    var formatedDuration = (hrs < 10 ? "0" : "") + hrs + ":" + (mns < 10 ? "0" : "") + mns + ":" + (seconds < 10 ? "0" : "") + seconds;
    return(formatedDuration);
  },
  /* format date and time for call history */
  formatDateTime: function (dateStr){
    var date = new Date(dateStr);
    var strDate =  (date.getMonth() + 1) + "/" + date.getDate();
    var hours = date.getHours();
    var minutes = date.getMinutes();
    var ampm = hours >= 12 ? 'PM' : 'AM';
    hours = hours % 12;
    hours = hours ? hours : 12; 
    minutes = minutes < 10 ? '0'+minutes : minutes;
    var strTime = hours + ':' + minutes + ' ' + ampm;
    return strDate + " - " + strTime;
  },
  /* Pull the URL variables out of URL */
  getSearchVariable: function(variable)
  {
    if(typeof location === 'undefined') {
      return false;
    }
    var search = decodeURIComponent($(location).attr('search').substring(1));
    var vars = search.split("&");
    for (var i=0;i<vars.length;i++)
    {
      var pair = vars[i].split("=");
      if(pair[0] === variable)
      {
        return pair[1];
      }
    }
    return false;
  },

  containsKey: function(object, value) {
    return $.inArray(value, $.map(object, function(key) { return key; })) !== -1;
  },

  containsValue: function(object, value) {
    return $.inArray(value, $.map(object, function(key, value) { return value; })) !== -1;
  },

  addSelectOptions: function(options, selector) {
    $.each(options, function(key, value) {
      $(selector)
        .append($('<option>', { value : value })
        .text(key));
    });
  },

  // Generate a random userid
  randomUserid: function()
  {
    var chars = "0123456789abcdef";
    var string_length = 10;
    var userid = '';
    for (var i=0; i<string_length; i++)
    {
      var rnum = Math.floor(Math.random() * chars.length);
      userid += chars.substring(rnum,rnum+1);
    }
    return userid;
  },

  whiteboardCompabilityCheck: function()
  {
    var isChrome = this.isChrome();

    // Only Chrome 34+
    if (!isChrome)
    {
      return "Chrome is required for whiteboard feature, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 34)
    {
      return "Your version of Chrome must be upgraded to at least version 34 in order to be able to use the whiteboard<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='https://www.google.com/intl/en/chrome/browser/canary.html'>https://www.google.com/intl/en/chrome/browser/canary.html</a>";
    }
  },

  compatibilityCheck: function(configuration)
  {
    var isChrome = this.isChrome();
    var isFirefox = this.isFirefox();

    // Only Chrome 25+ and Firefox 22+ are supported
    if (!isChrome && !isFirefox)
    {
      return "Chrome or Firefox is required, please go to:<br>" +
        "<a href='http://chrome.google.com'>http://chrome.google.com</a> or <a href='http:www.mozilla.org'>http://www.mozilla.org</a>";
    }
    var major = this.majorVersion();
    if (isChrome && major < 25)
    {
      return "Your version of Chrome must be upgraded to at least version 25<br>" +
        "Please go to: <a href='http://chrome.google.com'>http://chrome.google.com</a>";
    }
    else
    {
      if (isFirefox && major < 22)
      {
        return "Your version of Firefox must be upgraded to at least version 22y<br>" +
          "Please go to: <a href='http://www.mozilla.org'>http://www.mozilla.org</a>";
      }
      configuration.enableStats = false;
    }
  },

  isValidUsPstn: function(pstn){
    pstn = pstn.replace(/-/g, '').replace(/\(/g, '').replace(/\)/g, '');
    return pstn.match(/^1?\d{10}$/) !== null;
  },

  majorVersion: function(){
    return adapter.webrtcDetectedVersion;
  },

  isChrome: function(){
    return adapter.webrtcDetectedBrowser === 'chrome';
  },

  isFirefox: function(){
    return adapter.webrtcDetectedBrowser === 'firefox';
  },

  rebindListeners: function(type, elements, listener){
    for(var i=0; i<elements.length; i++) {
      this.rebindListener(type, elements[i], listener);
    }
  },

  rebindListener: function(type, element, listener){
    element.off(type);
    element.on(type, listener);
  },

  colorNameToHex: function(color){
    if(!color) {
      return false;
    }
    var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
      "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
      "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
      "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
      "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
      "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
      "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
      "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
      "honeydew":"#f0fff0","hotpink":"#ff69b4",
      "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
      "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
      "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
      "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
      "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
      "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
      "navajowhite":"#ffdead","navy":"#000080",
      "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
      "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
      "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
      "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
      "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
      "violet":"#ee82ee",
      "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
      "yellow":"#ffff00","yellowgreen":"#9acd32","transparent":"transparent"};

    if (typeof colors[color.toLowerCase()] !== 'undefined') {
      return colors[color.toLowerCase()];
    }

    return this.isHexColor(color) ? (color.indexOf("#") !== -1 ? color : "#"+color) : false;
  },

  isHexColor: function(color) {
    return (/(^#?[0-9A-F]{6}$)|(^#?[0-9A-F]{3}$)/i.test(color));
  },

  parseDTMFTones: function(destination) {
    if(!destination) {
      return null;
    }
    var dtmfMatch = destination.match(/,[0-9A-D#*,]+/, '');
    return dtmfMatch ? dtmfMatch[0] : null;
  }
};

module.exports = Utils;
},{"./adapter":457}],456:[function(require,module,exports){
var ExSIP = require('exsip');
var jQuery = jquery = $ = require('jquery');
require('jquery.cookie')
var Client = require('./views/client');
var Constants = require('./Constants');
var Utils = require('./Utils');
var ClientConfig = require('../js/client-config.js.default');
var WebRTC = {
  Client: Client,
  Utils: Utils,
  C: Constants,
  Sound: require('./models/sound')
};

module.exports = WebRTC;

Object.defineProperties(WebRTC, {
  version: {
    get: function() {
      return '<%= pkg.version %>';
    }
  },
  name: {
    get: function() {
      return '<%= pkg.title %>';
    }
  }
});

// jQuery.fn.putCursorAtEnd = function() {

//   return this.each(function() {

//     $(this).focus();

//     // If this function exists...
//     if (this.setSelectionRange) {
//       // ... then use it (Doesn't work in IE)

//       // Double the length because Opera is inconsistent about whether a carriage return is one character or two. Sigh.
//       var len = $(this).val().length * 2;

//       this.setSelectionRange(len, len);

//     } else {
//       // ... otherwise replace the contents with itself
//       // (Doesn't work in Google Chrome)

//       $(this).val($(this).val());

//     }

//     // Scroll to the bottom, in case we're in a tall textarea
//     // (Necessary for Firefox and Google Chrome)
//     this.scrollTop = 999999;

//   });

// };

// $.cssHooks.backgroundColor = {
//   get: function(elem) {
//     var bg = null;
//     if (elem.currentStyle) {
//       bg = elem.currentStyle.backgroundColor;
//     } else if (window.getComputedStyle) {
//       bg = document.defaultView.getComputedStyle(elem,
//         null).getPropertyValue("background-color");
//     }
//     if (bg.search("rgb") === -1 || bg === 'transparent') {
//       return bg;
//     } else {
//       bg = bg.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+).*\)$/);
//       var hex = function(x) {
//         return ("0" + parseInt(x, 10).toString(16)).slice(-2);
//       };
//       return "#" + hex(bg[1]) + hex(bg[2]) + hex(bg[3]);
//     }
//   }
// };

var currentScript = $('script').last();
$(document).ready(function() {
  window.BroadSoftWebRTC = window.BroadSoftWebRTC || {};
  window.BroadSoftWebRTC.clients = [];

  if (!currentScript.text()) {
    return;
  }
  var configData = JSON.parse(currentScript.text());
  console.log("script config : ", configData);
  var clientConfig = Utils.clone(ClientConfig);
  var options = $.extend({}, clientConfig, configData);
  console.log("options : ", options);
  options.id = options.id || window.BroadSoftWebRTC.clients.length === 0 && 'default' || Utils.rstring();
  var client = require('./factory')(Client)(options);
  client.appendTo(currentScript.parent());
  var styleData = currentScript.data();
  if (styleData) {
    client.updateCss(styleData);
  }
  client.src = currentScript[0].src;
  currentScript.remove();
  window.BroadSoftWebRTC.clients.push(client);
});

(function($) {
  $.isBlank = function(obj) {
    return (!obj || $.trim(obj) === "");
  };
})(jQuery);

if (typeof String.prototype.endsWith !== 'function') {
  String.prototype.endsWith = function(suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
  };
}
},{"../js/client-config.js.default":1,"./Constants":452,"./Utils":455,"./factory":459,"./models/sound":467,"./views/client":471,"exsip":202,"jquery":230,"jquery.cookie":229}],457:[function(require,module,exports){
/*
 *  Copyright (c) 2014 The WebRTC project authors. All Rights Reserved.
 *
 *  Use of this source code is governed by a BSD-style license
 *  that can be found in the LICENSE file in the root of the source
 *  tree.
 */

/* More information about these options at jshint.com/docs/options */
/* global mozRTCIceCandidate, mozRTCPeerConnection,
mozRTCSessionDescription, webkitRTCPeerConnection */
/* exported trace,requestUserMedia */

'use strict';

var RTCPeerConnection = null;
var getUserMedia = null;
var attachMediaStream = null;
var reattachMediaStream = null;
var webrtcDetectedBrowser = null;
var webrtcDetectedVersion = null;

function trace(text) {
  // This function is used for logging.
  if (text[text.length - 1] === '\n') {
    text = text.substring(0, text.length - 1);
  }
  if (window.performance) {
    var now = (window.performance.now() / 1000).toFixed(3);
    console.log(now + ': ' + text);
  } else {
    console.log(text);
  }
}

if (typeof navigator !== 'undefined' && navigator.mozGetUserMedia) {
  console.log('This appears to be Firefox');

  webrtcDetectedBrowser = 'firefox';

  webrtcDetectedVersion =
    parseInt(navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1], 10);

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    // .urls is not supported in FF yet.
    if (pcConfig && pcConfig.iceServers) {
      for (var i = 0; i < pcConfig.iceServers.length; i++) {
        if (pcConfig.iceServers[i].hasOwnProperty('urls')) {
          pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
          delete pcConfig.iceServers[i].urls;
        }
      }
    }
    return new mozRTCPeerConnection(pcConfig, pcConstraints);
  };

  // The RTCSessionDescription object.
  window.RTCSessionDescription = mozRTCSessionDescription;

  // The RTCIceCandidate object.
  window.RTCIceCandidate = mozRTCIceCandidate;

  // getUserMedia shim (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.mozGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Shim for MediaStreamTrack.getSources.
  MediaStreamTrack.getSources = function(successCb) {
    setTimeout(function() {
      var infos = [
        {kind: 'audio', id: 'default', label:'', facing:''},
        {kind: 'video', id: 'default', label:'', facing:''}
      ];
      successCb(infos);
    }, 0);
  };

  // Creates ICE server from the URL for FF.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create ICE server with STUN URL.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      if (webrtcDetectedVersion < 27) {
        // Create iceServer with turn url.
        // Ignore the transport parameter from TURN url for FF version <=27.
        var turnUrlParts = url.split('?');
        // Return null for createIceServer if transport=tcp.
        if (turnUrlParts.length === 1 ||
          turnUrlParts[1].indexOf('transport=udp') === 0) {
          iceServer = {
            'url': turnUrlParts[0],
            'credential': password,
            'username': username
          };
        }
      } else {
        // FF 27 and above supports transport parameters in TURN url,
        // So passing in the full url to create iceServer.
        iceServer = {
          'url': url,
          'credential': password,
          'username': username
        };
      }
    }
    return iceServer;
  };

  window.createIceServers = function(urls, username, password) {
    var iceServers = [];
    // Use .url for FireFox.
    for (var i = 0; i < urls.length; i++) {
      var iceServer =
        window.createIceServer(urls[i], username, password);
      if (iceServer !== null) {
        iceServers.push(iceServer);
      }
    }
    return iceServers;
  };

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    console.log('Attaching media stream');
    element.mozSrcObject = stream;
  };

  reattachMediaStream = function(to, from) {
    console.log('Reattaching media stream');
    to.mozSrcObject = from.mozSrcObject;
  };

} else if (typeof navigator !== 'undefined' && navigator.webkitGetUserMedia) {
  console.log('This appears to be Chrome');

  webrtcDetectedBrowser = 'chrome';
  // Temporary fix until crbug/374263 is fixed.
  // Setting Chrome version to 999, if version is unavailable.
  var result = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
  if (result !== null) {
    webrtcDetectedVersion = parseInt(result[2], 10);
  } else {
    webrtcDetectedVersion = 999;
  }

  // Creates iceServer from the url for Chrome M33 and earlier.
  window.createIceServer = function(url, username, password) {
    var iceServer = null;
    var urlParts = url.split(':');
    if (urlParts[0].indexOf('stun') === 0) {
      // Create iceServer with stun url.
      iceServer = {
        'url': url
      };
    } else if (urlParts[0].indexOf('turn') === 0) {
      // Chrome M28 & above uses below TURN format.
      iceServer = {
        'url': url,
        'credential': password,
        'username': username
      };
    }
    return iceServer;
  };

  // Creates an ICEServer object from multiple URLs.
  window.createIceServers = function(urls, username, password) {
    return {
      'urls': urls,
      'credential': password,
      'username': username
    };
  };

  // The RTCPeerConnection object.
  RTCPeerConnection = function(pcConfig, pcConstraints) {
    return new webkitRTCPeerConnection(pcConfig, pcConstraints);
  };

  // Get UserMedia (only difference is the prefix).
  // Code from Adam Barth.
  getUserMedia = navigator.webkitGetUserMedia.bind(navigator);
  navigator.getUserMedia = getUserMedia;

  // Attach a media stream to an element.
  attachMediaStream = function(element, stream) {
    if (typeof element.srcObject !== 'undefined') {
      element.srcObject = stream;
    } else if (typeof element.mozSrcObject !== 'undefined') {
      element.mozSrcObject = stream;
    } else if (typeof element.src !== 'undefined') {
      element.src = URL.createObjectURL(stream);
    } else {
      console.log('Error attaching stream to element.');
    }
  };

  reattachMediaStream = function(to, from) {
    to.src = from.src;
  };
} else {
  console.log('Browser does not appear to be WebRTC-capable');
}

// Returns the result of getUserMedia as a Promise.
function requestUserMedia(constraints) {
  return new Promise(function(resolve, reject) {
    var onSuccess = function(stream) {
      resolve(stream);
    };
    var onError = function(error) {
      reject(error);
    };

    try {
      getUserMedia(constraints, onSuccess, onError);
    } catch (e) {
      reject(e);
    }
  });
}

if (typeof module !== 'undefined') {
  module.exports = {
    RTCPeerConnection: RTCPeerConnection,
    getUserMedia: getUserMedia,
    attachMediaStream: attachMediaStream,
    reattachMediaStream: reattachMediaStream,
    webrtcDetectedBrowser: webrtcDetectedBrowser,
    webrtcDetectedVersion: webrtcDetectedVersion,
    requestUserMedia: requestUserMedia,
    trace: trace
  };
}

},{}],458:[function(require,module,exports){
module.exports = CookieProp;

var Prop = require('./prop');
var C = require('./Constants');
var Utils = require('./Utils');
var $ = require('jquery');

function CookieProp(obj, prop, cookie, expires) {

	var self = {};

	self.__proto__ = Prop(obj, prop);

	var superSet = self.__proto__.__set;

	cookie = cookie || Utils.camelize(obj._name + ' ' + self._name);
	expires = expires || C.EXPIRES;

	self.__proto__.__init = function() {
		if(prop.value) {
			obj[self._name] = prop.value();
		}	else {
 			obj[self._name] = $.cookie(cookie);
		}
 	};
	self.__proto__.__set = function(value) {
		superSet(value);
		if (value) {
			$.cookie(cookie, value, {
				expires: expires
			});
		} else {
			$.removeCookie(cookie);
		}
	};

	return self;
}
},{"./Constants":452,"./Utils":455,"./prop":469,"jquery":230}],459:[function(require,module,exports){
(function (global){
var $ = require('jquery');
var templates = require('../js/templates');
require('./prop');
require('./cookieprop');

module.exports = Factory;

function Factory(constructor){
	return function(options) {
		require('./models/callcontrol');
		require('./models/configuration');
		require('./models/debug');
		require('./models/eventbus');
		require('./models/settings');
		require('./models/sipstack');
		require('./models/smsprovider');
		require('./models/sound');
		require('./models/xmpp');
		require('./views/authentication');
		require('./views/client');
		require('./views/connectionstatus');
		require('./views/dialpad');
		require('./views/fileshare');
		require('./views/history');
		require('./views/incomingcall');
		require('./views/messages');
		require('./views/popup');
		require('./views/reinvite');
		require('./views/settings');
		require('./views/sms');
		require('./views/stats');
		require('./views/timer');
		require('./views/transfer');
		require('./views/video');
		require('./views/videobar');
		require('./views/whiteboard');
		require('./views/xmpp');
		global.instances = global.instances || {};
		var name = functionName(constructor);
		var id = getId(options, name);
		// console.log('factory : ' + id);
		if (!global.instances[id]) {
			options = $.extend({}, options);
			// console.log('factory : args for '+ id + ' : ', argNames(constructor));
			var constructorArgs = args(options, constructor);
			// console.log('factory : create ' + id + ' with ', argNames(constructor));
			var object = create(constructor, constructorArgs);
			object._name = name;
			global.instances[id] = object;
			if (name.match(/view$/)) {
				var viewName = name.replace('view', '');
				options = options[viewName] || {};
				object.view = $(options.view || templates[viewName]());
				(object.elements || []).forEach(function(element) {
					object[element] = object.view.find(options[element] || '.' + element);
				});
			} else {
				// console.log('factory : extend props : '+name);
				Object.keys(object.props || {}).forEach(function(name) {
					var prop = $.extend({name: name}, object.props[name])
					var type = prop.type || object.props._type || '';
					require('./'+type+'prop')(object, prop).define();
				});
			}
			constructorArgs.forEach(function(arg){
				arg._init && arg._init();
			});
			object.init && object.init(options);
			object.listeners && object.listeners();

		}
		return global.instances[id];
	}
}

var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
var ARGUMENT_NAMES = /([^\s,]+)/g;

var __slice = [].slice;

function getId (options, name) {
	var id = options;
	if (typeof options === "object") {
		id = options.id;
	}
	id = id || 'default';

	id = name + '_' + id;
	return id;
};

function extend () {
  var consumer = arguments[0],
      providers = __slice.call(arguments, 1),
      key,
      i,
      provider;

  for (i = 0; i < providers.length; ++i) {
    provider = providers[i];
    for (key in provider) {
      if (provider.hasOwnProperty(key)) {
        consumer[key] = provider[key];
      };
    };
  };
  return consumer;
};

function delegateFunction (toProvider, options) {
	var _toProvider;
  return function () {
  	_toProvider = _toProvider || toProvider(options);
    return _toProvider.apply(this, arguments);
  };
};

function delegate (toProvider, options, methods, props, receiver) {
	receiver = receiver || {};
	methods = methods || Object.getOwnPropertyNames(toProvider);
	var _toProvider;
  methods.forEach(function (method) {
    receiver[method] = function () {
    	_toProvider = _toProvider || toProvider(options);
      return _toProvider[method].apply(receiver, arguments);
    };
  });
  props.forEach(function (prop) {
  	Object.defineProperty(receiver, prop, {
			writeable: false,
			get: function() {
	    	_toProvider = _toProvider || toProvider(options);
	    	return _toProvider[prop];
			},
			set: function(value) {
	    	_toProvider = _toProvider || toProvider(options);
	    	_toProvider[prop] = value;
			}
		});
  });
  receiver._init = function(){
		_toProvider = _toProvider || toProvider(options);
	}
  return receiver;
};

function args(options, constructor) {
	var names = argNames(constructor) || [];
	return names.map(function(argName) {
		if (argName === 'options') {
			return options;
		}

		var path;
		if (argName.match(/view$/i)) {
			path = './views/' + argName.replace(/view$/i, '');
		} else {
			if (argName === 'debug') {
				options.name = name;
			}
			path = './models/' + argName;
		}
		
		var arg;
		var argConstructor = require(path);
		var obj = argConstructor();
		if(typeof obj === 'function') {
			// console.log('factory : args : delegateFunction :'+argName);
			arg = delegateFunction(Factory(require(path)), options);
		} else {
			var methods = Object.getOwnPropertyNames(obj);
			var props = obj.elements || Object.keys(obj.props || {});
			if(argName.match(/view$/i)) {
				props = props.concat(['view']);
			}
			console.log('factory : args : delegate :'+argName, methods, props);
			arg = delegate(Factory(require(path)), options, methods, props);
			arg._name = argName;
		}
		// var argId = getId(options, functionName(argConstructor));
		// console.log('factory : args : global.instances '+argId);
		// global.instances[argId] = arg;
		return arg;
	});
};

function argNames(fun) {
	var fnStr = fun.toString().replace(STRIP_COMMENTS, '')
	var result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES)
	if (result === null)
		result = []
	return result
};

function functionName(fun) {
	var ret = fun.toString();
	ret = ret.substr('function '.length);
	ret = ret.substr(0, ret.indexOf('('));
	return ret.toLowerCase();
}

function create(constructor, argArray) {
	var args = [null].concat(argArray);
	var factoryFunction = constructor.bind.apply(constructor, args);
	return new factoryFunction();
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../js/templates":2,"./cookieprop":458,"./models/callcontrol":460,"./models/configuration":461,"./models/debug":462,"./models/eventbus":463,"./models/settings":464,"./models/sipstack":465,"./models/smsprovider":466,"./models/sound":467,"./models/xmpp":468,"./prop":469,"./views/authentication":470,"./views/client":471,"./views/connectionstatus":472,"./views/dialpad":473,"./views/fileshare":474,"./views/history":475,"./views/incomingcall":476,"./views/messages":477,"./views/popup":478,"./views/reinvite":479,"./views/settings":480,"./views/sms":481,"./views/stats":482,"./views/timer":483,"./views/transfer":484,"./views/video":485,"./views/videobar":486,"./views/whiteboard":487,"./views/xmpp":488,"jquery":230}],460:[function(require,module,exports){
module.exports = CallControl;

var $ = require('jquery');

var C = require('../Constants');

function CallControl(options, eventbus, configuration, sipstack, debug) {
  var self = {};


  self.listeners = function() {
    eventbus.on('userMediaUpdated', function(e) {
      if (configuration.destination) {
        self.callUri(configuration.destination);
      }
    })
  };

  self.formatDestination = function(destination, domainTo) {
    if (destination.indexOf("@") === -1) {
      destination = (destination + "@" + domainTo);
    }

    var domain = destination.substring(destination.indexOf("@"));
    if (domain.indexOf(".") === -1) {
      destination = destination + "." + domainTo;
    }

    // WEBRTC-35 : filter out dtmf tones from destination
    return destination.replace(/,[0-9A-D#*,]+/, '');
  };

  self.isValidDestination = function(destination, allowOutside, domainTo) {
    if (!allowOutside && !new RegExp("[.||@]" + domainTo).test(destination)) {
      return false;
    }
    return true;
  };


  // Make sure destination allowed and in proper format
  self.validateDestination = function(destination) {
    if (!self.isValidDestination(destination, configuration.allowOutside, configuration.domainTo)) {
      eventbus.emit('message', {
        text: configuration.messageOutsideDomain,
        level: 'alert'
      });
      return false;
    }

    if (destination.indexOf("sip:") === -1) {
      destination = ("sip:" + destination);
    }

    return self.formatDestination(destination, configuration.domainTo);
  };

  // URL call
  self.callUri = function(destinationToValidate) {
    console.log('sipstack.C.STATE_CONNECTED : '+sipstack.C);
    if (sipstack.getCallState() !== C.STATE_CONNECTED) {
      debug('Already in call with state : ' + sipstack.getCallState());
      return;
    }
    if (destinationToValidate === "") {
      eventbus.message(configuration.messageEmptyDestination, "alert");
      return;
    }

    var destination = self.validateDestination(destinationToValidate);
    if (!destination) {
      debug("destination is not valid : " + destinationToValidate);
      return;
    }

    debug("calling destination : " + destination);

    eventbus.message(configuration.messageCall, 'success');

    // Start the Call
    sipstack.call(destination);
  };


  return self;
}
},{"../Constants":452,"jquery":230}],461:[function(require,module,exports){
module.exports = Configuration;

var Flags = {
  enableHD: 1,
  enableCallControl: 2,
  enableCallTimer: 4,
  enableCallHistory: 8,
  enableFullScreen: 16,
  enableSelfView: 32,
  enableCallStats: 64,
  enableDialpad: 128,
  enableMute: 256,
  enableMessages: 512,
  enableRegistrationIcon: 1024,
  enableConnectionIcon: 2048,
  enableWindowDrag: 4096,
  enableSettings: 8192,
  enableAutoAnswer: 16384,
  enableAutoAcceptReInvite: 32768,
  enableConnectLocalMedia: 65536,
  enableTransfer: 131072,
  enableHold: 262144,
  enableIms: 524288
};

Configuration.Flags = Flags;

var Utils = require('../Utils');
var WebRTC_C = require('../Constants');
var ExSIP = require('exsip');
var jQuery = $ = require('jquery');
// TODO : hack to test in node js directly
if(typeof document === 'undefined') {
  document = {};
}
function Configuration(options, eventbus, debug, settings) {
  var self = {};
  options = options || {};

  jQuery.extend(self, options);

  var screenshare = false;
  var offerToReceiveVideo = true;
  var bodyBackgroundColor = $('body').css('backgroundColor');
  
  // TODO - refactor to not have to specify each config prop but use from options
  self.props = {
    enableHD: {value: function(){return options.enableHD}},
    enableCallControl: {value: function(){return options.enableCallControl}},
    enableCallTimer: {value: function(){return options.enableCallTimer}},
    enableCallHistory: {value: function(){return options.enableCallHistory}},
    enableFullScreen: {value: function(){return options.enableFullScreen}},
    enableSelfView: {value: function(){return options.enableSelfView}},
    enableCallStats: {value: function(){return options.enableCallStats}},
    enableDialpad: {value: function(){return options.enableDialpad}},
    enableMute: {value: function(){return options.enableMute}},
    enableRegistrationIcon: {value: function(){return options.enableRegistrationIcon}},
    enableConnectionIcon: {value: function(){return options.enableConnectionIcon}},
    enableWindowDrag: {value: function(){return options.enableWindowDrag}},
    enableAutoAcceptReInvite: {value: function(){return options.enableAutoAcceptReInvite}},
    enableConnectLocalMedia: {value: function(){return options.enableConnectLocalMedia}},
    enableIms: {value: function(){return options.enableIms}},
    enableSettings: {value: function(){return options.enableSettings}},
    enableAutoAnswer: {value: function(){return options.enableAutoAnswer}},
    enableTransfer: {value: function(){return options.enableTransfer}},
    enableHold: {value: function(){return options.enableHold}},
    pAssertedIdentity: {value: function(){return options.pAssertedIdentity}},
    disableICE: {value: function(){return options.disableICE}},
    volumeClick: {value: function(){return options.volumeClick}},
    volumeDTMF: {value: function(){return options.volumeDTMF}},
    websocketsServers: {value: function(){return options.websocketsServers}},
    stunServer: {value: function(){return options.stunServer}},
    stunPort: {value: function(){return options.stunPort}},
    allowOutside: {value: function(){return options.allowOutside}},
    domainFrom: {value: function(){debug('domainFrom : '+options.domainFrom); return options.domainFrom}},
    domainTo: {value: function(){return options.domainTo}},
    endCallURL: {value: function(){return options.endCallURL}},
    bandwidthLow: {value: function(){return options.bandwidthLow}},
    bandwidthMed: {value: function(){return options.bandwidthMed}},
    bandwidthHigh: {value: function(){return options.bandwidthHigh}},
    expires: {value: function(){return options.expires}},
    debug: {value: function(){return options.debug}},
    encodingResolution: {value: function(){return options.encodingResolution}},
    displayResolution: {value: function(){return options.displayResolution}},
    view: {value: function(){return options.view}},
    selfViewLocation: {value: function(){return options.selfViewLocation}},
    register: {value: function(){return options.register}},
    messageEnded: {value: function(){return options.messageEnded}},
    messageResume: {value: function(){return options.messageResume}},
    messageHold: {value: function(){return options.messageHold}},
    messageStarted: {value: function(){return options.messageStarted}},
    messageConnected: {value: function(){return options.messageConnected}},
    messageConnectionFailed: {value: function(){return options.messageConnectionFailed}},
    messageProgress: {value: function(){return options.messageProgress}},
    messageRegistrationFailed: {value: function(){return options.messageRegistrationFailed}},
    messageRegistered: {value: function(){return options.messageRegistered}},
    messageUnregistered: {value: function(){return options.messageUnregistered}},
    messageOutsideDomain: {value: function(){return options.messageOutsideDomain}},
    messageEmptyDestination: {value: function(){return options.messageEmptyDestination}},
    messageGetUserMedia: {value: function(){return options.messageGetUserMedia}},
    destination: {
      value: function(){return options.destination || Utils.getSearchVariable("destination");}
    },
    networkUserId: {
      value: function(){return options.networkUserId || Utils.getSearchVariable("networkUserId");}
    },
    hd: {
      value: function(){return Utils.getSearchVariable("hd") === "true" || $.cookie('settingHD');}
    },
    audioOnly: {
      value: function(){return Utils.getSearchVariable("audioOnly") === "true";}
    },
    sipDisplayName: {
      value: function(){
        var name = options.displayName || Utils.getSearchVariable("name") || $.cookie('settingDisplayName');
        if (name) {
          name = name.replace(/%20/g, " ");
        }
        return name;
      }
    },
    maxCallLength: {
      value: function(){return Utils.getSearchVariable("maxCallLength");}
    },
    size: {
      value: function(){return Utils.getSearchVariable("size") || $.cookie('settingsize') || 1;}
    },
    color: {
      value: function(){return Utils.colorNameToHex(Utils.getSearchVariable("color")) || $.cookie('settingColor');}
    },
    enableMessages: {
      value: function(){return !(!!Utils.getSearchVariable("disableMessages"));}
    },
    features: {
      value: function(){
        var features = Utils.getSearchVariable("features");
        if (features) {
         self.setClientConfigFlags(parseInt(features, 10));
        }
      }
    }
  };

  self.init = function(options) { 
    debug('configuration options : ' + ExSIP.Utils.toString(options));
    debug('configuration : ' + ExSIP.Utils.toString(self));
  };

  self.listeners = function(audioOnly) { 
    eventbus.on('screenshare', function(e) {
      self.screenshare = e.enabled;
    });
    eventbus.on("started", function(e) {
      //remove configuration.destination to avoid multiple calls
      delete self.destination;
    });
  };

  self.setAudioOnlyOfferAndRec = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = !audioOnly;
    sipstack.updateUserMedia();
  };

  self.setAudioOnly = function(audioOnly) { 
    self.audioOnly = audioOnly;
    offerToReceiveVideo = true;
    sipstack.updateUserMedia();
  };

  self.getClientConfigFlags = function() {
    var flags = 0;
    for (var flag in Flags) {
      var value = Flags[flag];
      if (self[flag]) {
        flags |= value;
      }
    }
    return flags;
  };
  self.setClientConfigFlags = function(flags) {
    for (var flag in Flags) {
      var value = Flags[flag];
      if (flags & value) {
        self[flag] = true;
      } else {
        self[flag] = false;
      }
    }
  };
  self.isAudioOnlyView = function() {
    var views = self.getViews();
    return views.indexOf('audioOnly') !== -1;
  };
  self.getViews = function() {
    var view = Utils.getSearchVariable("view");
    var views = [];
    if (self.view) {
      $.merge(views, self.view.split(' '));
    }
    if (view) {
      $.merge(views, view.split(' '));
    }
    return $.unique(views);
  };
  self.getBackgroundColor = function() {
    return self.color || self.bodyBackgroundColor;
  };
  self.getPassword = function() {
    return $.cookie('settingPassword');
  };
  self.isAutoAnswer = function() {
    return settings.autoAnswer;
  };
  self.getDTMFOptions = function() {
    return {
      duration: WebRTC_C.DEFAULT_DURATION,
      interToneGap: WebRTC_C.DEFAULT_INTER_TONE_GAP
    };
  };
  self.getExSIPOptions = function() {
    // Options Passed to ExSIP
    var options = {
      mediaConstraints: {
        audio: true,
        video: self.getVideoConstraints()
      },
      createOfferConstraints: {
        mandatory: {
          OfferToReceiveAudio: true,
          OfferToReceiveVideo: !self.isAudioOnlyView() && offerToReceiveVideo
        }
      }
    };
    return options;
  };

  self.getMediaConstraints = function() {
    if (self.screenshare) {
      return {
        video: {
          mandatory: {
            chromeMediaSource: 'screen'
          }
        }
      };
    } else {
      return {
        audio: true,
        video: self.getVideoConstraints()
      };
    }
  };

  self.getVideoConstraints = function() {
    if (self.isAudioOnlyView() || self.audioOnly) {
      return false;
    } else {
      var constraints = self.getResolutionConstraints();
      return constraints ? constraints : true;
    }
  };

  self.getResolutionConstraints = function() {
    if (self.hd === true) {
      return {
        mandatory: {
          minWidth: 1280,
          minHeight: 720
        }
      };
    } else {
      var width = settings.getResolutionEncodingWidth();
      var height = settings.getResolutionEncodingHeight();
      if (width && height) {
        if (height <= 480) {
          return {
            mandatory: {
              maxWidth: width,
              maxHeight: height
            }
          };
        } else {
          return {
            mandatory: {
              minWidth: width,
              minHeight: height
            }
          };
        }
      } else {
        return false;
      }
    }
  };

  self.getExSIPConfig = function(data) {
    data = data || {};
    var userid = data.userId || $.cookie('settingUserId') || self.networkUserId || Utils.randomUserid();

    var sip_uri = encodeURI(userid);
    if ((sip_uri.indexOf("@") === -1)) {
      sip_uri = (sip_uri + "@" + self.domainFrom);
    }

    var config = {
      'uri': sip_uri,
      'authorization_user': data.authenticationUserId || $.cookie('settingAuthenticationUserId') || userid,
      'ws_servers': self.websocketsServers,
      'stun_servers': 'stun:' + self.stunServer + ':' + self.stunPort,
      'trace_sip': self.debug,
      'enable_ims': self.enableIms,
      'p_asserted_identity': self.pAssertedIdentity,
      'enable_datachannel': self.enableWhiteboard || self.enableFileShare
    };

    // Add Display Name if set
    if (self.sipDisplayName) {
      config.display_name = self.sipDisplayName;
    }

    // do registration if setting User ID or configuration register is set
    if ($.cookie('settingUserId') || self.register) {
      config.register = true;
      config.password = data.password || $.cookie('settingPassword');
    } else {
      config.register = false;
    }
    return config;
  };

  self.getRtcMediaHandlerOptions = function() {
    var options = {
      reuseLocalMedia: self.enableConnectLocalMedia,
      videoBandwidth: settings.getBandwidth(),
      disableICE: self.disableICE,
      RTCConstraints: {
        'optional': [],
        'mandatory': {}
      }
    };
    return options;
  };

  self.isHD = function() {
    // console.log('isHD : '+self.enabledHD+', '+self.hd);
    return self.enableHD === true && self.hd === true;
  };

  self.isWidescreen = function() {
    return self.isHD() || settings.resolutionType === WebRTC_C.WIDESCREEN;
  };

  self.setResolutionDisplay = function(resolutionDisplay) {
    self.hd = false;
    settings.setResolutionDisplay(resolutionDisplay);
    eventbus.viewChanged(self);
  };

  self.getResolutionDisplay = function() {
    return self.isHD() ? WebRTC_C.R_1280x720 : settings.getResolutionDisplay();
  }  

  return self;
}


},{"../Constants":452,"../Utils":455,"exsip":202,"jquery":230}],462:[function(require,module,exports){
module.exports = Debug

var stacktrace = require('stacktrace-js');
var debug = require('debug');
var enabled = {};

function Debug(options) {
	options = options || {};
	var id = options && options.id || options || '';
	if (options.debug) {
		enabled[id] = '*:' + id;
	} else {
		delete enabled[id];
	}
	updateEnabled();

	return function(msg) {
		var prefix = (options.name || caller()) + ':' + id;
		debug(prefix)(msg);
	};
}

var caller = function(){
	var list = stacktrace();
	for(var i=list.length-1; i >= 0; i--) {
		var match = null;
		if((match = list[i].match(/([A-Z]\S*).*@/g))) {
			if(match !== 'Object') {
				return match;				
			}
		}
	}

	return stacktrace().pop().match('(.*)@').pop();
}
var updateEnabled = function() {
	var values = [];
	Object.keys(enabled).forEach(function(key) {
		values.push(enabled[key]);
	});
	debug.enable(values.join(','));
};
// exports.enable = function(id){
// 	enabledList.push('*'+id);
// 	var enabledStr = enabledList.join(',');
// 	debug.enable(enabledStr);
// };
// exports.disable = function(){
// 	enabledList = [];
// 	debug.disable();
// };
// exports.log = debug.log;
},{"debug":168,"stacktrace-js":231}],463:[function(require,module,exports){
module.exports = EventBus;

var ee = require('event-emitter');

function EventBus() {
	var self = {};

	var emitter = ee({});
	self.test = '121';
	
	self.on = function(type, listener){
		emitter.on(type, listener);
	};
	self.once = function(type, listener){
		emitter.once(type, listener);
	};
	self.emit = function(type, obj){
		emitter.emit(type, obj);
	};
	self.message = function(text, level) {
		self.emit('message', {
			text: text,
			level: level
		});
	};
	self.viewChanged = function(view) {
		self.emit('viewChanged', {
			visible: view.visible,
			view: view._name.replace(/view$/i, '')
		});
	};
	self.calling = function(destination, session) {
		self.emit('calling', {
			destination: destination,
			session: session
		});
	};
	self.modifier = function(which) {
		self.emit('modifier', {
			which: which
		});
	};
	self.screenshare = function(enabled) {
		self.emit('screenshare', {
			enabled: enabled
		});
	};
	self.signIn = function() {
		self.emit('signIn');
	};
	self.signOut = function() {
		self.emit('signOut');
	};

	return self;
}

},{"event-emitter":175}],464:[function(require,module,exports){
module.exports = Settings;

var WebRTC_C = require('../Constants');
var Utils = require('../Utils');

function Settings(options, configuration, settingsView, eventbus, debug) {
  var self = {};
  self.view = settingsView;
  
  var updatePageColor = function() {
    var color = configuration.getBackgroundColor();
    debug('updating page color : ' + color);
    $('body').css('backgroundColor', color || '');
  };

  var isStarted = false;
  self.changed = false;

  self.init = function(options) {
    updatePageColor();
  };

  self.listeners = function() {
    eventbus.on("ended", function() {
      isStarted = false;
      if (self.changed) {
        self.reload();
      }
    });
    eventbus.on("started", function() {
      isStarted = true;
    });
  };

  self.getBandwidth = function() {
    var height = self.getResolutionEncodingHeight();
    if (height <= 240) {
      return self.bandwidthLow;
    } else if (height <= 480) {
      return self.bandwidthMed;
    } else if (height <= 720) {
      return self.bandwidthHigh;
    }
  };
  self.reload = function() {
    location.reload(0);
  };
  self.getResolutionDisplay = function() {
    debug('+++++++++++++'+$.cookie('settingResolutionDisplay'));
    return self.getResolution("resolutionDisplayStandard", "resolutionDisplayWidescreen");
  };
  self.getResolutionEncoding = function() {
    return self.getResolution("resolutionEncodingStandard", "resolutionEncodingWidescreen");
  };
  self.getResolutionEncodingWidth = function() {
    var resolution = self.getResolutionEncoding();
    if (!$.isBlank(resolution)) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[0], 10);
    }
  };
  self.getResolutionEncodingHeight = function() {
    var resolution = self.getResolutionEncoding();
    if (!$.isBlank(resolution)) {
      var resolutions = resolution.split('x');
      return parseInt(resolutions[1], 10);
    }
  };
  self.getResolution = function(resolutionStandard, resolutionWidescreen) {
    // console.log('self.resolutionType : '+self.resolutionType);
    if (self.resolutionType === WebRTC_C.STANDARD) {
      return self[resolutionStandard];
    } else if (self.resolutionType === WebRTC_C.WIDESCREEN) {
      return self[resolutionWidescreen];
    } else {
      return false;
    }
  };

  self.setResolutionDisplay = function(resolution) {
    self.setResolution(resolution, "resolutionDisplayStandard", "resolutionDisplayWidescreen");
  };

  self.setResolutionEncoding = function(resolution) {
    self.setResolution(resolution, "resolutionEncodingStandard", "resolutionEncodingWidescreen");
  };

  self.setResolution = function(resolution, resolutionStandard, resolutionWidescreen) {
    if (Utils.containsKey(WebRTC_C.STANDARD_RESOLUTIONS, resolution)) {
      self.resolutionType = WebRTC_C.STANDARD;
      self[resolutionStandard] = resolution;
    } else if (Utils.containsKey(WebRTC_C.WIDESCREEN_RESOLUTIONS, resolution)) {
      self.resolutionType = WebRTC_C.WIDESCREEN;
      self[resolutionWidescreen] = resolution;
    } else {
      debug('no resolution type for ' + resolution);
    }
    settingsView.updateResolutionSelectVisibility();
  };

  self.changed = function() {
    if (!isStarted) {
      self.reload();
    } else {
      self.changed = true;
    }
  };
  self.save = function() {
    self.persist();
    view.hide();
    self.changed();
  };
  self.signIn = function() {
    self.persist();
    eventbus.signIn();
    view.enableRegistration(false);
  };
  self.signOut = function() {
    eventbus.signOut();
    self.clearConfigurationCookies();
    view.enableRegistration(false);
  };
  self.resetLayout = function() {
    self.resolutionEncoding = WebRTC_C.DEFAULT_RESOLUTION_ENCODING;
    self.resolutionDisplay = WebRTC_C.DEFAULT_RESOLUTION_DISPLAY;
    eventbus.viewChanged(self);
  };
  self.clearConfigurationCookies = function() {
    $.removeCookie('settingDisplayName');
    $.removeCookie('settingUserid');
    $.removeCookie('settingAuthenticationUserid');
    $.removeCookie('settingPassword');
  };
  self.clearConfiguration = function() {
    self.displayName = null;
    self.userid = null ;
    self.authenticationUserid = null;
    self.password = null;
  };
  self.clear = function() {
    for (var name in self.props) {
      self[name] = null;
    }
  };
  self.persist = function() {
    for (var name in self.props) {
      self[name] = self[name];
    }
  };


  self.props = {
    _type: 'cookie',
    userid: true,
    password: true,
    authenticationUserid: true,
    resolutionType: true,
    displayName: {
      value: function(){return configuration.sipDisplayName || $.cookie('settingDisplayName')}
    },
    selfViewDisabled: {
      value: function(){return $.cookie('selfViewDisable') === "true"}
    },
    hd: {
      value: function(){return $.cookie('hd') === "true"}
    },
    bandwidthLow: {
      value: function(){return configuration.bandwidthLow || $.cookie('settingBandwidthLow')}
    },
    bandwidthMed: {
      value: function(){return configuration.bandwidthMed || $.cookie('settingBandwidthMed')}
    },
    bandwidthHigh: {
      value: function(){return configuration.bandwidthHigh || $.cookie('settingBandwidthHigh')}
    },
    color: {
      value: function(){return configuration.getBackgroundColor()},
      default: '#ffffff'
    },
    resolutionDisplayStandard: true,
    resolutionDisplayWidescreen: true,
    resolutionEncodingStandard: true,
    resolutionEncodingWidescreen: true,
    resolutionDisplay: {
      get: function(){
        return self.getResolution("resolutionDisplayStandard", "resolutionDisplayWidescreen");
      },
      set: function(resolution){
        self.setResolution(resolution, "resolutionDisplayStandard", "resolutionDisplayWidescreen")
      },
      value: function(){
            debug('+++++++++++++ : '+configuration.displayResolution);
            debug('+++++++++++++ : '+$.cookie('settingResolutionDisplay'));

        return configuration.displayResolution || $.cookie('settingResolutionDisplay') || WebRTC_C.DEFAULT_RESOLUTION_DISPLAY
      }
    },
    resolutionEncoding: {
      get: function(){
        return self.getResolution("resolutionEncodingStandard", "resolutionEncodingWidescreen");
      },
      set: function(resolution){
        self.setResolution(resolution, "resolutionEncodingStandard", "resolutionEncodingWidescreen")
      },
      value: function(){ return configuration.encodingResolution || $.cookie('settingResolutionEncoding') || WebRTC_C.DEFAULT_RESOLUTION_ENCODING;}
    },
    size: {
      value: function(){return configuration.size || $.cookie('size')}
    },
    autoAnswer: {
      value: function(){return $.cookie('autoAnswer') === "true"}
    },
    windowPosition: {
      get: function() {
        return ".localVideo" + "-" + self.localVideoTop.val() + "-" + self.localVideoLeft.val() + "|" +
          ".callHistory" + "-" + self.callHistoryTop.val() + "-" + self.callHistoryLeft.val() + "|" +
          ".callStats" + "-" + self.callStatsTop.val() + "-" + self.callStatsLeft.val();
      },
      set: function(val) {}
    }
  };


  return self;
}
},{"../Constants":452,"../Utils":455}],465:[function(require,module,exports){
module.exports = SIPStack;

var ExSIP = require('exsip');
var C = require('../Constants');

function SIPStack(options, eventbus, debug, configuration, settings) {
  var self = {};

  self.ua = null;
  self.activeSession = null;
  var sessions = [];

  var setActiveSession = function(session) {
    debug("setting active session to " + session.id);
    self.activeSession = session;
  };

  self.listeners = function() {
    eventbus.on("signOut", function(e) {
      self.unregister();
    });
    eventbus.on("signIn", function(e) {
      self.init();
    });
    eventbus.on("connected", function(e) {
      self.updateUserMedia();
    });
    eventbus.on("resumed", function(e) {
      setActiveSession(e.sender);
    });
    eventbus.on("started", function(e) {
      setActiveSession(e.sender);
      var dtmfTones = Utils.parseDTMFTones(configuration.destination);
      if (dtmfTones && e.data && !e.data.isReconnect) {
        debug("DTMF tones found in destination - sending DTMF tones : " + dtmfTones);
        self.sendDTMF(dtmfTones);
      }
    });
    eventbus.on('authenticate', function(e) {
      self.init(e);
    });
  };
  self.getLocalStreams = function() {
    return self.activeSession ? self.activeSession.getLocalStreams() : null;
  };
  self.getRemoteStreams = function() {
    return self.activeSession ? self.activeSession.getRemoteStreams() : null;
  };
  self.getSessionId = function() {
    return self.activeSession.id.replace(/\./g, '');
  };
  self.terminateSession = function(session) {
    session = session || self.activeSession;
    if (!session) {
      return;
    }
    var index = sessions.indexOf(session);
    if (index !== -1) {
      sessions.splice(index, index + 1);
    }
    if (session.status !== ExSIP.RTCSession.C.STATUS_TERMINATED) {
      session.terminate();
    }
    if (session === self.activeSession) {
      debug("clearing active session");
      self.activeSession = null;
    }
    eventbus.viewChanged(self);
  };
  self.terminateSessions = function() {
    var allSessions = [];
    allSessions = allSessions.concat(sessions);
    for (var i = 0; i < allSessions.length; i++) {
      self.terminateSession(allSessions[i]);
    }
  };
  self.holdAndAnswer = function(session) {
    var firstSession = self.activeSession;
    session.on('ended', function() {
      eventbus.emit('message', {text: 'Resuming with ' + firstSession.remote_identity.uri.user, level: 'normal'});
      debug("incoming call ended - unholding first call");
      firstSession.unhold(function() {
        debug("unhold first call successful");
      });
    });
    self.activeSession.hold(function() {
      debug("hold successful - answering incoming call");
      self.answer(session);
    });
  };
  self.answer = function(session) {
    session.answer(configuration.getExSIPOptions());
  };
  self.hold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.hold(successCallback, failureCallback);
    }
  };
  self.unhold = function(successCallback, failureCallback) {
    if (self.activeSession) {
      self.activeSession.unhold(successCallback, failureCallback);
    }
  };
  self.reconnectUserMedia = function(successCallback, failureCallback) {
    var onUserMediaUpdateSuccess = function(localMedia) {
      debug("reconnect user media successful");
      if (self.activeSession) {
        self.activeSession.changeSession({
          localMedia: localMedia
        }, function() {
          debug("session changed successfully");
          if (successCallback) {
            successCallback(localMedia);
          }
        }, failureCallback);
      } else if (successCallback) {
        successCallback(localMedia);
      }
    };
    self.updateUserMedia(onUserMediaUpdateSuccess, failureCallback);
  };
  self.call = function(destination) {
    var session = self.ua.call(destination, configuration.getExSIPOptions());
    session.on('failed', function(e) {
      eventbus.emit('failed', e.data);
    });
    eventbus.calling(destination, session);
  };
  self.sendDTMF = function(digit) {
    self.activeSession.sendDTMF(digit, configuration.getDTMFOptions());
  };
  self.isStarted = function() {
    return self.getCallState() === C.STATE_STARTED;
  };
  self.unregister = function() {
    return self.ua && self.ua.unregister();
  };
  self.register = function() {
    return self.ua && self.ua.register();
  };
  self.isRegistered = function() {
    return self.ua && self.ua.isRegistered();
  };
  self.sendData = function(data) {
    if (self.activeSession) {
      self.activeSession.sendData(data);
    }
  };
  self.transfer = function(transferTarget, isAttended) {
    if (isAttended) {
      self.ua.attendedTransfer(transferTarget, self.activeSession);
    } else {
      self.ua.transfer(transferTarget, self.activeSession);
    }
  };
  self.updateRtcMediaHandlerOptions = function() {
    if (typeof(self.ua) === 'undefined') {
      return;
    }

    self.ua.setRtcMediaHandlerOptions(configuration.getRtcMediaHandlerOptions());
  };
  self.getCallState = function() {
    if (sessions.length > 0) {
      if (sessions.length === 1 && !sessions[0].isStarted()) {
        return C.STATE_CALLING;
      } else {
        if (self.activeSession && self.activeSession.isHeld()) {
          return C.STATE_STARTED + " " + C.STATE_HELD;
        } else {
          return C.STATE_STARTED;
        }
      }
    } else {
      if (self.ua && self.ua.isConnected && self.ua.isConnected()) {
        return C.STATE_CONNECTED;
      } else {
        return C.STATE_DISCONNECTED;
      }
    }
  };
  self.updateUserMedia = function(userMediaCallback, failureCallback) {
    debug('updateUserMedia : '+configuration.disabled+', '+configuration.enableConnectLocalMedia+', '+self.activeSession);
    if (!configuration.disabled && (configuration.enableConnectLocalMedia || self.activeSession)) {
      // Connect to local stream
      var options = configuration.getExSIPOptions();
      debug("updating user media ...");
      self.ua.getUserMedia(options, function(localStream) {
        eventbus.emit('userMediaUpdated', localStream);
        if (self.activeSession) {
          debug("changing active session ...");
          self.activeSession.changeSession({
            localMedia: localStream,
            createOfferConstraints: options.createOfferConstraints
          }, function() {
            debug('change session succeeded');
          }, function() {
            debug('change session failed');
          });
        }

        if (userMediaCallback) {
          userMediaCallback(localStream);
        }
      }, function(e) {
        eventbus.emit('message', {text: configuration.messageGetUserMedia || "Get User Media Failed", level: "alert"});
        if (failureCallback) {
          failureCallback(e);
        }
      }, true);
    }
  };

  // Incoming reinvite function
  self.incomingReInvite = function(e) {
    if (configuration.enableAutoAcceptReInvite) {
      debug("auto accepting reInvite");
      e.data.session.acceptReInvite();
    } else {
      console.log('@@@@@@@@@@@@@ emit reinvite : ', e.data);
      eventbus.emit('reInvite', e.data);
    }
  };

  self.incomingCall = function(evt) {
    var session = evt.data.session;
    if (!self.activeSession && configuration.isAutoAnswer()) {
      session.answer(configuration.getExSIPOptions());
    } else {
      eventbus.emit('incomingCall', evt);
    }
  };

  self.init = function(data) {
    try {
      if (self.ua) {
        debug('stopping existing UA');
        self.ua.stop();
      }

      if (configuration.disabled) {
        debug('sipstack disabled');
        return;
      }
      self.ua = new ExSIP.UA(configuration.getExSIPConfig(data));

      self.updateRtcMediaHandlerOptions();

      // Start SIP Stack
      self.ua.start();

      // sipStack callbacks
      self.ua.on('connected', function(e) {
        eventbus.viewChanged(self);
        var hasListeners = require('event-emitter/has-listeners');
        debug('$$$$$$$$$$ connected : '+hasListeners(eventbus, 'connected'));
        eventbus.emit('connected', e);
      });
      self.ua.on('disconnected', function(e) {
        eventbus.viewChanged(self);
        eventbus.emit('disconnected', e);
      });
      self.ua.on('onReInvite', function(e) {
        debug("incoming onReInvite event");
        self.incomingReInvite(e);
      });
      self.ua.on('newRTCSession', function(e) {
        var session = e.data.session;
        sessions.push(session);
        eventbus.viewChanged(self);

        // call event handlers
        session.on('progress', function(e) {
          eventbus.emit('progress', e);
        });
        session.on('failed', function(e) {
          eventbus.emit('failed', e);
        });
        session.on('started', function(e) {
          eventbus.viewChanged(self);
          eventbus.emit('started', e);
        });
        session.on('resumed', function(e) {
          eventbus.viewChanged(self);
          eventbus.emit('resumed', e);
        });
        session.on('held', function(e) {
          eventbus.viewChanged(self);
          eventbus.emit('held', e);
        });
        session.on('ended', function(e) {
          eventbus.emit('ended', e);
        });
        session.on('newDTMF', function(e) {
          eventbus.emit('newDTMF', e);
        });
        session.on('dataSent', function(e) {
          eventbus.emit('dataSent', e);
        });
        session.on('dataReceived', function(e) {
          eventbus.emit('dataReceived', e);
        });
        // handle incoming call
        if (e.data.session.direction === "incoming") {
          self.incomingCall(e);
        } else {
          if (!self.activeSession) {
            debug('new active session : ' + session.id);
            self.activeSession = session;
          }
        }
      });

      self.ua.on('registered', function() {
        eventbus.emit('registered');
      });
      self.ua.on('unregistered', function() {
        eventbus.emit('unregistered');
      });
      self.ua.on('registrationFailed', function(e) {
        eventbus.emit('registrationFailed', e);
      });
    } catch (e) {
      debug(e.stack);
      debug('could not init sip stack');
    }
  };

  return self;
}
},{"../Constants":452,"event-emitter/has-listeners":174,"exsip":202}],466:[function(require,module,exports){
module.exports = SMSProvider;

var ExSIP = require('exsip');

function SMSProvider(eventbus, debug) {
  var self = {};

  self.send = function(type, restSuffix, jsonData, successCallback, failureCallback, isJsonp) {
    //      $.flXHRproxy.registerOptions("http://"+ClientConfig.smsHost+"/", {xmlResponseText:false});
    //      $.ajaxSetup({transport:'flXHRproxy'});

    var url = "http://" + ClientConfig.smsHost + "/" + ClientConfig.smsUser + "/" + restSuffix;
    if (self.sessionid) {
      url += ";jsessionid=" + self.sessionid;
    }
    debug("Request to " + url + " : " + ExSIP.Utils.toString(jsonData));
    $.ajax({
        crossDomain: true,
        contentType: type === "GET" ? "text/plain" : "text/plain",
        dataType: isJsonp ? "jsonp" : "json",
        type: type,
        url: url,
        data: type === "GET" ? jsonData : JSON.stringify(jsonData)
      })
      .done(function(msg) {
        if (msg.status === "empty" || msg.status === "success" || msg.status.code === "0000001") {
          debug("Response successful : " + ExSIP.Utils.toString(msg));
          if (successCallback) {
            successCallback(msg);
          }
        } else {
          debug("Response failed : " + ExSIP.Utils.toString(msg));
          if (failureCallback) {
            failureCallback(msg.status.message);
          }
        }
      })
      .fail(function(jqXHR, textStatus) {
        debug('Response error : ' + textStatus);
        if (failureCallback) {
          failureCallback(textStatus);
        }
      });
  };

  self.getUpdate = function(onNotification, onFailure) {
    var onSuccess = function(msg) {
      debug("received notification : " + ExSIP.Utils.toString(msg));
      onNotification(msg.notifications);
    };
    var data = {
      fid: self.name,
      platform: "fmc"
    };
    self.send("GET", "getUpdate", data, onSuccess, onFailure, false);
  };
  self.sendSMS = function(desttnarray, body, onFailure) {
    var onSuccess = function(msg) {
      debug("sent msg " + msg + " to " + desttnarray);
      eventbus.emit('smsSent', {
        desttnarray: desttnarray,
        body: body
      });
    };
    var data = {
      desttnarray: desttnarray,
      body: body
    };
    self.send("POST", "ua/msg/sms/send", data, onSuccess, onFailure);
  };
  self.remove = function(mids, onSuccess, onFailure) {
    var data = {
      mids: mids
    };
    self.send("POST", "ua/msg/sms/delete", data, function() {
      debug("Deleted msgs : " + mids);
      if (onSuccess) {
        onSuccess();
      }
    }, onFailure);
  };
  self.readAll = function(onFailure) {
    var onSuccess = function(msg) {
      debug("Read all mgs : " + ExSIP.Utils.toString(msg.messages));
      eventbus.emit('smsReadAll', {
        messages: msg.messages
      });
    };
    var data = null;
    self.send("GET", "ua/msg/sms/all", data, onSuccess, onFailure);
  };
  self.login = function(name, password, onFailure) {
    var onSuccess = function(msg) {
      self.sessionid = msg.sessionid;
      self.name = name;
      debug("Logged in " + name + " : " + msg.sessionid);
      eventbus.emit('smsLoggedIn');
    };
    var data = {
      spcode: ClientConfig.smsSpcode,
      password: password,
      name: name,
      platform: "fmc"
    };
    self.send("POST", "ua/login", data, onSuccess, onFailure);
  };

  return self;
}
},{"exsip":202}],467:[function(require,module,exports){
module.exports = Sound;

var $ = require('jquery');

// TODO - refactor
var medias = {};
medias.click = "T2dnUwACAAAAAAAAAACvSVNLAAAAAO0Xz6IBHgF2b3JiaXMAAAAAAUSsAAAAAAAAAHcBAAAAAAC4AU9nZ1MAAAAAAAAAAAAAr0lTSwEAAABX6v5BEf8D///////////////////JA3ZvcmJpcx0AAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDA5MDcwOQcAAAAbAAAAVElUTEU9V2ViUlRDIENsaWVudCAtIGNsaWNrFgAAAEFSVElTVD1OYXRoYW4gU3RyYXR0b24JAAAAREFURT0yMDEzHgAAAENPUFlSSUdIVD0yMDEzIEV4YXJpbyBOZXR3b3Jrcx8AAABMSUNFTlNFPWh0dHA6Ly93d3cucm9ib3RpY3MubmV0MAAAAEVOQ09ERUQtQlk9TmF0aGFuIFN0cmF0dG9uIDxuYXRoYW5Acm9ib3RpY3MubmV0PhIAAABlbmNvZGVyPUxhdmY1My4yLjABBXZvcmJpcylCQ1YBAAgAAAAxTCDFgNCQVQAAEAAAYCQpDpNmSSmllKEoeZiUSEkppZTFMImYlInFGGOMMcYYY4wxxhhjjCA0ZBUAAAQAgCgJjqPmSWrOOWcYJ45yoDlpTjinIAeKUeA5CcL1JmNuprSma27OKSUIDVkFAAACAEBIIYUUUkghhRRiiCGGGGKIIYcccsghp5xyCiqooIIKMsggg0wy6aSTTjrpqKOOOuootNBCCy200kpMMdVWY669Bl18c84555xzzjnnnHPOCUJDVgEAIAAABEIGGWQQQgghhRRSiCmmmHIKMsiA0JBVAAAgAIAAAAAAR5EUSbEUy7EczdEkT/IsURM10TNFU1RNVVVVVXVdV3Zl13Z113Z9WZiFW7h9WbiFW9iFXfeFYRiGYRiGYRiGYfh93/d93/d9IDRkFQAgAQCgIzmW4ymiIhqi4jmiA4SGrAIAZAAABAAgCZIiKZKjSaZmaq5pm7Zoq7Zty7Isy7IMhIasAgAAAQAEAAAAAACgaZqmaZqmaZqmaZqmaZqmaZqmaZpmWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWZZlWUBoyCoAQAIAQMdxHMdxJEVSJMdyLAcIDVkFAMgAAAgAQFIsxXI0R3M0x3M8x3M8R3REyZRMzfRMDwgNWQUAAAIACAAAAAAAQDEcxXEcydEkT1It03I1V3M913NN13VdV1VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWB0JBVAAAEAAAhnWaWaoAIM5BhIDRkFQCAAAAAGKEIQwwIDVkFAAAEAACIoeQgmtCa8805DprloKkUm9PBiVSbJ7mpmJtzzjnnnGzOGeOcc84pypnFoJnQmnPOSQyapaCZ0JpzznkSmwetqdKac84Z55wOxhlhnHPOadKaB6nZWJtzzlnQmuaouRSbc86JlJsntblUm3POOeecc84555xzzqlenM7BOeGcc86J2ptruQldnHPO+WSc7s0J4ZxzzjnnnHPOOeecc84JQkNWAQBAAAAEYdgYxp2CIH2OBmIUIaYhkx50jw6ToDHIKaQejY5GSqmDUFIZJ6V0gtCQVQAAIAAAhBBSSCGFFFJIIYUUUkghhhhiiCGnnHIKKqikkooqyiizzDLLLLPMMsusw84667DDEEMMMbTSSiw11VZjjbXmnnOuOUhrpbXWWiullFJKKaUgNGQVAAACAEAgZJBBBhmFFFJIIYaYcsopp6CCCggNWQUAAAIACAAAAPAkzxEd0REd0REd0REd0REdz/EcURIlURIl0TItUzM9VVRVV3ZtWZd127eFXdh139d939eNXxeGZVmWZVmWZVmWZVmWZVmWZQlCQ1YBACAAAABCCCGEFFJIIYWUYowxx5yDTkIJgdCQVQAAIACAAAAAAEdxFMeRHMmRJEuyJE3SLM3yNE/zNNETRVE0TVMVXdEVddMWZVM2XdM1ZdNVZdV2Zdm2ZVu3fVm2fd/3fd/3fd/3fd/3fd/XdSA0ZBUAIAEAoCM5kiIpkiI5juNIkgSEhqwCAGQAAAQAoCiO4jiOI0mSJFmSJnmWZ4maqZme6amiCoSGrAIAAAEABAAAAAAAoGiKp5iKp4iK54iOKImWaYmaqrmibMqu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67qu67pAaMgqAEACAEBHciRHciRFUiRFciQHCA1ZBQDIAAAIAMAxHENSJMeyLE3zNE/zNNETPdEzPVV0RRcIDVkFAAACAAgAAAAAAMCQDEuxHM3RJFFSLdVSNdVSLVVUPVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVdU0TdM0gdCQlQAAGQAAI0EGGYQQinKQQm49WAgx5iQFoTkGocQYhKcQMww5DSJ0kEEnPbiSOcMM8+BSKBVETIONJTeOIA3CplxJ5TgIQkNWBABRAACAMcgxxBhyzknJoETOMQmdlMg5J6WT0kkpLZYYMyklphJj45yj0knJpJQYS4qdpBJjia0AAIAABwCAAAuh0JAVAUAUAABiDFIKKYWUUs4p5pBSyjHlHFJKOaecU845CB2EyjEGnYMQKaUcU84pxxyEzEHlnIPQQSgAACDAAQAgwEIoNGRFABAnAOBwJM+TNEsUJUsTRc8UZdcTTdeVNM00NVFUVcsTVdVUVdsWTVW2JU0TTU30VFUTRVUVVdOWTVW1bc80ZdlUVd0WVdW2ZdsWfleWdd8zTVkWVdXWTVW1ddeWfV/WbV2YNM00NVFUVU0UVdVUVds2Vde2NVF0VVFVZVlUVVl2ZVn3VVfWfUsUVdVTTdkVVVW2Vdn1bVWWfeF0VV1XZdn3VVkWflvXheH2feEYVdXWTdfVdVWWfWHWZWG3dd8oaZppaqKoqpooqqqpqrZtqq6tW6LoqqKqyrJnqq6syrKvq65s65ooqq6oqrIsqqosq7Ks+6os67aoqrqtyrKwm66r67bvC8Ms67pwqq6uq7Ls+6os67qt68Zx67owfKYpy6ar6rqpurpu67pxzLZtHKOq6r4qy8KwyrLv67ovtHUhUVV13ZRd41dlWfdtX3eeW/eFsm07v637ynHrutL4Oc9vHLm2bRyzbhu/rfvG8ys/YTiOpWeatm2qqq2bqqvrsm4rw6zrQlFVfV2VZd83XVkXbt83jlvXjaKq6roqy76wyrIx3MZvHLswHF3bNo5b152yrQt9Y8j3Cc9r28Zx+zrj9nWjrwwJx48AAIABBwCAABPKQKEhKwKAOAEABiHnFFMQKsUgdBBS6iCkVDEGIXNOSsUclFBKaiGU1CrGIFSOScickxJKaCmU0lIHoaVQSmuhlNZSa7Gm1GLtIKQWSmktlNJaaqnG1FqMEWMQMuekZM5JCaW0FkppLXNOSuegpA5CSqWkFEtKLVbMScmgo9JBSKmkElNJqbVQSmulpBZLSjG2FFtuMdYcSmktpBJbSSnGFFNtLcaaI8YgZM5JyZyTEkppLZTSWuWYlA5CSpmDkkpKrZWSUsyck9JBSKmDjkpJKbaSSkyhlNZKSrGFUlpsMdacUmw1lNJaSSnGkkpsLcZaW0y1dRBaC6W0FkpprbVWa2qtxlBKayWlGEtKsbUWa24x5hpKaa2kEltJqcUWW44txppTazWm1mpuMeYaW2091ppzSq3W1FKNLcaaY2291Zp77yCkFkppLZTSYmotxtZiraGU1koqsZWSWmwx5tpajDmU0mJJqcWSUowtxppbbLmmlmpsMeaaUou15tpzbDX21FqsLcaaU0u11lpzj7n1VgAAwIADAECACWWg0JCVAEAUAABBiFLOSWkQcsw5KglCzDknqXJMQikpVcxBCCW1zjkpKcXWOQglpRZLKi3FVmspKbUWay0AAKDAAQAgwAZNicUBCg1ZCQBEAQAgxiDEGIQGGaUYg9AYpBRjECKlGHNOSqUUY85JyRhzDkIqGWPOQSgphFBKKimFEEpJJaUCAAAKHAAAAmzQlFgcoNCQFQFAFAAAYAxiDDGGIHRUMioRhExKJ6mBEFoLrXXWUmulxcxaaq202EAIrYXWMkslxtRaZq3EmForAADswAEA7MBCKDRkJQCQBwBAGKMUY845ZxBizDnoHDQIMeYchA4qxpyDDkIIFWPOQQghhMw5CCGEEELmHIQQQgihgxBCCKWU0kEIIYRSSukghBBCKaV0EEIIoZRSCgAAKnAAAAiwUWRzgpGgQkNWAgB5AACAMUo5B6GURinGIJSSUqMUYxBKSalyDEIpKcVWOQehlJRa7CCU0lpsNXYQSmktxlpDSq3FWGuuIaXWYqw119RajLXmmmtKLcZaa825AADcBQcAsAMbRTYnGAkqNGQlAJAHAIAgpBRjjDGGFGKKMeecQwgpxZhzzimmGHPOOeeUYow555xzjDHnnHPOOcaYc8455xxzzjnnnHOOOeecc84555xzzjnnnHPOOeecc84JAAAqcAAACLBRZHOCkaBCQ1YCAKkAAAARVmKMMcYYGwgxxhhjjDFGEmKMMcYYY2wxxhhjjDHGmGKMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhjjDHGGGOMMcYYY4wxxhhba6211lprrbXWWmuttdZaa60AQL8KBwD/BxtWRzgpGgssNGQlABAOAAAYw5hzjjkGHYSGKeikhA5CCKFDSjkoJYRQSikpc05KSqWklFpKmXNSUiolpZZS6iCk1FpKLbXWWgclpdZSaq211joIpbTUWmuttdhBSCml1lqLLcZQSkqttdhijDWGUlJqrcXYYqwxpNJSbC3GGGOsoZTWWmsxxhhrLSm11mKMtcZaa0mptdZiizXWWgsA4G5wAIBIsHGGlaSzwtHgQkNWAgAhAQAEQow555xzEEIIIVKKMeeggxBCCCFESjHmHHQQQgghhIwx56CDEEIIIYSQMeYcdBBCCCGEEDrnHIQQQgihhFJK5xx0EEIIIZRQQukghBBCCKGEUkopHYQQQiihhFJKKSWEEEIJpZRSSimlhBBCCKGEEkoppZQQQgillFJKKaWUEkIIIZRSSimllFJCCKGUUEoppZRSSgghhFJKKaWUUkoJIYRQSimllFJKKSGEEkoppZRSSimlAACAAwcAgAAj6CSjyiJsNOHCA1BoyEoAgAwAAHHYausp1sggxZyElkuEkHIQYi4RUoo5R7FlSBnFGNWUMaUUU1Jr6JxijFFPnWNKMcOslFZKKJGC0nKstXbMAQAAIAgAMBAhM4FAARQYyACAA4QEKQCgsMDQMVwEBOQSMgoMCseEc9JpAwAQhMgMkYhYDBITqoGiYjoAWFxgyAeADI2NtIsL6DLABV3cdSCEIAQhiMUBFJCAgxNueOINT7jBCTpFpQ4CAAAAAAABAB4AAJINICIimjmODo8PkBCREZISkxOUAAAAAADgAYAPAIAkBYiIiGaOo8PjAyREZISkxOQEJQAAAAAAAAAAAAgICAAAAAAABAAAAAgIT2dnUwAEwBoAAAAAAACvSVNLAgAAAJnCDh0OHRA0pCktMi81M9MuAQHUHLfm5vrCcE88HgEoo0dnZJJXkshGaSJ3yQvoANpl/PcsX5oADgAAAAAAAADeZfz3KF+aAjYAAmamTMAUAKDDfqS1Xcy+ZGJ+tncTadB7YjcumGwebCAAEpAPBfMnigIAlmV8n+NdRwNsNA7oHFCtTHJlM0k4AEBpCNU3Ll6OH+a+emtl+j+Zu0NHFgVYcqOz/x9JaLvVIj5feTokAo9bCr1/HQKsl1JSlaZlvAvn8C491NMmwYFz7M/t7u63IwjWjiADj1/2YGDJIbIO2k6VgP3f/P9eWNtt+/9PZ1IWd4sp0FprA7Jl+78u7Uyg7IoVrKwg+PrSP6IiVbmPJACQ1v//O6f8/KjkP1S7LuLV5G1aojNwlG3n60B8dYbvkjq3rEHaUX4RDPSVSio7AHzxBAIE7QLH/OwBpJ52cXskdW2cVkl7kPNd7PjkfjqBeyeGb9JAdfWrG/JMCWTxdJgdByYMQdoBrHMy4JeqWupVUVx5+vdwgevLmh9i+sXWTNVki/zxR8mE4uRzLAsAvP1KFDEW1HhG9zMHUM67qyST0RRn+SqOrlkQoMesdZ1wVXzyCAxRXOLdW3a4CwCsJXcpjWfunKEYYHhVDgkeMY+D0ceOwdY4mlufs4aZzHUZ7x4avbN9QK8w1nK6uyW/5BgXAcz9dPJko9BBa1CUdW8CYMP4ajSossiq22l7m+SF5amVf8r2pvjJ4xFC/AS0JQbOyNReA1o2NGunmexQ+HhmzM9kF7aP4e6944R5ng3DmD1WlCNLpzSAm+uegZw+K9VB5OT6KvjoPY7d91//76v1x+PH8bhf4T0mWy6Xy/uHy6V7QUnJs1egBMDn5TL05fL+4TJ0d5+a4vsZAHxeLpf3Dx8+XFm6u5dgKHm2Z69zKi+Z/o6FJQsTC+3rv7+wf7DOu3+3MGC8CHh2Yz0/u+Fhavr7Uc9GLSF/xrOXQgEsLj4/Pz8/Pz8DcN3rAvFlLZoUAChTeD27wT4OTKZkAPfz8/Pz8/PzMwDeZfz3LF+aAjYAZmaACSgAABM04BjeK9eI3iobZGCs2+3CDJOmBRqAzQYKChQADg4=";
medias['dtmf-0'] = "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";
medias['dtmf-1'] = "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";
medias['dtmf-2'] = "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";
medias['dtmf-3'] = "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";
medias['dtmf-4'] = "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";
medias['dtmf-5'] = "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";
medias['dtmf-6'] = "T2dnUwACAAAAAAAAAAC/67J4AAAAAHN3d4ABHgF2b3JiaXMAAAAAAYC7AAAAAAAAgDgBAAAAAAC4AU9nZ1MAAAAAAAAAAAAAv+uyeAEAAADG2NltDu3///////////////+BA3ZvcmJpcx0AAABYaXBoLk9yZyBsaWJWb3JiaXMgSSAyMDA5MDcwOQYAAAAcAAAAVElUTEU9V2ViUlRDIENsaWVudCAtIGR0bWYgNhYAAABBUlRJU1Q9TmF0aGFuIFN0cmF0dG9uCQAAAERBVEU9MjAxMx4AAABDT1BZUklHSFQ9MjAxMyBFeGFyaW8gTmV0d29ya3MfAAAATElDRU5TRT1odHRwOi8vd3d3LnJvYm90aWNzLm5ldDAAAABFTkNPREVELUJZPU5hdGhhbiBTdHJhdHRvbiA8bmF0aGFuQHJvYm90aWNzLm5ldD4BBXZvcmJpcyJCQ1YBAEAAACRzGCpGpXMWhBAaQlAZ4xxCzmvsGUJMEYIcMkxbyyVzkCGkoEKIWyiB0JBVAABAAACHQXgUhIpBCCGEJT1YkoMnPQghhIg5eBSEaUEIIYQQQgghhBBCCCGERTlokoMnQQgdhOMwOAyD5Tj4HIRFOVgQgydB6CCED0K4moOsOQghhCQ1SFCDBjnoHITCLCiKgsQwuBaEBDUojILkMMjUgwtCiJqDSTX4GoRnQXgWhGlBCCGEJEFIkIMGQcgYhEZBWJKDBjm4FITLQagahCo5CB+EIDRkFQCQAACgoiiKoigKEBqyCgDIAAAQQFEUx3EcyZEcybEcCwgNWQUAAAEACAAAoEiKpEiO5EiSJFmSJVmSJVmS5omqLMuyLMuyLMsyEBqyCgBIAABQUQxFcRQHCA1ZBQBkAAAIoDiKpViKpWiK54iOCISGrAIAgAAABAAAEDRDUzxHlETPVFXXtm3btm3btm3btm3btm1blmUZCA1ZBQBAAAAQ0mlmqQaIMAMZBkJDVgEACAAAgBGKMMSA0JBVAABAAACAGEoOogmtOd+c46BZDppKsTkdnEi1eZKbirk555xzzsnmnDHOOeecopxZDJoJrTnnnMSgWQqaCa0555wnsXnQmiqtOeeccc7pYJwRxjnnnCateZCajbU555wFrWmOmkuxOeecSLl5UptLtTnnnHPOOeecc84555zqxekcnBPOOeecqL25lpvQxTnnnE/G6d6cEM4555xzzjnnnHPOOeecIDRkFQAABABAEIaNYdwpCNLnaCBGEWIaMulB9+gwCRqDnELq0ehopJQ6CCWVcVJKJwgNWQUAAAIAQAghhRRSSCGFFFJIIYUUYoghhhhyyimnoIJKKqmooowyyyyzzDLLLLPMOuyssw47DDHEEEMrrcRSU2011lhr7jnnmoO0VlprrbVSSimllFIKQkNWAQAgAAAEQgYZZJBRSCGFFGKIKaeccgoqqIDQkFUAACAAgAAAAABP8hzRER3RER3RER3RER3R8RzPESVREiVREi3TMjXTU0VVdWXXlnVZt31b2IVd933d933d+HVhWJZlWZZlWZZlWZZlWZZlWZYgNGQVAAACAAAghBBCSCGFFFJIKcYYc8w56CSUEAgNWQUAAAIACAAAAHAUR3EcyZEcSbIkS9IkzdIsT/M0TxM9URRF0zRV0RVdUTdtUTZl0zVdUzZdVVZtV5ZtW7Z125dl2/d93/d93/d93/d93/d9XQdCQ1YBABIAADqSIymSIimS4ziOJElAaMgqAEAGAEAAAIriKI7jOJIkSZIlaZJneZaomZrpmZ4qqkBoyCoAABAAQAAAAAAAAIqmeIqpeIqoeI7oiJJomZaoqZoryqbsuq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq7ruq4LhIasAgAkAAB0JEdyJEdSJEVSJEdygNCQVQCADACAAAAcwzEkRXIsy9I0T/M0TxM90RM901NFV3SB0JBVAAAgAIAAAAAAAAAMybAUy9EcTRIl1VItVVMt1VJF1VNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVN0zRNEwgNWQkAAAEA0FpzzK2XjkHorJfIKKSg10455qTXzCiCnOcQMWOYx1IxQwzGlkGElAVCQ1YEAFEAAIAxyDHEHHLOSeokRc45Kh2lxjlHqaPUUUqxplo7SqW2VGvjnKPUUcoopVpLqx2lVGuqsQAAgAAHAIAAC6HQkBUBQBQAAIEMUgophZRizinnkFLKOeYcYoo5p5xjzjkonZTKOSedkxIppZxjzinnnJTOSeack9JJKAAAIMABACDAQig0ZEUAECcA4HAcTZM0TRQlTRNFTxRd1xNF1ZU0zTQ1UVRVTRRN1VRVWRZNVZYlTTNNTRRVUxNFVRVVU5ZNVbVlzzRt2VRV3RZV1bZlW/Z9V5Z13TNN2RZV1bZNVbV1V5Z1XbZt3Zc0zTQ1UVRVTRRV11RV2zZV1bY1UXRdUVVlWVRVWXZdWddVV9Z9TRRV1VNN2RVVVZZV2dVlVZZ1X3RV3VZd2ddVWdZ929aFX9Z9wqiqum7Krq6rsqz7si77uu3rlEnTTFMTRVXVRFFVTVe1bVN1bVsTRdcVVdWWRVN1ZVWWfV91ZdnXRNF1RVWVZVFVZVmVZV13ZVe3RVXVbVV2fd90XV2XdV1YZlv3hdN1dV2VZd9XZVn3ZV3H1nXf90zTtk3X1XXTVXXf1nXlmW3b+EVV1XVVloVflWXf14XheW7dF55RVXXdlF1fV2VZF25fN9q+bjyvbWPbPrKvIwxHvrAsXds2ur5NmHXd6BtD4TeGNNO0bdNVdd10XV+Xdd1o67pQVFVdV2XZ91VX9n1b94Xh9n3fGFXX91VZFobVlp1h932l7guVVbaF39Z155htXVh+4+j8vjJ0dVto67qxzL6uPLtxdIY+AgAABhwAAAJMKAOFhqwIAOIEABiEnENMQYgUgxBCSCmEkFLEGITMOSkZc1JCKamFUlKLGIOQOSYlc05KKKGlUEpLoYTWQimxhVJabK3VmlqLNYTSWiiltVBKi6mlGltrNUaMQcick5I5J6WU0loopbXMOSqdg5Q6CCmllFosKcVYOSclg45KByGlkkpMJaUYQyqxlZRiLCnF2FpsucWYcyilxZJKbCWlWFtMObYYc44Yg5A5JyVzTkoopbVSUmuVc1I6CCllDkoqKcVYSkoxc05KByGlDkJKJaUYU0qxhVJiKynVWEpqscWYc0sx1lBSiyWlGEtKMbYYc26x5dZBaC2kEmMoJcYWY66ttRpDKbGVlGIsKdUWY629xZhzKCXGkkqNJaVYW425xhhzTrHlmlqsucXYa2259Zpz0Km1WlNMubYYc465BVlz7r2D0FoopcVQSoyttVpbjDmHUmIrKdVYSoq1xZhza7H2UEqMJaVYS0o1thhrjjX2mlqrtcWYa2qx5ppz7zHm2FNrNbcYa06x5Vpz7r3m1mMBAAADDgAAASaUgUJDVgIAUQAABCFKMQahQYgx56Q0CDHmnJSKMecgpFIx5hyEUjLnIJSSUuYchFJSCqWkklJroZRSUmqtAACAAgcAgAAbNCUWByg0ZCUAkAoAYHAcy/I8UTRV2XYsyfNE0TRV1bYdy/I8UTRNVbVty/NE0TRV1XV13fI8UTRVVXVdXfdEUTVV1XVlWfc9UTRVVXVdWfZ901RV1XVlWbaFXzRVV3VdWZZl31hd1XVlWbZ1WxhW1XVdWZZtWzeGW9d13feFYTk6t27ruu/7wvE7xwAA8AQHAKACG1ZHOCkaCyw0ZCUAkAEAQBiDkEFIIYMQUkghpRBSSgkAABhwAAAIMKEMFBqyEgCIAgAACJFSSimNlFJKKaWRUkoppZQSQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQggFAPhPOAD4P9igKbE4QKEhKwGAcAAAwBilmHIMOgkpNYw5BqGUlFJqrWGMMQilpNRaS5VzEEpJqbXYYqycg1BSSq3FGmMHIaXWWqyx1po7CCmlFmusOdgcSmktxlhzzr33kFJrMdZac++9l9ZirDXn3IMQwrQUY6659uB77ym2WmvNPfgghFCx1Vpz8EEIIYSLMffcg/A9CCFcjDnnHoTwwQdhAAB3gwMARIKNM6wknRWOBhcashIACAkAIBBiijHnnIMQQgiRUow55xyEEEIoJVKKMeecgw5CCCVkjDnnHIQQQiillIwx55yDEEIJpZSSOecchBBCKKWUUjLnoIMQQgmllFJK5xyEEEIIpZRSSumggxBCCaWUUkopIYQQQgmllFJKKSWEEEIJpZRSSimlhBBKKKWUUkoppZQQQimllFJKKaWUEkIopZRSSimllJJCKaWUUkoppZRSUiillFJKKaWUUkoJpZRSSimllJRSSQUAABw4AAAEGEEnGVUWYaMJFx6AQkNWAgBAAAAUxFZTiZ1BzDFnqSEIMaipQkophjFDyiCmKVMKIYUhc4ohAqHFVkvFAAAAEAQACAgJADBAUDADAAwOED4HQSdAcLQBAAhCZIZINCwEhweVABExFQAkJijkAkCFxUXaxQV0GeCCLu46EEIQghDE4gAKSMDBCTc88YYn3OAEnaJSBwEAAAAAYAAADwAAxwUQEdEcRobGBkeHxwdISAAAAAAAuADABwDAIQJERDSHkaGxwdHh8QESEgAAAAAAAAAAAAQEBAAAAAAAAgAAAAQET2dnUwAEgCUAAAAAAAC/67J4AgAAANS0R9sLHUk6ODk5PDo6OqRE79VDp5JDx0t91EAAID3S8de8U4fD4ZpUwjAMAdq51vi3ADT6ng+Y41mOv5Ka4jR2vn/13fe//8YcOAcAIAUAAAAAAAAAUEutuhCtOUcjHwGAvo2jKIrKy6NIQDA/jAJM77333gE+yo7rj+AHpPZ8zKjv48uJLakpTgMAnFUAACkAAAAAAAAAAABAVFRUWk8AAJ0KrAQAAJo+HQsAAAAAPsqOx4/gB7T2vGOgvo9eTqiSmuI0AMB0AABQAQAAAAAAAAAAgIoOK9p6AgA4tloBAAChxL8dAwA+yo7bH8EXeO15j4H6fiK3kpriNADAJwAAoAIAAAAAAAAAAIAW2zFiqzcHAG6/PZAAAGDHvOUAAAA+yo7bH8EXeO15D4H6fiInVElNcRoA4A8AAFABAAAAAAAAAABQXvvFmu+7AwCvmm0EAABC9+2OAQA+yo7Hj+AHtPa8Q6C+j15OuJKa4hIAAAAAVAAAAAAAAAAAALj+AgBuAwA22Eo22Mq+d58DAAB2zHIAAAA+yo6XH8EXeO15joH6fkpO6JOa4jQALP4EAAAqAAAAAAAAAAAAyvuyQ3f7cwCAV9dtBAAAQncZIAAAPsqO2x/BF3jteQ+B+n5KTuiTmuI0AMAtAABQAQAAAAAAAAAAgIaepKGvbwYA3L55IAAAwK4pDAAAAP7JdvWH/1rt+Qajvk9PLpGa4jRAxwHOAACACgAAAAAAAAAAdflvlJ30KEtPAgD31yMFAACh00uAAAC+Wa7KLwHQrtP9eYV37HfuBDXFM3fOMTaazu/e6IQA+vZUAgAkSYxgAOA91kwPpf4+7qilJV/Iz+7eXFt9XmhJLInaXBtrtad0zoXY7Hsp+86F2Ky9lPHawnvZ97KUsLYQl30vOV5beMq+lzleW3jKvpc5Xqu9lH0vC/HawkvZdy7Ea30vpbO2EK/VXkrnXIjN2ktpzwUvay+zXeqWlpQDs0EAJA==";
medias['dtmf-7'] = "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";
medias['dtmf-8'] = "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";
medias['dtmf-9'] = "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";
medias['dtmf-busy'] = "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";
medias['dtmf-pound'] = "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";
medias['dtmf-ringback'] = "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";
medias['dtmf-star'] = "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";
medias.ringtone = "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";

function Sound(options, eventbus, configuration, sipstack) {
  var self = {};

  var soundOut;
  var soundOutDTMF;
  var muted = false;
  
  self.init = function() {
    soundOut = $('<audio>', {volume: configuration.volumeClick}).appendTo($('body'));
    soundOutDTMF = $('<audio>', {volume: configuration.volumeDTMF}).appendTo($('body'));
  };

  self.listeners = function() {
    eventbus.on("progress", function(e) {
      self.playDtmfRingback();
    });
    eventbus.on("failed", function(e) {
      self.pause();
    });
    eventbus.on("resumed", function() {
      self.pause();
      self.updateLocalAudio();
    });
    eventbus.on("started", function() {
      self.pause();
      self.updateLocalAudio();
    });
    eventbus.on("userMediaUpdated", function() {
      self.updateLocalAudio();
    });
    eventbus.on('newDTMF', function(e) {
      var digit = e.data.tone;
      debug('DTMF sent : ' + digit);
      if (!digit) {
        return;
      }
      var file = null;
      if (digit === "*") {
        file = "star";
      } else if (digit === "#") {
        file = "pound";
      } else {
        file = digit;
      }
      self.playDtmfTone(file);
    });    
  };

  self.setMuted = function(m) {
    muted = m;
    eventbus.viewChanged(self);
    self.updateLocalAudio();
  };

  self.updateLocalAudio = function() {
    self.enableLocalAudio(!muted);
  };

  self.enableLocalAudio = function(enabled) {
    var localStreams = sipstack.getLocalStreams();
    if (!localStreams || localStreams.length === 0) {
      return;
    }
    var localMedia = localStreams[0];
    var localAudio = localMedia.getAudioTracks()[0];
    localAudio.enabled = enabled;
  };

  self.pause = function() {
    soundOut.trigger('pause');
    soundOutDTMF.trigger('pause');
  };

  self.playDtmfRingback = function() {
    self.playDtmf("dtmf-ringback", {
      loop: true
    });
  };

  self.playRingtone = function() {
    self.play("ringtone", {
      loop: true
    });
  };

  self.playDtmfTone = function(tone) {
    self.playDtmf("dtmf-" + tone);
  };

  self.playClick = function() {
    self.play("click");
  };

  self.play = function(media, options) {
    self.playTone(soundOut, media, options);
  };

  self.playTone = function(audioSource, media, options) {
    // avoid restarting same playing audio
    if (audioSource.attr("src") === media && !audioSource[0].paused) {
      return;
    }
    options = options || {};
    audioSource.attr("src", medias[media]);
    if (options.loop) {
      audioSource.attr("loop", "true");
    } else {
      audioSource.attr('loop', '');
    }
    audioSource.trigger('play');
  };

  self.playDtmf = function(media, options) {
    self.playTone(soundOutDTMF, media, options);
  };

  return self;
}

},{"jquery":230}],468:[function(require,module,exports){
module.exports = XMPP;

var XMPP = require('stanza.io');

function XMPP(options, debug, eventbus) {
  var self = {};

  var client;
  self.login = function(jid, password) {
    client = XMPP.createClient({
      jid: jid,
      password: password,

      // If you have a .well-known/host-meta.json file for your 
      // domain, the connection transport config can be skipped. 

      transport: 'bosh',
      boshURL: 'broadsoft.com'
        // (or `boshURL` if using 'bosh' as the transport) 
    });
    return client;
  };

  self.init = function() {
  };

  self.listeners = function() {
    var self = this;
    eventbus.on("started", function() {
      // self.statusBeforeCall = converse.getStatus();
      // debug('status before call : ' + self.statusBeforeCall);
      // converse.setStatus('dnd');
    });
    eventbus.on("ended", function() {
      // debug('reset status to : ' + self.statusBeforeCall);
      // converse.setStatus(self.statusBeforeCall);
    });
  };

  return self;
}
},{"stanza.io":232}],469:[function(require,module,exports){
module.exports = Prop;

function Prop(obj, prop) {
	var self = {};

	self._name = prop.name || prop;
	var internal;
	var data = obj.view && obj.view[self._name] || function(value){
		if(arguments.length === 1) {
			internal = value;
		} else {
			return internal;
		}
	};

	self.__get = function(){
		if(data.val) {
			return data.val();
		} else if(data.prop) {
			return data.prop('checked');
		} else {
			return data()
		}
	};
	self.__init = function(){
		if(prop.value) {
			obj[self._name] = prop.value();
		}	
	};
	self.__set = function(value){
		if(prop.default && !value) {
			value = prop.default;
		}
		if(data.val) {
			data.val(value);
		} else if(data.prop) {
			data.prop('checked', value);
		} else {
			data(value);
		}
	};

	self.define = function(){
		Object.defineProperty(obj, self._name, {
			writeable: false,
			get: prop.get || self.__get,
			set: prop.set || self.__set
		});	

		self.__init();
	};

	return self;
}
},{}],470:[function(require,module,exports){
module.exports = AuthenticationView;

var $ = require('jquery');
var PopupView = require('./popup');

function AuthenticationView(options, eventbus, settings, configuration, debug) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['ok', 'userid', 'authUserid', 'password', 'alert'];

  self.listeners = function() {
    eventbus.on('registrationFailed', function(e) {
      var statusCode = e.data.response.status_code;
      debug('registration failed : '+statusCode+', '+settings.userid+', '+settings.password);
      if ((statusCode === 403 && settings.userid && !settings.password) || configuration.register) {
        self.setVisible(true);
      }
    });

    eventbus.on('viewChanged', function(e) {
      if(e.view === 'authentication' && e.visible) {
        self.authUserid.val(settings.authenticationUserid);
        self.userid.val(settings.userid);
      }
    });

    self.ok.bind('click', function() {
      var userId = self.userid.val();
      if (!userId) {
        self.alert.text("Invalid User ID").fadeIn(10).fadeOut(4000);
        return;
      }
      var authUserId = self.authUserid.val();
      var password = self.password.val();
      self.setVisible(false);
      eventbus.emit('authenticate', {
        userId: userId,
        authenticationUserId: authUserId,
        password: password
      })
      eventbus.once("registered", function() {
        if (authUserId && settings.userid !== authUserId) {
          settings.authenticationUserid = authUserId;
        }
        settings.userid = userId;
        settings.password = password;
      });
    });

    self.view.bind('keypress', function(e) {
      if (e.which === 13) {
        self.ok.click();
      }
    });
  };

  return self;
}
},{"./popup":478,"jquery":230}],471:[function(require,module,exports){
module.exports = ClientView;


var styles = ".bdsft-reset{font-size:14px;font:normal normal 14px Open Sans,Arial,sans-serif}.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-size:100%;font:normal normal 100% Open Sans,Arial,sans-serif}.bdsft-reset,.bdsft-reset div,.bdsft-reset span,.bdsft-reset applet,.bdsft-reset object,.bdsft-reset iframe,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset p,.bdsft-reset blockquote,.bdsft-reset pre,.bdsft-reset a,.bdsft-reset abbr,.bdsft-reset acronym,.bdsft-reset address,.bdsft-reset big,.bdsft-reset cite,.bdsft-reset code,.bdsft-reset del,.bdsft-reset dfn,.bdsft-reset em,.bdsft-reset img,.bdsft-reset ins,.bdsft-reset kbd,.bdsft-reset q,.bdsft-reset s,.bdsft-reset samp,.bdsft-reset small,.bdsft-reset strike,.bdsft-reset strong,.bdsft-reset sub,.bdsft-reset sup,.bdsft-reset tt,.bdsft-reset var,.bdsft-reset b,.bdsft-reset u,.bdsft-reset i,.bdsft-reset center,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset dd,.bdsft-reset ol,.bdsft-reset ul,.bdsft-reset li,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset label,.bdsft-reset legend,.bdsft-reset table,.bdsft-reset caption,.bdsft-reset tbody,.bdsft-reset tfoot,.bdsft-reset thead,.bdsft-reset tr,.bdsft-reset th,.bdsft-reset td,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset menu,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary,.bdsft-reset time,.bdsft-reset mark,.bdsft-reset audio,.bdsft-reset video,.bdsft-reset button,.bdsft-reset textarea,.bdsft-reset input{font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal;alignment-adjust:auto;alignment-baseline:baseline;-webkit-animation:none 0 ease 0 1 normal;-moz-animation:none 0 ease 0 1 normal;-ms-animation:none 0 ease 0 1 normal;animation:none 0 ease 0 1 normal;-webkit-animation-play-state:running;-moz-play-state:running;-ms-animation-play-state:running;animation-play-state:running;appearance:normal;azimuth:center;backface-visibility:visible;background:none 0 0 auto repeat scroll padding-box transparent;background-color:transparent;background-image:none;baseline-shift:baseline;binding:none;bleed:6pt;bookmark-label:content();bookmark-level:none;bookmark-state:open;bookmark-target:none;border:0 none transparent;-webkit-border-radius:0;-moz-border-radius:0;border-radius:0;bottom:auto;box-align:stretch;box-decoration-break:slice;box-direction:normal;box-flex:0;box-flex-group:1;box-lines:single;box-ordinal-group:1;box-orient:inline-axis;box-pack:start;-webkit-box-shadow:none;-moz-box-shadow:none;box-shadow:none;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;break-after:auto;break-before:auto;break-inside:auto;caption-side:top;clear:none;clip:auto;color:inherit;color-profile:auto;-webkit-column-count:auto;-webkit-column-fill:balance;-webkit-column-gap:normal;-webkit-column-rule:medium medium #1f1f1f;-webkit-column-span:1;-webkit-column-width:auto;-webkit-columns:auto auto;-moz-column-count:auto;-moz-column-fill:balance;-moz-column-gap:normal;-moz-column-rule:medium medium #1f1f1f;-moz-column-span:1;-moz-column-width:auto;-moz-columns:auto auto;column-count:auto;column-fill:balance;column-gap:normal;column-rule:medium medium #1f1f1f;column-span:1;column-width:auto;columns:auto auto;content:normal;counter-increment:none;counter-reset:none;crop:auto;cursor:auto;direction:ltr;display:inline;dominant-baseline:auto;drop-initial-after-adjust:text-after-edge;drop-initial-after-align:baseline;drop-initial-before-adjust:text-before-edge;drop-initial-before-align:caps-height;drop-initial-size:auto;drop-initial-value:initial;elevation:level;empty-cells:show;fit:fill;fit-position:0;float:none;float-offset:0;grid-columns:none;grid-rows:none;hanging-punctuation:none;height:auto;hyphenate-after:auto;hyphenate-before:auto;hyphenate-character:auto;hyphenate-lines:no-limit;hyphenate-resource:none;hyphens:manual;icon:auto;image-orientation:auto;image-rendering:auto;image-resolution:normal;inline-box-align:last;left:auto;line-height:inherit;line-stacking:inline-line-height exclude-ruby consider-shifts;list-style:disc outside none;margin:0;marks:none;marquee-direction:forward;marquee-loop:1;marquee-play-count:1;marquee-speed:normal;marquee-style:scroll;max-height:none;max-width:none;min-height:0;min-width:0;move-to:normal;nav-down:auto;nav-index:auto;nav-left:auto;nav-right:auto;nav-up:auto;opacity:1;orphans:2;outline:invert none medium;outline-offset:0;overflow:visible;overflow-style:auto;padding:0;page:auto;page-break-after:auto;page-break-before:auto;page-break-inside:auto;page-policy:start;perspective:none;perspective-origin:50% 50%;position:static;presentation-level:0;punctuation-trim:none;quotes:none;rendering-intent:auto;resize:none;right:auto;rotation:0;rotation-point:50% 50%;ruby-align:auto;ruby-overhang:none;ruby-position:before;ruby-span:none;size:auto;string-set:none;table-layout:auto;top:auto;-webkit-transform:none;-moz-transform:none;transform:none;-webkit-transform-origin:50% 50%;-moz-transform-origin:50% 50%;-o-transform-origin:50% 50%;transform-origin:50% 50% 0;transform-style:flat;-webkit-transition:all 0 ease 0;-moz-transition:all 0 ease 0;-o-transition:all 0 ease 0;transition:all 0 ease 0;unicode-bidi:normal;vertical-align:baseline;white-space:normal;white-space-collapse:collapse;widows:2;width:auto;word-break:normal;word-spacing:normal;word-wrap:normal;z-index:auto;text-align:start}.bdsft-reset address,.bdsft-reset blockquote,.bdsft-reset dd,.bdsft-reset div,.bdsft-reset dl,.bdsft-reset dt,.bdsft-reset fieldset,.bdsft-reset form,.bdsft-reset div.form,.bdsft-reset frame,.bdsft-reset frameset,.bdsft-reset h1,.bdsft-reset h2,.bdsft-reset h3,.bdsft-reset h4,.bdsft-reset h5,.bdsft-reset h6,.bdsft-reset noframes,.bdsft-reset ol,.bdsft-reset p,.bdsft-reset ul,.bdsft-reset center,.bdsft-reset dir,.bdsft-reset hr,.bdsft-reset menu,.bdsft-reset pre,.bdsft-reset article,.bdsft-reset aside,.bdsft-reset canvas,.bdsft-reset details,.bdsft-reset figcaption,.bdsft-reset figure,.bdsft-reset footer,.bdsft-reset header,.bdsft-reset hgroup,.bdsft-reset nav,.bdsft-reset section,.bdsft-reset summary{display:block}.bdsft-reset li{display:list-item}.bdsft-reset table{display:table}.bdsft-reset tr{display:table-row}.bdsft-reset thead{display:table-header-group}.bdsft-reset tbody{display:table-row-group}.bdsft-reset tfoot{display:table-footer-group}.bdsft-reset col{display:table-column}.bdsft-reset colgroup{display:table-column-group}.bdsft-reset td,.bdsft-reset th{display:table-cell}.bdsft-reset caption{display:table-caption}.bdsft-reset input,.bdsft-reset select{display:inline-block}.bdsft-reset b,.bdsft-reset strong,.bdsft-reset strong>*{font-weight:bold}.bdsft-reset textarea,.bdsft-reset input{cursor:text}.bdsft-reset textarea .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset textarea::-webkit-input-placeholder,.bdsft-reset textarea .bdsft-reset input::-webkit-input-placeholder,.bdsft-reset input .bdsft-reset input::-webkit-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-moz-placeholder,.bdsft-reset input .bdsft-reset textarea:-moz-placeholder,.bdsft-reset textarea .bdsft-reset input:-moz-placeholder,.bdsft-reset input .bdsft-reset input:-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea::-moz-placeholder,.bdsft-reset input .bdsft-reset textarea::-moz-placeholder,.bdsft-reset textarea .bdsft-reset input::-moz-placeholder,.bdsft-reset input .bdsft-reset input::-moz-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset textarea .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset input .bdsft-reset textarea:-ms-input-placeholder,.bdsft-reset textarea .bdsft-reset input:-ms-input-placeholder,.bdsft-reset input .bdsft-reset input:-ms-input-placeholder{background-color:inherit;color:inherit;font-family:Open Sans,Arial,sans-serif;font-size-adjust:none;font-size:100%;font-style:normal;letter-spacing:normal;font-stretch:normal;font-variant:normal;font-weight:normal;font:normal normal 100% Open Sans,Arial,sans-serif;text-align:left;text-align-last:start;text-decoration:none;text-emphasis:none;text-height:auto;text-indent:0;text-justify:auto;text-outline:0;text-shadow:none;text-transform:none;text-wrap:normal}.bdsft-reset input[type=checkbox],.bdsft-reset input[type=radio]{cursor:default}.bdsft-reset a,.bdsft-reset a *,.bdsft-reset a span,.bdsft-reset button,.bdsft-reset button *,.bdsft-reset button span,.bdsft-reset input[type=submit],.bdsft-reset input[type=reset]{cursor:pointer}.bdsft-reset a:link,.bdsft-reset a:visited,.bdsft-reset a:hover,.bdsft-reset a:active{color:inherit;background:transparent;text-shadow:none}.bdsft-reset button::-moz-focus-inner{border:0;padding:0}.bdsft-reset *[class^='bdsft-icon']{font-family:FontAwesome!important}body{background-color:#fff;margin:0;font-family:'Open Sans',Arial,sans-serif;-webkit-font-smoothing:antialiased!important}.button:active{color:#04aff0;background:-webkit-gradient(linear,left top,right bottom,from(#7cdd07),to(#faa51a));background:linear-gradient(to bottom left,#7cdd07,#faa51a)}.button:hover{box-shadow:0 0 10px #999}.popup{display:none;background:#333;padding:10px;border:2px solid #ddd;float:left;position:absolute;top:0;bottom:0;left:0;right:0;margin:auto;box-shadow:0 0 10px #999;border-radius:3px;font-size:14px;line-height:18px;z-index:100}.popup .actions{text-align:right}.popup .title{font-weight:bold;font-size:16px;color:#fff}.ui-widget-content.ui-dialog{display:none;color:#999;font-size:22px;background:#333;padding:10px;border:2px solid #ddd;box-shadow:0 0 10px #999;border-radius:3px;z-index:99}.no-close .ui-dialog-titlebar-close{display:none}.unsupported{position:absolute;top:240px;left:30px;width:600px;background-color:#191414;text-align:center;display:none;color:#fff;z-index:10}#screen_sharing_unsupported{position:relative;top:0;left:0;margin:10px;background:#f00}#screen_sharing_unsupported{display:none}#screen_sharing_unsupported span{text-decoration:underline}.historyRowSample{display:none}.default-color{color:#2ba6cb}[id$=\"sample\"]{display:none!important}#javascript_disabled{display:block;background-color:#fff;color:#000}a.disabled{pointer-events:none;cursor:default;background-color:#999;opacity:.5}.main{position:relative;top:0;left:0;width:100%}.main:-webkit-full-screen-ancestor:not(iframe){position:absolute!important;top:0;left:0;right:0;bottom:0;width:100%;height:100%}.client{position:relative;top:0;left:0}.client.r1280x720{width:1280px}.client.r960x720{width:960px}.client .table{display:table;width:100%}.client .fixed{table-layout:fixed}.client .collapse{border-collapse:collapse}.client .cell{display:table-cell}.client .heading{display:table-row;font-weight:bold}.client .row{display:table-row;margin:0}.client .group{display:table-row-group}.client .fadeable{opacity:0;display:block;z-index:-1;backface-visibility:hidden}.client::-webkit-scrollbar{width:8px}.client::-webkit-scrollbar-track,.client::-webkit-scrollbar-thumb{background:#272727}.client::-webkit-scrollbar-track:window-inactive,.client::-webkit-scrollbar-thumb:window-inactive{background:#272727}.client.view-centered{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);backface-visibility:hidden}.client.r640x360,.client.r640x480{width:640px}.client.r320x180,.client.r320x240{width:320px}.full-screen-expanded.client{width:100%!important;height:100%!important}.full-screen-expanded .main{height:100%}.client .row:before,.client .row:after{display:none}.client.view-audioOnly{display:inline-block;width:auto}.callHistory{display:none;position:absolute;width:200px;height:258px;right:auto;left:200px;bottom:40px;top:auto;background:#292929;overflow:hidden;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:0}.callHistory .rowSpace{padding:.5em}.callHistory .actions{margin-top:12px}.callHistory .content{padding:16px 0 10px 0;height:68%;width:200px;overflow:auto;margin-bottom:10px}.callHistory .content .history-row:hover,.callHistory .content .history-row.active{background:#353535}.callHistory .content .history-row{cursor:pointer;position:relative}.callHistory .content .history-row .row{display:block;margin:0;position:relative;height:46px}.callHistory .content .history-row .hist-direction{position:absolute;color:#3da005;left:3px;font-family:arial;font-size:18px;top:6px}.callHistory .content .history-row .icon-arrow-down-thick{color:#e9651d}.callHistory .content .history-row .hist-destination{position:absolute;color:#b3b3b3;left:25px;font-family:arial;font-size:18px;text-decoration:none;top:6px}.callHistory .content .history-row .hist-date{position:absolute;color:#b3b3b3;left:26px;font-family:arial;font-size:10px;top:29px}.callHistory .content .history-row .hist-length{position:absolute;color:#b3b3b3;left:104px;font-family:arial;font-size:10px;top:29px}.callHistory .content .history-row .hist-details-arrow{position:absolute;right:8px;font-size:16px;top:14px}.callHistory .historyClose a{color:#04aff0;font-size:14px;font-weight:700;text-decoration:none;margin-left:8px}.callHistory .historyClose a:hover{color:#017ead}.callHistory .callHistoryDetails{background:#fff;width:194px;height:auto;clear:both;top:0;bottom:-1;left:201px;right:auto;box-shadow:none;border-radius:0;background:#292929;border:1px solid #3c3c3c;border-top:0;overflow:auto}.callHistory .callHistoryDetails .callLink{text-align:left;background:#6f6f6f;float:left;padding:6px 10px 6px 10px;text-decoration:none;font-weight:bold;color:#fff!important;border-radius:50px;font-size:14px!important}.callHistory .callHistoryDetails .historyDetailsClose{text-align:right;margin-top:10px;text-align:right;margin-top:10px;display:inline-block!important;height:26px;margin-top:0}.callHistory .callHistoryDetails .historyDetailsClose .icon-ok{margin:0}.callHistory .callHistoryDetails .historyDetailsClose a{text-decoration:none;outline-color:rgba(0,0,0,0);color:#aaa;font-size:18px}.callHistory .callHistoryDetails .table{font-size:13px;padding-left:8px}.callHistory .callHistoryDetails .table #history-dt-close-container{text-align:right}.callHistory .classHistoryActions{padding-top:2px}.callHistory .historyClear a{text-decoration:none;color:#fff;font-size:14px;font-weight:700;background:#6f6f6f;border-radius:20px;padding:5px 10px;margin-left:15px}.callHistory .historyClear a:hover{background:#4e4e4e}.stats{display:none;position:absolute;top:10px;left:660px;width:400px;top:auto;bottom:40px;right:0;left:auto;background-color:#292929;border-radius:0;border:1px solid #3c3c3c;box-shadow:none;color:#999;z-index:200;padding:10px}.stats .statsVideo{position:absolute;white-space:pre-wrap;color:#0082ff;left:10px;font-family:arial;font-size:18px;text-decoration:none}.stats .statsAudio{position:absolute;white-space:pre-wrap;color:#0082ff;left:260px;float:left;font-family:arial;font-size:18px;text-decoration:none}.stats a{color:#2ba6cb}.stats .spacer{height:15px}.stats .statsDelay{display:none}.stats-table-container,.stats-graph-sub-container{display:none}.stats0-selected .kiloBitsSentPerSecond-video,.stats1-selected .kiloBitsSentPerSecond-audio,.stats2-selected .kiloBitsReceivedPerSecond-video,.stats3-selected .kiloBitsReceivedPerSecond-audio,.stats4-selected .packetsLost-video,.stats5-selected .packetsLostPer-video,.stats6-selected .packetsLost-audio,.stats7-selected .packetsLostPer-audio,.stats8-selected .googFrameRateSent-video,.stats9-selected .googFrameRateReceived-video,.stats10-selected .audioOutputLevel-audio,.stats11-selected .audioInputLevel-audio,.stats12-selected .googFrameWidthReceived-video,.stats13-selected .googFrameHeightReceived-video,.stats14-selected .googFrameWidthSent-video,.stats15-selected .googFrameHeightSent-video,.stats16-selected .googRtt-audio,.stats17-selected .googJitterReceived-audio{display:block}.callStats{color:<%= statsColor %>}.stats-graph-sub-container canvas{width:100%}.statsContainer{margin-bottom:18px}.dialpad{padding:15px;background:#292929;border:1px solid #3c3c3c;display:none;position:absolute;bottom:40px;right:auto;width:170px;top:auto;left:0;letter-spacing:5px;z-index:100;box-sizing:content-box;height:228px;padding-left:14px}.dialpad button{color:#333;opacity:.8;font-family:arial;font-size:20px;width:30px;border-color:#000;border-width:1px;border-radius:4px;border-spacing:5em;font-weight:bold;line-height:33px;margin:.1em;border-top-style:outset;cursor:pointer;color:#b3b3b3;background:0;border-radius:0;font-weight:normal;padding:0;margin:0;border:0;width:50px}.dialpad button:active{color:#04aff0;background:-webkit-gradient(linear,left top,left bottom,from(#f47a20),to(#faa51a));background:linear-gradient(to left bottom,#f47a20,#faa51a)}.dialpad button:hover{box-shadow:1px 1px 20px #999;background:#3a3a3a;box-shadow:none}.dialpad button:focus{outline:0}.dialpad button span{display:block;font-size:8px;text-align:center;font-weight:bold;margin-top:-13px;color:#2d7b99}.dialpad .btn-star{font-size:30px;vertical-align:middle}.dialpad .historyButton{font-size:16px!important;padding-top:5px;padding-bottom:5px;outline:0;position:absolute;right:4px;top:5px;width:25px}.dialpad .historyButton.active{color:#04aff0}.dialpad .dialpad-control-bar{margin-top:6px}.dialpad .dialpad-control-bar .main-button{background:#3da005;border-radius:14px;width:70px;padding:5px;margin:0 auto}.dialpad .dialpad-control-bar a{color:#fff;text-decoration:none;text-align:center;width:100%;display:inline-block;font-size:14px;font-weight:700;letter-spacing:1}.dialpad .dialpad-control-bar a span{margin-right:5px}.view-audioOnly .dialpad{top:45px}.callControl{display:none;position:relative;left:0;top:0;height:75px;color:#666;font-family:arial;font-size:18px;font-weight:bold;height:auto;display:block}.callControl .destination::-webkit-input-placeholder{color:#04aff0;font-style:italic;padding-left:5px;font-weight:400}.callControl hr{border:0;border-bottom:1px solid #3c3c3c}.callControl input{background:#333;border:1px solid #3c3c3c;color:#d3d3d3;font-family:arial;font-size:18px;padding:0;border-radius:0;width:171px;line-height:30px;padding-left:8px;padding-right:35px}.callControl input:focus{outline:0}.transferPopup{color:#fff;width:280px;height:60px}.transferTarget{width:200px}.call{display:none;position:absolute;z-index:10;top:25px;left:265px;display:block;position:static;top:auto;left:auto}.client:not(.connected) .call{transition:all 1s linear;opacity:0;z-index:-1}.enable-call-control .callControl{transition:all 1s linear;opacity:1;z-index:20}.callPopup{padding:0;background:#292929;border:1px solid #3c3c3c;box-shadow:none;width:220px;border-radius:0;height:168px}.callPopup span{color:#999;font-size:22px}.callPopup .incomingCallTitle{display:block;padding:8px;font-size:18px;font-weight:bold;background:#3c3c3c;margin-bottom:18px;color:#e4e4e4}.callPopup .acceptIncomingCall{background:#3da005;border:0;border-radius:20px;padding:5px 10px;font-size:14px;color:#fff;margin-left:12px}.callPopup #rejectIncomingCallContainer{text-align:right}.callPopup #rejectIncomingCallContainer button{background:#f00;border:0;border-radius:20px;padding:5px 10px;font-size:14px;color:#fff;margin-right:12px}.holdAndAnswerButton,.dropAndAnswerButton,.acceptIncomingCall{display:none}.started .holdAndAnswerButton,.started .dropAndAnswerButton,.client:not(.started) .acceptIncomingCall{display:inline-block}.callPopup{width:170px;height:137px}.incomingCallName,.incomingCallUser{display:block;margin-left:10px;margin-bottom:18px}.incomingcall-shown .callPopup{transition:all 1s linear;opacity:1;z-index:100}.reInvitePopup{width:170px;height:137px;transition:all 1s linear;opacity:0;z-index:-1}.reinvite-shown .reInvitePopup{transition:all 1s linear;opacity:1;z-index:100}.reinvite-hidden .reInvitePopup{transition:all 1s linear;opacity:0;z-index:-1}.video{position:relative;top:0;left:0;width:100%;height:auto}.video:-webkit-full-screen{position:absolute;height:100%;border:0;z-index:1}.video .remote{position:absolute;top:0;left:0;width:100%;height:100%;background-color:#191414;border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #000;border-radius:0;border:0;box-shadow:0 0 1px rgba(0,0,0,0.05);background:#000;background:-moz-linear-gradient(top,#181818 0,#494949 100%);background:-webkit-gradient(linear,left top,left bottom,color-stop(0%,#181818),color-stop(100%,#494949));background:-webkit-linear-gradient(top,#181818 0,#494949 100%);background:-o-linear-gradient(top,#181818 0,#494949 100%);background:-ms-linear-gradient(top,#181818 0,#494949 100%);background:linear-gradient(to bottom,#181818 0,#494949 100%);overflow:hidden}.video .localVideo{position:absolute;top:auto;left:0;bottom:0;right:auto;width:25%;height:25%;background-color:transparent;z-index:99}.video .localVideo video{border-radius:0;box-shadow:none;background:#292929;border:1px solid #3c3c3c;cursor:move;width:100%;height:100%;position:absolute}.video .localVideo .inner{margin:5px;position:absolute;top:0;bottom:0;right:0;left:0}.full-screen-expanded .video{padding-bottom:0;bottom:40px;position:absolute;height:auto!important}.widescreen .video{padding-bottom:56.25%}.standard .video{padding-bottom:75%}:-webkit-full-screen .remote{z-index:1}:-webkit-full-screen .localVideo{z-index:2}:-webkit-full-screen .remote,:-webkit-full-screen .localVideo{border:0;border-radius:0}.started .watermark-icon{display:none;transform:none;box-shadow:0 0 1px rgba(0,0,0,0.05)}.started .remote{box-shadow:0 0 1px rgba(0,0,0,0.1)}.connected .watermark-icon{box-shadow:0 0 1px rgba(0,0,0,0.05)}.selfView-bl .localVideo{top:auto;bottom:0;left:0;right:auto}.selfView-tl .localVideo{top:0;bottom:auto;left:0;right:auto}.selfView-tr .localVideo{top:0;bottom:auto;left:auto!important;right:0}.selfView-br .localVideo{top:auto;bottom:0;left:auto!important;right:0}.selfView-1x .localVideo{width:25%;height:25%}.selfView-2x .localVideo{width:50%;height:50%}.view-audioOnly .video{display:none!important}.settingsPopup{display:none;padding:2px;position:absolute;line-height:28px;z-index:99;border:1px solid #3c3c3c;background:#292929;border-radius:0;box-shadow:none;bottom:40px;right:0;top:auto;left:auto;width:304px!important;font-size:14px;height:276px;overflow:hidden}.settingsPopup span{color:#999;font-size:20px;font-size:14px}.settingsPopup [type=\"checkbox\"]{width:18;height:18;vertical-align:middle}.settingsPopup .short{width:36px}.settingsPopup input{background:#333;border:1px solid #414141;color:#eee;padding-left:5px;line-height:22px;font-size:13px;margin-left:14px}.settingsPopup select{margin-left:14px}.settingsPopup .tabs span{margin-right:5px;color:#fff}.settingsPopup .btn{background:#04aff0;color:#fff;padding:5px 10px;text-decoration:none;border-radius:20px;margin-left:9px;margin-top:15px;font-weight:700;text-align:center}.settingsPopup .btn:hover{background:#017ead}.settingsPopup .clear{display:inline-block;color:#04aff0;margin-left:10px;text-decoration:none;font-weight:700}.settingsPopup .clear:hover{color:#017ead}.settingsPopup .save{display:inline-block}.settingsPopup .resolutionSubType{display:none}.settingsPopup .tabs{width:250px;padding-left:0}.settingsPopup .tabs li{list-style:none;display:inline}.settingsPopup .tabs a{padding:5px 10px;display:inline-block;background:#494949;color:#fff;text-decoration:none}.settingsPopup .tabs a.active{background:#04aff0;color:#fff}.settingsPopup .tabs ~div p,.settingsPopup .tabs ~div h3{margin-bottom:15px;color:#999;font-size:14px}.tabs .settingsPopup ~ div{padding:10px;margin-bottom:10px}.enable-mute.unmuted.started .muteAudioIcon,.enable-mute.muted.started .unmuteAudioIcon,.enable-full-screen.full-screen-contracted .fullScreenExpand,.enable-full-screen.full-screen-expanded .fullScreenContract,.enable-self-view.self-view-enabled .selfViewDisable,.enable-self-view.self-view-disabled .selfViewEnable,.enable-self-view.self-view-enabled .localVideo,.enable-dialpad.dialpad-shown .dialpadIconHide,.enable-dialpad.dialpad-hidden .dialpadIconShow,.enable-call-control.connected .call,.enable-transfer.started .transfer,.enable-timer.started .timer,.client:not(.held).enable-hold.started .hold,.enable-hold.started.held .resume,.enable-screen-sharing.screen-sharing-off .shareScreen,.enable-screen-sharing.screen-sharing .stopShareScreen,.enable-file-share.started .file_share,.enable-settings .settings{transition:all 1s linear;opacity:1;z-index:20}.enable-transfer.started.transfer-visible .transferPopup,.enable-dialpad.dialpad-shown .dialpad,.enable-sms.sms-shown .sms,.enable-settings.settings-shown .settingsPopup{transition:all 1s linear;opacity:1;z-index:100}.enable-screen-sharing.screen-sharing .shareScreen,.enable-screen-sharing.screen-sharing-off .stopShareScreen,.enable-mute.connected .muteAudioIcon,.enable-mute.disconnected .muteAudioIcon,.enable-mute.connected .unmuteAudioIcon,.enable-mute.disconnected .unmuteAudioIcon,.enable-mute.muted .muteAudioIcon,.enable-mute.unmuted .unmuteAudioIcon,.enable-full-screen.full-screen-expanded .fullScreenExpand,.enable-full-screen.full-screen-contracted .fullScreenContract,.enable-self-view.self-view-disabled .selfViewDisable,.enable-self-view.self-view-enabled .selfViewEnable,.enable-self-view.self-view-disabled .localVideo,.enable-dialpad.dialpad-hidden .dialpadIconHide,.enable-dialpad.dialpad-shown .dialpadIconShow,.enable-dialpad.dialpad-hidden .dialpad,.enable-sms.sms-hidden .sms,.enable-stats.stats-hidden .stats,.enable-transfer.connected .transfer,.enable-transfer.disconnected .transfer,.enable-transfer.transfer-hidden .transferPopup,.enable-settings.settings-hidden .settingsPopup{transition:all 1s linear;opacity:0;z-index:-1}.enable-file-share .fileshare-container{display:table}.settings{margin-top:12px!important}.settings .icon-settings{margin:0;font-size:18px;color:#fff}.client:not(.enable-mute) .cell-muteAudio,.client:not(.enable-transfer) .cell-transfer,.client:not(.enable-hold) .cell-hold,.client:not(.enable-timer) .cell-timer,.client:not(.enable-full-screen) .cell-fullScreen,.client:not(.enable-self-view) .cell-selfView,.client:not(.enable-settings) .cell-settings,.client:not(.enable-dialpad) .cell-dialpad,.client:not(.enable-shareScreen) .cell-shareScreen,.client:not(.enable-call-control) .callControl{display:none!important}.whiteboard{display:none;position:absolute;top:40px;left:378px}.whiteboard .canvas{border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #999;background-color:#fff}.whiteboard .tools{padding-bottom:10px}.whiteboard .tools a{border:1px solid #000;height:30px;line-height:30px;padding:0 10px;vertical-align:middle;text-align:center;text-decoration:none;display:inline-block;color:#000;font-weight:bold}.whiteboard .tools a.selected{border-color:#f00;border-width:3px}#whiteboard_unsupported{position:relative;top:0;left:0;margin:10px;background:#f00}@font-face{font-family:'Exario-Icon-Fonts';src:url(\"../fonts/Exario-Icon-Fonts.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'Exario-Icon-Fonts';src:url(\"data:application/font-woff;base64,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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,AAEAAAALAIAAAwAwT1MvMggi/LsAAAC8AAAAYGNtYXDmQODcAAABHAAAAFRnYXNwAAAAEAAAAXAAAAAIZ2x5ZjoCSh4AAAF4AAAnRGhlYWT/pwt9AAAovAAAADZoaGVhA+QCFAAAKPQAAAAkaG10eGEABp4AACkYAAAA0GxvY2HiFtguAAAp6AAAAGptYXhwAEIBBQAAKlQAAAAgbmFtZVNJ8lkAACp0AAABk3Bvc3QAAwAAAAAsCAAAACAAAwIAAZAABQAAAUwBZgAAAEcBTAFmAAAA9QAZAIQAAAAAAAAAAAAAAAAAAAABEAAAAAAAAAAAAAAAAAAAAABAAADmBQHg/+D/4AHgACAAAAABAAAAAAAAAAAAAAAgAAAAAAACAAAAAwAAABQAAwABAAAAFAAEAEAAAAAMAAgAAgAEAAEAIOAt5gX//f//AAAAAAAg4ADmBP/9//8AAf/jIAQaLgADAAEAAAAAAAAAAAAAAAAAAQAB//8ADwABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAQAAAAAAAAAAAAIAADc5AQAAAAABACD/4AF9AeAADgAABT4BLgEHFSc3FTYeAQYHAX0VExtWVMDAZHIjJzUgJ1pOMgJ/wMB8Ak13iTkAAAABAIP/4AHgAeAADgAAATUXBzUmDgEWFy4BPgEXASDAwFRWGxMVNScjcmQBZHzAwH8CMk5aJzmJd00CAAANAAD/4AIAAeAAAwAHAAsAEwAbAB8AIwAnACsAMwA3ADsAQwAAEyEVIQczFSMRMxUjAzUjNSMVMzUDFTM1MzUzNQczFSMRMxUjATMVIyMzFSM3FTMVMxUzNQMzFSM7ARUjNxUjFSMVMzWAAQD/ACAgICAgICAgYGAgICAgICAgIAFgICAgICAgICAggCAgICAgQCAgYAFAwCAgAUAg/qAgIGAgAeBgICAgQCD+wCABgCAggCAgIGD+gCAgICAgIGAAAAAADQAA/+ACAAHgAAMACwAPABcAGwAfACMAKwAvADMANwA/AEMAADczFSM1FTMVMxUzNQczFSMTFSMVIxUzNSczFSM7ARUjFyEVIQE1IzUjFTM1JzMVIzczFSMRMxUjJxUzNTM1MzUHMxUjICAgICAggCAgYCAgYIAgICAgIGABAP8AAUAgIGAgICAgICAgIGAgICAgICAgIGAgICBgYCAB4CAgIGAgICBgwAEAICBgIEAgQCD+QCCAYCAgIEAgAAAABAArAAsBwAG1AAoADwAUABkAAAEVIxUjFSMVIREjAyM1MxUzIxEzETMjETMRAStWVVUBlZVAQEBVQEBVQEABtVVVVqoBqv6Aq6sBAP8AAVb+qgAAAwArAAsBwAG1AAoADwAUAAABFSMVIxUjFSERIxMjETMRMyMRMxEBK1ZVVQGVlRVAQFVAQAG1VVVWqgGq/oABAP8AAVb+qgAAAgArAAsBwAG1AAoADwAAARUjFSMVIxUhESMTIxEzEQErVlVVAZWVakBAAbVVVVaqAar+gAFW/qoAAAAAAQArAAsBwAG1AAoAAAEVIxUjFSMVIREjAStWVVUBlZUBtVVVVqoBqgAAAAAEACv/9QHAAcsAGgApAC4ARQAAAQcjIg4CHQEUHgI7ARc6AzERKgMjAyMiLgI9ATQ+AjsBFRcnNTcRExUeAxUUDgIHFT4DNTQuAicBEFVVDhUQCAgQFQ5VVQgRDgkICwoLCGVFBQYEAgIEBgVFalVVVhARCAEBCBEQGCAUCQkUIBgBy2sMExkNew0YEQprAdb+wAMGCAR7BAoHBapWVqpW/qoBFi0DDBASCwoTEAwDLAMTHCMTEyMcEwQAAAMAK//1AdMBywAMADMAOAAAJRUnBx8BFjYWNhU1BwcUNDA0FTU0PgIXNxU3NTcVNzUmBiYGJwcnDgMdARQeAhc3BycBFwEBK0geC1YIEQ0JKsABBAcERRVWKggLCQsIVlUNFg8JAQMEAiEiHgGKHv52xpBHHAFqAQEBAQH8KygBAgIBfAMLBgYBAUQWLVcwLEMBAQEBAWwBAQsUGA56BgkKCAQijR8Bih3+dAADABEAQQIAAYAAMgBLAFQAAAEjIg4CDwE1NC4CIyEiDgIdARQeAjMhMj4CPQEXHgM7ATI+Aj0BNC4CIwEiLgI9ATQ+AjMhMh4CHQEUDgIjISUjJzEnNTczFQHhDgMGBQUCKggMEQr+2woRDQcHDREKASUKEQwIKgIFBQYDDgYMCAUFCAwG/l8EBQQDAwQFBAElBAUEAwMEBQT+2wGhDz4QTg8BcQECAwInEgkQDAcHDBAJ6AkQCwcHCxAJEicCAwIBBAgLBugGCwgE/u0CBAUD6AMGBAICBAYD6AMFBAIOOg9XSOgAAAAAAgAjAAMB3QG9ADYAbQAAAScuASIGDwEOARQWHwEeAxc3LgMvAS4BNDY/AT4BMhYfAR4BFAYPAR4DBzc+ATQmJwcuAycHHgMfAR4BFAYPAQ4BIiYvAS4BNDY/AS4DNwcOARQWHwEeATI2PwE+ATQmLwEB3QISLS4tEW4REhIRAgIDAwMCKAIDBAMBAgoJCQptCRkZGAkCCgoKCjEDBQMCAU0REhIRoQIDAwMCKAIDBAMBAgoJCQptCRkZGAkCCgoKCjEDBQMCAU0REhIRAhItLi0RbhESEhECAbsCERISEW0SLS4tEgIBAwIDASgBAgIDAgIJGBoYCW0KCgoKAgkYGRkJMggQERAJTREtLi0SnQEDAgMBKAECAgMCAgkYGhgJbQoKCgoCCRgZGQkyCBAQEQlNES0uLRICERISEW0SLS4tEgIABAADAAAB/QHCAFUAbgCpALgAABM+AR4BFxYyPgEzND4CMzQ+ATQnLgMnJj4CIyImKgEHDgMHDgMjDgMHDgEqAQcOAwcOARQWFzAeAhceAjY3PgMzNjQ+ATcXLgEiBg8BDgEUFh8BHgI2PwE+ATQmLwElNCYiBgcOAwcOAiYnLgI2Nz4DNzYuAgcOAwcGFA4BDwEXNz4DFxY+Ajc+AiYnAQ4BFBYfAR4BPgE/AScHUAkREREKAgIDAgEMDgwBAQEBAQUFBgISIzMqCgUXGRQDDRoaFggKDwkEAQMBAgQFBgkIBgQBBgYFAQECAQELDAsBAQQEBAICBQYEAQEBAwSSAQIDAwElAQEBAdQCBQUFAhkCAwIB0wEbAwQDAQIGBwgCAggNEAsLCAEFAQIHCAYBAQECBAQDFhcVAwMBBwsiIisDDA0PCA8ZEw4FBQQBAQH+SQICAgIYAgUGBQJ9JoMBMAcCBxALAgICAQsMCwEBAgICAQUHCAMXJRsPAQEBCw8QBQcLCAUDCAkKBQQDAwIEBAUBAQMDAwILDgwCAQIBAQIBBQUEAQcKCgMOAgEBASABAgMDAfICAgECAhUCBAYFAvRnBQQCAgIKCwwEBAkGAQgIDQsJBAQMDQoCAQQEAQECCQ8UDAwXFhYKJCgoBAcEAgIDAgkPCggZGRUF/qICBQUFAhgCAQEDAnssfwAEAAIAHAIBAZUAhgCoAMUAzQAANy4DLwE3Jy4DJy4BPAE1PAI2Nz4DNz4BHgEXMh4CHwE3PgMxMh4CHwEHFTc+Azc+Azc+ATIWFx4DFRQWHAEdAQcOAwcOAiIjKgImJy4DJy4DMTAUBhQVFA4CByIGKgErAQcOAzEwLgInMTc+AyMuASoBBw4DFQ4CFBcVFx4DMTI+AjcxFzI+AjU+ATwBPQEHDgMxBh4BMjM6ATYyNzE3NSMPARczNQ0BAgICAQMiBwEDAgIBAQICAQIHCQoHBWJ0YAMBBAMDAQcVBAgGBAEBAwICBy8GAgUGCAQECAUFAQMKCgoDAgYGBAEDAgICBAICBAQGBgQGBQMCAQUICQUECAcEAQUJDgkCFCc4J5QWBQgGBAECAQHLNz4eBQECYHNhAgECAQIBAQEBBQECAgIBGSo5IJYBAgECAQGHHDIlFwIEGDYxIzMhEAF2EkwBTRIgAQMCAgEDHAcBBAQEAQQHGDIuLjIYCAMFCQcFAQEBAQEBAgICAQQRBAYFAwEDAgIIKBwFAQUGBwMFBgQDAQEBAQEBBAYGAwEVIiwZeAcCAwMCAQIBAQEBAQQGCAQECAUEAgQEAgoQDAgCARMEBgUDAQEBAb8uNBkHAQEBAQECAQECCBowKnkEAQEBARUjLxuAAQICAQEIGCsmbXEXKSATAQEBAQGBdUdaSXUAAAABAAD/4AHgAcAAMgAAJQ4DIyIuAicuAzU0PgI3Ni4CIyIOAjEUHgIXHgMzMD4CNTQuAgcBYAwODA4MDBgYGAwMFxILCxIXDAwSJCoMDCEeFRYlLhcXRElEGB4kHh8qKwygDBcSCwsSFwwMGBgYDAwODA4MDCsqHx4kHhhESUQXFy4lFhUeIQwMKiQSDAAAAAABAAMAcAH9AUAAUgAAJR4CBgcOAS4BJz4CJicuAyMiDgIHBhQeAQcWDgEmJy4CNjU+AzciMiIyIz4DMyMyMDIwMyIyIjIjMzIeAhcyIjIiMx4DFQH9AgEBBQQJMDYoAQEFBQIHCRQaGxAOHRgWBwkDBwEBKjQyBwYDAQMCBAkMCgEBAQEBDyQ0Qy4BAQEBAQIBAgEBLEUyJg0BAQEBAQgOBwbAChgWEwUJCAQTEgkPDxAJCQkFAQEFCQkJEA8PCRITBAgJBRMWGAoHDw8RCg0XEgoKEhcNChEPDwcACQAA/+AB4AHAAAQACQAOABMAGAAdACIAJwAsAAAlFTM1IyMVMzUjIxUzNSMlFTM1IyMVMzUjIxUzNSMlFTM1IyMVMzUjIxUzNSMBgGBgwGBgwGBgAYBgYMBgYMBgYAGAYGDAYGDAYGBAYGBgYGBgwGBgYGBgYMBgYGBgYGAAAAACAAD/4AIAAeAAFAAbAAABIg4CFRQeAjMyPgI1NC4CIwMnNxc3FwcBADVdRigoRl01NV1GKChGXTUwai87uRfQAeAoRl01NV1GKChGXTU1XUYo/mCKMUuXF/AAAAcAIP/gAeAB4ABeAHUAjACjALoA0QECAAAFISIuAj0BIyIuAj0BND4COwE1IyIuAj0BND4COwE1IyIuAj0BND4COwE1IyIuAj0BND4COwE1IyIuAj0BND4COwE1ND4CMyEyHgIVERQOAiMBIyIOAhUUHgI7ATI+AjU0LgIjFSMiDgIVFB4COwEyPgI1NC4CIxUjIg4CFRQeAjsBMj4CNTQuAiMVIyIOAhUUHgI7ATI+AjU0LgIjFSMiDgIVFB4COwEyPgI1NC4CIyU0LgInPgM3IzI+Aj0BNC4CKwEiDgIdARQeAjMjHgMXDgMdATM1AdD+oAMGBAMwAwYEAwMEBgMwMAMGBAMDBAYDMDADBgQDAwQGAzAwAwYEAwMEBgMwMAMGBAMDBAYDMAMEBgMBYAMGBAMDBAYD/pAgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMgAwYEAwMEBgMBIAwVHREBAQIBAQcDBgQDAwQGAyADBgQDAwQGAwcBAQIBAREdFQzAIAMEBgMQAwQGAyADBgQDIAMEBgMgAwYEAyADBAYDIAMGBAMgAwQGAyADBgQDIAMEBgMgAwYEAxADBgQDAwQGA/4gAwYEAwHQAwQGAwMGBAMDBAYDAwYEA2ADBAYDAwYEAwMEBgMDBgQDYAMEBgMDBgQDAwQGAwMGBANgAwQGAwMGBAMDBAYDAwYEA2ADBAYDAwYEAwMEBgMDBgQDYgoPCQYBAQEBAQEDBAYDYAMGBAMDBAYDYAMGBAMBAQEBAQEGCg4KEhIAAAAABAAg/+AB4AHgAAQACQAOACUAABMzESMROwERIxE7AREjESUVMxEUHgIzITI+AjURMzUjNSMVI4BAQGBAQGBAQP7gIAsSFwwBAAwXEgsggMCAAUD+4AEg/uABIP7gASBgQP7ADBcSCwsSFwwBQEBAQAAAAAAEAAMAIAH7AaAAUgBnAHwAkQAAJTI+AjU0LgIjIg4CBy4DJy4DJzMeAzMyPgI1NC4CIyIOAgcjLgMjIg4CFRQeAjMyPgI3HgMXHgMXHgMzETIeAhUUDgIjIi4CNTQ+AjMFND4CMzIeAhUUDgIjIi4CNQU0PgIzMh4CFRQOAiMiLgI1AbMPGhQLCxQaDwsUEQ0EFhwTDAcDBwgLB3sEDhEUCw8aFAsLFBoPCxQRDgTkBA0RFQsPGhMMDBMaDwsUEQ4EFhwSDQYHER8wJgQNERULCQ8LBwcLDwkIDwwGBgwPCP5vBgsQCAkPCwcHCw8JCBALBgFoBgwPCAkPCwcHCw8JCA8MBiALFBoPDxoUCwYLEAkCEBoiFAoWFRUKChAMBgsUGg8PGhQLBgwQCQkQDAYLFBoPDxoUCwYLEAkCEBoiFBUuKB0ECRELBwFiBwsPCQkPCwcHCw8JCQ8LByoJDwsHBwsPCQkPCwcHCw8J8AkPCwcHCw8JCQ8LBwcLDwkAAAACAHgAMwGIAZoAFgAtAAABIg4CFREUHgIzMj4CNRE0LgIjIyIOAhURFB4CMzI+AjURNC4CIwFaChEMBwcMEQoJEQwICAwRCbQJEQwICAwRCQoRDAcHDBEKAZoEBw0K/twJDQgDAwgNCQEkCg0HBAQHDQr+3AkNCAMDCA0JASQKDQcEAAABALMAUQGzAXsAFwAAJScuAQ4BFREUHgE2PwEUPgI1NC4CNQGr2wYKCAUFCAoG2wMDAgIDA/SIAwIFCQn++gkJBgMCiQEDAwYBBAQFAQEAAAEAIP/gAX0B4AAOAAAFPgEuAQcVJzcVNh4BBgcBfRUTG1ZUwMBkciMnNSAnWk4yAn/AwHwCTXeJOQAAAAEAg//gAeAB4AAOAAABNRcHNSYOARYXLgE+ARcBIMDAVFYbExU1JyNyZAFkfMDAfwIyTlonOYl3TQIAAA0AAP/gAgAB4AADAAcACwATABsAHwAjACcAKwAzADcAOwBDAAATIRUhBzMVIxEzFSMDNSM1IxUzNQMVMzUzNTM1BzMVIxEzFSMBMxUjIzMVIzcVMxUzFTM1AzMVIzsBFSM3FSMVIxUzNYABAP8AICAgICAgICBgYCAgICAgICAgAWAgICAgICAgICCAICAgICBAICBgAUDAICABQCD+oCAgYCAB4GAgICBAIP7AIAGAICCAICAgYP6AICAgICAgYAAAAAANAAD/4AIAAeAAAwALAA8AFwAbAB8AIwArAC8AMwA3AD8AQwAANzMVIzUVMxUzFTM1BzMVIxMVIxUjFTM1JzMVIzsBFSMXIRUhATUjNSMVMzUnMxUjNzMVIxEzFSMnFTM1MzUzNQczFSMgICAgICCAICBgICBggCAgICAgYAEA/wABQCAgYCAgICAgICAgYCAgICAgICAgYCAgIGBgIAHgICAgYCAgIGDAAQAgIGAgQCBAIP5AIIBgICAgQCAAAAAEACsACwHAAbUACgAPABQAGQAAARUjFSMVIxUhESMDIzUzFTMjETMRMyMRMxEBK1ZVVQGVlUBAQFVAQFVAQAG1VVVWqgGq/oCrqwEA/wABVv6qAAADACsACwHAAbUACgAPABQAAAEVIxUjFSMVIREjEyMRMxEzIxEzEQErVlVVAZWVFUBAVUBAAbVVVVaqAar+gAEA/wABVv6qAAACACsACwHAAbUACgAPAAABFSMVIxUjFSERIxMjETMRAStWVVUBlZVqQEABtVVVVqoBqv6AAVb+qgAAAAABACsACwHAAbUACgAAARUjFSMVIxUhESMBK1ZVVQGVlQG1VVVWqgGqAAAAAAQAK//1AcABywAaACkALgBFAAABByMiDgIdARQeAjsBFzoDMREqAyMDIyIuAj0BND4COwEVFyc1NxETFR4DFRQOAgcVPgM1NC4CJwEQVVUOFRAICBAVDlVVCBEOCQgLCgsIZUUFBgQCAgQGBUVqVVVWEBEIAQEIERAYIBQJCRQgGAHLawwTGQ17DRgRCmsB1v7AAwYIBHsECgcFqlZWqlb+qgEWLQMMEBILChMQDAMsAxMcIxMTIxwTBAAAAwAr//UB0wHLAAwAMwA4AAAlFScHHwEWNhY2FTUHBxQ0MDQVNTQ+Ahc3FTc1NxU3NSYGJgYnBycOAx0BFB4CFzcHJwEXAQErSB4LVggRDQkqwAEEBwRFFVYqCAsJCwhWVQ0WDwkBAwQCISIeAYoe/nbGkEccAWoBAQEBAfwrKAECAgF8AwsGBgEBRBYtVzAsQwEBAQEBbAEBCxQYDnoGCQoIBCKNHwGKHf50AAMAEQBBAgABgAAyAEsAVAAAASMiDgIPATU0LgIjISIOAh0BFB4CMyEyPgI9ARceAzsBMj4CPQE0LgIjASIuAj0BND4CMyEyHgIdARQOAiMhJSMnMSc1NzMVAeEOAwYFBQIqCAwRCv7bChENBwcNEQoBJQoRDAgqAgUFBgMOBgwIBQUIDAb+XwQFBAMDBAUEASUEBQQDAwQFBP7bAaEPPhBODwFxAQIDAicSCRAMBwcMEAnoCRALBwcLEAkSJwIDAgEECAsG6AYLCAT+7QIEBQPoAwYEAgIEBgPoAwUEAg46D1dI6AAAAAACACMAAwHdAb0ANgBtAAABJy4BIgYPAQ4BFBYfAR4DFzcuAy8BLgE0Nj8BPgEyFh8BHgEUBg8BHgMHNz4BNCYnBy4DJwceAx8BHgEUBg8BDgEiJi8BLgE0Nj8BLgM3Bw4BFBYfAR4BMjY/AT4BNCYvAQHdAhItLi0RbhESEhECAgMDAwIoAgMEAwECCgkJCm0JGRkYCQIKCgoKMQMFAwIBTRESEhGhAgMDAwIoAgMEAwECCgkJCm0JGRkYCQIKCgoKMQMFAwIBTRESEhECEi0uLRFuERISEQIBuwIREhIRbRItLi0SAgEDAgMBKAECAgMCAgkYGhgJbQoKCgoCCRgZGQkyCBAQEQlNES0uLRKdAQMCAwEoAQICAwICCRgaGAltCgoKCgIJGBkZCTIIEBARCU0RLS4tEgIREhIRbRItLi0SAgAEAAMAAAH9AcIAVQBuAKkAuAAAEz4BHgEXFjI+ATM0PgIzND4BNCcuAycmPgIjIiYqAQcOAwcOAyMOAwcOASoBBw4DBw4BFBYXMB4CFx4CNjc+AzM2ND4BNxcuASIGDwEOARQWHwEeAjY/AT4BNCYvASU0JiIGBw4DBw4CJicuAjY3PgM3Ni4CBw4DBwYUDgEPARc3PgMXFj4CNz4CJicBDgEUFh8BHgE+AT8BJwdQCREREQoCAgMCAQwODAEBAQEBBQUGAhIjMyoKBRcZFAMNGhoWCAoPCQQBAwECBAUGCQgGBAEGBgUBAQIBAQsMCwEBBAQEAgIFBgQBAQEDBJIBAgMDASUBAQEB1AIFBQUCGQIDAgHTARsDBAMBAgYHCAICCA0QCwsIAQUBAgcIBgEBAQIEBAMWFxUDAwEHCyIiKwMMDQ8IDxkTDgUFBAEBAf5JAgICAhgCBQYFAn0mgwEwBwIHEAsCAgIBCwwLAQECAgIBBQcIAxclGw8BAQELDxAFBwsIBQMICQoFBAMDAgQEBQEBAwMDAgsODAIBAgEBAgEFBQQBBwoKAw4CAQEBIAECAwMB8gICAQICFQIEBgUC9GcFBAICAgoLDAQECQYBCAgNCwkEBAwNCgIBBAQBAQIJDxQMDBcWFgokKCgEBwQCAgMCCQ8KCBkZFgT+ogIFBQUCGAIBAQMCeyx/AAQAAgAcAgEBlQCGAKgAxQDNAAA3LgMvATcnLgMnLgE8ATU8AjY3PgM3PgEeARcyHgIfATc+AzEyHgIfAQcVNz4DNz4DNz4BMhYXHgMVFBYcAR0BBw4DBw4CIiMqAiYnLgMnLgMxMBQGFBUUDgIHIgYqASsBBw4DMTAuAicxNz4DIy4BKgEHDgMVDgIUFxUXHgMxMj4CNzEXMj4CNT4BPAE9AQcOAzEGHgEyMzoBNjI3MTc1Iw8BFzM1DQECAgIBAyIHAQMCAgEBAgIBAgcJCgcFYnRgAwEEAwMBBxUECAYEAQEDAgIHLwYCBQYIBAQIBQUBAwoKCgMCBgYEAQMCAgIEAgIEBAYGBAYFAwIBBQgJBQQIBwQBBQkOCQIUJzgnlBYFCAYEAQIBAcs3Ph4FAQJgc2ECAQIBAgEBAQEFAQICAgEZKjkglgECAQIBAYccMiUXAgQYNjEjMyEQAXYSTAFNEiABAwICAQMcBwEEBAQBBAcYMi4uMhgIAwUJBwUBAQEBAQECAQMBBBEEBgUDAQMCAggoHAUBBQYHAwUGBAMBAQEBAQEEBgYDARUiLBl4BwIDAwIBAgEBAQEBBAYIBAQIBQQCBAQCChAMCAIBEwQGBQMBAQEBvy40GQcBAQEBAQIBAQIIGjAqeQQBAQEBFSMvG4ABAgIBAQgYKyZtcRcpIBMBAQEBAYF1R1pJdQAAAAEAAP/gAeABwAAyAAAlDgMjIi4CJy4DNTQ+Ajc2LgIjIg4CMRQeAhceAzMwPgI1NC4CBwFgDA4MDgwMGBgYDAwXEgsLEhcMDBIkKgwMIR4VFiUuFxdESUQYHiQeHyorDKAMFxILCxIXDAwYGBgMDA4MDgwMKyofHiQeGERJRBcXLiUWFR4hDAwqJBIMAAAAAAEAAwBwAf0BQABSAAAlHgIGBw4BLgEnPgImJy4DIyIOAgcGFB4BBxYOASYnLgI2NT4DNyIyIjIjPgMzIzIwMjAzIjIiMiMzMh4CFzIiMiIzHgMVAf0CAQEFBAkwNigBAQUFAgcJFBobEA4dGBYHCQMHAQEqNDIHBgMBAwIECQwKAQEBAQEPJDRDLgEBAQEBAgECAQEsRTImDQEBAQEBCA4HBsAKGBYTBQkIBBMSCQ8PEAkJCQUBAQUJCQkQDw8JEhMECAkFExYYCgcPDxEKDRcSCgoSFw0KEQ8PBwAJAAD/4AHgAcAABAAJAA4AEwAYAB0AIgAnACwAACUVMzUjIxUzNSMjFTM1IyUVMzUjIxUzNSMjFTM1IyUVMzUjIxUzNSMjFTM1IwGAYGDAYGDAYGABgGBgwGBgwGBgAYBgYMBgYMBgYEBgYGBgYGDAYGBgYGBgwGBgYGBgYAAAAAIAAP/gAgAB4AAUABsAAAEiDgIVFB4CMzI+AjU0LgIjAyc3FzcXBwEANV1GKChGXTU1XUYoKEZdNTBqLzu5F9AB4ChGXTU1XUYoKEZdNTVdRij+YIoxS5cX8AAABwAg/+AB4AHgAF4AdQCMAKMAugDRAQIAAAUhIi4CPQEjIi4CPQE0PgI7ATUjIi4CPQE0PgI7ATUjIi4CPQE0PgI7ATUjIi4CPQE0PgI7ATUjIi4CPQE0PgI7ATU0PgIzITIeAhURFA4CIwEjIg4CFRQeAjsBMj4CNTQuAiMVIyIOAhUUHgI7ATI+AjU0LgIjFSMiDgIVFB4COwEyPgI1NC4CIxUjIg4CFRQeAjsBMj4CNTQuAiMVIyIOAhUUHgI7ATI+AjU0LgIjJTQuAic+AzcjMj4CPQE0LgIrASIOAh0BFB4CMyMeAxcOAx0BMzUB0P6gAwYEAzADBgQDAwQGAzAwAwYEAwMEBgMwMAMGBAMDBAYDMDADBgQDAwQGAzAwAwYEAwMEBgMwAwQGAwFgAwYEAwMEBgP+kCADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAyADBgQDAwQGAwEgDBUdEQEBAgEBBwMGBAMDBAYDIAMGBAMDBAYDBwEBAgEBER0VDMAgAwQGAxADBAYDIAMGBAMgAwQGAyADBgQDIAMEBgMgAwYEAyADBAYDIAMGBAMgAwQGAyADBgQDEAMGBAMDBAYD/iADBgQDAdADBAYDAwYEAwMEBgMDBgQDYAMEBgMDBgQDAwQGAwMGBANgAwQGAwMGBAMDBAYDAwYEA2ADBAYDAwYEAwMEBgMDBgQDYAMEBgMDBgQDAwQGAwMGBANiCg8JBgEBAQEBAQMEBgNgAwYEAwMEBgNgAwYEAwEBAQEBAQYKDgoSEgAAAAAEACD/4AHgAeAABAAJAA4AJQAAEzMRIxE7AREjETsBESMRJRUzERQeAjMhMj4CNREzNSM1IxUjgEBAYEBAYEBA/uAgCxIXDAEADBcSCyCAwIABQP7gASD+4AEg/uABIGBA/sAMFxILCxIXDAFAQEBAAAAAAAQAAwAgAfsBoABSAGcAfACRAAAlMj4CNTQuAiMiDgIHLgMnLgMnMx4DMzI+AjU0LgIjIg4CByMuAyMiDgIVFB4CMzI+AjceAxceAxceAzMRMh4CFRQOAiMiLgI1ND4CMwU0PgIzMh4CFRQOAiMiLgI1BTQ+AjMyHgIVFA4CIyIuAjUBsw8aFAsLFBoPCxQRDQQWHBMMBwMHCAsHewQOERQLDxoUCwsUGg8LFBEOBOQEDREVCw8aEwwMExoPCxQRDgQWHBINBgcRHzAmBA0RFQsJDwsHBwsPCQgPDAYGDA8I/m8GCxAICQ8LBwcLDwkIEAsGAWgGDA8ICQ8LBwcLDwkIDwwGIAsUGg8PGhQLBgsQCQIQGiIUChYVFQoKEAwGCxQaDw8aFAsGDBAJCRAMBgsUGg8PGhQLBgsQCQIQGiIUFS4oHQQJEQsHAWIHCw8JCQ8LBwcLDwkJDwsHKgkPCwcHCw8JCQ8LBwcLDwnwCQ8LBwcLDwkJDwsHBwsPCQAAAAIAeAAzAYgBmgAWAC0AAAEiDgIVERQeAjMyPgI1ETQuAiMjIg4CFREUHgIzMj4CNRE0LgIjAVoKEQwHBwwRCgkRDAgIDBEJtAkRDAgIDBEJChEMBwcMEQoBmgQHDQr+3AkNCAMDCA0JASQKDQcEBAcNCv7cCQ0IAwMIDQkBJAoNBwQAAAEAswBRAbMBewAXAAAlJy4BDgEVERQeATY/ARQ+AjU0LgI1AavbBgoIBQUICgbbAwMCAgMD9IgDAgUJCf76CQkGAwKJAQMDBgEEBAUBAQAAAwAAAEACAAGAABQAUQBmAAABIg4CBx4DMzI+AjcuAyMXHgMXDgMHDgMjIi4CJy4DJz4DNz4BMjY3DgMVFB4CMzI+AjU0LgInHgEyFhcHFA4CIyIuAjU0PgIzMh4CFQEAKk1CNRISNUJNKipNQjUSEjVCTSp+DBQTEQcHERMUDA4eICERESEgHg4MFBMRBwcRExQMAQEBAgECAwIBFCMuGxsuIxQBAgMCAQIBAQF+CA0RCgoRDQgIDREKChENCAGAFyo7JCQ7KhcXKjskJDsqF1UHERMVCwsVExEHCQ4JBQUJDgkHERMVCwsVExEHAQEBAQULCwsGGy4jFBQjLhsGCwsLBQEBAQEYChENCAgNEQoKEQ0ICA0RCgAAAAAFAAAAAAIAAeAAJQA2AE0AXgB5AAABHgMXDgMHLgMnNx4BMhY3Fj4CNz4DNy4DJzcHJiImIic3FhQWFBcOAwcTDwEuAwcmDgIHHgMXDwE3ATcFNh4CFwcuAzcmPgIXBz4DNzYwNjI3DgIUBx4DFwcuAycBpA8aGBMJEzRDTCsLGBUXCiYICw4MBxAiHx8NDRMUEAgIDxMTDCSlAwoHCQOcAgIBARMkLRzhHG0LFBcWDClOQTYRBxUVGw5aARwBxAH+7woPDgcCNwgQCgcBAQkMEgmYBhISFQsCAgECAwIDAQEDBwkHHgkVEBEGAUwKGRofDyU6KxYBAQEFBAUmAQMCAQEGCA8ICBAUFAwKFRIRBiTKAQICnAMJBwoDHC0kEwEBXgFtAwYCAwEBGCk8IxEdGxcMWRwBAcQcngEHChAINwIHDg8KCRIMCQFiChYSEgYCAQIGCgwKBwoWExMHHggPExMMAAEAAAAAAAC5BtUEXw889QALAgAAAAAAz0PlYAAAAADPQ+VgAAD/4AIBAeAAAAAIAAIAAAAAAAAAAQAAAeD/4AAAAgAAAP//AgEAAQAAAAAAAAAAAAAAAAAAADQAAAAAAAAAAAAAAAABAAAAAgAAIAIAAIMCAAAAAgAAAAIAACsCAAArAgAAKwIAACsCAAArAgAAKwIAABECAAAjAgAAAwIAAAICAAAAAgAAAwIAAAACAAAAAgAAIAIAACACAAADAgAAeAIAALMCAAAgAgAAgwIAAAACAAAAAgAAKwIAACsCAAArAgAAKwIAACsCAAArAgAAEQIAACMCAAADAgAAAgIAAAACAAADAgAAAAIAAAACAAAgAgAAIAIAAAMCAAB4AgAAswIAAAACAAAAAAAAAAAKABQAHgA8AFoAvAEcAUYBagGIAZ4B/AJSAsYDaARuBXYFvgYsBmwGmgfcCBYI1gkYCUAJXgl8Cd4KPgpoCowKqgrACx4LdAvoDIoNkA6YDuAPTg+OD7wQ/hE4EfgSOhJiEvATogAAAAEAAAA0AQMADQAAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAOAK4AAQAAAAAAAQAiAAAAAQAAAAAAAgAOAI0AAQAAAAAAAwAiADgAAQAAAAAABAAiAJsAAQAAAAAABQAWACIAAQAAAAAABgARAFoAAQAAAAAACgAoAL0AAwABBAkAAQAiAAAAAwABBAkAAgAOAI0AAwABBAkAAwAiADgAAwABBAkABAAiAJsAAwABBAkABQAWACIAAwABBAkABgAiAGsAAwABBAkACgAoAL0ARQB4AGEAcgBpAG8ALQBJAGMAbwBuAC0ARgBvAG4AdABzAFYAZQByAHMAaQBvAG4AIAAxAC4AMABFAHgAYQByAGkAbwAtAEkAYwBvAG4ALQBGAG8AbgB0AHNFeGFyaW8tSWNvbi1Gb250cwBFAHgAYQByAGkAbwAtAEkAYwBvAG4ALQBGAG8AbgB0AHMAUgBlAGcAdQBsAGEAcgBFAHgAYQByAGkAbwAtAEkAYwBvAG4ALQBGAG8AbgB0AHMARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABJAGMAbwBNAG8AbwBuAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\") format(\"truetype\"),url(\"../fonts/Exario-Icon-Fonts.svg#Exario-Icon-Fonts\") format(\"svg\");font-weight:normal;font-style:normal}@font-face{font-family:'bsl_icons';src:url(\"../fonts/bsl_icons.eot?\") format(\"embedded-opentype\")}@font-face{font-family:'bsl_icons';src:url(\"data:application/font-woff;base64,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N3JgWV1XfTGc+xSMgoiFgoeIiomKiYuFi4aOh5CHkIeRh5KHkYOYgZ+AnoGeg54Ig52EoYSkhaSHoougi56MnIybjZuNnY+dj52RnJGakpqUm5ablpuYmZqXmpedl6CWCKCWo5Slk6aSqZGuj62PsI60iwjmi4v3AQWLm5OXmpGQjY+MkIuVi5OHk4QI92/7bwWSg4+Di4GLgYeChIQIDvtv+bn3hhWLgYl+h3qHeod+h4KDeHR3ZHVneGiBaIuBi4GMgYyBjICOf45/j4KNhY6FjYCPfJAIfJGCjoeNZphpm26dWqlZtFe/V79ivm27eal7rH2wio+IlIWahZuIlYiRiZGJlIeXCIiXiJaKlYqVipWLlYuula6er6CyoKKek5SPmI+cj5uPmY2Vi5CLj4qOipKJlXyYcQiQg5CBk36SfZF/koCRgZGAkIKMiY+HkIORg4+EjoWNho2Fi4aLg4WCgH+AgICBfoEIfoF/gYCBgYCFgouEi4iMh42GjYWNiIyIjIiOh4+Ej4WNh4uKqFetXrBmsGa4ar9uCIyKj4mRh5GHkIiOio2Kj4mQiZGJj4qOi5KLlJGWlpWVlZeVmJSYlpeWlZeWlJGTiwiQi5GJkImRiJGHk4WThpCIjYmUhpWFloWWhZeEmYSYg5WGkoemfZqBjYSMiYyHi4UIDv0m9+j4JhWLhomHh4cI+577ngWHh4eJhouGi4eNh48IbqcFh4+JkIuQi5CNj4+PCPd193T7dfd1BYePiY+LkIuQjY+PjwioqAWPj4+MkIuQi4+Kj4cI9577nwWPiI2Gi4YIDviU+fQV+3qL+077Tov7eov7evdO+073eov3eov3TvdOi/d6i/d6+073Tvt6iwj3fPu+FfvD+8MFg4N/i4OTCIWRi4v7O/c8BYOTi5eTkwi0tAWTk5eLk4MI9wr7C/eM94wFk5OXi5ODCLRiBZODi3+DgwgO+JSrFft6i/tO906L93qL93r3TvdO93qL93qL9077Tov7eov7evtO+077eosI91P4rRWTk4uYg5MIYLUFg5N/i4ODCPsM+wz7DfcMBYOTf4uDgwhgYQWEg4t+koMI9w37DPsN+wwFhIOLfpKDCLZhBZODl4uTkwj3DfcM9wz7DAWTg5eLk5MItrUFk5OLmIOTCPsN9wz3DfcMBQ74hPnkFft6i/tO+06L+3qL+3r3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\") format(\"woff\"),url(\"data:application/x-font-ttf;base64,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\") format(\"truetype\"),url(\"../fonts/bsl_icons.svg#bsl_icons\") format(\"svg\");font-weight:normal;font-style:normal}.client [class^=\"icon-\"],.client [class*=\" icon-\"]{font-family:'bsl_icons';speak:none;font-style:normal;font-weight:normal;font-variant:normal;text-transform:none;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.icon{cursor:pointer}.icon a{speak:none;text-decoration:none;margin:0 .35em 0 0}.icon a:before{color:#fff}.icon-trash:before{content:\"\\e013\";color:#f00}.icon-screen-sharing:before{content:\"\\e604\"}.icon-screen-sharing-off:before{content:\"\\e605\"}.icon-link:before{content:\"\\e00b\"}.icon-dialpadShow:before,.icon-dialpadShow:hover:before,.icon-dialpadHide:before,.icon-dialpadHide:hover:before{content:\"\\ed3b\"}.icon-hangup:before,.icon-hangup:hover:before{content:\"\\e600\"}.icon-clock:before{content:\"\\e634\"}.client .icon-cog:before,.icon-settings:before,.icon-settings:hover:before{content:\"\\e601\"}.icon-resume:before,.icon-resume:hover:before,.icon-hold:before,.icon-hold:hover:before{content:\"\\e6bb\"}.icon-unmuteAudio:before,.icon-unmuteAudio:hover:before{content:\"\\e6c1\"}.icon-muteAudio:before,.icon-muteAudio:hover:before{content:\"\\e6c3\"}.icon-arrow-up-thick:before{content:\"\\f5a4\"}.icon-arrow-down-thick:before{content:\"\\f5a5\"}.icon-cancel3:before{content:\"\\f2c9\"}.icon-fullScreenContract:before,.icon-fullScreenContract:hover:before,.icon-fullScreenExpand:before,.icon-fullScreenExpand:hover:before{content:\"\\f371\"}.icon-th:before{content:\"\\e602\"}.icon-selfViewEnable:before,.icon-selfViewEnable:hover:before,.icon-selfViewDisable:before,.icon-selfViewDisable:hover:before{content:\"\\f17f\"}.icon-transfer:before,.icon-transfer:hover:before{content:\"\\f186\"}.icon-angle-right:before{content:\"\\f1fe\"}.icon-call:before{content:\"\\e00e\";color:#3b9e3b}.icon-hangup:before{content:\"\\e00f\";color:#f00}.view-conference .icon-hangup:before,.view-conference .icon-hangup:hover:before{color:#fff!important}.view-conference .selfViewDisable,.view-conference .selfViewEnable{text-align:right!important}.view-conference .fullScreenExpand,.view-conference .fullScreenContract{text-align:left!important}.view-audioOnly .fullScreenExpand,.view-audioOnly .fullScreenContract,.view-audioOnly .selfViewDisable,.view-audioOnly .selfViewEnable,.view-audioOnly .cell-fullScreen,.view-audioOnly .cell-selfView{display:none!important}.selfViewEnable a,.dialpadIconHide a,.unmuteAudio a,.fullScreenContract a{color:#04aff0!important}.watermark-icon{position:absolute;top:50%;left:50%;backface-visibility:hidden;transform:translate(-50%,-50%);color:rgba(255,255,255,0.08);z-index:1;font-size:265px;text-align:center;width:100%}.icon-highlightable:hover{color:<%= iconHightlightColor %>}.icon a:hover,.icon span:hover,.videoBar a:hover{color:<%= iconHightlightColor %>}.connection-status{display:none;position:absolute;top:13px}.connectedIcon{right:5px}.registeredIcon{right:40px}.quality{display:none;position:absolute;z-index:10;top:13px;left:15px}.icon-quality:before{color:#0f0;opacity:.4}.icon-quality1:before{content:\"\\e007\"}.icon-quality2:before{content:\"\\e006\"}.icon-quality3:before{content:\"\\e005\"}.icon-quality4:before{content:\"\\e004\"}.view-audioOnly .quality1,.view-audioOnly .quality2,.view-audioOnly .quality3,.view-audioOnly .quality4{display:none!important}.videoBar{position:relative;top:0;left:0;width:100%;height:40px;background:#000;background-image:-ms-linear-gradient(center top,#404040,#000);background-image:linear-gradient(to bottom,#404040,#000);background-image:-webkit-linear-gradient(#404040,#000);background-image:-moz-linear-gradient(top,#404040,#000);border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #000;margin-top:5px;background-image:none;border-radius:0;border:0;box-shadow:none;margin-top:0;background:#292929;border-top:1px solid #3c3c3c}.videoBar .icon{z-index:10;margin:0 2.5px;position:absolute}.videoBar .table{height:100%;margin:6px;margin:0}.videoBar .cell{position:relative;top:0;left:0;width:35px;width:36px}.videoBar .cell .icon{width:100%;text-align:center;margin-top:10px;margin-right:0;margin-left:0}.videoBar .cell .icon a{margin:0}.videoBar .cell:first-child{padding:0}.videoBar span{color:#808080}.videoBar .unmuteAudio{margin-top:-1px}.videoBar .leftSpacer{width:8px}.videoBar .cell-hangup{width:42px}.videoBar .subtitle{display:none}.videoBar .cellTimer{position:relative;top:0;left:0;width:auto}.videoBar .rightSpacer{width:8px}.full-screen-expanded .videoBar{top:auto!important;bottom:0;position:absolute}.hangup,.fullScreen,.selfView,.muteAudioIcon,.dialpadIcon,.messages{top:0;left:0}#videoBar #settings{width:auto;background-color:transparent}.view-audioOnly .videoBar{display:inline-block;width:auto}.view-audioOnly .videoBar .table{table-layout:auto;width:auto}.view-audioOnly .cell-hangup{width:35px!important}.view-conference .cell-hangup{width:30px!important;top:2px}.view-conference .videoBar .cell .hangup{margin-top:0;width:140px;background-color:#f00;border-radius:5px;margin-left:10px;height:36px;line-height:14px}.view-conference .hangup .subtitle{display:block!important;font-size:14px;color:#fff}.videoBar .icon,.videoBar a{font-size:20px;color:#808080;text-decoration:none}.videoBar .hold,.videoBar .resume{margin-top:-1px}.started .hangup,.calling .hangup{transition:all 1s linear;opacity:1;z-index:20}.connected .hangup,.disconnected .hangup,.client.held .hold,.client:not(.started) .hold,.client:not(.held) .resume,.client:not(.started) .resume{transition:all 1s linear;opacity:0;z-index:-1}.sms{display:none;position:absolute;top:10px;right:10px}.sms .view{padding:10px;border-radius:4px;border:2px solid #ddd;box-shadow:0 0 10px #999}.sms .loginForm{width:250px}.sms .sendForm{width:600px;display:none}.sms .sendBody{width:339px}.sms .inbox{width:600px;display:none}.sms .inbox .inner{max-height:250px;overflow:auto}.sms .inbox .cell{padding:5px}.sms .inbox .from{width:100px}.sms .inbox .status{width:50px}.sms .inbox .time{width:135px}.sms .inbox .body{word-wrap:break-word}.sms .inbox .body>div{display:none}.sms .inbox .inboxItem.image .body .image span{margin-right:5px}.sms .inbox .actions{width:15px}.sms .inbox .icon-trash{font-size:15px}.sms .status{display:none;text-align:right}.sms .status .statusContent{text-align:right;border:1px solid #c3c3c3;background-color:#e3e2e2;font-size:70%;padding:1px 3px;border-top:0;margin-right:15px;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.sms .status.error{color:#f00}.sms .inbox .inboxItem.text .body .text,.sms .inbox .inboxItem.image .body .image,.sms .inbox .inboxItem.video .body .video,.sms .inbox .inboxItem.audio .body .audio{display:block}.sms .inbox .inboxItem.audio .body .audio audio,.sms .inbox .inboxItem.video .body .video video{width:100%}.inbox .inboxContent{display:table-row-group}authPopup{width:210px;height:200px}authPopup span{color:#999;font-size:14px;line-height:18px}authPopup input{background:#666;border-bottom:1px solid #333;border-left:1px solid #000;border-right:1px solid #333;border-top:1px solid #000;color:#fff;border-radius:3px;font-family:arial;font-size:16px;padding:6px 6px 4px;width:200px}authPopup button{border-color:#999;border-width:1px;border-radius:4px;color:#333;cursor:pointer;padding:6px 6px 4px;margin-top:10px;font-size:12px;width:200px}authPopup .alert{font-size:20px;text-align:center;color:#f00}.sign-in,.sign-out{display:none}.client:not(.registered) .sign-in,.client.registered .sign-out{display:block}.client:not(.disconnected).auth-visible .authPopup{transition:all 1s linear;opacity:1;z-index:100}.client.disconnected .authPopup,.client.auth-hidden .authPopup{transition:all 1s linear;opacity:0;z-index:-1}.timer{display:none;position:absolute;top:3px;left:0;width:100%;text-align:center;font-family:arial;font-size:16px;top:11px}.timer{color:<%= timerColor %>}.view-audioOnly .timer{position:relative;margin-right:10px}.client:not(.started) .timer{transition:all 1s linear;opacity:0;z-index:-1}.messages{position:absolute;font-family:arial;text-align:left;width:auto;font-size:12px;bottom:auto;top:10px;left:10px}.view-audioOnly .messages{left:10px!important;top:48px!important;font-weight:bold;font-size:14px}.normal{color:<%= infoMessageColor %>}.success{color:<%= successMessageColor %>}.warning{color:<%= successMessageColor %>}.alert{color:<%= alertMessageColor %>}.client .fileshare-container{display:none}.client:not(.started) .file_share{transition:all 1s linear;opacity:0;z-index:-1}.enable-xmpp.xmpp-shown .xmpp{transition:all 1s linear;opacity:1;z-index:100}.enable-xmpp.xmpp-hidden .xmpp{transition:all 1s linear;opacity:0;z-index:-1}";
var ejs = require('ejs');
var $ = jQuery = require('jquery');
var Icon = require('../Icon');
var WebRTC_C = require('../Constants');
var Utils = require('../Utils');
var ExSIP = require('exsip');
require('../models/eventbus');
var ClientConfig = require('../../js/client-config.js.default');

function ClientView(options, eventbus, debug, configuration, videoView, videobarView, sound, callcontrol, sipstack, transferview, authenticationview, 
  xmppView, incomingcallView, reinviteView, messagesView, settings) {
  var self = {};

  self.elements = ['client', 'main', 'errorPopup'];

  options = options || Utils.clone(ClientConfig);
  self.visibilities = {};

  self.appendTo = function(parent) {
    parent.append(self.view);
  };

  self.updateCss = function(styleData) {
    self.styleData = styleData || {};
    var cssData = $.extend({}, WebRTC_C.STYLES, WebRTC_C.FONTS, self.styleData);
    var cssStr = ejs.render(styles, cssData);
    if ($("#webrtc_css").length === 0) {
      $("<style type='text/css' id='webrtc_css'>" + cssStr + "</style>").appendTo("head");
    } else {
      $("#webrtc_css").text(cssStr);
    }
  };

  self.init = function(options) {
    var unsupported = Utils.compatibilityCheck(configuration);
    if (unsupported) {
      $('#unsupported').html(unsupported).show();
    }

    var whiteboardUnsupported = Utils.whiteboardCompabilityCheck();
    if (whiteboardUnsupported) {
      $('#whiteboard_unsupported').html(whiteboardUnsupported).show();
    }

    self.updateCss();

    videoView.view.appendTo(self.main);
    videobarView.view.appendTo(self.main);
    messagesView.view.appendTo(self.main);

    self.updateClientClass();

    $.cookie.raw = true;

    sipstack.init();

    if (!configuration.enableConnectLocalMedia && configuration.destination) {
      eventbus.once("connected", function(e) {
        callcontrol.callUri(configuration.destination);
      });
    }
  };

  self.showErrorPopup = function(error) {
    window.alert(error);
  };

  self.setClientConfig = function(clientConfig) {
    var connectionChanged = configuration.websocketsServers[0].ws_uri !== clientConfig.websocketsServers[0].ws_uri;
    jQuery.extend(options, clientConfig);
    jQuery.extend(configuration, options);
    self.updateClientClass();
    if (connectionChanged) {
      sipstack.init();
    }
  };

  self.listeners = function() {
    $(document).unbind('keypress').bind('keypress', function(e) {});
    $(document).unbind('keydown').bind('keydown', function(event) {
      var isModifier = event.altKey;
      if (isModifier) {
        if (transferview.targetInput.is(event.target)) {
          return;
        }

        eventbus.modifier(event.which);
      }
    });

    eventbus.on("viewChanged", function(e) {
      self.visibilities[e.view] = e.visible;
      self.updateClientClass();
    });
    eventbus.on("failed", function(e) {
      var error = e.cause;
      if (error === "User Denied Media Access") {
        self.showErrorPopup("WebRTC was not able to access your microphone/camera!");
      }
    });
    eventbus.on("registrationFailed", function(e) {
      self.updateClientClass();
    });
    eventbus.on("registered", function(e) {
      self.updateClientClass();
    });
    eventbus.on("unregistered", function(e) {
      self.updateClientClass();
    });
  };

  // Buttons


  self.asScript = function() {
    var script = '<script src="' + self.src + '" ';
    var dataStrs = Object.keys(self.styleData).filter(function(key) {
      var value = self.styleData[key];
      var defaultValue = WebRTC_C.STYLES[key];
      return !!value && value !== defaultValue;
    }).map(function(key) {
      var value = self.styleData[key];
      return "data-" + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase() + "='" + value + "'";
    });
    script += dataStrs.join(' ');

    var config = $.extend({}, options);
    Object.keys(config).forEach(function(key) {
      var value = config[key];
      var defaultValue = ClientConfig[key];
      if (!value && !defaultValue) {
        delete config[key];
        return;
      }
      if (Array.isArray(value)) {
        value = JSON.stringify(value);
        defaultValue = JSON.stringify(defaultValue);
      } else {
        value = value + "";
        defaultValue = defaultValue + "";
      }
      if (value === defaultValue) {
        delete config[key];
      }
    });
    script += '>\n' + JSON.stringify(config, undefined, 2) + '\n</script>';
    return script;
  };

  self.updateClientClass = function() {
    var classes = ["client"];
    classes.push("r" + configuration.getResolutionDisplay());
    classes.push(configuration.isWidescreen() ? "widescreen" : "standard");
    var callState = sipstack.getCallState();
    if (callState) {
      classes.push(callState);
    }
    if (sipstack.isRegistered()) {
      classes.push('registered');
    }
    if (configuration.enableMute) {
      classes.push("enable-mute");
    }
    if (configuration.enableShareScreen) {
      classes.push("enable-shareScreen");
    }
    if (configuration.enableCallControl) {
      classes.push("enable-call-control");
    }
    if (configuration.enableTransfer) {
      classes.push("enable-transfer");
    }
    if (configuration.enableHold) {
      classes.push("enable-hold");
    }
    if (configuration.enableCallTimer) {
      classes.push("enable-timer");
    }
    if (configuration.enableSettings) {
      classes.push("enable-settings");
    }
    if (configuration.enableFullScreen) {
      classes.push("enable-full-screen");
    }
    if (configuration.enableSelfView) {
      classes.push("enable-self-view");
    }
    if (configuration.enableDialpad) {
      classes.push("enable-dialpad");
    }
    if (configuration.enableSMS) {
      classes.push("enable-sms");
    }
    if (configuration.enableStats) {
      classes.push("enable-stats");
    }
    if (configuration.enableXMPP) {
      classes.push("enable-xmpp");
    }
    var views = configuration.getViews();
    if (views && views.length > 0) {
      views.map(function(view) {
        classes.push("view-" + view);
      });
    }
    if (configuration.enableScreenSharing) {
      classes.push("enable-screen-sharing");
    }
    if (configuration.enableFileShare) {
      classes.push("enable-file-share");
    }
    if (configuration.selfViewSize) {
      classes.push("selfView-" + configuration.selfViewSize);
    }
    if (configuration.selfViewLocation) {
      classes.push("selfView-" + configuration.selfViewLocation);
    }
    if (sound.muted) {
      classes.push("muted");
    } else {
      classes.push("unmuted");
    }
    if (self.selfViewEnabled) {
      classes.push("self-view-enabled");
    } else {
      classes.push("self-view-disabled");
    }
    Object.keys(self.visibilities).forEach(function(view) {
      classes.push(view + '-' + (self.visibilities[view] ? 'shown' : 'hidden'));
    });
    if (self.fullScreen) {
      classes.push("full-screen-expanded");
    } else {
      classes.push("full-screen-contracted");
    }
    if (self.isScreenSharing) {
      classes.push("screen-sharing");
    } else {
      classes.push("screen-sharing-off");
    }
    if (transferview.visible) {
      classes.push("transfer-visible");
    } else {
      classes.push("transfer-hidden");
    }
    if (authenticationview.visible) {
      classes.push("auth-visible");
    } else {
      classes.push("auth-hidden");
    }
    self.client.attr("class", classes.join(" "));
  };

  return self;
}

exports.constructor = ClientView;
},{"../../js/client-config.js.default":1,"../Constants":452,"../Icon":454,"../Utils":455,"../models/eventbus":463,"ejs":171,"exsip":202,"jquery":230}],472:[function(require,module,exports){
module.exports = ConnectionStatusView

var Utils = require('../Utils');
var ExSIP = require('exsip');

function ConnectionStatusView(options, eventbus, configuration) {
  var self = {};

  self.elements = ['connectedIcon', 'registeredIcon'];

  self.listeners = function() {
    eventbus.on("disconnected", function(e) {
      if (configuration.enableConnectionIcon) {
        self.connectedIcon.removeClass("success");
        self.connectedIcon.addClass("alert").fadeIn(100);
      }
    });
    eventbus.on("connected", function(e) {
      if (configuration.enableConnectionIcon) {
        self.connectedIcon.removeClass("alert");
        self.connectedIcon.addClass("success").fadeIn(10).fadeOut(3000);
      }
    });
    eventbus.on("registrationFailed", function(e) {
      if (configuration.enableRegistrationIcon) {
        self.registeredIcon.addClass("alert").fadeIn(100);
      }
    });
    eventbus.on("registered", function(e) {
      if (configuration.enableRegistrationIcon) {
        self.registeredIcon.removeClass("alert");
        self.registeredIcon.addClass("success").fadeIn(10).fadeOut(3000);
      }
    });
  };

  return self;
}
},{"../Utils":455,"exsip":202}],473:[function(require,module,exports){
module.exports = DialpadView

var PopupView = require('./popup');

function DialpadView(options, eventbus, callcontrol, historyView, videobarView) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['historyButton', 'destination', 'call', 'keys'];

  self.listeners = function() {
    window.onbeforeunload = function(e) {
      self.endCall({
        rtcSession: 'all'
      });
      return null;
    };
    eventbus.on("disconnected", function(e) {
      videobarView.endCall();
    });
    eventbus.on("failed", function(e) {
      videobarView.endCall({
        rtcSession: e.sender
      });
    });
    self.keys.bind('click', function(e) {
      e.preventDefault();
      self.destination.val(self.destination.val() + e.firstChild.nodeValue);
      self.processDigitInput(e.target.textContent);
    });
    eventbus.on("ended", function(e) {
      videobarView.endCall({
        rtcSession: e.sender
      });
    });
    self.destination.keypress(function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        callcontrol.callUri(self.destination.val());
      }
    });
    self.historyButton.bind('click', function(e) {
      e.preventDefault();
      historyView.toggle();
    });
    self.call.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      callcontrol.callUri(self.destination.val());
    });
    eventbus.on('calling', function(e) {
      self.destination.val(e.destination);
    });
    eventbus.on('viewChanged', function(e) {
      if (e.view === 'dialpad' && e.visible) {
        self.destination.focus();
      }
    });
    eventbus.on('viewChanged', function(e) {
      if (e.view === 'history') {
        if (e.visible) {
          self.historyButton.removeClass("active");
        } else {
          self.historyButton.addClass("active");
        }
      } else if (e.view === 'settings' && e.visible) {
        self.hide();
      }
    });
    // Prevent the backspace key from navigating back if dialpad is shown
    $(document).bind('keydown', function(event) {
      if (self.visible) {
        var doPrevent = false;
        if (event.keyCode === 8) {
          var d = event.srcElement || event.target;
          if ((d.tagName.toUpperCase() === 'INPUT' && (d.type.toUpperCase() === 'TEXT' ||
              d.type.toUpperCase() === 'PASSWORD' || d.type.toUpperCase() === 'FILE' ||
              d.type.toUpperCase() === 'EMAIL')) || d.tagName.toUpperCase() === 'TEXTAREA') {
            doPrevent = d.readOnly || d.disabled;
          } else {
            doPrevent = true;
            self.destination.trigger('keydown', event);
            self.destination.putCursorAtEnd();
          }
        }

        if (doPrevent) {
          event.preventDefault();
          return;
        }
      }

      var digit = String.fromCharCode(event.which);
      self.processDigitInput(digit, event);
    });

  };

  self.pressDTMF = function(digit) {
    if (digit.length !== 1) {
      return;
    }
    if (sipstack.isStarted()) {
      self.destination.val(self.destination.val() + digit);
      sound.playClick();
      sipstack.sendDTMF(digit);
    }
  };

  self.processDigitInput = function(digit, event) {
    if (!sipstack.isStarted() && self.visible) {
      // ignore if event happened on destination input itself
      if (event && self.destination.is(event.target)) {
        return;
      }
      self.destination.val(self.destination.val() + digit);
      self.destination.putCursorAtEnd();
    } else if (digit.match(/^[0-9A-D#*,]+$/i)) {
      self.pressDTMF(digit);
    }
  };

  return self;
}
},{"./popup":478}],474:[function(require,module,exports){
module.exports = FileShareView

var Utils = require('../Utils');

function FileShareView(options, sipstack, eventbus, debug) {
  var self = {};

  var C = self.C = {
    ACTION_REQUEST: 'request',
    ACTION_REPLY: 'reply',
    ACTION_SEND: 'send',
    ACTION_RECEIVED: 'received'
  };

  var requests = {};

  var handleFileSelect = function(evt) {
    var file = evt.target.files[0];

    if (file) {
      var reader = new FileReader();
      reader.onload = $.proxy(requestSend, self);
      reader.readAsDataURL(file);
    } else {
      alert("Failed to load file");
    }
  };

  var process = function(action, fileName, data) {
    if (action === C.ACTION_REQUEST) {
      var accept = window.confirm("User wants to share the file " + fileName + " with you. Do you want to receive it?");
      replyRequest(accept, fileName);
    } else if (action === C.ACTION_REPLY) {
      if (data === 'true') {
        var fileData = requests[fileName];
        sendFile(fileData, fileName);
      } else {
        updateStatus("rejected request for " + fileName);
        delete requests[fileName];
      }
    } else if (action === C.ACTION_SEND) {
      receivedFile(data, fileName);
    } else if (action === C.ACTION_RECEIVED) {
      updateStatus(fileName + " transferred successfully");
      delete requests[fileName];
    }
  };
  var requestSend = function(e) {
    var data = e.target.result;
    var file = self.file.val();
    var fileNameStr = fileName(file);
    requests[fileNameStr] = data;

    updateStatus("requesting sending file " + fileNameStr + " ...");
    send(C.ACTION_REQUEST, fileNameStr);
  };
  var replyRequest = function(accept, fileName) {
    if (accept) {
      updateStatus("receiving file " + fileName + " ...");
    }
    send(C.ACTION_REPLY, fileName, accept);
  };
  var receivedFile = function(data, fileName) {
    updateStatus("received file " + fileName);
    var blob = Utils.dataURItoBlob(data);
    window.saveAs(blob, fileName);
    send(C.ACTION_RECEIVED, fileName);
  };
  var sendFile = function(data, fileName) {
    updateStatus("sending file " + fileName + " ...");
    send(C.ACTION_SEND, fileName, data);
  };
  var send = function(action, fileName, data) {
    var dataString = "fileshare:" + action + ":" + fileName;
    if (data) {
      dataString += ":" + data;
    }
    sipstack.sendData(dataString);
  };
  var updateStatus = function(status) {
    debug(status);
    self.status.text(status);
  };
  var fileName = function(file) {
    return file.split('\\').pop();
  };

  self.elements = ['file', 'status'];

  self.listeners = function() {
    self.file.on('change', $.proxy(handleFileSelect, self));

    eventbus.on("dataReceived", function(e) {
      var data = e.data, match;
      var regex = /^fileshare:([^:]*):([^:]*):?/;
      if (!!(match = data.match(regex))) {
        var fileName = match.pop();
        var action = match.pop();
        data = data.replace(regex, '');
        process(action, fileName, data);
      }
    });
  };

  return self;
}
},{"../Utils":455}],475:[function(require,module,exports){
module.exports = HistoryView

var Utils = require('../Utils');
var PopupView = require('./popup');

function Page(number, callsValue) {
  var self = {};

  self.callsAsString = function() {
    return self.calls.map(function(call) {
      return call.toString();
    }).join("~");
  };
  self.parseCalls = function(callsValue) {
    var calls = [];
    if (callsValue.trim().length > 0) {
      var callsArray = callsValue.split("~");
      for (var i = 0; i < callsArray.length; i++) {
        calls.push(new Call(callsArray[i]));
      }
    }
    return calls;
  };

  self.calls = self.parseCalls(callsValue);
  self.number = number;

  return self;
}

function Call(value) {
  var self = {};

  var values = value ? value.split("|") : [];
  self.startTime = values[0];
  self.destination = values[1];
  self.direction = values[2];
  self.resolutionIn = values[3];
  self.resolutionOut = values[4];
  self.bitrateIn = values[5];
  self.bitrateOut = values[6];
  self.frameRateIn = values[7];
  self.frameRateOut = values[8];
  self.audioLostPer = values[9];
  self.videoLostPer = values[10];
  self.jitter = values[11];
  self.length = values[12];

  self.startDate = function() {
    var date = new Date();
    date.setTime(self.startTime);
    return date.toLocaleString();
  };
  self.destinationWithoutSip = function() {
    return self.destination.replace(/sip:([^@]+)@.+/, "$1");
  };
  self.toString = function() {
    var values = [self.startTime, self.destination, self.direction, self.resolutionIn, self.resolutionOut, self.bitrateIn,
      self.bitrateOut, self.frameRateIn, self.frameRateOut, self.audioLostPer, self.videoLostPer, self.jitter, self.length
    ];
    return values.join("|");
  };

  return self;
}

function HistoryView(options, sound, statsView, sipstack, configuration, eventbus, callcontrol) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  var pagePrefix = 'page_';

  var pageNumber = 0;
  var callsPerPage = 10;
  var maxPages = 25;
  var rows = [];

  var callDetailsHandler = function(call) {
    return function(e) {
      e.preventDefault();
      self.resolutionIn.text(call.resolutionIn);
      self.resolutionOut.text(call.resolutionOut);
      self.bitrateIn.text(call.bitrateIn);
      self.bitrateOut.text(call.bitrateOut);
      self.frameRateIn.text(call.frameRateIn);
      self.frameRateOut.text(call.frameRateOut);
      self.audioLostPer.text(call.audioLostPer);
      self.videoLostPer.text(call.videoLostPer);
      self.jitter.text(call.jitter);
      self.callLink.attr("data-destination", call.destinationWithoutSip());
      self.callLink.text("Call " + call.destinationWithoutSip());
      self.callHistoryDetails.fadeIn(100);
      self.callHistory.css({
        width: "416px"
      });
      $(".history-row").removeClass("active");
      // TODO - missing property to activate
      $(self).addClass("active");
    };
  };

  var createCall = function(rtcSession) {
    var call = new Call();
    var start = rtcSession.start_time;
    call.startTime = new Date(start).getTime();
    call.destination = rtcSession.remote_identity.uri;
    if (rtcSession.direction === "outgoing") {
      call.direction = "up";
    } else {
      call.direction = "down";
    }
    call.resolutionIn = stats.getValue("video", "googFrameWidthReceived") + "x" + stats.getValue("video", "googFrameHeightReceived");
    call.resolutionOut = stats.getValue("video", "googFrameWidthSent") + "x" + stats.getValue("video", "googFrameHeightSent");
    call.bitrateIn = stats.getAvg("video", "kiloBitsReceivedPerSecond");
    call.bitrateOut = stats.getAvg("video", "kiloBitsSentPerSecond");
    call.frameRateIn = stats.getAvg("video", "googFrameRateReceived");
    call.frameRateOut = stats.getAvg("video", "googFrameRateSent");
    call.audioLostPer = stats.getAvg("audio", "packetsLostPer");
    call.videoLostPer = stats.getAvg("video", "packetsLostPer");
    call.jitter = stats.getAvg("audio", "googJitterReceived");
    call.length = Utils.format(Math.round(Math.abs((rtcSession.end_time - start) / 1000)));
    return call;
  };

  var updateButtonsVisibility = function() {
    var pages = self.pages();
    var pagesCount = pages ? pages.length - 1 : 0;
    if (self.pageNumber < pagesCount) {
      self.historyForward.show();
    } else {
      self.historyForward.hide();
    }
    if (self.pageNumber > 0) {
      self.historyBack.show();
    } else {
      self.historyBack.hide();
    }
  };

  var updateContent = function() {
    self.content.html("");
    self.rows = [];
    updateButtonsVisibility();
    var calls = self.getAllCalls();
    var startPos = self.callsPerPage * self.pageNumber;
    for (var i = startPos; i < startPos + self.callsPerPage && i < calls.length; i++) {
      var row = self.historyRowSample.clone();
      row.attr('id', '');
      row.attr('class', 'history-row');
      var call = calls[i];
      row.bind("click", callDetailsHandler(call));
      row.find(".historyCall").text((self.pageNumber * 10) + i + 1);
      row.find(".hist-destination").text(call.destinationWithoutSip());
      //row.find(".historyDirection").text(call.direction);
      row.find(".hist-direction").append("<i class='icon-arrow-" + call.direction + "-thick'></i>");
      //row.find(".historyDate").text(call.startDate());
      row.find(".hist-date").text(Utils.formatDateTime(call.startDate()));
      row.find(".hist-length").text(call.length);
      self.rows.push(row);
      row.appendTo(self.content);
    }
  };

  self.elements = ['content', 'historyForward', 'historyBack', 'callHistoryDetails', 'historyDetailsClose', 'resolutionIn',
    'resolutionOut', 'bitrateIn', 'bitrateOut', 'frameRateIn', 'frameRateOut', 'audioLostPer', 'videoLostPer', 'jitter',
    'historyClear', 'callLink', 'historyRowSample', 'historyClose'
  ];

  self.pages = function() {
    var pages = [];
    for (var i = 0; i < localStorage.length; i++) {
      var key = localStorage.key(i);
      var regex = new RegExp(pagePrefix + '(.*)', 'g');
      var match = regex.exec(key);
      if (match !== null && match.length > 1) {
        var value = localStorage.getItem(key);
        var page = new Page(parseInt(match[1], 10), value);
        pages.push(page);
      }
    }
    // sort pages descendingly
    pages.sort(function(page1, page2) {
      return page2.number - page1.number;
    });
    return pages;
  };

  self.getAllCalls = function() {
    var pages = self.pages();
    var calls = [];
    for (var i = 0; i < pages.length; i++) {
      calls = calls.concat(pages[i].calls);
    }
    return calls;
  };


  self.setPageNumber = function(pageNumber) {
    self.pageNumber = pageNumber;
    updateContent();
  };

  self.listeners = function() {
    eventbus.on("ended", function(e) {
      self.persistCall(e.sender);
    });
    eventbus.on('modifier', function(e) {
      if (e.which === 72) {
        self.show();
      }
    });
    eventbus.on('viewChanged', function(e) {
      if (e.view === 'history' && e.visible) {
        updateContent();
      } else if (e.view === 'settings' && e.visible) {
        self.hide();
      } else if (e.view === 'dialpad' && !e.visible) {
        self.hide();
      }
    });
    self.historyForward.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.setPageNumber(self.pageNumber + 1);
    });

    self.historyBack.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.setPageNumber(self.pageNumber - 1);
    });

    self.historyClose.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.hide();
    });

    self.historyDetailsClose.bind('click', function(e) {
      e.preventDefault();
      self.callHistoryDetails.fadeOut(100);
      self.callHistory.css({
        width: "200px"
      });
    });

    self.callLink.bind('click', function(e) {
      e.preventDefault();
      if (sipstack.getCallState() === sipstack.C.STATE_CONNECTED) {
        sound.playClick();
        var destination = self.callLink.attr("data-destination");
        callcontrol.callUri(destination);
        self.callHistory.css({
          width: "200px"
        });
        self.callHistory.fadeOut(100);
      }
      self.callHistoryDetails.hide();
    });

    self.historyClear.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      var pages = self.pages();
      for (var i = 0; i < pages.length; i++) {
        localStorage.removeItem(pagePrefix + (pages[i].number));
      }
      self.setPageNumber(0);
    });
  };

  self.persistPage = function(page) {
    var key = (pagePrefix + page.number);
    var value = page.callsAsString();
    localStorage[key] = value;
  };

  self.persistCall = function(rtcSession) {
    if (!configuration.enableCallHistory) {
      return;
    }
    // Get latest cookie
    var pages = self.pages();
    var page = null;
    if (pages.length > 0) {
      page = pages[0];
    } else {
      page = new Page(0, "");
    }

    if (page.calls.length >= self.callsPerPage) {
      if (page.number + 1 >= self.maxPages) {
        // remove oldest call and reorder calls to each page
        for (var i = 0; i < pages.length; i++) {
          var lastPageCall = pages[i].calls.pop();
          if (i + 1 < pages.length) {
            pages[i + 1].calls.unshift(lastPageCall);
          }
          self.persistPage(pages[i]);
        }
      } else {
        page = new Page(page.number + 1, "");
      }
    }

    // cookie vars
    var call = createCall(rtcSession);
    page.calls.unshift(call);
    self.persistPage(page);
    updateContent();
  };

  return self;

}
},{"../Utils":455,"./popup":478}],476:[function(require,module,exports){
module.exports = IncomingCallView

var Utils = require('../Utils');
var ExSIP = require('exsip');
var PopupView = require('./popup');

function IncomingCallView(options, eventbus, sound, sipstack) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['incomingCallName', 'incomingCallUser', 'acceptIncomingCall', 'rejectIncomingCall', 'holdAndAnswerButton', 'dropAndAnswerButton'];

  self.incomingCallHandler = function(source, session) {
    self.hide();
    sound.pause();
    if (source.is(self.acceptIncomingCall)) {
      sipstack.answer(session);
    } else if (source.is(self.dropAndAnswerButton)) {
      sipstack.terminateSession();
      sipstack.answer(session);
    } else if (source.is(self.holdAndAnswerButton)) {
      sipstack.holdAndAnswer(session);
    } else if (source.is(self.rejectIncomingCall)) {
      sipstack.terminateSession(session);
    }
  };

  self.listeners = function() {
    eventbus.on("failed", function(e) {
      var error = e.cause;
      if (error === ExSIP.C.causes.CANCELED) {
        self.hide();
      }
    });

    eventbus.on("incomingCall", function(evt) {
      var incomingCallName = evt.data.request.from.display_name;
      var incomingCallUser = evt.data.request.from.uri.user;
      eventbus.message("Incoming Call", "success");
      self.show();
      self.incomingCallName.text(incomingCallName);
      self.incomingCallUser.text(incomingCallUser);
      Utils.rebindListeners("click", [self.rejectIncomingCall, self.acceptIncomingCall, self.holdAndAnswerButton, self.dropAndAnswerButton],
        function(e) {
          e.preventDefault();
          self.incomingCallHandler($(this), evt.data.session);
        }
      );
      sound.playRingtone();
    });
  };

  return self;
}
},{"../Utils":455,"./popup":478,"exsip":202}],477:[function(require,module,exports){
module.exports = MessagesView

var Utils = require('../Utils');
var ExSIP = require('exsip');

function MessagesView(options, eventbus, configuration) {
  var self = {};

  self.elements = ['alert', 'success', 'warning', 'normal'];

  // Display status messages
  self.message = function(text, level) { 
    if (!configuration.enableMessages) {
      return;
    }
    console.log('message : '+text, level);
    var messageEl = self[level];
    messageEl.stop(true, true).fadeOut();
    messageEl.text(text).fadeIn(10).fadeOut(10000);
  };

  self.getRemoteUser = function(rtcSession) {
    return rtcSession.remote_identity.uri.user || rtcSession.remote_identity.uri.host;
  };

  self.listeners = function() {
    eventbus.on("ended", function(e) {
      self.message(configuration.messageEnded.replace('{0}', self.getRemoteUser(e.sender)), "normal");
    });
    eventbus.on("resumed", function(e) {
      self.message(configuration.messageResume.replace('{0}', self.getRemoteUser(e.sender)), "success");
    });
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.message(configuration.messageStarted.replace('{0}', self.getRemoteUser(e.sender)), "success");
      }
    });
    eventbus.on("held", function(e) {
      self.message(configuration.messageHold.replace('{0}', self.getRemoteUser(e.sender)), "success");
    });
    eventbus.on("disconnected", function(e) {
      var msg = configuration.messageConnectionFailed;
      if (e.data && e.data.reason) {
        msg = e.data.reason;
      }
      if (e.data && e.data.retryAfter) {
        msg += " - Retrying in " + e.data.retryAfter + " seconds";
      }
      self.message(msg, "alert");
    });
    eventbus.on("failed", function(e) {
      var error = e.cause;
      self.message(error, "alert");
    });
    eventbus.on("progress", function(e) {
      self.message(configuration.messageProgress, "normal");
    });
    eventbus.on("message", function(e) {
      self.message(e.text, e.level);
    });
    eventbus.on("registrationFailed", function(e) {
      var msg = statusCode;
      if (statusCode === 403) {
        msg = "403 Authentication Failure";
      }
      self.message(configuration.messageRegistrationFailed.replace('{0}', msg), "alert");
    });
    eventbus.on("registered", function(e) {
      self.message(configuration.messageRegistered, "success");
    });
    eventbus.on("unregistered", function(e) {
      self.message(configuration.messageUnregistered || 'Unregistered', "success");
    });
    eventbus.on("connected", function(e) {
      self.message(configuration.messageConnected, "success");
    });

  };

  return self;
}
},{"../Utils":455,"exsip":202}],478:[function(require,module,exports){
(function (global){
module.exports = PopupView;

var $ = require('jquery');

function PopupView(options, parent, eventbus) {
  var self = {};

  var attached = false;

  self.visible = false;

  self.show = function() {
    self.setVisible(true);
  };

  self.hide = function() {
    self.setVisible(false);
  };

  self.toggle = function() {
    self.setVisible(!self.visible);
  };

  self.setVisible = function(visible) {
    if (!attached) {
      parent.view.appendTo(global.instances['clientview_'+options.id].client);        
      attached = true;
    }
    self.visible = visible;

    eventbus.viewChanged(parent);
  };

  return self;
}
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"jquery":230}],479:[function(require,module,exports){
module.exports = ReinviteView

var PopupView = require('./popup');

function ReinviteView(options, eventbus) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['incomingCallName', 'incomingCallUser', 'acceptReInviteCall', 'rejectReInviteCall', 'title'];

  self.listeners = function() {
    eventbus.on("reInvite", function(e) {
      self.show();
      var incomingCallName = e.request.from.display_name;
      var incomingCallUser = e.request.from.uri.user;
      var title = e.audioAdd ? "Adding Audio" : "Adding Video";
      eventbus.message(title, "success");    
      self.incomingCallName.text(incomingCallName);
      self.incomingCallUser.text(incomingCallUser);
      self.title.text(title);
      self.acceptReInviteCall.off("click");
      self.acceptReInviteCall.on("click", function() {
        self.hide();
        e.session.acceptReInvite();
      });
      self.rejectReInviteCall.off("click");
      self.rejectReInviteCall.on("click", function() {
        self.hide();
        e.session.rejectReInvite();
      });
    });
  };

  return self;
}
},{"./popup":478}],480:[function(require,module,exports){
module.exports = SettingsView;

var WebRTC_C = require('../Constants');
var Utils = require('../Utils');
var PopupView = require('./popup');

function SettingsView(options, settings, configuration, sipstack, eventbus, debug, sound) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  var updateRowVisibility = function() {
    self.autoAnswerRow.toggle(configuration.enableAutoAnswer);
    self.selfViewDisableRow.toggle(!configuration.hasOwnProperty("enableSelfView"));
    self.hdRow.toggle(!configuration.hasOwnProperty("enableHD"));
    self.resolutionRow.toggle(!configuration.hasOwnProperty("displayResolution") || !configuration.hasOwnProperty("encodingResolution"));
    self.resolutionDisplayRow.toggle(!configuration.hasOwnProperty("displayResolution"));
    self.resolutionEncodingRow.toggle(!configuration.hasOwnProperty("encodingResolution"));
    self.resolutionTypeRow.toggle(!configuration.hasOwnProperty("displayResolution") && !configuration.hasOwnProperty("encodingResolution"));
    self.bandwidthLow.toggle(!configuration.hasOwnProperty("bandwidthLow"));
    self.bandwidthMed.toggle(!configuration.hasOwnProperty("bandwidthMed"));
    self.bandwidthHigh.toggle(!configuration.hasOwnProperty("bandwidthHigh"));
    self.bandwidthRow.toggle(!configuration.hasOwnProperty("bandwidthLow") || !configuration.hasOwnProperty("bandwidthMed") || !configuration.hasOwnProperty("bandwidthHigh"));
    self.displayNameRow.toggle(!configuration.hasOwnProperty("displayName"));
  };

  self.elements = ['localVideoTop', 'localVideoLeft', 'userid', 'password', 'save', 'authenticationUserid', 'signIn', 'signOut',
    'displayName', 'resolutionType', 'resolutionDisplayWidescreen', 'resolutionDisplayStandard', 'resolutionEncodingWidescreen',
    'resolutionEncodingStandard', 'bandwidthLow', 'bandwidthMed', 'bandwidthHigh', 'displayNameRow', 'useridRow', 'selfViewDisableRow',
    'hdRow', 'autoAnswerRow', 'resolutionTypeRow', 'resolutionDisplayRow', 'resolutionEncodingRow', 'resolutionRow', 'bandwidthRow',
    'callHistoryTop', 'callHistoryLeft', 'callStatsTop', 'callStatsLeft', 'selfViewDisable', 'hd', 'size', 'autoAnswer', 'configure',
    'layout', 'clear', 'tabs'
  ];

  self.init = function(options) {
    Utils.addSelectOptions(WebRTC_C.RESOLUTION_TYPES, self.resolutionType);
    Utils.addSelectOptions(WebRTC_C.STANDARD_RESOLUTIONS, self.resolutionDisplayStandard);
    Utils.addSelectOptions(WebRTC_C.WIDESCREEN_RESOLUTIONS, self.resolutionDisplayWidescreen);
    Utils.addSelectOptions(WebRTC_C.STANDARD_RESOLUTIONS, self.resolutionEncodingStandard);
    Utils.addSelectOptions(WebRTC_C.WIDESCREEN_RESOLUTIONS, self.resolutionEncodingWidescreen);

    settings.setResolutionDisplay(WebRTC_C.DEFAULT_RESOLUTION_DISPLAY);
    settings.setResolutionEncoding(WebRTC_C.DEFAULT_RESOLUTION_ENCODING);
    

    updateRowVisibility();
  };

  self.listeners = function() {
    eventbus.on("viewChanged", function(e) {
      if (e.view === 'dialpad' && e.visible) {
        self.hide();
      }
    });
    eventbus.on("registered", function() {
      self.enableRegistration(true);
    });
    eventbus.on("unregistered", function() {
      self.enableRegistration(true);
    });
    eventbus.on("registrationFailed", function() {
      self.enableRegistration(true);
    });
    self.clear.on('click', function(e) {
      e.preventDefault();
      settings.resetLayout();
      eventbus.emit('message', {
        text: 'Settings reset'
      });
    });
    self.signOut.on('click', function(e) {
      e.preventDefault();
      sound.playClick();
      settings.signOut();
    });
    self.save.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      settings.save();
    });
    self.signIn.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      settings.signIn();
    });
    self.bandwidthLow.bind('blur', function() {
      sipstack.updateRtcMediaHandlerOptions();
    });
    self.bandwidthMed.bind('blur', function() {
      sipstack.updateRtcMediaHandlerOptions();
    });
    self.bandwidthHigh.bind('blur', function() {
      sipstack.updateRtcMediaHandlerOptions();
    });
    self.resolutionType.bind('change', function() {
      self.updateResolutionSelectVisibility();
      eventbus.viewChanged(self);
      sipstack.updateRtcMediaHandlerOptions();
      sipstack.updateUserMedia();
    });
    self.resolutionDisplayWidescreen.bind('change', function() {
      eventbus.viewChanged(self);
    });
    self.resolutionDisplayStandard.bind('change', function() {
      eventbus.viewChanged(self);
    });
    self.resolutionEncodingWidescreen.bind('change', function() {
      sipstack.updateRtcMediaHandlerOptions();
      sipstack.updateUserMedia();
    });
    self.resolutionEncodingStandard.bind('change', function() {
      sipstack.updateRtcMediaHandlerOptions();
      sipstack.updateUserMedia();
    });
    self.tabs.each(function() {
      var $active, $content, $links = $(this).find('a');
      $active = $($links.filter('[href="' + location.hash + '"]')[0] || $links[0]);
      $active.addClass('active');
      $content = $($active[0].hash);
      $links.not($active).each(function() {
        $(this.hash).hide();
      });
      $(this).on('click', 'a', function(e) {
        $active.removeClass('active');
        $content.hide();
        $active = $(this);
        $content = $(self.hash);
        $active.addClass('active');
        $content.show();
        e.preventDefault();
      });
    });
  };

  self.updateResolutionSelectVisibility = function() {
    var resolutionType = self.resolutionType.val();
    self.resolutionDisplayStandard.toggle(resolutionType === WebRTC_C.STANDARD);
    self.resolutionEncodingStandard.toggle(resolutionType === WebRTC_C.STANDARD);
    self.resolutionDisplayWidescreen.toggle(resolutionType === WebRTC_C.WIDESCREEN);
    self.resolutionEncodingWidescreen.toggle(resolutionType === WebRTC_C.WIDESCREEN);
  };
  self.enableRegistration = function(enable) {
    self.signIn.removeClass("disabled");
    self.signOut.removeClass("disabled");
    if (!enable) {
      self.signIn.addClass("disabled");
      self.signOut.addClass("disabled");
    }
  };

  return self;
}
},{"../Constants":452,"../Utils":455,"./popup":478}],481:[function(require,module,exports){
module.exports = SMSView;

var DateFormat = require('../DateFormat');
var Utils = require('../Utils');

function InboxItem(sms, message) {
  var self = {};

  self.cloned = sms.inboxItemSample.clone(false);
  self.cloned.removeClass('inboxItemSample');
  self.cloned.attr('id', message.mid);
  self.from = self.cloned.find('.from');
  self.status = self.cloned.find('.status');
  self.time = self.cloned.find('.time');
  self.bodyText = self.cloned.find('.body .text');
  self.bodyImageLink = self.cloned.find('.body .image a');
  self.bodyImageText = self.cloned.find('.body .image span');
  self.bodyImageThumbnail = self.cloned.find('.body .image img');
  self.bodyVideo = self.cloned.find('.body .video video');
  self.bodyAudio = self.cloned.find('.body .audio audio');
  self.removeLink = self.cloned.find('.icon-trash');
  self.dateFormat = new DateFormat('%m/%d/%y %H:%M:%S');

  self.listeners = function() {
    self.removeLink.bind('click', function() {
      sms.remove(message, self);
    });
    eventbus.on('modifier', function(e) {
      if (e.which === 84) {
        self.show();
      }
    });
  };
  self.enableActions = function(enable) {
    self.removeLink.attr('disabled', !enable);
  };
  self.updateContent = function(message) {
    var messageType = self.getMessageType(message);
    self.cloned.addClass(messageType);

    self.from.text(message.tn);
    self.status.text(sms.getStatusAsString(message.status));
    self.time.text(self.dateFormat.format(new Date(message.time)));

    var body = message.body.trim();
    if (messageType === 'image') {
      self.bodyImageLink.attr('href', message.mmscontentlocation);
      self.bodyImageText.text(body);
      if (message.mmscontentthumbnail) {
        self.bodyImageThumbnail.attr('src', 'data:' + message.mmscontentsubtype + ';base64,' + message.mmscontentthumbnail);
      }
    } else if (messageType === 'video') {
      self.bodyVideo.attr('src', message.mmscontentlocation);
      self.bodyVideo.text(body);
    } else if (messageType === 'audio') {
      self.bodyAudio.attr('src', message.mmscontentlocation);
      self.bodyAudio.text(body);
    } else {
      self.bodyText.html(body);
    }
  };
  self.getMessageType = function(message) {
    if (message.mmscontentsubtype && message.mmscontentsubtype.indexOf('image/') !== -1) {
      return 'image';
    } else if (message.mmscontentsubtype && message.mmscontentsubtype.indexOf('video/') !== -1) {
      return 'video';
    } else if (message.mmscontentsubtype && message.mmscontentsubtype.indexOf('audio/') !== -1) {
      return 'audio';
    } else {
      return 'text';
    }
  };
  self.remove = function() {
    self.cloned.remove();
  };
  self.appendTo = function(element) {
    self.cloned.appendTo(element);
  };

  self.listeners();

  self.updateContent(message);

  return self;
};

function SMSView(options, eventbus, debug, smsprovider, sound) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['status', 'statusContent', 'inbox', 'inboxContent', 'loginForm', 'loginLink', 'name', 'password', 'sendForm',
    'sendTo', 'sendBody', 'sendButton'
  ];
  self.inboxItems = [];

  self.getStatusAsString = function(status) {
    if (status === 'N') {
      return "New";
    } else if (status === 'U') {
      return "Unread";
    } else if (status === 'R') {
      return "Read";
    } else if (status === 'L') {
      return "Locked";
    } else if (status === 'D') {
      return "Deleted";
    } else {
      throw new Error('Unsupported status : ' + status);
    }
  };

  self.listeners = function() {
    eventbus.on('smsLoggedIn', function() {
      self.onLoggedIn();
    });
    eventbus.on('smsSent', function() {
      self.status.hide();
      self.sendBody.val('');
      self.sendTo.val('');
      self.sendButton.attr('disabled', false);
    });
    eventbus.on('smsReadAll', function(e) {
      self.status.hide();
      var messages = e.messages;

      messages = messages.sort(function(a, b) {
        return b.time - a.time;
      });

      var incomingMessages = $.grep(messages, function(n) {
        return (n.dir === 'I');
      });
      //        var outgoingMessages = $.grep(messages, function( n, i ) {
      //          return ( n.dir === 'O' );
      //        });
      self.updateInbox(incomingMessages);
    });

    self.loginLink.bind('click', function(e) {
      e.preventDefault();
      self.login(self.name.val(), self.password.val());
    });
    self.password.bind('keypress', function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        self.login(self.name.val(), self.password.val());
      }
    });
    self.sendButton.bind('click', function(e) {
      e.preventDefault();
      self.sendSMS();
    });
    self.sendBody.bind('keypress', function(e) {
      if (e.keyCode === 13) {
        e.preventDefault();
        self.sendSMS();
      }
    });
  };

  self.remove = function(message, inboxItem) {
    sound.playClick();
    if (!window.confirm("Do you really want to delete SMS from " + message.tn + "?")) {
      return;
    }
    self.info("Deleting SMS...");
    if (inboxItem) {
      inboxItem.enableActions(false);
    }
    smsprovider.remove([message.mid], function() {
      self.status.hide();
      inboxItem.remove();
    }, function(msg) {
      self.error("Deleting SMS failed : " + msg);
      inboxItem.enableActions(true);
    });
  };

  self.login = function(name, password) {
    sound.playClick();
    self.info("Logging in...");
    smsprovider.login(name, password, function(msg) {
      self.error("Logging failed : " + msg);
    });
  };

  self.onNotification = function(notifications) {
    var needsRead = false;
    if (!notifications) {
      return;
    }

    for (var i = 0; i < notifications.length; i++) {
      if (notifications[i].action === 'new-rec' || notifications[i].action === 'update' || notifications[i].action === 'delete') {
        needsRead = true;
        break;
      }
    }
    if (needsRead) {
      smsprovider.readAll(function(msg) {
        self.error("Fetching SMS failed : " + msg);
      });
    }
  };

  self.enableUpdate = function(enable) {
    self.enableUpdate = enable;
    self.triggerUpdate();
  };

  self.triggerUpdate = function() {
    if (self.enableUpdate && !self.pendingUpdate) {
      debug('triggering getUpdate');
      self.pendingUpdate = true;
      smsprovider.getUpdate(function(notifications) {
        self.pendingUpdate = false;
        self.onNotification(notifications);
        self.triggerUpdate();
      }, function() {
        self.pendingUpdate = false;
        self.error("Technical problems connecting to server - auto refresh disabled");
      });
    }
  };

  self.sendSMS = function() {
    sound.playClick();
    var msg = self.validateSendForm();
    if (msg !== "") {
      self.error(msg);
      return;
    }
    self.info("Sending SMS...");
    self.sendButton.attr("disabled", true);
    smsprovider.sendSMS([self.sendTo.val()], self.sendBody.val(), function(msg) {
      self.sendButton.attr("disabled", false);
      self.error("Sending SMS failed : " + msg);
    });
  };

  self.validateSendForm = function() {
    var to = self.sendTo.val();
    var msgs = [];
    if (to === '') {
      msgs.push('Please enter a phone number to send to');
    } else if (!Utils.isValidUsPstn(to)) {
      msgs.push(to + ' not a valid US phone number');
    }

    var body = self.sendBody.val();
    if (body === '') {
      msgs.push('Please enter a text to send');
    }

    return msgs.join('\n');
  };

  self.onLoggedIn = function() {
    self.loginForm.hide();
    self.inbox.show();
    self.sendForm.show();
    self.enableUpdate(true);
    smsprovider.readAll(function(msg) {
      self.error("Fetching SMS failed : " + msg);
    });
    self.info("Fetching SMS...");
  };

  self.updateInbox = function(messages) {
    self.inboxContent.html('');
    self.inboxItems = [];
    for (var i = 0; i < messages.length; i++) {
      var inboxItem = new InboxItem(this, messages[i]);
      inboxItem.appendTo(self.inboxContent);
      self.inboxItems.push(inboxItem);
    }
  };

  self.setStatus = function(msg, type) {
    self.status.show();
    self.status.attr("class", type);
    self.statusContent.text(msg);
  };

  self.error = function(msg) {
    self.setStatus(msg, "error");
  };

  self.info = function(msg) {
    self.setStatus(msg, "info");
  };

  return self;
}
},{"../DateFormat":453,"../Utils":455}],482:[function(require,module,exports){
module.exports = StatsView;

var PopupView = require('./popup');

function StatsView(options, eventbus, configuration, sipstack) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['statsVar', 'statsContainer'];

  self.getReportById = function(reports, id) {
    for (var i = 0; i < reports.length; i++) {
      if (reports[i].id === id) {
        return reports[i];
      }
    }
    return null;
  };

  self.processStats = function() {
    var peerConnection = sipstack.activeSession.rtcMediaHandler.peerConnection;

    peerConnection.getStats(function(stats) {
      var results = stats.result();
      var reports = [];
      for (var i = 0; i < results.length; ++i) {
        var res = results[i];
        var report = self.getReportById(reports, res.id);
        if (!report) {
          report = {};
          report.type = res.type;
          report.id = res.id;
        }

        var names = res.names();
        var values = [];
        for (var j = 0; j < names.length; j++) {
          var name = names[j];
          if (!name) {
            continue;
          }
          var value = res.stat(name);
          values.push(name);
          values.push(value);
        }
        var valueObj = {};
        valueObj.timestamp = res.timestamp;
        valueObj.values = values;
        report.stats = valueObj;
        reports.push(report);
      }
      var data = {
        "lid": 1,
        "pid": self.sipstack.getSessionId(),
        "reports": reports
      };
      addStats(data);
    });
  };

  self.getDataSerie = function(type, label, sessionId) {
    var dataSeries = getDataSeriesByLabel(sessionId || this.sipstack.getSessionId(), type, label);
    var result;
    for (var i = 0; i < dataSeries.length; i++) {
      var dataSerie = dataSeries[i];
      if (!result || dataSerie.getAvg() > result.getAvg()) {
        result = dataSerie;
      }
    }
    return result;
  };

  self.getStatValues = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.dataPoints_.map(function(e) {
      return e.value;
    }) : null;
  };

  self.getStatAvg = function(type, label, sessionId) {
    var dataSerie = this.getDataSerie(type, label, sessionId);
    return dataSerie ? dataSerie.getAvg() : null;
  };

  self.setSelected = function(id, parentSelector, selected) {
    if (arguments.length === 2) {
      selected = true;
    }
    var className = id.replace(/\d+/g, '');
    var classes = jQuery.grep($(parentSelector).attr('class').split(" "), function(n) {
      return n.indexOf(className) === -1;
    });
    if (selected) {
      classes.push(id + '-selected');
      if (id !== className) {
        classes.push(className + '-selected');
      }
    }
    var classNames = classes.join(" ");
    $(parentSelector).attr('class', classNames);
  };

  self.getValue = function(type, name) {
    return $('[data-type="' + type + '"][data-var="' + name + '"]').text();
  };

  self.getAvg = function(type, name) {
    return Math.round(($('[data-type="' + type + '"][data-var="' + name + '"]').attr("data-avg") * 100)) / 100.0;
  };

  self.listeners = function() {
    self.statsVar.click(function() {
      var index = self.statsVar.index($(this)[0]);
      self.setSelected("stats" + index, this.callStats);
    });
    eventbus.on('modifier', function(e){
      if(e.which === 83) {
        self.show();
      }
    });
    eventbus.on("started", function(e) {
      self.statsContainer.attr('id', sipstack.getSessionId() + '-1');
    });
  };

  return self;
}
},{"./popup":478}],483:[function(require,module,exports){
module.exports = TimerView;

var Utils = require('../Utils');

function TimerView(options, debug, eventbus, statsView, configuration) {
  var self = {};

  self.callTimer = null;
  self.startTime = null;

  self.elements = ['text'];

  self.init = function() {
    self.updateText();
  };

  self.listeners = function() {
    eventbus.on("started", function(e) {
      if (e.data && !e.data.isReconnect) {
        self.start();
      }
    });
  };

  self.start = function() {
    if (self.callTimer) {
      debug('timer ' + self.callTimer + ' already running');
      return;
    }

    var timer = self.runningTimer();
    self.callTimer = setInterval(timer, 1000);
    debug("started timer interval : " + self.callTimer);
  },

  self.stop = function() {
    self.startTime = null;
    clearInterval(self.callTimer);
    debug("cleared timer interval : " + self.callTimer);
    self.callTimer = null;
    self.updateText();
  },

  self.getSeconds = function() {
    return Math.round((new Date().getTime() - (self.startTime || new Date().getTime())) / 1000);
  },

  self.updateText = function() {
    var secs = self.getSeconds();
    self.text.text(Utils.format(secs));
  },

  // Display the timer on the screen
  self.runningTimer = function() {
    self.startTime = new Date().getTime();
    return function() {
      var secs = self.getSeconds();
      if (self.configuration.maxCallLength && secs >= self.configuration.maxCallLength) {
        self.client.terminateSessions();
        self.client.endCall();
        return;
      }
      self.updateText();
      if (self.configuration.enableCallStats && Utils.isChrome()) {
        self.statsView.processStats();
      }
    };
  }

  return self;
}
},{"../Utils":455}],484:[function(require,module,exports){
module.exports = TransferView;

var PopupView = require('./popup');

function TransferView(options, sound, sipstack, eventbus, configuration, callcontrol) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['accept', 'reject', 'targetInput', 'typeAttended'];

  self.listeners = function() {
    eventbus.on('viewChanged', function(e){
      if(e.view === 'transfer' && e.visible) {
        self.targetInput.focus();
      }
    });
    self.accept.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      var targetInput = self.targetInput.val();
      if ($.isBlank(targetInput)) {
        eventbus.emit('message', {text: configuration.messageOutsideDomain, level: 'alert'});
        return;
      }
      targetInput = callcontrol.validateDestination(targetInput);
      if(targetInput) {
        self.setVisible(false);
        sipstack.transfer(targetInput, self.typeAttended.is(':checked'));        
      }
    });

    self.reject.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.setVisible(false);
    });
  };

  return self;
}
},{"./popup":478}],485:[function(require,module,exports){
module.exports = VideoView;
require('jquery-ui/draggable');

function VideoView(options, sipstack, eventbus, debug, settings, configuration, historyView) {
  var self = {}; 
  self.elements = ['local', 'remote', 'localVideo'];

  var validateUserMediaResolution = function() {
    var encodingWidth = settings.getResolutionEncodingWidth();
    var encodingHeight = settings.getResolutionEncodingHeight();
    var videoWidth = self.localWidth();
    var videoHeight = self.localHeight();
    debug("validating video resolution " + videoWidth + "," + videoHeight + " to match selected encoding " + encodingWidth + "," + encodingHeight);
    if (!videoWidth && !videoHeight) {
      return;
    }

    if (encodingWidth !== videoWidth || encodingHeight !== videoHeight) {
      var msg = "Video resolution " + videoWidth + "," + videoHeight + " does not match selected encoding " + encodingWidth + "," + encodingHeight;
      debug(msg);
    }
  };

  self.init = function() {
    // Allow some windows to be draggable, required jQuery.UI
    if (configuration.enableWindowDrag) {
      $(function() {
        self.localVideo.draggable({
          snap: ".remoteVideo,.videoBar",
          containment: ".main",
          snapTolerance: 200,
          stop: function(event, ui) {
            self.settings.updateViewPositions();
          }
        });
      });
    }
  };

  self.listeners = function() {
    self.view.bind("click", function(e) {
      historyView.hide();
    });
    self.local.bind("playing", function() {
      validateUserMediaResolution();
    });
    eventbus.on("userMediaUpdated", function(e) {
      self.updateStreams([e && e.localStream], []);
    });
    eventbus.on("resumed", function(e) {
      self.updateSessionStreams(e.sender);
    });
    eventbus.on("started", function(e) {
      self.updateSessionStreams(e.sender);
    });
  };

  self.updateSessionStreams = function() {
    self.updateStreams(sipstack.getLocalStreams(), sipstack.getRemoteStreams());
  };

  self.updateStreams = function(localStreams, remoteStreams) {
    debug("updating video streams");
    self.setVideoStream(self.local[0], localStreams);
    self.setVideoStream(self.remote[0], remoteStreams);
  };

  self.localWidth = function() {
    return self.local[0].videoWidth;
  };

  self.localHeight = function() {
    return self.local[0].videoHeight;
  };

  self.setVideoStream = function(video, streams) {
    var hasStream = streams && streams.length > 0 && typeof(streams[0]) !== 'undefined' && !streams[0].ended;
    if (video && video.mozSrcObject !== undefined) {
      if (hasStream) {
        video.mozSrcObject = streams[0];
        video.play();
      } else {
        video.mozSrcObject = null;
      }
    } else if (video) {
      if (hasStream) {
        video.src = (window.URL && window.URL.createObjectURL(streams[0])) || streams[0];
      } else {
        video.src = "";
      }
    }
  };

  return self;
}
},{"jquery-ui/draggable":226}],486:[function(require,module,exports){
module.exports = VideoBarView;

var Icon = require('../Icon');
var events;

function VideoBarView(options, eventbus, sound, sipstack, transferView, settingsView, dialpadView, timerView, videoView, configuration) {
  var self = {};

  self.fullScreen = false;
  self.selfViewEnabled = true;
  self.isScreenSharing = false;

  self.elements = ['transfer', 'settings', 'dialpadIconShow', 'dialpadIconHide', 'cellTimer', 'hangup', 'fullScreenExpand', 'fullScreenContract',
    'muteAudioIcon', 'unmuteAudioIcon', 'selfViewEnable', 'selfViewDisable', 'shareScreen', 'stopShareScreen', 'hold', 'resume'
  ];

  var toggleView = function(e, popup) {
    e.preventDefault();
    sound.playClick();
    popup.toggle();
  };

  self.endCall = function(options) { 
    options = options || {};
    var rtcSession = options.rtcSession;
    if (rtcSession === 'all') {
      sipstack.terminateSessions();
    } else if (rtcSession) {
      sipstack.terminateSession(rtcSession);
    } else {
      sipstack.terminateSession();
    }
    sound.pause();
    videoView.updateSessionStreams();

    // self.guiStart();

    timerView.stop();
    self.checkEndCallURL();
  };

  // Initial startup
  self.checkEndCallURL = function() {
    if (configuration.endCallURL && !configuration.disabled) {
      window.location = configuration.endCallURL;
    }
  };

  self.enableScreenSharing = function(enabled) {
    self.isScreenSharing = enabled;
    eventbus.screenshare(enabled);
    eventbus.viewChanged(self);
    if (enabled) {
      var onShareScreenSuccess = function(localMedia) {
        localMedia.onended = function() {
          self.enableScreenSharing(false);
        };
      };
      var onShareScreenFailure = function(e) {
        // no way to distinguish between flag not enabled or simply rejected enabling screen sharing
        if (e) {
          self.screenSharingUnsupported.show();
        }
        self.enableScreenSharing(false);
      };
      sipstack.reconnectUserMedia(onShareScreenSuccess, onShareScreenFailure);
    } else {
      sipstack.reconnectUserMedia();
    }
  };

  self.holdCall = function() {
    self.hold.disable();
    var enable = function() {
      self.hold.enable();
    };
    sipstack.hold(enable, enable);
  };

  self.resumeCall = function() {
    self.resume.disable();
    var enable = function() {
      self.resume.enable();
    };
    sipstack.unhold(enable, enable);
  };

  self.hideSelfView = function() {
    self.selfViewEnabled = false;
    eventbus.viewChanged(self);
  };

  self.stopFullScreen = function() {
    if (document.webkitCancelFullScreen) {
      document.webkitCancelFullScreen();
    }
    self.fullScreen = false;
    eventbus.viewChanged(self);
  };

  self.showSelfView = function() {
    self.selfViewEnabled = true;
    eventbus.viewChanged(self);
  };

  self.updateFullScreen = function() {
    self.fullScreen = document.fullscreen || document.mozFullScreen || document.webkitIsFullScreen;
    self.updateClientClass();
  };

  self.showFullScreen = function() {
    if (self.client[0].webkitRequestFullScreen) {
      self.client[0].webkitRequestFullScreen();
    }
    self.fullScreen = true;
    eventbus.viewChanged(self);
  };

  self.muteAudio = function() {
    sound.setMuted(true);
  };

  self.unmuteAudio = function() {
    sound.setMuted(false);
  };


  self.listeners = function() {
    self.hold = new Icon(self.hold, sound);
    self.resume = new Icon(self.resume, sound);

    self.transfer.bind('click', function(e) {
      toggleView(e, transferView);
    });
    self.settings.bind('click', function(e) {
      toggleView(e, settingsView);
    });
    self.dialpadIconShow.bind('click', function(e) {
      toggleView(e, dialpadView);
    });
    self.dialpadIconHide.bind('click', function(e) {
      toggleView(e, dialpadView);
    });
    self.shareScreen.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.enableScreenSharing(true);
    });
    self.stopShareScreen.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.enableScreenSharing(false);
    });

    self.hangup.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.endCall();
      if (self.fullScreen) {
        self.fullScreenContract.click();
      }
    });

    self.fullScreenExpand.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.showFullScreen();
    });

    self.fullScreenContract.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.stopFullScreen();
    });
    $(document).on('webkitfullscreenchange mozfullscreenchange fullscreenchange', function(e) {
      self.updateFullScreen();
    });

    self.selfViewDisable.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.hideSelfView();
    });

    self.selfViewEnable.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.showSelfView();
    });

    self.hold.onClick(function(e) {
      self.holdCall();
    });

    self.resume.onClick(function(e) {
      self.resumeCall();
    });

    self.muteAudioIcon.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.muteAudio();
    });

    self.unmuteAudioIcon.bind('click', function(e) {
      e.preventDefault();
      sound.playClick();
      self.unmuteAudio();
    });


  };

  return self;
}
},{"../Icon":454}],487:[function(require,module,exports){
module.exports = WhiteboardView;

function WhiteboardView(options, eventbus, sipstack) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['canvas', 'tools'];

  if(self.canvas[0] && self.canvas[0].getContext) {
    self.context = self.canvas[0].getContext('2d');    
  }

  self.color = '#000';
  self.size = 5;
  self.tool = 'marker';
  self.action = [];

  self.listeners = function() {
    self.initCanvas();
    eventbus.on('modifier', function(e){
      if(e.which === 87) {
        self.show();
      }
    });
    eventbus.on("dataReceived", function(e) {
      var data = e.data;
      var regex = /^whiteboard:/;
      if (data.match(regex)) {
        data = data.replace(regex, '');
        var img = new Image();
        img.onload = function() {
          self.clear();
          self.context.drawImage(img, 0, 0); // Or at whatever offset you like
        };
        img.src = data;
      }
    });
    self.updateToolsSelection();
  };
  self.initCanvas = function() {
    $.each(['#f00', '#ff0', '#0f0', '#0ff', '#00f', '#f0f', '#000', '#fff'], function() {
      self.tools.append("<a href='.canvas' onclick='javascript:;' data-color='" + this + "' style='width: 10px; background: " + this + ";'></a> ");
    });
    $.each([3, 5, 10, 15], function() {
      self.tools.append("<a href='.canvas' onclick='javascript:;' data-size='" + this + "' style='background: #ccc'>" + this + "</a> ");
    });

    self.canvas.bind('click mousedown mouseup mousemove mouseleave mouseout touchstart touchmove touchend touchcancel', jQuery.proxy(this, "onEvent"));

    $('body').delegate("a[href=\"." + (self.canvas.attr('class')) + "\"]", 'click', function() {
      var $canvas, $this, key, sketch, _i, _len, _ref;
      $this = $(this);
      $canvas = $($self.attr('href'));
      sketch = $canvas.data('sketch');
      _ref = ['color', 'size', 'tool'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        var value = $self.attr("data-" + key);
        if (value) {
          if (key === "size") {
            value = +value;
          }
          self[key] = value;
        }
      }
      self.updateToolsSelection();
      return false;
    });
  };
  self.updateToolsSelection = function() {
    $.each(self.tools.find('a'), function() {
      var selected = $(this).data('color') === self.color || $(this).data('tool') === self.tool || +$(this).data('size') === self.size;
      if (selected) {
        $(this).attr('class', 'selected');
      } else {
        $(this).attr('class', '');
      }
    });
  };
  self.sendData = function() {
    var data = self.canvas[0].toDataURL();
    sipstack.sendData("whiteboard:" + data);
  };
  self.clear = function() {
    // Store the current transformation matrix
    self.context.save();

    // Use the identity matrix while clearing the canvas
    self.context.setTransform(1, 0, 0, 1, 0, 0);
    self.context.clearRect(0, 0, self.canvas[0].width, self.canvas[0].height);

    // Restore the transform
    self.context.restore();
  };
  self.onEvent = function(e) {
    if (e.originalEvent && e.originalEvent.targetTouches) {
      e.pageX = e.originalEvent.targetTouches[0].pageX;
      e.pageY = e.originalEvent.targetTouches[0].pageY;
    }
    switch (e.type) {
      case 'mousedown':
      case 'touchstart':
        self.painting = true;
        self.action = {
          tool: self.tool,
          color: self.color,
          size: parseFloat(self.size),
          eventbus: []
        };
        break;
    }
    if (self.painting) {
      self.action.eventbus.push({
        x: e.pageX - self.canvas.offset().left,
        y: e.pageY - self.canvas.offset().top,
        event: e.type
      });
      if (self.tool === 'marker') {
        self.draw(self.action);
      } else if (self.tool === 'eraser') {
        self.erase(self.action);
      }
    }
    switch (e.type) {
      case 'mouseup':
      case 'mouseout':
      case 'mouseleave':
      case 'touchend':
      case 'touchcancel':
        self.painting = false;
        self.action = null;
        self.sendData();
    }
    e.preventDefault();
    return false;
  };
  self.erase = function(action) {
    var oldcomposite;
    oldcomposite = self.context.globalCompositeOperation;
    self.context.globalCompositeOperation = "copy";
    action.color = "rgba(0,0,0,0)";
    self.draw(action);
    self.context.globalCompositeOperation = oldcomposite;
    return self.context.globalCompositeOperation;
  };
  self.draw = function(action) {
    var event, previous, _i, _len, _ref;
    self.context.lineJoin = "round";
    self.context.lineCap = "round";
    self.context.beginPath();
    self.context.moveTo(action.eventbus[0].x, action.eventbus[0].y);
    _ref = action.eventbus;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      self.context.lineTo(event.x, event.y);
      previous = event;
    }
    self.context.strokeStyle = action.color;
    self.context.lineWidth = action.size;
    return self.context.stroke();
  };
}
},{}],488:[function(require,module,exports){
module.exports = XMPPView;

// var View = require('ampersand-view');
// var GroupedCollectionView = require('ampersand-grouped-collection-view');
// var ChatInputView = require('otalk-chat-input-view');
var PopupView = require('./popup');
var $ = require('jquery');

function XMPPView(options, debug, eventbus, configuration, sound, xmpp) {
  var self = {};

  self.__proto__ = PopupView(options, self, eventbus);

  self.elements = ['content', 'name', 'password', 'login', 'messages'];

  // var chatInputView = new ChatInputView({
  //   sendChat: function(body, prevID) {
  //     client.sendChat({
  //       to: peer.id,
  //       body: body,
  //       replace: prevID
  //     });
  //   },
  //   sendChatState: function(state) {
  //     client.sendChatState({
  //       to: peer.id,
  //       chatState: state
  //     });
  //   },
  //   previousMessage: function() {
  //     return {
  //       id: peer.lastSentMessage.id,
  //       body: peer.lastSentMessage.body
  //     };
  //   }
  // });


  self.init = function() {
    // self.content.append($(chatInputView));
  };

  self.listeners = function() {
    self.login.on('click', function(e) {
      sound.playClick();
      xmpp.login(name.val(), password.val());
    });
    eventbus.on('modifier', function(e) {
      if (e.which === 88) {
        self.show();
      }
    });    
    eventbus.on('xmppmessages', function(e) {
      // var view = new GroupedCollectionView({
      //     el: self.messages,
      //     collection: e.messages,

      //     itemView: View.extend({
      //         template: '<div><p data-hook="msg-body"></p><span data-hook="msg-time"><span></div>',
      //         bindings: {
      //             'model.body': {
      //                 type: 'text',
      //                 hook: 'msg-body'
      //             },
      //             'model.timestamp': {
      //                 type: 'text',
      //                 hook: 'msg-time'
      //             }
      //         }
      //     }),
      //     groupView: View.extend({
      //         template: '<div><img data-hook="avatar"/><ul data-hook="messages"></ul></div>',
      //         bindings: {
      //             'model.avatar': {
      //                 type: 'attribute',
      //                 name: 'src',
      //                 hook: 'avatar'
      //             }
      //         },
      //         render: function () {
      //             this.renderWithTemplate();
      //             // The `groupEl` property is special for group views. If provided, item
      //             // views will be appended there instead of on the root element for the
      //             // group view.
      //             this.cacheElements({
      //                 groupEl: '[data-hook=messages]'
      //             });
      //         }
      //     }),

      //     groupsWith: function (model, prevModel, currentGroup) {
      //         // Used to determine when a new group is needed.
      //         // Return `true` if `model` belongs to the same group
      //         // as `prevModel`.
      //         // The current group is also available for comparison.
      //         return model.sender.id === prevModel.sender.id;
      //     },
      //     prepareGroup: function (model, prevGroup) {
      //         // Prepare a Group model based on the Item model
      //         // that triggered the group's creation.
      //         // The previous group model is also provided.
      //         return model.sender; 
      //     }
      // });
    });    
  };

  return self;
}
},{"./popup":478,"jquery":230}]},{},[456]);
